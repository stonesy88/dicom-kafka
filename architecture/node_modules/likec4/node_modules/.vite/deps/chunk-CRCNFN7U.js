// node_modules/@likec4/core/dist/shared/core.C-YXI-43.mjs
function nonNullable(value, message) {
  if (typeof value === "undefined" || value == null) {
    const msg = typeof message === "function" ? message() : message;
    throw new Error(msg ?? `Expected defined value, but received ${value}`);
  }
  return value;
}
function invariant(condition, message) {
  if (condition) {
    return;
  }
  throw new Error(message ?? "Invariant failed");
}
function nonexhaustive(value) {
  throw new Error(`NonExhaustive value: ${value}`);
}

// node_modules/@likec4/core/dist/shared/core.CQXU9DF7.mjs
var e = { done: true, hasNext: false };
var s = { done: false, hasNext: false };
var a = () => e;
function C(t2, ...o) {
  let n = t2, u = o.map((e2) => "lazy" in e2 ? y(e2) : void 0), p = 0;
  for (; p < o.length; ) {
    if (u[p] === void 0 || !B(n)) {
      let i = o[p];
      n = i(n), p += 1;
      continue;
    }
    let r = [];
    for (let i = p; i < o.length; i++) {
      let l = u[i];
      if (l === void 0 || (r.push(l), l.isSingle)) break;
    }
    let a2 = [];
    for (let i of n) if (f(i, a2, r)) break;
    let { isSingle: s2 } = r.at(-1);
    n = s2 ? a2[0] : a2, p += r.length;
  }
  return n;
}
function f(t2, o, n) {
  if (n.length === 0) return o.push(t2), false;
  let u = t2, p = s, e2 = false;
  for (let [r, a2] of n.entries()) {
    let { index: s2, items: i } = a2;
    if (i.push(u), p = a2(u, s2, i), a2.index += 1, p.hasNext) {
      if (p.hasMany ?? false) {
        for (let l of p.next) if (f(l, o, n.slice(r + 1))) return true;
        return e2;
      }
      u = p.next;
    }
    if (!p.hasNext) break;
    p.done && (e2 = true);
  }
  return p.hasNext && o.push(u), e2;
}
function y(t2) {
  let { lazy: o, lazyArgs: n } = t2, u = o(...n);
  return Object.assign(u, { isSingle: o.single ?? false, index: 0, items: [] });
}
function B(t2) {
  return typeof t2 == "string" || typeof t2 == "object" && t2 !== null && Symbol.iterator in t2;
}
function t$1(r) {
  return typeof r == "string";
}
function t(n) {
  return typeof n == "function";
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var defaultMap;
var hasRequiredDefaultMap;
function requireDefaultMap() {
  if (hasRequiredDefaultMap) return defaultMap;
  hasRequiredDefaultMap = 1;
  function DefaultMap2(factory) {
    if (typeof factory !== "function")
      throw new Error("mnemonist/DefaultMap.constructor: expecting a function.");
    this.items = /* @__PURE__ */ new Map();
    this.factory = factory;
    this.size = 0;
  }
  DefaultMap2.prototype.clear = function() {
    this.items.clear();
    this.size = 0;
  };
  DefaultMap2.prototype.get = function(key) {
    var value = this.items.get(key);
    if (typeof value === "undefined") {
      value = this.factory(key, this.size);
      this.items.set(key, value);
      this.size++;
    }
    return value;
  };
  DefaultMap2.prototype.peek = function(key) {
    return this.items.get(key);
  };
  DefaultMap2.prototype.set = function(key, value) {
    this.items.set(key, value);
    this.size = this.items.size;
    return this;
  };
  DefaultMap2.prototype.has = function(key) {
    return this.items.has(key);
  };
  DefaultMap2.prototype.delete = function(key) {
    var deleted = this.items.delete(key);
    this.size = this.items.size;
    return deleted;
  };
  DefaultMap2.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    this.items.forEach(callback, scope);
  };
  DefaultMap2.prototype.entries = function() {
    return this.items.entries();
  };
  DefaultMap2.prototype.keys = function() {
    return this.items.keys();
  };
  DefaultMap2.prototype.values = function() {
    return this.items.values();
  };
  if (typeof Symbol !== "undefined")
    DefaultMap2.prototype[Symbol.iterator] = DefaultMap2.prototype.entries;
  DefaultMap2.prototype.inspect = function() {
    return this.items;
  };
  if (typeof Symbol !== "undefined")
    DefaultMap2.prototype[Symbol.for("nodejs.util.inspect.custom")] = DefaultMap2.prototype.inspect;
  DefaultMap2.autoIncrement = function() {
    var i = 0;
    return function() {
      return i++;
    };
  };
  defaultMap = DefaultMap2;
  return defaultMap;
}
var defaultMapExports = requireDefaultMap();
var DefaultMap = getDefaultExportFromCjs(defaultMapExports);
var naturalCompareLite = { exports: {} };
var hasRequiredNaturalCompareLite;
function requireNaturalCompareLite() {
  if (hasRequiredNaturalCompareLite) return naturalCompareLite.exports;
  hasRequiredNaturalCompareLite = 1;
  var naturalCompare = function(a2, b) {
    var i, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
    function getCode(str, pos, code) {
      if (code) {
        for (i = pos; code = getCode(str, i), code < 76 && code > 65; ) ++i;
        return +str.slice(pos - 1, i);
      }
      code = alphabet && alphabet.indexOf(str.charAt(pos));
      return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63;
    }
    if ((a2 += "") != (b += "")) for (; codeB; ) {
      codeA = getCode(a2, posA++);
      codeB = getCode(b, posB++);
      if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
        codeA = getCode(a2, posA, posA);
        codeB = getCode(b, posB, posA = i);
        posB = i;
      }
      if (codeA != codeB) return codeA < codeB ? -1 : 1;
    }
    return 0;
  };
  try {
    naturalCompareLite.exports = naturalCompare;
  } catch (e2) {
    String.naturalCompare = naturalCompare;
  }
  return naturalCompareLite.exports;
}
var naturalCompareLiteExports = requireNaturalCompareLite();
var compare = getDefaultExportFromCjs(naturalCompareLiteExports);
function compareNatural(a2, b) {
  if (a2 === b) return 0;
  if (t$1(a2)) {
    if (t$1(b)) {
      return compare(a2, b);
    }
    return 1;
  }
  return t$1(b) ? -1 : 0;
}
function isString(value) {
  return value != null && typeof value === "string";
}
function isNonEmptyArray(arr) {
  return !!arr && Array.isArray(arr) && arr.length > 0;
}
function parentFqn(fqn) {
  const lastDot = fqn.lastIndexOf(".");
  if (lastDot > 0) {
    return fqn.slice(0, lastDot);
  }
  return null;
}
function nameFromFqn(fqn) {
  const lastDot = fqn.lastIndexOf(".");
  if (lastDot > 0) {
    return fqn.slice(lastDot + 1);
  } else {
    return fqn;
  }
}
var asString = (e2) => isString(e2) ? e2 : e2.id;
function isAncestor(arg1, arg2) {
  const arg1Id = asString(arg1);
  if (arg2) {
    const arg2Id = asString(arg2);
    return arg2Id.startsWith(arg1Id + ".");
  }
  return (ancestor) => {
    const ancestorId = asString(ancestor);
    return arg1Id.startsWith(ancestorId + ".");
  };
}
function isSameHierarchy(one, another) {
  if (!another) {
    return (b) => isSameHierarchy(one, b);
  }
  const first = asString(one);
  const second = asString(another);
  return first === second || second.startsWith(first + ".") || first.startsWith(second + ".");
}
function isDescendantOf(descedant, ancestor) {
  if (!ancestor) {
    return (d) => isAncestor(descedant, d);
  }
  return isAncestor(ancestor, descedant);
}
function hierarchyLevel(elementOfFqn) {
  const first = isString(elementOfFqn) ? elementOfFqn : elementOfFqn.id;
  return first.split(".").length;
}
function hierarchyDistance(one, another) {
  const first = isString(one) ? one : one.id;
  const second = isString(another) ? another : another.id;
  if (first === second) {
    return 0;
  }
  const firstDepth = hierarchyLevel(first);
  const secondDepth = hierarchyLevel(second);
  if (isSameHierarchy(first, second)) {
    return Math.abs(firstDepth - secondDepth);
  }
  const ancestor = commonAncestor(first, second);
  const ancestorDepth = ancestor ? hierarchyLevel(ancestor) : 0;
  return firstDepth + secondDepth - (2 * ancestorDepth + 1);
}
function commonAncestor(first, second) {
  const a2 = first.split(".");
  if (a2.length < 2) {
    return null;
  }
  const b = second.split(".");
  if (b.length < 2) {
    return null;
  }
  let ancestor = [];
  for (let i = 0; i < Math.min(a2.length, b.length) - 1 && a2[i] === b[i]; i++) {
    ancestor.push(a2[i]);
  }
  if (ancestor.length === 0) {
    return null;
  }
  return ancestor.join(".");
}
function ancestorsFqn(fqn) {
  const path = fqn.split(".");
  path.pop();
  if (path.length === 0) {
    return [];
  }
  return path.reduce((acc, part, idx) => {
    if (idx === 0) {
      acc.push(part);
      return acc;
    }
    acc.unshift(`${acc[0]}.${part}`);
    return acc;
  }, []);
}
function compareFqnHierarchically(a2, b) {
  const depthA = a2.split(".").length;
  const depthB = b.split(".").length;
  switch (true) {
    case depthA > depthB: {
      return 1;
    }
    case depthA < depthB: {
      return -1;
    }
    default: {
      return 0;
    }
  }
}
function compareByFqnHierarchically(a2, b) {
  return compareFqnHierarchically(a2.id, b.id);
}
function sortByFqnHierarchically(array) {
  return array.map((item) => ({ item, fqn: item.id.split(".") })).sort((a2, b) => {
    return a2.fqn.length - b.fqn.length;
  }).map(({ item }) => item);
}
function findTopAncestor(items, item) {
  let parent = item;
  for (const e2 of items) {
    if (isAncestor(e2, parent)) {
      parent = e2;
    }
  }
  return parent !== item ? parent : null;
}
function sortParentsFirst(array) {
  const result = [];
  const items = [...array];
  let item;
  while (item = items.shift()) {
    let parent;
    while (parent = findTopAncestor(items, item)) {
      result.push(items.splice(items.indexOf(parent), 1)[0]);
    }
    result.push(item);
  }
  return result;
}
function sortNaturalByFqn(array, sort) {
  if (!array || isString(array)) {
    const dir2 = array ?? "asc";
    return (arr) => sortNaturalByFqn(arr, dir2);
  }
  const dir = sort === "desc" ? -1 : 1;
  return array.map((item) => ({ item, fqn: item.id.split(".") })).sort((a2, b) => {
    if (a2.fqn.length !== b.fqn.length) {
      return (a2.fqn.length - b.fqn.length) * dir;
    }
    for (let i = 0; i < a2.fqn.length; i++) {
      const compare2 = compareNatural(a2.fqn[i], b.fqn[i]);
      if (compare2 !== 0) {
        return compare2;
      }
    }
    return 0;
  }).map(({ item }) => item);
}
function ifilter(arg1, arg2) {
  const pred = arg2 ?? arg1;
  invariant(t(pred));
  function* _filter(iter) {
    for (const value of iter) {
      if (pred(value)) {
        yield value;
      }
    }
    return;
  }
  if (!arg2) {
    return _filter;
  }
  return _filter(arg1);
}
function imap(arg1, arg2) {
  const mapper = arg2 ?? arg1;
  invariant(t(mapper));
  function* _map(iter) {
    for (const value of iter) {
      yield mapper(value);
    }
    return;
  }
  if (!arg2) {
    return _map;
  }
  return _map(arg1);
}
function toArray(iterable) {
  if (iterable) {
    return Array.from(iterable);
  }
  return (it) => Array.from(it);
}
function toSet(iterable) {
  if (iterable) {
    return new Set(iterable);
  }
  return (it) => new Set(it);
}

export {
  nonNullable,
  invariant,
  nonexhaustive,
  s,
  a,
  C,
  t$1,
  t,
  getDefaultExportFromCjs,
  DefaultMap,
  compareNatural,
  isString,
  isNonEmptyArray,
  parentFqn,
  nameFromFqn,
  isAncestor,
  isSameHierarchy,
  isDescendantOf,
  hierarchyLevel,
  hierarchyDistance,
  commonAncestor,
  ancestorsFqn,
  compareFqnHierarchically,
  compareByFqnHierarchically,
  sortByFqnHierarchically,
  sortParentsFirst,
  sortNaturalByFqn,
  ifilter,
  imap,
  toArray,
  toSet
};
/*! Bundled license information:

@likec4/core/dist/shared/core.CQXU9DF7.mjs:
  (*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   *)
*/
//# sourceMappingURL=chunk-CRCNFN7U.js.map
