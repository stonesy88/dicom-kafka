import {
  n,
  requireForeach,
  requireIterator
} from "./chunk-HKC6AVZT.js";
import {
  commonAncestor,
  compareFqnHierarchically,
  getDefaultExportFromCjs,
  invariant,
  t
} from "./chunk-CRCNFN7U.js";

// node_modules/@likec4/core/dist/utils/index.mjs
function o(r, n2) {
  let e = Math.ceil(r), t2 = Math.floor(n2);
  if (t2 < e) throw new RangeError(`randomInteger: The range [${r.toString()},${n2.toString()}] contains no integer`);
  return Math.floor(Math.random() * (t2 - e + 1) + e);
}
var biMap$1;
var hasRequiredBiMap;
function requireBiMap() {
  if (hasRequiredBiMap) return biMap$1;
  hasRequiredBiMap = 1;
  var forEach = requireForeach();
  function InverseMap(original) {
    this.size = 0;
    this.items = /* @__PURE__ */ new Map();
    this.inverse = original;
  }
  function BiMap() {
    this.size = 0;
    this.items = /* @__PURE__ */ new Map();
    this.inverse = new InverseMap(this);
  }
  function clear() {
    this.size = 0;
    this.items.clear();
    this.inverse.items.clear();
  }
  BiMap.prototype.clear = clear;
  InverseMap.prototype.clear = clear;
  function set(key, value) {
    if (this.items.has(key)) {
      var currentValue = this.items.get(key);
      if (currentValue === value)
        return this;
      else
        this.inverse.items.delete(currentValue);
    }
    if (this.inverse.items.has(value)) {
      var currentKey = this.inverse.items.get(value);
      if (currentKey === key)
        return this;
      else
        this.items.delete(currentKey);
    }
    this.items.set(key, value);
    this.inverse.items.set(value, key);
    this.size = this.items.size;
    this.inverse.size = this.inverse.items.size;
    return this;
  }
  BiMap.prototype.set = set;
  InverseMap.prototype.set = set;
  function del(key) {
    if (this.items.has(key)) {
      var currentValue = this.items.get(key);
      this.items.delete(key);
      this.inverse.items.delete(currentValue);
      this.size = this.items.size;
      this.inverse.size = this.inverse.items.size;
      return true;
    }
    return false;
  }
  BiMap.prototype.delete = del;
  InverseMap.prototype.delete = del;
  var METHODS = ["has", "get", "forEach", "keys", "values", "entries"];
  METHODS.forEach(function(name) {
    BiMap.prototype[name] = InverseMap.prototype[name] = function() {
      return Map.prototype[name].apply(this.items, arguments);
    };
  });
  if (typeof Symbol !== "undefined") {
    BiMap.prototype[Symbol.iterator] = BiMap.prototype.entries;
    InverseMap.prototype[Symbol.iterator] = InverseMap.prototype.entries;
  }
  BiMap.prototype.inspect = function() {
    var dummy = {
      left: this.items,
      right: this.inverse.items
    };
    Object.defineProperty(dummy, "constructor", {
      value: BiMap,
      enumerable: false
    });
    return dummy;
  };
  if (typeof Symbol !== "undefined")
    BiMap.prototype[Symbol.for("nodejs.util.inspect.custom")] = BiMap.prototype.inspect;
  InverseMap.prototype.inspect = function() {
    var dummy = {
      left: this.inverse.items,
      right: this.items
    };
    Object.defineProperty(dummy, "constructor", {
      value: InverseMap,
      enumerable: false
    });
    return dummy;
  };
  if (typeof Symbol !== "undefined")
    InverseMap.prototype[Symbol.for("nodejs.util.inspect.custom")] = InverseMap.prototype.inspect;
  BiMap.from = function(iterable) {
    var bimap = new BiMap();
    forEach(iterable, function(value, key) {
      bimap.set(key, value);
    });
    return bimap;
  };
  biMap$1 = BiMap;
  return biMap$1;
}
var biMapExports = requireBiMap();
var biMap = getDefaultExportFromCjs(biMapExports);
var defaultWeakMap$1;
var hasRequiredDefaultWeakMap;
function requireDefaultWeakMap() {
  if (hasRequiredDefaultWeakMap) return defaultWeakMap$1;
  hasRequiredDefaultWeakMap = 1;
  function DefaultWeakMap(factory) {
    if (typeof factory !== "function")
      throw new Error("mnemonist/DefaultWeakMap.constructor: expecting a function.");
    this.items = /* @__PURE__ */ new WeakMap();
    this.factory = factory;
  }
  DefaultWeakMap.prototype.clear = function() {
    this.items = /* @__PURE__ */ new WeakMap();
  };
  DefaultWeakMap.prototype.get = function(key) {
    var value = this.items.get(key);
    if (typeof value === "undefined") {
      value = this.factory(key);
      this.items.set(key, value);
    }
    return value;
  };
  DefaultWeakMap.prototype.peek = function(key) {
    return this.items.get(key);
  };
  DefaultWeakMap.prototype.set = function(key, value) {
    this.items.set(key, value);
    return this;
  };
  DefaultWeakMap.prototype.has = function(key) {
    return this.items.has(key);
  };
  DefaultWeakMap.prototype.delete = function(key) {
    return this.items.delete(key);
  };
  DefaultWeakMap.prototype.inspect = function() {
    return this.items;
  };
  if (typeof Symbol !== "undefined")
    DefaultWeakMap.prototype[Symbol.for("nodejs.util.inspect.custom")] = DefaultWeakMap.prototype.inspect;
  defaultWeakMap$1 = DefaultWeakMap;
  return defaultWeakMap$1;
}
var defaultWeakMapExports = requireDefaultWeakMap();
var defaultWeakMap = getDefaultExportFromCjs(defaultWeakMapExports);
var linkedList$1;
var hasRequiredLinkedList;
function requireLinkedList() {
  if (hasRequiredLinkedList) return linkedList$1;
  hasRequiredLinkedList = 1;
  var Iterator = requireIterator(), forEach = requireForeach();
  function LinkedList() {
    this.clear();
  }
  LinkedList.prototype.clear = function() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  };
  LinkedList.prototype.first = function() {
    return this.head ? this.head.item : void 0;
  };
  LinkedList.prototype.peek = LinkedList.prototype.first;
  LinkedList.prototype.last = function() {
    return this.tail ? this.tail.item : void 0;
  };
  LinkedList.prototype.push = function(item) {
    var node = { item, next: null };
    if (!this.head) {
      this.head = node;
      this.tail = node;
    } else {
      this.tail.next = node;
      this.tail = node;
    }
    this.size++;
    return this.size;
  };
  LinkedList.prototype.unshift = function(item) {
    var node = { item, next: null };
    if (!this.head) {
      this.head = node;
      this.tail = node;
    } else {
      if (!this.head.next)
        this.tail = this.head;
      node.next = this.head;
      this.head = node;
    }
    this.size++;
    return this.size;
  };
  LinkedList.prototype.shift = function() {
    if (!this.size)
      return void 0;
    var node = this.head;
    this.head = node.next;
    this.size--;
    return node.item;
  };
  LinkedList.prototype.forEach = function(callback, scope) {
    if (!this.size)
      return;
    scope = arguments.length > 1 ? scope : this;
    var n2 = this.head, i = 0;
    while (n2) {
      callback.call(scope, n2.item, i, this);
      n2 = n2.next;
      i++;
    }
  };
  LinkedList.prototype.toArray = function() {
    if (!this.size)
      return [];
    var array = new Array(this.size);
    for (var i = 0, l = this.size, n2 = this.head; i < l; i++) {
      array[i] = n2.item;
      n2 = n2.next;
    }
    return array;
  };
  LinkedList.prototype.values = function() {
    var n2 = this.head;
    return new Iterator(function() {
      if (!n2)
        return {
          done: true
        };
      var value = n2.item;
      n2 = n2.next;
      return {
        value,
        done: false
      };
    });
  };
  LinkedList.prototype.entries = function() {
    var n2 = this.head, i = 0;
    return new Iterator(function() {
      if (!n2)
        return {
          done: true
        };
      var value = n2.item;
      n2 = n2.next;
      i++;
      return {
        value: [i - 1, value],
        done: false
      };
    });
  };
  if (typeof Symbol !== "undefined")
    LinkedList.prototype[Symbol.iterator] = LinkedList.prototype.values;
  LinkedList.prototype.toString = function() {
    return this.toArray().join(",");
  };
  LinkedList.prototype.toJSON = function() {
    return this.toArray();
  };
  LinkedList.prototype.inspect = function() {
    var array = this.toArray();
    Object.defineProperty(array, "constructor", {
      value: LinkedList,
      enumerable: false
    });
    return array;
  };
  if (typeof Symbol !== "undefined")
    LinkedList.prototype[Symbol.for("nodejs.util.inspect.custom")] = LinkedList.prototype.inspect;
  LinkedList.from = function(iterable) {
    var list = new LinkedList();
    forEach(iterable, function(value) {
      list.push(value);
    });
    return list;
  };
  linkedList$1 = LinkedList;
  return linkedList$1;
}
var linkedListExports = requireLinkedList();
var linkedList = getDefaultExportFromCjs(linkedListExports);
var multiMap$1;
var hasRequiredMultiMap;
function requireMultiMap() {
  if (hasRequiredMultiMap) return multiMap$1;
  hasRequiredMultiMap = 1;
  var Iterator = requireIterator(), forEach = requireForeach();
  function MultiMap(Container) {
    this.Container = Container || Array;
    this.items = /* @__PURE__ */ new Map();
    this.clear();
    Object.defineProperty(this.items, "constructor", {
      value: MultiMap,
      enumerable: false
    });
  }
  MultiMap.prototype.clear = function() {
    this.size = 0;
    this.dimension = 0;
    this.items.clear();
  };
  MultiMap.prototype.set = function(key, value) {
    var container = this.items.get(key), sizeBefore;
    if (!container) {
      this.dimension++;
      container = new this.Container();
      this.items.set(key, container);
    }
    if (this.Container === Set) {
      sizeBefore = container.size;
      container.add(value);
      if (sizeBefore < container.size)
        this.size++;
    } else {
      container.push(value);
      this.size++;
    }
    return this;
  };
  MultiMap.prototype.delete = function(key) {
    var container = this.items.get(key);
    if (!container)
      return false;
    this.size -= this.Container === Set ? container.size : container.length;
    this.dimension--;
    this.items.delete(key);
    return true;
  };
  MultiMap.prototype.remove = function(key, value) {
    var container = this.items.get(key), wasDeleted, index;
    if (!container)
      return false;
    if (this.Container === Set) {
      wasDeleted = container.delete(value);
      if (wasDeleted)
        this.size--;
      if (container.size === 0) {
        this.items.delete(key);
        this.dimension--;
      }
      return wasDeleted;
    } else {
      index = container.indexOf(value);
      if (index === -1)
        return false;
      this.size--;
      if (container.length === 1) {
        this.items.delete(key);
        this.dimension--;
        return true;
      }
      container.splice(index, 1);
      return true;
    }
  };
  MultiMap.prototype.has = function(key) {
    return this.items.has(key);
  };
  MultiMap.prototype.get = function(key) {
    return this.items.get(key);
  };
  MultiMap.prototype.multiplicity = function(key) {
    var container = this.items.get(key);
    if (typeof container === "undefined")
      return 0;
    return this.Container === Set ? container.size : container.length;
  };
  MultiMap.prototype.count = MultiMap.prototype.multiplicity;
  MultiMap.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    var key;
    function inner(value) {
      callback.call(scope, value, key);
    }
    this.items.forEach(function(container, k) {
      key = k;
      container.forEach(inner);
    });
  };
  MultiMap.prototype.forEachAssociation = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    this.items.forEach(callback, scope);
  };
  MultiMap.prototype.keys = function() {
    return this.items.keys();
  };
  MultiMap.prototype.values = function() {
    var iterator = this.items.values(), inContainer = false, countainer, step, i, l;
    if (this.Container === Set)
      return new Iterator(function next() {
        if (!inContainer) {
          step = iterator.next();
          if (step.done)
            return { done: true };
          inContainer = true;
          countainer = step.value.values();
        }
        step = countainer.next();
        if (step.done) {
          inContainer = false;
          return next();
        }
        return {
          done: false,
          value: step.value
        };
      });
    return new Iterator(function next() {
      if (!inContainer) {
        step = iterator.next();
        if (step.done)
          return { done: true };
        inContainer = true;
        countainer = step.value;
        i = 0;
        l = countainer.length;
      }
      if (i >= l) {
        inContainer = false;
        return next();
      }
      return {
        done: false,
        value: countainer[i++]
      };
    });
  };
  MultiMap.prototype.entries = function() {
    var iterator = this.items.entries(), inContainer = false, countainer, step, key, i, l;
    if (this.Container === Set)
      return new Iterator(function next() {
        if (!inContainer) {
          step = iterator.next();
          if (step.done)
            return { done: true };
          inContainer = true;
          key = step.value[0];
          countainer = step.value[1].values();
        }
        step = countainer.next();
        if (step.done) {
          inContainer = false;
          return next();
        }
        return {
          done: false,
          value: [key, step.value]
        };
      });
    return new Iterator(function next() {
      if (!inContainer) {
        step = iterator.next();
        if (step.done)
          return { done: true };
        inContainer = true;
        key = step.value[0];
        countainer = step.value[1];
        i = 0;
        l = countainer.length;
      }
      if (i >= l) {
        inContainer = false;
        return next();
      }
      return {
        done: false,
        value: [key, countainer[i++]]
      };
    });
  };
  MultiMap.prototype.containers = function() {
    return this.items.values();
  };
  MultiMap.prototype.associations = function() {
    return this.items.entries();
  };
  if (typeof Symbol !== "undefined")
    MultiMap.prototype[Symbol.iterator] = MultiMap.prototype.entries;
  MultiMap.prototype.inspect = function() {
    return this.items;
  };
  if (typeof Symbol !== "undefined")
    MultiMap.prototype[Symbol.for("nodejs.util.inspect.custom")] = MultiMap.prototype.inspect;
  MultiMap.prototype.toJSON = function() {
    return this.items;
  };
  MultiMap.from = function(iterable, Container) {
    var map = new MultiMap(Container);
    forEach(iterable, function(value, key) {
      map.set(key, value);
    });
    return map;
  };
  multiMap$1 = MultiMap;
  return multiMap$1;
}
var multiMapExports = requireMultiMap();
var multiMap = getDefaultExportFromCjs(multiMapExports);
var queue$1;
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue$1;
  hasRequiredQueue = 1;
  var Iterator = requireIterator(), forEach = requireForeach();
  function Queue() {
    this.clear();
  }
  Queue.prototype.clear = function() {
    this.items = [];
    this.offset = 0;
    this.size = 0;
  };
  Queue.prototype.enqueue = function(item) {
    this.items.push(item);
    return ++this.size;
  };
  Queue.prototype.dequeue = function() {
    if (!this.size)
      return;
    var item = this.items[this.offset];
    if (++this.offset * 2 >= this.items.length) {
      this.items = this.items.slice(this.offset);
      this.offset = 0;
    }
    this.size--;
    return item;
  };
  Queue.prototype.peek = function() {
    if (!this.size)
      return;
    return this.items[this.offset];
  };
  Queue.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    for (var i = this.offset, j = 0, l = this.items.length; i < l; i++, j++)
      callback.call(scope, this.items[i], j, this);
  };
  Queue.prototype.toArray = function() {
    return this.items.slice(this.offset);
  };
  Queue.prototype.values = function() {
    var items = this.items, i = this.offset;
    return new Iterator(function() {
      if (i >= items.length)
        return {
          done: true
        };
      var value = items[i];
      i++;
      return {
        value,
        done: false
      };
    });
  };
  Queue.prototype.entries = function() {
    var items = this.items, i = this.offset, j = 0;
    return new Iterator(function() {
      if (i >= items.length)
        return {
          done: true
        };
      var value = items[i];
      i++;
      return {
        value: [j++, value],
        done: false
      };
    });
  };
  if (typeof Symbol !== "undefined")
    Queue.prototype[Symbol.iterator] = Queue.prototype.values;
  Queue.prototype.toString = function() {
    return this.toArray().join(",");
  };
  Queue.prototype.toJSON = function() {
    return this.toArray();
  };
  Queue.prototype.inspect = function() {
    var array = this.toArray();
    Object.defineProperty(array, "constructor", {
      value: Queue,
      enumerable: false
    });
    return array;
  };
  if (typeof Symbol !== "undefined")
    Queue.prototype[Symbol.for("nodejs.util.inspect.custom")] = Queue.prototype.inspect;
  Queue.from = function(iterable) {
    var queue2 = new Queue();
    forEach(iterable, function(value) {
      queue2.enqueue(value);
    });
    return queue2;
  };
  Queue.of = function() {
    return Queue.from(arguments);
  };
  queue$1 = Queue;
  return queue$1;
}
var queueExports = requireQueue();
var queue = getDefaultExportFromCjs(queueExports);
function ireduce(arg1, arg2, arg3) {
  const reducer = n(arg3) ? arg2 : arg1;
  const initialValue = arg3 ?? arg2;
  invariant(t(reducer));
  function _reduce(iter) {
    let acc = initialValue;
    for (const value of iter) {
      acc = reducer(acc, value);
    }
    return acc;
  }
  return n(arg3) ? _reduce(arg1) : _reduce;
}
var DELAY = "LIKEC4_DELAY";
function delay(...args) {
  let ms = 100;
  if (args.length === 2) {
    ms = o(args[0], args[1]);
  } else if (args.length === 1) {
    ms = args[0];
  }
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(DELAY);
    }, ms ?? 100);
  });
}
var compareRelations = (a, b) => {
  const parentA = commonAncestor(a.source, a.target);
  const parentB = commonAncestor(b.source, b.target);
  if (parentA && !parentB) {
    return 1;
  }
  if (!parentA && parentB) {
    return -1;
  }
  const compareParents = parentA && parentB ? compareFqnHierarchically(parentA, parentB) : 0;
  if (compareParents !== 0) {
    return compareParents;
  }
  const compareSource = compareFqnHierarchically(a.source, b.source);
  if (compareSource !== 0) {
    return compareSource;
  }
  return compareFqnHierarchically(a.target, b.target);
};

export {
  biMap,
  defaultWeakMap,
  linkedList,
  multiMap,
  queue,
  ireduce,
  delay,
  compareRelations
};
//# sourceMappingURL=chunk-Q54ELBT6.js.map
