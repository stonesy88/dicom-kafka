import {
  Stack,
  commonHead,
  d,
  difference,
  equals,
  getOrCreate,
  hasIntersection,
  i$1,
  ifind,
  iflat,
  intersection,
  isIterable,
  isome,
  iunique,
  l,
  m,
  n,
  objectHash,
  requireForeach,
  requireIterator,
  stringHash,
  u,
  u2,
  union
} from "./chunk-HKC6AVZT.js";
import {
  C,
  DefaultMap,
  a,
  ancestorsFqn,
  commonAncestor,
  compareByFqnHierarchically,
  compareNatural,
  getDefaultExportFromCjs,
  hierarchyLevel,
  ifilter,
  imap,
  invariant,
  isAncestor,
  isDescendantOf,
  isNonEmptyArray,
  isSameHierarchy,
  isString,
  nameFromFqn,
  nonNullable,
  nonexhaustive,
  parentFqn,
  s,
  sortByFqnHierarchically,
  sortNaturalByFqn,
  sortParentsFirst,
  t$1,
  toArray,
  toSet
} from "./chunk-CRCNFN7U.js";
import {
  __privateAdd,
  __privateGet,
  __publicField
} from "./chunk-EAWROPGL.js";

// node_modules/@likec4/core/dist/shared/core.DgfwjBtu.mjs
function n$1(e3) {
  return !!e3;
}
function o$1(a3) {
  return (t3) => !a3(t3);
}
function n2(e3) {
  return e3 == null;
}
function o(r3) {
  return Array.isArray(r3);
}
function t(...a3) {
  return u(e, a3);
}
var e = (a3, o3) => o3.every((l3) => l3(a3));
function y(...a3) {
  return u(r, a3);
}
var r = (a3, o3) => o3.some((e3) => e3(a3));
var BorderStyles = ["solid", "dashed", "dotted", "none"];
var ElementKind;
((ElementKind2) => {
  ElementKind2.Group = "@group";
})(ElementKind || (ElementKind = {}));
var ElementShapes = [
  "rectangle",
  "person",
  "browser",
  "mobile",
  "cylinder",
  "storage",
  "queue"
];
var DefaultThemeColor = "primary";
var DefaultElementShape = "rectangle";
var DefaultShapeSize = "md";
var DefaultPaddingSize = "md";
var DefaultTextSize = "md";
function AsFqn(name, parent) {
  return parent ? parent + "." + name : name;
}
function GlobalFqn(projectId, name) {
  invariant(n$1(projectId), "Project ID must start with @");
  return "@" + projectId + "." + name;
}
function isGlobalFqn(fqn) {
  return fqn.startsWith("@");
}
function splitGlobalFqn(fqn) {
  if (!fqn.startsWith("@")) {
    return [null, fqn];
  }
  const firstDot = fqn.indexOf(".");
  if (firstDot < 2) {
    throw new Error("Invalid global FQN");
  }
  const projectId = fqn.slice(1, firstDot);
  const name = fqn.slice(firstDot + 1);
  return [projectId, name];
}
var DeploymentElement;
((DeploymentElement2) => {
  DeploymentElement2.isDeploymentNode = (el) => {
    return "kind" in el && !("element" in el);
  };
  DeploymentElement2.isInstance = (el) => {
    return "element" in el && !("kind" in el);
  };
})(DeploymentElement || (DeploymentElement = {}));
var FqnRef;
((FqnRef2) => {
  FqnRef2.isInsideInstanceRef = (ref) => {
    return "deployment" in ref && "element" in ref;
  };
  FqnRef2.isDeploymentElementRef = (ref) => {
    return "deployment" in ref && !("element" in ref);
  };
  FqnRef2.isDeploymentRef = (ref) => {
    return !(0, FqnRef2.isModelRef)(ref) && !(0, FqnRef2.isImportRef)(ref);
  };
  FqnRef2.isModelRef = (ref) => {
    return "model" in ref && !("project" in ref);
  };
  FqnRef2.isImportRef = (ref) => {
    return "project" in ref && "model" in ref;
  };
  FqnRef2.toDeploymentRef = (ref) => {
    invariant((0, FqnRef2.isDeploymentRef)(ref), "Expected DeploymentRef");
    return (0, FqnRef2.isInsideInstanceRef)(ref) ? {
      id: ref.deployment,
      element: ref.element
    } : {
      id: ref.deployment
    };
  };
  FqnRef2.toModelFqn = (ref) => {
    if ((0, FqnRef2.isImportRef)(ref)) {
      return GlobalFqn(ref.project, ref.model);
    }
    if ((0, FqnRef2.isModelRef)(ref)) {
      return ref.model;
    }
    throw new Error("Expected FqnRef.ModelRef or FqnRef.ImportRef");
  };
})(FqnRef || (FqnRef = {}));
var FqnExpr;
((FqnExpr2) => {
  FqnExpr2.isWildcard = (expr) => {
    return "wildcard" in expr && expr.wildcard === true;
  };
  FqnExpr2.isModelRef = (ref) => {
    return "ref" in ref && (FqnRef.isModelRef(ref.ref) || FqnRef.isImportRef(ref.ref));
  };
  FqnExpr2.isDeploymentRef = (ref) => {
    return "ref" in ref && FqnRef.isDeploymentRef(ref.ref);
  };
  function isElementKindExpr(expr) {
    return "elementKind" in expr && "isEqual" in expr;
  }
  FqnExpr2.isElementKindExpr = isElementKindExpr;
  function isElementTagExpr(expr) {
    return "elementTag" in expr && "isEqual" in expr;
  }
  FqnExpr2.isElementTagExpr = isElementTagExpr;
  FqnExpr2.isWhere = (expr) => {
    return "where" in expr && (0, FqnExpr2.is)(expr.where.expr);
  };
  FqnExpr2.isCustom = (expr) => {
    return "custom" in expr && ((0, FqnExpr2.is)(expr.custom.expr) || (0, FqnExpr2.isWhere)(expr.custom.expr));
  };
  FqnExpr2.is = (expr) => {
    return (0, FqnExpr2.isWildcard)(expr) || (0, FqnExpr2.isModelRef)(expr) || (0, FqnExpr2.isDeploymentRef)(expr) || isElementKindExpr(expr) || isElementTagExpr(expr);
  };
  FqnExpr2.unwrap = (expr) => {
    if ((0, FqnExpr2.isCustom)(expr)) {
      expr = expr.custom.expr;
    }
    if ((0, FqnExpr2.isWhere)(expr)) {
      expr = expr.where.expr;
    }
    return expr;
  };
})(FqnExpr || (FqnExpr = {}));
var RelationExpr;
((RelationExpr2) => {
  RelationExpr2.isDirect = (expr) => {
    return "source" in expr && "target" in expr;
  };
  RelationExpr2.isIncoming = (expr) => {
    return "incoming" in expr;
  };
  RelationExpr2.isOutgoing = (expr) => {
    return "outgoing" in expr;
  };
  RelationExpr2.isInOut = (expr) => {
    return "inout" in expr;
  };
  RelationExpr2.isWhere = (expr) => {
    return "where" in expr && ((0, RelationExpr2.isDirect)(expr.where.expr) || (0, RelationExpr2.isIncoming)(expr.where.expr) || (0, RelationExpr2.isOutgoing)(expr.where.expr) || (0, RelationExpr2.isInOut)(expr.where.expr));
  };
  RelationExpr2.isCustom = (expr) => {
    return "customRelation" in expr;
  };
  RelationExpr2.is = (expr) => {
    return (0, RelationExpr2.isDirect)(expr) || (0, RelationExpr2.isIncoming)(expr) || (0, RelationExpr2.isOutgoing)(expr) || (0, RelationExpr2.isInOut)(expr);
  };
  RelationExpr2.unwrap = (expr) => {
    if ((0, RelationExpr2.isCustom)(expr)) {
      expr = expr.customRelation.expr;
    }
    if ((0, RelationExpr2.isWhere)(expr)) {
      expr = expr.where.expr;
    }
    return expr;
  };
})(RelationExpr || (RelationExpr = {}));
var ExpressionV2;
((ExpressionV22) => {
  ExpressionV22.isWhere = (expr) => {
    return "where" in expr;
  };
  ExpressionV22.isRelationWhere = (expr) => {
    return RelationExpr.isWhere(expr);
  };
  ExpressionV22.isFqnExprWhere = (expr) => {
    return FqnExpr.isWhere(expr);
  };
  ExpressionV22.isFqnExpr = (expr) => {
    return FqnExpr.is(expr) || FqnExpr.isWhere(expr) || FqnExpr.isCustom(expr);
  };
  ExpressionV22.isRelation = (expr) => {
    return RelationExpr.is(expr) || RelationExpr.isWhere(expr) || RelationExpr.isCustom(expr);
  };
})(ExpressionV2 || (ExpressionV2 = {}));
var ModelLayer;
((ModelLayer2) => {
  ((FqnRef2) => {
    FqnRef2.isModelRef = (ref) => {
      return "model" in ref && !("project" in ref);
    };
    FqnRef2.isImportRef = (ref) => {
      return "project" in ref && "model" in ref;
    };
    FqnRef2.toFqn = (ref) => {
      if ((0, FqnRef2.isImportRef)(ref)) {
        return GlobalFqn(ref.project, ref.model);
      }
      if ((0, FqnRef2.isModelRef)(ref)) {
        return ref.model;
      }
      throw new Error("Expected FqnRef.ModelRef or FqnRef.ImportRef");
    };
  })(ModelLayer2.FqnRef || (ModelLayer2.FqnRef = {}));
  let FqnExpr2;
  ((FqnExpr22) => {
    FqnExpr22.isWildcard = (expr) => {
      return "wildcard" in expr && expr.wildcard === true;
    };
    FqnExpr22.isModelRef = (ref) => {
      return "ref" in ref;
    };
    function isElementKindExpr(expr) {
      return "elementKind" in expr && "isEqual" in expr;
    }
    FqnExpr22.isElementKindExpr = isElementKindExpr;
    function isElementTagExpr(expr) {
      return "elementTag" in expr && "isEqual" in expr;
    }
    FqnExpr22.isElementTagExpr = isElementTagExpr;
    FqnExpr22.isWhere = (expr) => {
      return "where" in expr && (0, FqnExpr22.is)(expr.where.expr);
    };
    FqnExpr22.isCustom = (expr) => {
      return "custom" in expr && ((0, FqnExpr22.is)(expr.custom.expr) || (0, FqnExpr22.isWhere)(expr.custom.expr));
    };
    FqnExpr22.is = (expr) => {
      return (0, FqnExpr22.isWildcard)(expr) || (0, FqnExpr22.isModelRef)(expr) || isElementKindExpr(expr) || isElementTagExpr(expr);
    };
  })(FqnExpr2 = ModelLayer2.FqnExpr || (ModelLayer2.FqnExpr = {}));
  function isAnyFqnExpr(expr) {
    return FqnExpr2.is(expr) || FqnExpr2.isWhere(expr) || FqnExpr2.isCustom(expr);
  }
  ModelLayer2.isAnyFqnExpr = isAnyFqnExpr;
  let RelationExpr2;
  ((RelationExpr22) => {
    RelationExpr22.isDirect = (expr) => {
      return "source" in expr && "target" in expr;
    };
    RelationExpr22.isIncoming = (expr) => {
      return "incoming" in expr;
    };
    RelationExpr22.isOutgoing = (expr) => {
      return "outgoing" in expr;
    };
    RelationExpr22.isInOut = (expr) => {
      return "inout" in expr;
    };
    RelationExpr22.isWhere = (expr) => {
      return "where" in expr && (0, RelationExpr22.is)(expr.where.expr);
    };
    RelationExpr22.isCustom = (expr) => {
      return "customRelation" in expr;
    };
    RelationExpr22.is = (expr) => {
      return (0, RelationExpr22.isDirect)(expr) || (0, RelationExpr22.isIncoming)(expr) || (0, RelationExpr22.isOutgoing)(expr) || (0, RelationExpr22.isInOut)(expr);
    };
  })(RelationExpr2 = ModelLayer2.RelationExpr || (ModelLayer2.RelationExpr = {}));
  function isAnyRelationExpr(expr) {
    return RelationExpr2.is(expr) || RelationExpr2.isWhere(expr) || RelationExpr2.isCustom(expr);
  }
  ModelLayer2.isAnyRelationExpr = isAnyRelationExpr;
  function isExpression(expr) {
    return isAnyFqnExpr(expr) || isAnyRelationExpr(expr);
  }
  ModelLayer2.isExpression = isExpression;
  ((Expression2) => {
    Expression2.isWhere = (expr) => {
      return "where" in expr;
    };
    Expression2.isCustomFqnExpr = (expr) => {
      return FqnExpr2.isCustom(expr);
    };
    Expression2.isCustomRelationExpr = (expr) => {
      return RelationExpr2.isCustom(expr);
    };
    Expression2.isFqnExpr = (expr) => {
      return FqnExpr2.is(expr);
    };
    Expression2.isRelation = (expr) => {
      return RelationExpr2.is(expr);
    };
  })(ModelLayer2.Expression || (ModelLayer2.Expression = {}));
})(ModelLayer || (ModelLayer = {}));
var isTagEqual = (operator) => {
  return "tag" in operator;
};
var isKindEqual = (operator) => {
  return "kind" in operator;
};
var isParticipantOperator = (operator) => {
  return "participant" in operator;
};
var isNotOperator = (operator) => {
  return "not" in operator;
};
var isAndOperator = (operator) => {
  return "and" in operator;
};
var isOrOperator = (operator) => {
  return "or" in operator;
};
function whereOperatorAsPredicate(operator) {
  switch (true) {
    case isParticipantOperator(operator): {
      const participant = operator.participant;
      const participantPredicate = whereOperatorAsPredicate(operator.operator);
      return participantIs(participant, participantPredicate);
    }
    case isTagEqual(operator): {
      if ("eq" in operator.tag) {
        const tag2 = operator.tag.eq;
        return (value) => {
          return Array.isArray(value.tags) && value.tags.includes(tag2);
        };
      }
      const tag = operator.tag.neq;
      return (value) => {
        return !Array.isArray(value.tags) || !value.tags.includes(tag);
      };
    }
    case isKindEqual(operator): {
      if ("eq" in operator.kind) {
        const kind2 = operator.kind.eq;
        return (value) => {
          return value.kind === kind2;
        };
      }
      const kind = operator.kind.neq;
      return (value) => {
        return n2(value.kind) || value.kind !== kind;
      };
    }
    case isNotOperator(operator): {
      const predicate = whereOperatorAsPredicate(operator.not);
      return o$1(predicate);
    }
    case isAndOperator(operator): {
      const predicates = operator.and.map(whereOperatorAsPredicate);
      return t(predicates);
    }
    case isOrOperator(operator): {
      const predicates = operator.or.map(whereOperatorAsPredicate);
      return y(predicates);
    }
    default:
      nonexhaustive(operator);
  }
}
function participantIs(participant, predicate) {
  return (value) => {
    if (!value.source || !value.target) {
      return false;
    }
    switch (participant) {
      case "source": {
        return predicate(value.source);
      }
      case "target": {
        return predicate(value.target);
      }
    }
  };
}
var DefaultLineStyle = "dashed";
var DefaultArrowType = "normal";
var DefaultRelationshipColor = "gray";
function isViewRulePredicate(rule) {
  return "include" in rule && Array.isArray(rule.include) || "exclude" in rule && Array.isArray(rule.exclude);
}
function isViewRuleGlobalPredicateRef(rule) {
  return "predicateId" in rule;
}
function isViewRuleStyle(rule) {
  return "style" in rule && "targets" in rule && Array.isArray(rule.targets);
}
function isViewRuleGlobalStyle(rule) {
  return "styleId" in rule;
}
function isAutoLayoutDirection(autoLayout) {
  return autoLayout === "TB" || autoLayout === "BT" || autoLayout === "LR" || autoLayout === "RL";
}
function isViewRuleAutoLayout(rule) {
  return "direction" in rule;
}
function isViewRuleGroup(rule) {
  return "title" in rule && "groupRules" in rule && Array.isArray(rule.groupRules);
}
function isDynamicViewParallelSteps(step) {
  return "__parallel" in step && o(step.__parallel);
}
function isDeploymentView(view) {
  return view.__ === "deployment";
}
function isDynamicView(view) {
  return view.__ === "dynamic";
}
function isElementView(view) {
  return n2(view.__) || view.__ === "element";
}
function isExtendsElementView(view) {
  return isElementView(view) && "extends" in view;
}
function isScopedElementView(view) {
  return isElementView(view) && "viewOf" in view;
}
function stepEdgeId(step, parallelStep) {
  const id = `step-${String(step).padStart(2, "0")}`;
  return parallelStep ? `${id}.${parallelStep}` : id;
}
function isStepEdgeId(id) {
  return id.startsWith("step-");
}
function extractStep(id) {
  if (!isStepEdgeId(id)) {
    throw new Error(`Invalid step edge id: ${id}`);
  }
  return parseFloat(id.slice("step-".length));
}
function getParallelStepsPrefix(id) {
  if (isStepEdgeId(id) && id.includes(".")) {
    return id.slice(0, id.indexOf(".") + 1);
  }
  return null;
}
var ComputedNode;
((ComputedNode2) => {
  function modelRef(node) {
    return node.modelRef === 1 ? node.id : node.modelRef ?? null;
  }
  ComputedNode2.modelRef = modelRef;
  function deploymentRef(node) {
    return node.deploymentRef === 1 ? node.id : node.deploymentRef ?? null;
  }
  ComputedNode2.deploymentRef = deploymentRef;
  function isNodesGroup(node) {
    return node.kind === ElementKind.Group;
  }
  ComputedNode2.isNodesGroup = isNodesGroup;
})(ComputedNode || (ComputedNode = {}));
var ComputedView;
((ComputedView2) => {
  function isDeployment(view) {
    return view.__ === "deployment";
  }
  ComputedView2.isDeployment = isDeployment;
  function isDynamic(view) {
    return view.__ === "dynamic";
  }
  ComputedView2.isDynamic = isDynamic;
  function isElement(view) {
    return n2(view.__) || view.__ === "element";
  }
  ComputedView2.isElement = isElement;
})(ComputedView || (ComputedView = {}));
function getBBoxCenter({
  x,
  y: y3,
  width,
  height
}) {
  return {
    x: x + width / 2,
    y: y3 + height / 2
  };
}
var DiagramNode;
((DiagramNode2) => {
  function modelRef(node) {
    return node.modelRef === 1 ? node.id : node.modelRef ?? null;
  }
  DiagramNode2.modelRef = modelRef;
  function deploymentRef(node) {
    return node.deploymentRef === 1 ? node.id : node.deploymentRef ?? null;
  }
  DiagramNode2.deploymentRef = deploymentRef;
  function isNodesGroup(node) {
    return node.kind === ElementKind.Group;
  }
  DiagramNode2.isNodesGroup = isNodesGroup;
})(DiagramNode || (DiagramNode = {}));

// node_modules/@likec4/core/dist/shared/core.CAcZ6_cP.mjs
function y$1(t3, i2) {
  let a3 = i2.length - t3.length;
  if (a3 === 1) {
    let [n4, ...r3] = i2;
    return C(n4, { lazy: t3, lazyArgs: r3 });
  }
  if (a3 === 0) {
    let n4 = { lazy: t3, lazyArgs: i2 };
    return Object.assign((e3) => C(e3, n4), n4);
  }
  throw new Error("Wrong number of arguments");
}
function r$3(...t3) {
  return u(Object.values, t3);
}
function d$5(...e3) {
  return e3.length === 2 ? (n4, ...r3) => t$5(n4, ...e3, ...r3) : t$5(...e3);
}
var t$5 = (e3, n4, r3, ...a3) => n4(e3, ...a3) ? typeof r3 == "function" ? r3(e3, ...a3) : r3.onTrue(e3, ...a3) : typeof r3 == "function" ? e3 : r3.onFalse(e3, ...a3);
function i$8(...e3) {
  return y$1(a$4, e3);
}
function a$4() {
  let e3 = /* @__PURE__ */ new Set();
  return (t3) => e3.has(t3) ? s : (e3.add(t3), { done: false, hasNext: true, next: t3 });
}
function l$6(...r3) {
  return u(o$7, r3, u$5);
}
var o$7 = (r3, e3) => e3 < 0 ? [] : r3.slice(0, e3);
function u$5(r3) {
  if (r3 <= 0) return a;
  let e3 = r3;
  return (a3) => (e3 -= 1, { done: e3 <= 0, hasNext: true, next: a3 });
}
var T$1 = { asc: (r3, n4) => r3 > n4, desc: (r3, n4) => r3 < n4 };
function s2(r3, n4) {
  let [e3, ...o3] = n4;
  if (!m$2(e3)) {
    let t3 = u$4(...o3);
    return r3(e3, t3);
  }
  let a3 = u$4(e3, ...o3);
  return (t3) => r3(t3, a3);
}
function u$4(r3, n4, ...e3) {
  let o3 = typeof r3 == "function" ? r3 : r3[0], a3 = typeof r3 == "function" ? "asc" : r3[1], { [a3]: t3 } = T$1, i2 = n4 === void 0 ? void 0 : u$4(n4, ...e3);
  return (y3, c2) => {
    let p2 = o3(y3), l3 = o3(c2);
    return t3(p2, l3) ? 1 : t3(l3, p2) ? -1 : (i2 == null ? void 0 : i2(y3, c2)) ?? 0;
  };
}
function m$2(r3) {
  if (d$4(r3)) return true;
  if (typeof r3 != "object" || !Array.isArray(r3)) return false;
  let [n4, e3, ...o3] = r3;
  return d$4(n4) && typeof e3 == "string" && e3 in T$1 && o3.length === 0;
}
var d$4 = (r3) => typeof r3 == "function" && r3.length === 1;
function m$1(...r3) {
  return u(o$6, r3);
}
function o$6(r3, t3) {
  let e3 = [...r3];
  return e3.sort(t3), e3;
}
function a$3(...r3) {
  return s2(n$2, r3);
}
var n$2 = (r3, t3) => [...r3].sort(t3);
function l$5(...e3) {
  return u(u$3, e3);
}
var u$3 = (e3, a3, n4) => e3.reduce(a3, n4);
function t$4(...e3) {
  return u(r$2, e3);
}
function r$2(e3) {
  return [...e3].reverse();
}
function p$1(...e3) {
  return u(t$3, e3);
}
var t$3 = (e3, o3) => e3[o3];
function d$3(...r3) {
  return u(i$7, r3);
}
var i$7 = (r3, t3) => {
  let a3 = [[], []];
  for (let [o3, e3] of r3.entries()) t3(e3, o3, r3) ? a3[0].push(e3) : a3[1].push(e3);
  return a3;
};
function i$6(...e3) {
  return u(o$5, e3);
}
function o$5(e3, n4) {
  let t3 = {};
  for (let r3 of n4) r3 in e3 && (t3[r3] = e3[r3]);
  return t3;
}
function d$2(...e3) {
  return u(i$5, e3);
}
function i$5(e3, o3) {
  let t3 = {};
  for (let [r3, n4] of Object.entries(e3)) o3(n4, r3, e3) && (t3[r3] = n4);
  return t3;
}
function i$4(...n4) {
  return (o3) => C(o3, ...n4);
}
function d$1(...e3) {
  return u(l$4, e3);
}
function l$4(e3, a3) {
  let t3 = { ...e3 };
  for (let [n4, o3] of Object.entries(t3)) a3(o3, n4, e3) && delete t3[n4];
  return t3;
}
function t$2(...n4) {
  return u(o$4, n4);
}
var o$4 = (n4) => n4.length === 1 ? n4[0] : void 0;
function i$3(...e3) {
  return u(o$3, e3);
}
function o$3(e3, r3) {
  let a3 = {};
  for (let [n4, u4] of Object.entries(e3)) {
    let l3 = r3(u4, n4, e3);
    a3[n4] = l3;
  }
  return a3;
}
function a$2(...e3) {
  return u(n$12, e3);
}
var n$12 = (e3) => e3.at(-1);
function l$3(...n4) {
  return u(d2, n4);
}
function d2(n4, o3) {
  let e3 = {};
  for (let [a3, t3] of n4.entries()) {
    let [y3, u4] = o3(t3, a3, n4);
    e3[y3] = u4;
  }
  return e3;
}
function e$1(r3) {
  return typeof r3 == "number" && !Number.isNaN(r3);
}
function n3(e3) {
  return e3 === void 0 ? true : typeof e3 == "string" || Array.isArray(e3) ? e3.length === 0 : Object.keys(e3).length === 0;
}
function e2(o3) {
  return typeof o3 == "boolean";
}
function i$2(...e3) {
  return u(p, e3);
}
var p = (e3, a3) => {
  let n4 = /* @__PURE__ */ new Map();
  for (let [d3, t3] of e3.entries()) {
    let y3 = a3(t3, d3, e3);
    if (y3 !== void 0) {
      let r3 = n4.get(y3);
      r3 === void 0 && (r3 = [], n4.set(y3, r3)), r3.push(t3);
    }
  }
  return Object.fromEntries(n4);
};
function k(...n4) {
  return u(u$2, n4);
}
function u$2(n4, e3) {
  if (n4 === e3 || Object.is(n4, e3)) return true;
  if (typeof n4 != "object" || typeof e3 != "object" || n4 === null || e3 === null || Object.getPrototypeOf(n4) !== Object.getPrototypeOf(e3)) return false;
  if (Array.isArray(n4)) return l$2(n4, e3);
  if (n4 instanceof Map) return a$1(n4, e3);
  if (n4 instanceof Set) return c(n4, e3);
  if (n4 instanceof Date) return n4.getTime() === e3.getTime();
  if (n4 instanceof RegExp) return n4.toString() === e3.toString();
  if (Object.keys(n4).length !== Object.keys(e3).length) return false;
  for (let [r3, t3] of Object.entries(n4)) if (!(r3 in e3) || !u$2(t3, e3[r3])) return false;
  return true;
}
function l$2(n4, e3) {
  if (n4.length !== e3.length) return false;
  for (let [r3, t3] of n4.entries()) if (!u$2(t3, e3[r3])) return false;
  return true;
}
function a$1(n4, e3) {
  if (n4.size !== e3.size) return false;
  for (let [r3, t3] of n4.entries()) if (!e3.has(r3) || !u$2(t3, e3.get(r3))) return false;
  return true;
}
function c(n4, e3) {
  if (n4.size !== e3.size) return false;
  let r3 = [...e3];
  for (let t3 of n4) {
    let o3 = false;
    for (let [s3, f] of r3.entries()) if (u$2(t3, f)) {
      o3 = true, r3.splice(s3, 1);
      break;
    }
    if (!o3) return false;
  }
  return true;
}
function u$1(...a3) {
  return u(o$2, a3, l$1);
}
var o$2 = (a3, r3) => a3.flatMap(r3);
var l$1 = (a3) => (r3, t3, y3) => {
  let n4 = a3(r3, t3, y3);
  return Array.isArray(n4) ? { done: false, hasNext: true, hasMany: true, next: n4 } : { done: false, hasNext: true, next: n4 };
};
function u3(...e3) {
  return u(o$12, e3, i$12);
}
function o$12(e3, a3) {
  return e3.forEach(a3), e3;
}
var i$12 = (e3) => (a3, n4, t3) => (e3(a3, n4, t3), { done: false, hasNext: true, next: a3 });
function t$12(...r3) {
  return u(Object.entries, r3);
}
function T(...a3) {
  return u(l2, a3, y2);
}
var l2 = (a3, r3) => a3.filter(r3);
var y2 = (a3) => (r3, t3, o3) => a3(r3, t3, o3) ? { done: false, hasNext: true, next: r3 } : s;
function o2(...e3) {
  return u(t2, e3);
}
var t2 = (e3, r3) => {
  for (let n4 = e3.length - 1; n4 >= 0; n4--) {
    let a3 = e3[n4];
    if (r3(a3, n4, e3)) return a3;
  }
};
function m2(...e3) {
  return u(i, e3);
}
function i(e3, t3) {
  for (let [n4, o3] of e3.entries()) if (!t3(o3, n4, e3)) return e3.slice(n4);
  return [];
}
function a2(...e3) {
  return u(r$1, e3);
}
var r$1 = (e3, t3) => [...e3, ...t3];
function r2(n4) {
  return () => n4;
}
var ElementModel = class {
  constructor($model, $element) {
    __publicField(this, "id");
    __publicField(this, "_literalId");
    __publicField(this, "hierarchyLevel");
    __publicField(this, "imported");
    __publicField(this, "cachedOutgoing", null);
    __publicField(this, "cachedIncoming", null);
    this.$model = $model;
    this.$element = $element;
    this.id = this.$element.id;
    this._literalId = this.$element.id;
    const [projectId, fqn] = splitGlobalFqn(this.id);
    if (projectId) {
      this.imported = {
        from: projectId,
        fqn
      };
      this.hierarchyLevel = hierarchyLevel(fqn);
    } else {
      this.imported = null;
      this.hierarchyLevel = hierarchyLevel(this.id);
    }
  }
  get parent() {
    return this.$model.parent(this);
  }
  get kind() {
    return this.$element.kind;
  }
  get shape() {
    return this.$element.shape ?? DefaultElementShape;
  }
  get color() {
    return this.$element.color ?? DefaultThemeColor;
  }
  get icon() {
    return this.$element.icon ?? null;
  }
  get tags() {
    return this.$element.tags ?? [];
  }
  get title() {
    return this.$element.title;
  }
  get description() {
    return this.$element.description;
  }
  get technology() {
    return this.$element.technology;
  }
  get links() {
    return this.$element.links ?? [];
  }
  get defaultView() {
    return this.scopedViews().next().value ?? null;
  }
  get isRoot() {
    return this.parent === null;
  }
  get style() {
    return {
      size: DefaultShapeSize,
      ...this.$element.style
    };
  }
  isAncestorOf(another) {
    return isAncestor(this, another);
  }
  isDescendantOf(another) {
    return isAncestor(another, this);
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors() {
    return this.$model.ancestors(this);
  }
  /**
   * Returns the common ancestor of this element and another element.
   */
  commonAncestor(another) {
    const common = commonAncestor(this.id, another.id);
    return common ? this.$model.element(common) : null;
  }
  children() {
    return this.$model.children(this);
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  descendants(sort) {
    if (sort) {
      const sorted = sortNaturalByFqn([...this.$model.descendants(this)], sort);
      return sorted[Symbol.iterator]();
    }
    return this.$model.descendants(this);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  siblings() {
    return this.$model.siblings(this);
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from closest to root)
   */
  *ascendingSiblings() {
    yield* this.siblings();
    for (const ancestor of this.ancestors()) {
      yield* ancestor.siblings();
    }
    return;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from root to closest)
   */
  *descendingSiblings() {
    for (const ancestor of [...this.ancestors()].reverse()) {
      yield* ancestor.siblings();
    }
    yield* this.siblings();
    return;
  }
  incoming(filter = "all") {
    return this.$model.incoming(this, filter);
  }
  *incomers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r3 of this.incoming(filter)) {
      if (unique.has(r3.source.id)) {
        continue;
      }
      unique.add(r3.source.id);
      yield r3.source;
    }
    return;
  }
  outgoing(filter = "all") {
    return this.$model.outgoing(this, filter);
  }
  *outgoers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r3 of this.outgoing(filter)) {
      if (unique.has(r3.target.id)) {
        continue;
      }
      unique.add(r3.target.id);
      yield r3.target;
    }
    return;
  }
  get allOutgoing() {
    this.cachedOutgoing ?? (this.cachedOutgoing = new Set(this.outgoing()));
    return this.cachedOutgoing;
  }
  get allIncoming() {
    this.cachedIncoming ?? (this.cachedIncoming = new Set(this.incoming()));
    return this.cachedIncoming;
  }
  /**
   * Iterate over all views that include this element.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (view.includesElement(this.id)) {
        yield view;
      }
    }
    return;
  }
  /**
   * Iterate over all views that scope this element.
   * It is possible that element is not included in the view.
   */
  *scopedViews() {
    for (const vm of this.$model.views()) {
      if (vm.isElementView() && vm.$view.viewOf === this.id) {
        yield vm;
      }
    }
    return;
  }
  /**
   * @returns true if the element is deployed
   */
  isDeployed() {
    return n$1(this.deployments().next().value);
  }
  deployments() {
    return this.$model.deployment.instancesOf(this);
  }
};
function isElementModel(element) {
  return element instanceof ElementModel;
}
function buildElementNotations(nodes) {
  return C(
    nodes,
    i$2(p$1("notation")),
    i$3(
      i$4(
        i$2(p$1("shape")),
        i$3(
          i$4(
            i$2(p$1("color")),
            i$3(
              i$4(
                m(p$1("kind")),
                i$8()
              )
            ),
            t$12(),
            m(([color, kinds]) => ({
              kinds,
              color
            }))
          )
        ),
        t$12(),
        u$1(
          ([shape, colors]) => colors.map(({ color, kinds }) => ({
            shape,
            color,
            kinds
          }))
        )
      )
    ),
    t$12(),
    u$1(
      ([title, shapes]) => shapes.map(({ shape, color, kinds }) => ({
        title,
        shape,
        color,
        kinds
      }))
    ),
    a$3(
      p$1("shape"),
      p$1("title"),
      [
        (n4) => n4.kinds.length,
        "desc"
      ]
    )
  );
}
function ancestorsOfNode(node, nodes) {
  const ancestors = [];
  let parentId = node.parent;
  while (parentId) {
    const parentNode = nonNullable(nodes.get(parentId), `Parent node ${parentId} not found`);
    ancestors.push(parentNode);
    parentId = parentNode.parent;
  }
  return ancestors;
}
function linkNodesWithEdges(nodesMap, edges) {
  for (const edge of edges) {
    const source = nodesMap.get(edge.source);
    const target = nodesMap.get(edge.target);
    invariant(source, `Source node ${edge.source} not found`);
    invariant(target, `Target node ${edge.target} not found`);
    source.outEdges.push(edge.id);
    target.inEdges.push(edge.id);
    const sourceAncestors = ancestorsOfNode(source, nodesMap);
    const targetAncestors = ancestorsOfNode(target, nodesMap);
    const hasAncestors = sourceAncestors.length > 0 && targetAncestors.length > 0;
    const edgeParent = hasAncestors ? a$2(
      commonHead(
        t$4(sourceAncestors),
        t$4(targetAncestors)
      )
    ) : null;
    edge.parent = edgeParent ? edgeParent.id : null;
    for (const sourceAncestor of sourceAncestors) {
      if (sourceAncestor === edgeParent) {
        break;
      }
      sourceAncestor.outEdges.push(edge.id);
    }
    for (const targetAncestor of targetAncestors) {
      if (targetAncestor === edgeParent) {
        break;
      }
      targetAncestor.inEdges.push(edge.id);
    }
  }
}
var graphology_umd_min$1 = { exports: {} };
var graphology_umd_min = graphology_umd_min$1.exports;
var hasRequiredGraphology_umd_min;
function requireGraphology_umd_min() {
  if (hasRequiredGraphology_umd_min) return graphology_umd_min$1.exports;
  hasRequiredGraphology_umd_min = 1;
  (function(module, exports) {
    !function(t3, e3) {
      module.exports = e3();
    }(graphology_umd_min, function() {
      function t3(e4) {
        return t3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
          return typeof t4;
        } : function(t4) {
          return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
        }, t3(e4);
      }
      function e3(t4, e4) {
        t4.prototype = Object.create(e4.prototype), t4.prototype.constructor = t4, r3(t4, e4);
      }
      function n4(t4) {
        return n4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, n4(t4);
      }
      function r3(t4, e4) {
        return r3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e5) {
          return t5.__proto__ = e5, t5;
        }, r3(t4, e4);
      }
      function i2() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if ("function" == typeof Proxy) return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t4) {
          return false;
        }
      }
      function o3(t4, e4, n5) {
        return o3 = i2() ? Reflect.construct.bind() : function(t5, e5, n6) {
          var i3 = [null];
          i3.push.apply(i3, e5);
          var o4 = new (Function.bind.apply(t5, i3))();
          return n6 && r3(o4, n6.prototype), o4;
        }, o3.apply(null, arguments);
      }
      function a3(t4) {
        var e4 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return a3 = function(t5) {
          if (null === t5 || (i3 = t5, -1 === Function.toString.call(i3).indexOf("[native code]"))) return t5;
          var i3;
          if ("function" != typeof t5) throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e4) {
            if (e4.has(t5)) return e4.get(t5);
            e4.set(t5, a4);
          }
          function a4() {
            return o3(t5, arguments, n4(this).constructor);
          }
          return a4.prototype = Object.create(t5.prototype, { constructor: { value: a4, enumerable: false, writable: true, configurable: true } }), r3(a4, t5);
        }, a3(t4);
      }
      function c2(t4) {
        if (void 0 === t4) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t4;
      }
      var u4 = function() {
        for (var t4 = arguments[0], e4 = 1, n5 = arguments.length; e4 < n5; e4++) if (arguments[e4]) for (var r4 in arguments[e4]) t4[r4] = arguments[e4][r4];
        return t4;
      };
      function d3(t4, e4, n5, r4) {
        var i3 = t4._nodes.get(e4), o4 = null;
        return i3 ? o4 = "mixed" === r4 ? i3.out && i3.out[n5] || i3.undirected && i3.undirected[n5] : "directed" === r4 ? i3.out && i3.out[n5] : i3.undirected && i3.undirected[n5] : o4;
      }
      function s3(e4) {
        return "object" === t3(e4) && null !== e4;
      }
      function h(t4) {
        var e4;
        for (e4 in t4) return false;
        return true;
      }
      function p2(t4, e4, n5) {
        Object.defineProperty(t4, e4, { enumerable: false, configurable: false, writable: true, value: n5 });
      }
      function f(t4, e4, n5) {
        var r4 = { enumerable: true, configurable: true };
        "function" == typeof n5 ? r4.get = n5 : (r4.value = n5, r4.writable = false), Object.defineProperty(t4, e4, r4);
      }
      function l3(t4) {
        return !!s3(t4) && !(t4.attributes && !Array.isArray(t4.attributes));
      }
      "function" == typeof Object.assign && (u4 = Object.assign);
      var g, y3 = { exports: {} }, w = "object" == typeof Reflect ? Reflect : null, v = w && "function" == typeof w.apply ? w.apply : function(t4, e4, n5) {
        return Function.prototype.apply.call(t4, e4, n5);
      };
      g = w && "function" == typeof w.ownKeys ? w.ownKeys : Object.getOwnPropertySymbols ? function(t4) {
        return Object.getOwnPropertyNames(t4).concat(Object.getOwnPropertySymbols(t4));
      } : function(t4) {
        return Object.getOwnPropertyNames(t4);
      };
      var b = Number.isNaN || function(t4) {
        return t4 != t4;
      };
      function m3() {
        m3.init.call(this);
      }
      y3.exports = m3, y3.exports.once = function(t4, e4) {
        return new Promise(function(n5, r4) {
          function i3(n6) {
            t4.removeListener(e4, o4), r4(n6);
          }
          function o4() {
            "function" == typeof t4.removeListener && t4.removeListener("error", i3), n5([].slice.call(arguments));
          }
          U(t4, e4, o4, { once: true }), "error" !== e4 && function(t5, e5, n6) {
            "function" == typeof t5.on && U(t5, "error", e5, n6);
          }(t4, i3, { once: true });
        });
      }, m3.EventEmitter = m3, m3.prototype._events = void 0, m3.prototype._eventsCount = 0, m3.prototype._maxListeners = void 0;
      var k2 = 10;
      function _(t4) {
        if ("function" != typeof t4) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t4);
      }
      function G(t4) {
        return void 0 === t4._maxListeners ? m3.defaultMaxListeners : t4._maxListeners;
      }
      function x(t4, e4, n5, r4) {
        var i3, o4, a4, c3;
        if (_(n5), void 0 === (o4 = t4._events) ? (o4 = t4._events = /* @__PURE__ */ Object.create(null), t4._eventsCount = 0) : (void 0 !== o4.newListener && (t4.emit("newListener", e4, n5.listener ? n5.listener : n5), o4 = t4._events), a4 = o4[e4]), void 0 === a4) a4 = o4[e4] = n5, ++t4._eventsCount;
        else if ("function" == typeof a4 ? a4 = o4[e4] = r4 ? [n5, a4] : [a4, n5] : r4 ? a4.unshift(n5) : a4.push(n5), (i3 = G(t4)) > 0 && a4.length > i3 && !a4.warned) {
          a4.warned = true;
          var u5 = new Error("Possible EventEmitter memory leak detected. " + a4.length + " " + String(e4) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          u5.name = "MaxListenersExceededWarning", u5.emitter = t4, u5.type = e4, u5.count = a4.length, c3 = u5, console && console.warn && console.warn(c3);
        }
        return t4;
      }
      function E() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function A(t4, e4, n5) {
        var r4 = { fired: false, wrapFn: void 0, target: t4, type: e4, listener: n5 }, i3 = E.bind(r4);
        return i3.listener = n5, r4.wrapFn = i3, i3;
      }
      function L(t4, e4, n5) {
        var r4 = t4._events;
        if (void 0 === r4) return [];
        var i3 = r4[e4];
        return void 0 === i3 ? [] : "function" == typeof i3 ? n5 ? [i3.listener || i3] : [i3] : n5 ? function(t5) {
          for (var e5 = new Array(t5.length), n6 = 0; n6 < e5.length; ++n6) e5[n6] = t5[n6].listener || t5[n6];
          return e5;
        }(i3) : D(i3, i3.length);
      }
      function S(t4) {
        var e4 = this._events;
        if (void 0 !== e4) {
          var n5 = e4[t4];
          if ("function" == typeof n5) return 1;
          if (void 0 !== n5) return n5.length;
        }
        return 0;
      }
      function D(t4, e4) {
        for (var n5 = new Array(e4), r4 = 0; r4 < e4; ++r4) n5[r4] = t4[r4];
        return n5;
      }
      function U(t4, e4, n5, r4) {
        if ("function" == typeof t4.on) r4.once ? t4.once(e4, n5) : t4.on(e4, n5);
        else {
          if ("function" != typeof t4.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t4);
          t4.addEventListener(e4, function i3(o4) {
            r4.once && t4.removeEventListener(e4, i3), n5(o4);
          });
        }
      }
      function N(t4) {
        if ("function" != typeof t4) throw new Error("obliterator/iterator: expecting a function!");
        this.next = t4;
      }
      Object.defineProperty(m3, "defaultMaxListeners", { enumerable: true, get: function() {
        return k2;
      }, set: function(t4) {
        if ("number" != typeof t4 || t4 < 0 || b(t4)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t4 + ".");
        k2 = t4;
      } }), m3.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, m3.prototype.setMaxListeners = function(t4) {
        if ("number" != typeof t4 || t4 < 0 || b(t4)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t4 + ".");
        return this._maxListeners = t4, this;
      }, m3.prototype.getMaxListeners = function() {
        return G(this);
      }, m3.prototype.emit = function(t4) {
        for (var e4 = [], n5 = 1; n5 < arguments.length; n5++) e4.push(arguments[n5]);
        var r4 = "error" === t4, i3 = this._events;
        if (void 0 !== i3) r4 = r4 && void 0 === i3.error;
        else if (!r4) return false;
        if (r4) {
          var o4;
          if (e4.length > 0 && (o4 = e4[0]), o4 instanceof Error) throw o4;
          var a4 = new Error("Unhandled error." + (o4 ? " (" + o4.message + ")" : ""));
          throw a4.context = o4, a4;
        }
        var c3 = i3[t4];
        if (void 0 === c3) return false;
        if ("function" == typeof c3) v(c3, this, e4);
        else {
          var u5 = c3.length, d4 = D(c3, u5);
          for (n5 = 0; n5 < u5; ++n5) v(d4[n5], this, e4);
        }
        return true;
      }, m3.prototype.addListener = function(t4, e4) {
        return x(this, t4, e4, false);
      }, m3.prototype.on = m3.prototype.addListener, m3.prototype.prependListener = function(t4, e4) {
        return x(this, t4, e4, true);
      }, m3.prototype.once = function(t4, e4) {
        return _(e4), this.on(t4, A(this, t4, e4)), this;
      }, m3.prototype.prependOnceListener = function(t4, e4) {
        return _(e4), this.prependListener(t4, A(this, t4, e4)), this;
      }, m3.prototype.removeListener = function(t4, e4) {
        var n5, r4, i3, o4, a4;
        if (_(e4), void 0 === (r4 = this._events)) return this;
        if (void 0 === (n5 = r4[t4])) return this;
        if (n5 === e4 || n5.listener === e4) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r4[t4], r4.removeListener && this.emit("removeListener", t4, n5.listener || e4));
        else if ("function" != typeof n5) {
          for (i3 = -1, o4 = n5.length - 1; o4 >= 0; o4--) if (n5[o4] === e4 || n5[o4].listener === e4) {
            a4 = n5[o4].listener, i3 = o4;
            break;
          }
          if (i3 < 0) return this;
          0 === i3 ? n5.shift() : function(t5, e5) {
            for (; e5 + 1 < t5.length; e5++) t5[e5] = t5[e5 + 1];
            t5.pop();
          }(n5, i3), 1 === n5.length && (r4[t4] = n5[0]), void 0 !== r4.removeListener && this.emit("removeListener", t4, a4 || e4);
        }
        return this;
      }, m3.prototype.off = m3.prototype.removeListener, m3.prototype.removeAllListeners = function(t4) {
        var e4, n5, r4;
        if (void 0 === (n5 = this._events)) return this;
        if (void 0 === n5.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n5[t4] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n5[t4]), this;
        if (0 === arguments.length) {
          var i3, o4 = Object.keys(n5);
          for (r4 = 0; r4 < o4.length; ++r4) "removeListener" !== (i3 = o4[r4]) && this.removeAllListeners(i3);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (e4 = n5[t4])) this.removeListener(t4, e4);
        else if (void 0 !== e4) for (r4 = e4.length - 1; r4 >= 0; r4--) this.removeListener(t4, e4[r4]);
        return this;
      }, m3.prototype.listeners = function(t4) {
        return L(this, t4, true);
      }, m3.prototype.rawListeners = function(t4) {
        return L(this, t4, false);
      }, m3.listenerCount = function(t4, e4) {
        return "function" == typeof t4.listenerCount ? t4.listenerCount(e4) : S.call(t4, e4);
      }, m3.prototype.listenerCount = S, m3.prototype.eventNames = function() {
        return this._eventsCount > 0 ? g(this._events) : [];
      }, "undefined" != typeof Symbol && (N.prototype[Symbol.iterator] = function() {
        return this;
      }), N.of = function() {
        var t4 = arguments, e4 = t4.length, n5 = 0;
        return new N(function() {
          return n5 >= e4 ? { done: true } : { done: false, value: t4[n5++] };
        });
      }, N.empty = function() {
        return new N(function() {
          return { done: true };
        });
      }, N.fromSequence = function(t4) {
        var e4 = 0, n5 = t4.length;
        return new N(function() {
          return e4 >= n5 ? { done: true } : { done: false, value: t4[e4++] };
        });
      }, N.is = function(t4) {
        return t4 instanceof N || "object" == typeof t4 && null !== t4 && "function" == typeof t4.next;
      };
      var O = N, j = {};
      j.ARRAY_BUFFER_SUPPORT = "undefined" != typeof ArrayBuffer, j.SYMBOL_SUPPORT = "undefined" != typeof Symbol;
      var C2 = O, M = j, z = M.ARRAY_BUFFER_SUPPORT, W = M.SYMBOL_SUPPORT;
      var P = function(t4) {
        var e4 = function(t5) {
          return "string" == typeof t5 || Array.isArray(t5) || z && ArrayBuffer.isView(t5) ? C2.fromSequence(t5) : "object" != typeof t5 || null === t5 ? null : W && "function" == typeof t5[Symbol.iterator] ? t5[Symbol.iterator]() : "function" == typeof t5.next ? t5 : null;
        }(t4);
        if (!e4) throw new Error("obliterator: target is not iterable nor a valid iterator.");
        return e4;
      }, R = P, K = function(t4, e4) {
        for (var n5, r4 = arguments.length > 1 ? e4 : 1 / 0, i3 = r4 !== 1 / 0 ? new Array(r4) : [], o4 = 0, a4 = R(t4); ; ) {
          if (o4 === r4) return i3;
          if ((n5 = a4.next()).done) return o4 !== e4 && (i3.length = o4), i3;
          i3[o4++] = n5.value;
        }
      }, T2 = function(t4) {
        function n5(e4) {
          var n6;
          return (n6 = t4.call(this) || this).name = "GraphError", n6.message = e4, n6;
        }
        return e3(n5, t4), n5;
      }(a3(Error)), B = function(t4) {
        function n5(e4) {
          var r4;
          return (r4 = t4.call(this, e4) || this).name = "InvalidArgumentsGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c2(r4), n5.prototype.constructor), r4;
        }
        return e3(n5, t4), n5;
      }(T2), F = function(t4) {
        function n5(e4) {
          var r4;
          return (r4 = t4.call(this, e4) || this).name = "NotFoundGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c2(r4), n5.prototype.constructor), r4;
        }
        return e3(n5, t4), n5;
      }(T2), I = function(t4) {
        function n5(e4) {
          var r4;
          return (r4 = t4.call(this, e4) || this).name = "UsageGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c2(r4), n5.prototype.constructor), r4;
        }
        return e3(n5, t4), n5;
      }(T2);
      function Y(t4, e4) {
        this.key = t4, this.attributes = e4, this.clear();
      }
      function q(t4, e4) {
        this.key = t4, this.attributes = e4, this.clear();
      }
      function J(t4, e4) {
        this.key = t4, this.attributes = e4, this.clear();
      }
      function V(t4, e4, n5, r4, i3) {
        this.key = e4, this.attributes = i3, this.undirected = t4, this.source = n5, this.target = r4;
      }
      Y.prototype.clear = function() {
        this.inDegree = 0, this.outDegree = 0, this.undirectedDegree = 0, this.undirectedLoops = 0, this.directedLoops = 0, this.in = {}, this.out = {}, this.undirected = {};
      }, q.prototype.clear = function() {
        this.inDegree = 0, this.outDegree = 0, this.directedLoops = 0, this.in = {}, this.out = {};
      }, J.prototype.clear = function() {
        this.undirectedDegree = 0, this.undirectedLoops = 0, this.undirected = {};
      }, V.prototype.attach = function() {
        var t4 = "out", e4 = "in";
        this.undirected && (t4 = e4 = "undirected");
        var n5 = this.source.key, r4 = this.target.key;
        this.source[t4][r4] = this, this.undirected && n5 === r4 || (this.target[e4][n5] = this);
      }, V.prototype.attachMulti = function() {
        var t4 = "out", e4 = "in", n5 = this.source.key, r4 = this.target.key;
        this.undirected && (t4 = e4 = "undirected");
        var i3 = this.source[t4], o4 = i3[r4];
        if (void 0 === o4) return i3[r4] = this, void (this.undirected && n5 === r4 || (this.target[e4][n5] = this));
        o4.previous = this, this.next = o4, i3[r4] = this, this.target[e4][n5] = this;
      }, V.prototype.detach = function() {
        var t4 = this.source.key, e4 = this.target.key, n5 = "out", r4 = "in";
        this.undirected && (n5 = r4 = "undirected"), delete this.source[n5][e4], delete this.target[r4][t4];
      }, V.prototype.detachMulti = function() {
        var t4 = this.source.key, e4 = this.target.key, n5 = "out", r4 = "in";
        this.undirected && (n5 = r4 = "undirected"), void 0 === this.previous ? void 0 === this.next ? (delete this.source[n5][e4], delete this.target[r4][t4]) : (this.next.previous = void 0, this.source[n5][e4] = this.next, this.target[r4][t4] = this.next) : (this.previous.next = this.next, void 0 !== this.next && (this.next.previous = this.previous));
      };
      function H(t4, e4, n5, r4, i3, o4, a4) {
        var c3, u5, d4, s4;
        if (r4 = "" + r4, 0 === n5) {
          if (!(c3 = t4._nodes.get(r4))) throw new F("Graph.".concat(e4, ': could not find the "').concat(r4, '" node in the graph.'));
          d4 = i3, s4 = o4;
        } else if (3 === n5) {
          if (i3 = "" + i3, !(u5 = t4._edges.get(i3))) throw new F("Graph.".concat(e4, ': could not find the "').concat(i3, '" edge in the graph.'));
          var h2 = u5.source.key, p3 = u5.target.key;
          if (r4 === h2) c3 = u5.target;
          else {
            if (r4 !== p3) throw new F("Graph.".concat(e4, ': the "').concat(r4, '" node is not attached to the "').concat(i3, '" edge (').concat(h2, ", ").concat(p3, ")."));
            c3 = u5.source;
          }
          d4 = o4, s4 = a4;
        } else {
          if (!(u5 = t4._edges.get(r4))) throw new F("Graph.".concat(e4, ': could not find the "').concat(r4, '" edge in the graph.'));
          c3 = 1 === n5 ? u5.source : u5.target, d4 = i3, s4 = o4;
        }
        return [c3, d4, s4];
      }
      var Q = [{ name: function(t4) {
        return "get".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3) {
          var o4 = H(this, e4, n5, t5, r4, i3), a4 = o4[0], c3 = o4[1];
          return a4.attributes[c3];
        };
      } }, { name: function(t4) {
        return "get".concat(t4, "Attributes");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4) {
          return H(this, e4, n5, t5, r4)[0].attributes;
        };
      } }, { name: function(t4) {
        return "has".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3) {
          var o4 = H(this, e4, n5, t5, r4, i3), a4 = o4[0], c3 = o4[1];
          return a4.attributes.hasOwnProperty(c3);
        };
      } }, { name: function(t4) {
        return "set".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3, o4) {
          var a4 = H(this, e4, n5, t5, r4, i3, o4), c3 = a4[0], u5 = a4[1], d4 = a4[2];
          return c3.attributes[u5] = d4, this.emit("nodeAttributesUpdated", { key: c3.key, type: "set", attributes: c3.attributes, name: u5 }), this;
        };
      } }, { name: function(t4) {
        return "update".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3, o4) {
          var a4 = H(this, e4, n5, t5, r4, i3, o4), c3 = a4[0], u5 = a4[1], d4 = a4[2];
          if ("function" != typeof d4) throw new B("Graph.".concat(e4, ": updater should be a function."));
          var s4 = c3.attributes, h2 = d4(s4[u5]);
          return s4[u5] = h2, this.emit("nodeAttributesUpdated", { key: c3.key, type: "set", attributes: c3.attributes, name: u5 }), this;
        };
      } }, { name: function(t4) {
        return "remove".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3) {
          var o4 = H(this, e4, n5, t5, r4, i3), a4 = o4[0], c3 = o4[1];
          return delete a4.attributes[c3], this.emit("nodeAttributesUpdated", { key: a4.key, type: "remove", attributes: a4.attributes, name: c3 }), this;
        };
      } }, { name: function(t4) {
        return "replace".concat(t4, "Attributes");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3) {
          var o4 = H(this, e4, n5, t5, r4, i3), a4 = o4[0], c3 = o4[1];
          if (!s3(c3)) throw new B("Graph.".concat(e4, ": provided attributes are not a plain object."));
          return a4.attributes = c3, this.emit("nodeAttributesUpdated", { key: a4.key, type: "replace", attributes: a4.attributes }), this;
        };
      } }, { name: function(t4) {
        return "merge".concat(t4, "Attributes");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3) {
          var o4 = H(this, e4, n5, t5, r4, i3), a4 = o4[0], c3 = o4[1];
          if (!s3(c3)) throw new B("Graph.".concat(e4, ": provided attributes are not a plain object."));
          return u4(a4.attributes, c3), this.emit("nodeAttributesUpdated", { key: a4.key, type: "merge", attributes: a4.attributes, data: c3 }), this;
        };
      } }, { name: function(t4) {
        return "update".concat(t4, "Attributes");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3) {
          var o4 = H(this, e4, n5, t5, r4, i3), a4 = o4[0], c3 = o4[1];
          if ("function" != typeof c3) throw new B("Graph.".concat(e4, ": provided updater is not a function."));
          return a4.attributes = c3(a4.attributes), this.emit("nodeAttributesUpdated", { key: a4.key, type: "update", attributes: a4.attributes }), this;
        };
      } }];
      var X = [{ name: function(t4) {
        return "get".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4) {
          var i3;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o4 = "" + t5, a4 = "" + r4;
            if (r4 = arguments[2], !(i3 = d3(this, o4, a4, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(o4, '" - "').concat(a4, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(i3 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          return i3.attributes[r4];
        };
      } }, { name: function(t4) {
        return "get".concat(t4, "Attributes");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5) {
          var r4;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 1) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var i3 = "" + t5, o4 = "" + arguments[1];
            if (!(r4 = d3(this, i3, o4, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(i3, '" - "').concat(o4, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(r4 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          return r4.attributes;
        };
      } }, { name: function(t4) {
        return "has".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4) {
          var i3;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o4 = "" + t5, a4 = "" + r4;
            if (r4 = arguments[2], !(i3 = d3(this, o4, a4, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(o4, '" - "').concat(a4, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(i3 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          return i3.attributes.hasOwnProperty(r4);
        };
      } }, { name: function(t4) {
        return "set".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3) {
          var o4;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 3) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var a4 = "" + t5, c3 = "" + r4;
            if (r4 = arguments[2], i3 = arguments[3], !(o4 = d3(this, a4, c3, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(a4, '" - "').concat(c3, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(o4 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          return o4.attributes[r4] = i3, this.emit("edgeAttributesUpdated", { key: o4.key, type: "set", attributes: o4.attributes, name: r4 }), this;
        };
      } }, { name: function(t4) {
        return "update".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4, i3) {
          var o4;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 3) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var a4 = "" + t5, c3 = "" + r4;
            if (r4 = arguments[2], i3 = arguments[3], !(o4 = d3(this, a4, c3, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(a4, '" - "').concat(c3, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(o4 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          if ("function" != typeof i3) throw new B("Graph.".concat(e4, ": updater should be a function."));
          return o4.attributes[r4] = i3(o4.attributes[r4]), this.emit("edgeAttributesUpdated", { key: o4.key, type: "set", attributes: o4.attributes, name: r4 }), this;
        };
      } }, { name: function(t4) {
        return "remove".concat(t4, "Attribute");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4) {
          var i3;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o4 = "" + t5, a4 = "" + r4;
            if (r4 = arguments[2], !(i3 = d3(this, o4, a4, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(o4, '" - "').concat(a4, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(i3 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          return delete i3.attributes[r4], this.emit("edgeAttributesUpdated", { key: i3.key, type: "remove", attributes: i3.attributes, name: r4 }), this;
        };
      } }, { name: function(t4) {
        return "replace".concat(t4, "Attributes");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4) {
          var i3;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o4 = "" + t5, a4 = "" + r4;
            if (r4 = arguments[2], !(i3 = d3(this, o4, a4, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(o4, '" - "').concat(a4, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(i3 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          if (!s3(r4)) throw new B("Graph.".concat(e4, ": provided attributes are not a plain object."));
          return i3.attributes = r4, this.emit("edgeAttributesUpdated", { key: i3.key, type: "replace", attributes: i3.attributes }), this;
        };
      } }, { name: function(t4) {
        return "merge".concat(t4, "Attributes");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4) {
          var i3;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o4 = "" + t5, a4 = "" + r4;
            if (r4 = arguments[2], !(i3 = d3(this, o4, a4, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(o4, '" - "').concat(a4, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(i3 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          if (!s3(r4)) throw new B("Graph.".concat(e4, ": provided attributes are not a plain object."));
          return u4(i3.attributes, r4), this.emit("edgeAttributesUpdated", { key: i3.key, type: "merge", attributes: i3.attributes, data: r4 }), this;
        };
      } }, { name: function(t4) {
        return "update".concat(t4, "Attributes");
      }, attacher: function(t4, e4, n5) {
        t4.prototype[e4] = function(t5, r4) {
          var i3;
          if ("mixed" !== this.type && "mixed" !== n5 && n5 !== this.type) throw new I("Graph.".concat(e4, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi) throw new I("Graph.".concat(e4, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o4 = "" + t5, a4 = "" + r4;
            if (r4 = arguments[2], !(i3 = d3(this, o4, a4, n5))) throw new F("Graph.".concat(e4, ': could not find an edge for the given path ("').concat(o4, '" - "').concat(a4, '").'));
          } else {
            if ("mixed" !== n5) throw new I("Graph.".concat(e4, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t5 = "" + t5, !(i3 = this._edges.get(t5))) throw new F("Graph.".concat(e4, ': could not find the "').concat(t5, '" edge in the graph.'));
          }
          if ("function" != typeof r4) throw new B("Graph.".concat(e4, ": provided updater is not a function."));
          return i3.attributes = r4(i3.attributes), this.emit("edgeAttributesUpdated", { key: i3.key, type: "update", attributes: i3.attributes }), this;
        };
      } }];
      var Z = O, $ = P, tt = function() {
        var t4 = arguments, e4 = null, n5 = -1;
        return new Z(function() {
          for (var r4 = null; ; ) {
            if (null === e4) {
              if (++n5 >= t4.length) return { done: true };
              e4 = $(t4[n5]);
            }
            if (true !== (r4 = e4.next()).done) break;
            e4 = null;
          }
          return r4;
        });
      }, et = [{ name: "edges", type: "mixed" }, { name: "inEdges", type: "directed", direction: "in" }, { name: "outEdges", type: "directed", direction: "out" }, { name: "inboundEdges", type: "mixed", direction: "in" }, { name: "outboundEdges", type: "mixed", direction: "out" }, { name: "directedEdges", type: "directed" }, { name: "undirectedEdges", type: "undirected" }];
      function nt(t4, e4, n5, r4) {
        var i3 = false;
        for (var o4 in e4) if (o4 !== r4) {
          var a4 = e4[o4];
          if (i3 = n5(a4.key, a4.attributes, a4.source.key, a4.target.key, a4.source.attributes, a4.target.attributes, a4.undirected), t4 && i3) return a4.key;
        }
      }
      function rt(t4, e4, n5, r4) {
        var i3, o4, a4, c3 = false;
        for (var u5 in e4) if (u5 !== r4) {
          i3 = e4[u5];
          do {
            if (o4 = i3.source, a4 = i3.target, c3 = n5(i3.key, i3.attributes, o4.key, a4.key, o4.attributes, a4.attributes, i3.undirected), t4 && c3) return i3.key;
            i3 = i3.next;
          } while (void 0 !== i3);
        }
      }
      function it(t4, e4) {
        var n5, r4 = Object.keys(t4), i3 = r4.length, o4 = 0;
        return new O(function() {
          do {
            if (n5) n5 = n5.next;
            else {
              if (o4 >= i3) return { done: true };
              var a4 = r4[o4++];
              if (a4 === e4) {
                n5 = void 0;
                continue;
              }
              n5 = t4[a4];
            }
          } while (!n5);
          return { done: false, value: { edge: n5.key, attributes: n5.attributes, source: n5.source.key, target: n5.target.key, sourceAttributes: n5.source.attributes, targetAttributes: n5.target.attributes, undirected: n5.undirected } };
        });
      }
      function ot(t4, e4, n5, r4) {
        var i3 = e4[n5];
        if (i3) {
          var o4 = i3.source, a4 = i3.target;
          return r4(i3.key, i3.attributes, o4.key, a4.key, o4.attributes, a4.attributes, i3.undirected) && t4 ? i3.key : void 0;
        }
      }
      function at(t4, e4, n5, r4) {
        var i3 = e4[n5];
        if (i3) {
          var o4 = false;
          do {
            if (o4 = r4(i3.key, i3.attributes, i3.source.key, i3.target.key, i3.source.attributes, i3.target.attributes, i3.undirected), t4 && o4) return i3.key;
            i3 = i3.next;
          } while (void 0 !== i3);
        }
      }
      function ct(t4, e4) {
        var n5 = t4[e4];
        return void 0 !== n5.next ? new O(function() {
          if (!n5) return { done: true };
          var t5 = { edge: n5.key, attributes: n5.attributes, source: n5.source.key, target: n5.target.key, sourceAttributes: n5.source.attributes, targetAttributes: n5.target.attributes, undirected: n5.undirected };
          return n5 = n5.next, { done: false, value: t5 };
        }) : O.of({ edge: n5.key, attributes: n5.attributes, source: n5.source.key, target: n5.target.key, sourceAttributes: n5.source.attributes, targetAttributes: n5.target.attributes, undirected: n5.undirected });
      }
      function ut(t4, e4) {
        if (0 === t4.size) return [];
        if ("mixed" === e4 || e4 === t4.type) return "function" == typeof Array.from ? Array.from(t4._edges.keys()) : K(t4._edges.keys(), t4._edges.size);
        for (var n5, r4, i3 = "undirected" === e4 ? t4.undirectedSize : t4.directedSize, o4 = new Array(i3), a4 = "undirected" === e4, c3 = t4._edges.values(), u5 = 0; true !== (n5 = c3.next()).done; ) (r4 = n5.value).undirected === a4 && (o4[u5++] = r4.key);
        return o4;
      }
      function dt(t4, e4, n5, r4) {
        if (0 !== e4.size) {
          for (var i3, o4, a4 = "mixed" !== n5 && n5 !== e4.type, c3 = "undirected" === n5, u5 = false, d4 = e4._edges.values(); true !== (i3 = d4.next()).done; ) if (o4 = i3.value, !a4 || o4.undirected === c3) {
            var s4 = o4, h2 = s4.key, p3 = s4.attributes, f2 = s4.source, l4 = s4.target;
            if (u5 = r4(h2, p3, f2.key, l4.key, f2.attributes, l4.attributes, o4.undirected), t4 && u5) return h2;
          }
        }
      }
      function st(t4, e4) {
        if (0 === t4.size) return O.empty();
        var n5 = "mixed" !== e4 && e4 !== t4.type, r4 = "undirected" === e4, i3 = t4._edges.values();
        return new O(function() {
          for (var t5, e5; ; ) {
            if ((t5 = i3.next()).done) return t5;
            if (e5 = t5.value, !n5 || e5.undirected === r4) break;
          }
          return { value: { edge: e5.key, attributes: e5.attributes, source: e5.source.key, target: e5.target.key, sourceAttributes: e5.source.attributes, targetAttributes: e5.target.attributes, undirected: e5.undirected }, done: false };
        });
      }
      function ht(t4, e4, n5, r4, i3, o4) {
        var a4, c3 = e4 ? rt : nt;
        if ("undirected" !== n5) {
          if ("out" !== r4 && (a4 = c3(t4, i3.in, o4), t4 && a4)) return a4;
          if ("in" !== r4 && (a4 = c3(t4, i3.out, o4, r4 ? void 0 : i3.key), t4 && a4)) return a4;
        }
        if ("directed" !== n5 && (a4 = c3(t4, i3.undirected, o4), t4 && a4)) return a4;
      }
      function pt(t4, e4, n5, r4) {
        var i3 = [];
        return ht(false, t4, e4, n5, r4, function(t5) {
          i3.push(t5);
        }), i3;
      }
      function ft(t4, e4, n5) {
        var r4 = O.empty();
        return "undirected" !== t4 && ("out" !== e4 && void 0 !== n5.in && (r4 = tt(r4, it(n5.in))), "in" !== e4 && void 0 !== n5.out && (r4 = tt(r4, it(n5.out, e4 ? void 0 : n5.key)))), "directed" !== t4 && void 0 !== n5.undirected && (r4 = tt(r4, it(n5.undirected))), r4;
      }
      function lt(t4, e4, n5, r4, i3, o4, a4) {
        var c3, u5 = n5 ? at : ot;
        if ("undirected" !== e4) {
          if (void 0 !== i3.in && "out" !== r4 && (c3 = u5(t4, i3.in, o4, a4), t4 && c3)) return c3;
          if (void 0 !== i3.out && "in" !== r4 && (r4 || i3.key !== o4) && (c3 = u5(t4, i3.out, o4, a4), t4 && c3)) return c3;
        }
        if ("directed" !== e4 && void 0 !== i3.undirected && (c3 = u5(t4, i3.undirected, o4, a4), t4 && c3)) return c3;
      }
      function gt(t4, e4, n5, r4, i3) {
        var o4 = [];
        return lt(false, t4, e4, n5, r4, i3, function(t5) {
          o4.push(t5);
        }), o4;
      }
      function yt(t4, e4, n5, r4) {
        var i3 = O.empty();
        return "undirected" !== t4 && (void 0 !== n5.in && "out" !== e4 && r4 in n5.in && (i3 = tt(i3, ct(n5.in, r4))), void 0 !== n5.out && "in" !== e4 && r4 in n5.out && (e4 || n5.key !== r4) && (i3 = tt(i3, ct(n5.out, r4)))), "directed" !== t4 && void 0 !== n5.undirected && r4 in n5.undirected && (i3 = tt(i3, ct(n5.undirected, r4))), i3;
      }
      var wt = [{ name: "neighbors", type: "mixed" }, { name: "inNeighbors", type: "directed", direction: "in" }, { name: "outNeighbors", type: "directed", direction: "out" }, { name: "inboundNeighbors", type: "mixed", direction: "in" }, { name: "outboundNeighbors", type: "mixed", direction: "out" }, { name: "directedNeighbors", type: "directed" }, { name: "undirectedNeighbors", type: "undirected" }];
      function vt() {
        this.A = null, this.B = null;
      }
      function bt(t4, e4, n5, r4, i3) {
        for (var o4 in r4) {
          var a4 = r4[o4], c3 = a4.source, u5 = a4.target, d4 = c3 === n5 ? u5 : c3;
          if (!e4 || !e4.has(d4.key)) {
            var s4 = i3(d4.key, d4.attributes);
            if (t4 && s4) return d4.key;
          }
        }
      }
      function mt(t4, e4, n5, r4, i3) {
        if ("mixed" !== e4) {
          if ("undirected" === e4) return bt(t4, null, r4, r4.undirected, i3);
          if ("string" == typeof n5) return bt(t4, null, r4, r4[n5], i3);
        }
        var o4, a4 = new vt();
        if ("undirected" !== e4) {
          if ("out" !== n5) {
            if (o4 = bt(t4, null, r4, r4.in, i3), t4 && o4) return o4;
            a4.wrap(r4.in);
          }
          if ("in" !== n5) {
            if (o4 = bt(t4, a4, r4, r4.out, i3), t4 && o4) return o4;
            a4.wrap(r4.out);
          }
        }
        if ("directed" !== e4 && (o4 = bt(t4, a4, r4, r4.undirected, i3), t4 && o4)) return o4;
      }
      function kt(t4, e4, n5) {
        var r4 = Object.keys(n5), i3 = r4.length, o4 = 0;
        return new O(function() {
          var a4 = null;
          do {
            if (o4 >= i3) return t4 && t4.wrap(n5), { done: true };
            var c3 = n5[r4[o4++]], u5 = c3.source, d4 = c3.target;
            a4 = u5 === e4 ? d4 : u5, t4 && t4.has(a4.key) && (a4 = null);
          } while (null === a4);
          return { done: false, value: { neighbor: a4.key, attributes: a4.attributes } };
        });
      }
      function _t(t4, e4) {
        var n5 = e4.name, r4 = e4.type, i3 = e4.direction;
        t4.prototype[n5] = function(t5) {
          if ("mixed" !== r4 && "mixed" !== this.type && r4 !== this.type) return [];
          t5 = "" + t5;
          var e5 = this._nodes.get(t5);
          if (void 0 === e5) throw new F("Graph.".concat(n5, ': could not find the "').concat(t5, '" node in the graph.'));
          return function(t6, e6, n6) {
            if ("mixed" !== t6) {
              if ("undirected" === t6) return Object.keys(n6.undirected);
              if ("string" == typeof e6) return Object.keys(n6[e6]);
            }
            var r5 = [];
            return mt(false, t6, e6, n6, function(t7) {
              r5.push(t7);
            }), r5;
          }("mixed" === r4 ? this.type : r4, i3, e5);
        };
      }
      function Gt(t4, e4) {
        var n5 = e4.name, r4 = e4.type, i3 = e4.direction, o4 = n5.slice(0, -1) + "Entries";
        t4.prototype[o4] = function(t5) {
          if ("mixed" !== r4 && "mixed" !== this.type && r4 !== this.type) return O.empty();
          t5 = "" + t5;
          var e5 = this._nodes.get(t5);
          if (void 0 === e5) throw new F("Graph.".concat(o4, ': could not find the "').concat(t5, '" node in the graph.'));
          return function(t6, e6, n6) {
            if ("mixed" !== t6) {
              if ("undirected" === t6) return kt(null, n6, n6.undirected);
              if ("string" == typeof e6) return kt(null, n6, n6[e6]);
            }
            var r5 = O.empty(), i4 = new vt();
            return "undirected" !== t6 && ("out" !== e6 && (r5 = tt(r5, kt(i4, n6, n6.in))), "in" !== e6 && (r5 = tt(r5, kt(i4, n6, n6.out)))), "directed" !== t6 && (r5 = tt(r5, kt(i4, n6, n6.undirected))), r5;
          }("mixed" === r4 ? this.type : r4, i3, e5);
        };
      }
      function xt(t4, e4, n5, r4, i3) {
        for (var o4, a4, c3, u5, d4, s4, h2, p3 = r4._nodes.values(), f2 = r4.type; true !== (o4 = p3.next()).done; ) {
          var l4 = false;
          if (a4 = o4.value, "undirected" !== f2) for (c3 in u5 = a4.out) {
            d4 = u5[c3];
            do {
              if (s4 = d4.target, l4 = true, h2 = i3(a4.key, s4.key, a4.attributes, s4.attributes, d4.key, d4.attributes, d4.undirected), t4) ;
              d4 = d4.next;
            } while (d4);
          }
          if ("directed" !== f2) {
            for (c3 in u5 = a4.undirected) if (!(e4 && a4.key > c3)) {
              d4 = u5[c3];
              do {
                if ((s4 = d4.target).key !== c3 && (s4 = d4.source), l4 = true, h2 = i3(a4.key, s4.key, a4.attributes, s4.attributes, d4.key, d4.attributes, d4.undirected), t4) ;
                d4 = d4.next;
              } while (d4);
            }
          }
          if (n5 && !l4 && (h2 = i3(a4.key, null, a4.attributes, null, null, null, null), t4)) ;
        }
      }
      function Et(t4) {
        if (!s3(t4)) throw new B('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');
        if (!("key" in t4)) throw new B("Graph.import: serialized node is missing its key.");
        if ("attributes" in t4 && (!s3(t4.attributes) || null === t4.attributes)) throw new B("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");
      }
      function At(t4) {
        if (!s3(t4)) throw new B('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');
        if (!("source" in t4)) throw new B("Graph.import: serialized edge is missing its source.");
        if (!("target" in t4)) throw new B("Graph.import: serialized edge is missing its target.");
        if ("attributes" in t4 && (!s3(t4.attributes) || null === t4.attributes)) throw new B("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");
        if ("undirected" in t4 && "boolean" != typeof t4.undirected) throw new B("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.");
      }
      vt.prototype.wrap = function(t4) {
        null === this.A ? this.A = t4 : null === this.B && (this.B = t4);
      }, vt.prototype.has = function(t4) {
        return null !== this.A && t4 in this.A || null !== this.B && t4 in this.B;
      };
      var Lt, St = (Lt = 255 & Math.floor(256 * Math.random()), function() {
        return Lt++;
      }), Dt = /* @__PURE__ */ new Set(["directed", "undirected", "mixed"]), Ut = /* @__PURE__ */ new Set(["domain", "_events", "_eventsCount", "_maxListeners"]), Nt = { allowSelfLoops: true, multi: false, type: "mixed" };
      function Ot(t4, e4, n5) {
        var r4 = new t4.NodeDataClass(e4, n5);
        return t4._nodes.set(e4, r4), t4.emit("nodeAdded", { key: e4, attributes: n5 }), r4;
      }
      function jt(t4, e4, n5, r4, i3, o4, a4, c3) {
        if (!r4 && "undirected" === t4.type) throw new I("Graph.".concat(e4, ": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));
        if (r4 && "directed" === t4.type) throw new I("Graph.".concat(e4, ": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));
        if (c3 && !s3(c3)) throw new B("Graph.".concat(e4, ': invalid attributes. Expecting an object but got "').concat(c3, '"'));
        if (o4 = "" + o4, a4 = "" + a4, c3 = c3 || {}, !t4.allowSelfLoops && o4 === a4) throw new I("Graph.".concat(e4, ': source & target are the same ("').concat(o4, `"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));
        var u5 = t4._nodes.get(o4), d4 = t4._nodes.get(a4);
        if (!u5) throw new F("Graph.".concat(e4, ': source node "').concat(o4, '" not found.'));
        if (!d4) throw new F("Graph.".concat(e4, ': target node "').concat(a4, '" not found.'));
        var h2 = { key: null, undirected: r4, source: o4, target: a4, attributes: c3 };
        if (n5) i3 = t4._edgeKeyGenerator();
        else if (i3 = "" + i3, t4._edges.has(i3)) throw new I("Graph.".concat(e4, ': the "').concat(i3, '" edge already exists in the graph.'));
        if (!t4.multi && (r4 ? void 0 !== u5.undirected[a4] : void 0 !== u5.out[a4])) throw new I("Graph.".concat(e4, ': an edge linking "').concat(o4, '" to "').concat(a4, `" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`));
        var p3 = new V(r4, i3, u5, d4, c3);
        t4._edges.set(i3, p3);
        var f2 = o4 === a4;
        return r4 ? (u5.undirectedDegree++, d4.undirectedDegree++, f2 && (u5.undirectedLoops++, t4._undirectedSelfLoopCount++)) : (u5.outDegree++, d4.inDegree++, f2 && (u5.directedLoops++, t4._directedSelfLoopCount++)), t4.multi ? p3.attachMulti() : p3.attach(), r4 ? t4._undirectedSize++ : t4._directedSize++, h2.key = i3, t4.emit("edgeAdded", h2), i3;
      }
      function Ct(t4, e4, n5, r4, i3, o4, a4, c3, d4) {
        if (!r4 && "undirected" === t4.type) throw new I("Graph.".concat(e4, ": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));
        if (r4 && "directed" === t4.type) throw new I("Graph.".concat(e4, ": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));
        if (c3) {
          if (d4) {
            if ("function" != typeof c3) throw new B("Graph.".concat(e4, ': invalid updater function. Expecting a function but got "').concat(c3, '"'));
          } else if (!s3(c3)) throw new B("Graph.".concat(e4, ': invalid attributes. Expecting an object but got "').concat(c3, '"'));
        }
        var h2;
        if (o4 = "" + o4, a4 = "" + a4, d4 && (h2 = c3, c3 = void 0), !t4.allowSelfLoops && o4 === a4) throw new I("Graph.".concat(e4, ': source & target are the same ("').concat(o4, `"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));
        var p3, f2, l4 = t4._nodes.get(o4), g2 = t4._nodes.get(a4);
        if (!n5 && (p3 = t4._edges.get(i3))) {
          if (!(p3.source.key === o4 && p3.target.key === a4 || r4 && p3.source.key === a4 && p3.target.key === o4)) throw new I("Graph.".concat(e4, ': inconsistency detected when attempting to merge the "').concat(i3, '" edge with "').concat(o4, '" source & "').concat(a4, '" target vs. ("').concat(p3.source.key, '", "').concat(p3.target.key, '").'));
          f2 = p3;
        }
        if (f2 || t4.multi || !l4 || (f2 = r4 ? l4.undirected[a4] : l4.out[a4]), f2) {
          var y4 = [f2.key, false, false, false];
          if (d4 ? !h2 : !c3) return y4;
          if (d4) {
            var w2 = f2.attributes;
            f2.attributes = h2(w2), t4.emit("edgeAttributesUpdated", { type: "replace", key: f2.key, attributes: f2.attributes });
          } else u4(f2.attributes, c3), t4.emit("edgeAttributesUpdated", { type: "merge", key: f2.key, attributes: f2.attributes, data: c3 });
          return y4;
        }
        c3 = c3 || {}, d4 && h2 && (c3 = h2(c3));
        var v2 = { key: null, undirected: r4, source: o4, target: a4, attributes: c3 };
        if (n5) i3 = t4._edgeKeyGenerator();
        else if (i3 = "" + i3, t4._edges.has(i3)) throw new I("Graph.".concat(e4, ': the "').concat(i3, '" edge already exists in the graph.'));
        var b2 = false, m4 = false;
        l4 || (l4 = Ot(t4, o4, {}), b2 = true, o4 === a4 && (g2 = l4, m4 = true)), g2 || (g2 = Ot(t4, a4, {}), m4 = true), p3 = new V(r4, i3, l4, g2, c3), t4._edges.set(i3, p3);
        var k3 = o4 === a4;
        return r4 ? (l4.undirectedDegree++, g2.undirectedDegree++, k3 && (l4.undirectedLoops++, t4._undirectedSelfLoopCount++)) : (l4.outDegree++, g2.inDegree++, k3 && (l4.directedLoops++, t4._directedSelfLoopCount++)), t4.multi ? p3.attachMulti() : p3.attach(), r4 ? t4._undirectedSize++ : t4._directedSize++, v2.key = i3, t4.emit("edgeAdded", v2), [i3, true, b2, m4];
      }
      function Mt(t4, e4) {
        t4._edges.delete(e4.key);
        var n5 = e4.source, r4 = e4.target, i3 = e4.attributes, o4 = e4.undirected, a4 = n5 === r4;
        o4 ? (n5.undirectedDegree--, r4.undirectedDegree--, a4 && (n5.undirectedLoops--, t4._undirectedSelfLoopCount--)) : (n5.outDegree--, r4.inDegree--, a4 && (n5.directedLoops--, t4._directedSelfLoopCount--)), t4.multi ? e4.detachMulti() : e4.detach(), o4 ? t4._undirectedSize-- : t4._directedSize--, t4.emit("edgeDropped", { key: e4.key, attributes: i3, source: n5.key, target: r4.key, undirected: o4 });
      }
      var zt = function(n5) {
        function r4(t4) {
          var e4;
          if (e4 = n5.call(this) || this, "boolean" != typeof (t4 = u4({}, Nt, t4)).multi) throw new B(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "`.concat(t4.multi, '".'));
          if (!Dt.has(t4.type)) throw new B(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "`.concat(t4.type, '".'));
          if ("boolean" != typeof t4.allowSelfLoops) throw new B(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "`.concat(t4.allowSelfLoops, '".'));
          var r5 = "mixed" === t4.type ? Y : "directed" === t4.type ? q : J;
          p2(c2(e4), "NodeDataClass", r5);
          var i4 = "geid_" + St() + "_", o4 = 0;
          return p2(c2(e4), "_attributes", {}), p2(c2(e4), "_nodes", /* @__PURE__ */ new Map()), p2(c2(e4), "_edges", /* @__PURE__ */ new Map()), p2(c2(e4), "_directedSize", 0), p2(c2(e4), "_undirectedSize", 0), p2(c2(e4), "_directedSelfLoopCount", 0), p2(c2(e4), "_undirectedSelfLoopCount", 0), p2(c2(e4), "_edgeKeyGenerator", function() {
            var t5;
            do {
              t5 = i4 + o4++;
            } while (e4._edges.has(t5));
            return t5;
          }), p2(c2(e4), "_options", t4), Ut.forEach(function(t5) {
            return p2(c2(e4), t5, e4[t5]);
          }), f(c2(e4), "order", function() {
            return e4._nodes.size;
          }), f(c2(e4), "size", function() {
            return e4._edges.size;
          }), f(c2(e4), "directedSize", function() {
            return e4._directedSize;
          }), f(c2(e4), "undirectedSize", function() {
            return e4._undirectedSize;
          }), f(c2(e4), "selfLoopCount", function() {
            return e4._directedSelfLoopCount + e4._undirectedSelfLoopCount;
          }), f(c2(e4), "directedSelfLoopCount", function() {
            return e4._directedSelfLoopCount;
          }), f(c2(e4), "undirectedSelfLoopCount", function() {
            return e4._undirectedSelfLoopCount;
          }), f(c2(e4), "multi", e4._options.multi), f(c2(e4), "type", e4._options.type), f(c2(e4), "allowSelfLoops", e4._options.allowSelfLoops), f(c2(e4), "implementation", function() {
            return "graphology";
          }), e4;
        }
        e3(r4, n5);
        var i3 = r4.prototype;
        return i3._resetInstanceCounters = function() {
          this._directedSize = 0, this._undirectedSize = 0, this._directedSelfLoopCount = 0, this._undirectedSelfLoopCount = 0;
        }, i3.hasNode = function(t4) {
          return this._nodes.has("" + t4);
        }, i3.hasDirectedEdge = function(t4, e4) {
          if ("undirected" === this.type) return false;
          if (1 === arguments.length) {
            var n6 = "" + t4, r5 = this._edges.get(n6);
            return !!r5 && !r5.undirected;
          }
          if (2 === arguments.length) {
            t4 = "" + t4, e4 = "" + e4;
            var i4 = this._nodes.get(t4);
            return !!i4 && i4.out.hasOwnProperty(e4);
          }
          throw new B("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i3.hasUndirectedEdge = function(t4, e4) {
          if ("directed" === this.type) return false;
          if (1 === arguments.length) {
            var n6 = "" + t4, r5 = this._edges.get(n6);
            return !!r5 && r5.undirected;
          }
          if (2 === arguments.length) {
            t4 = "" + t4, e4 = "" + e4;
            var i4 = this._nodes.get(t4);
            return !!i4 && i4.undirected.hasOwnProperty(e4);
          }
          throw new B("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i3.hasEdge = function(t4, e4) {
          if (1 === arguments.length) {
            var n6 = "" + t4;
            return this._edges.has(n6);
          }
          if (2 === arguments.length) {
            t4 = "" + t4, e4 = "" + e4;
            var r5 = this._nodes.get(t4);
            return !!r5 && (void 0 !== r5.out && r5.out.hasOwnProperty(e4) || void 0 !== r5.undirected && r5.undirected.hasOwnProperty(e4));
          }
          throw new B("Graph.hasEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i3.directedEdge = function(t4, e4) {
          if ("undirected" !== this.type) {
            if (t4 = "" + t4, e4 = "" + e4, this.multi) throw new I("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");
            var n6 = this._nodes.get(t4);
            if (!n6) throw new F('Graph.directedEdge: could not find the "'.concat(t4, '" source node in the graph.'));
            if (!this._nodes.has(e4)) throw new F('Graph.directedEdge: could not find the "'.concat(e4, '" target node in the graph.'));
            var r5 = n6.out && n6.out[e4] || void 0;
            return r5 ? r5.key : void 0;
          }
        }, i3.undirectedEdge = function(t4, e4) {
          if ("directed" !== this.type) {
            if (t4 = "" + t4, e4 = "" + e4, this.multi) throw new I("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");
            var n6 = this._nodes.get(t4);
            if (!n6) throw new F('Graph.undirectedEdge: could not find the "'.concat(t4, '" source node in the graph.'));
            if (!this._nodes.has(e4)) throw new F('Graph.undirectedEdge: could not find the "'.concat(e4, '" target node in the graph.'));
            var r5 = n6.undirected && n6.undirected[e4] || void 0;
            return r5 ? r5.key : void 0;
          }
        }, i3.edge = function(t4, e4) {
          if (this.multi) throw new I("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.edge: could not find the "'.concat(t4, '" source node in the graph.'));
          if (!this._nodes.has(e4)) throw new F('Graph.edge: could not find the "'.concat(e4, '" target node in the graph.'));
          var r5 = n6.out && n6.out[e4] || n6.undirected && n6.undirected[e4] || void 0;
          if (r5) return r5.key;
        }, i3.areDirectedNeighbors = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.areDirectedNeighbors: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" !== this.type && (e4 in n6.in || e4 in n6.out);
        }, i3.areOutNeighbors = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.areOutNeighbors: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" !== this.type && e4 in n6.out;
        }, i3.areInNeighbors = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.areInNeighbors: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" !== this.type && e4 in n6.in;
        }, i3.areUndirectedNeighbors = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.areUndirectedNeighbors: could not find the "'.concat(t4, '" node in the graph.'));
          return "directed" !== this.type && e4 in n6.undirected;
        }, i3.areNeighbors = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.areNeighbors: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" !== this.type && (e4 in n6.in || e4 in n6.out) || "directed" !== this.type && e4 in n6.undirected;
        }, i3.areInboundNeighbors = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.areInboundNeighbors: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" !== this.type && e4 in n6.in || "directed" !== this.type && e4 in n6.undirected;
        }, i3.areOutboundNeighbors = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.areOutboundNeighbors: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" !== this.type && e4 in n6.out || "directed" !== this.type && e4 in n6.undirected;
        }, i3.inDegree = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.inDegree: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e4.inDegree;
        }, i3.outDegree = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.outDegree: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e4.outDegree;
        }, i3.directedDegree = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.directedDegree: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e4.inDegree + e4.outDegree;
        }, i3.undirectedDegree = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.undirectedDegree: could not find the "'.concat(t4, '" node in the graph.'));
          return "directed" === this.type ? 0 : e4.undirectedDegree;
        }, i3.inboundDegree = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.inboundDegree: could not find the "'.concat(t4, '" node in the graph.'));
          var n6 = 0;
          return "directed" !== this.type && (n6 += e4.undirectedDegree), "undirected" !== this.type && (n6 += e4.inDegree), n6;
        }, i3.outboundDegree = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.outboundDegree: could not find the "'.concat(t4, '" node in the graph.'));
          var n6 = 0;
          return "directed" !== this.type && (n6 += e4.undirectedDegree), "undirected" !== this.type && (n6 += e4.outDegree), n6;
        }, i3.degree = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.degree: could not find the "'.concat(t4, '" node in the graph.'));
          var n6 = 0;
          return "directed" !== this.type && (n6 += e4.undirectedDegree), "undirected" !== this.type && (n6 += e4.inDegree + e4.outDegree), n6;
        }, i3.inDegreeWithoutSelfLoops = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e4.inDegree - e4.directedLoops;
        }, i3.outDegreeWithoutSelfLoops = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e4.outDegree - e4.directedLoops;
        }, i3.directedDegreeWithoutSelfLoops = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(t4, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e4.inDegree + e4.outDegree - 2 * e4.directedLoops;
        }, i3.undirectedDegreeWithoutSelfLoops = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(t4, '" node in the graph.'));
          return "directed" === this.type ? 0 : e4.undirectedDegree - 2 * e4.undirectedLoops;
        }, i3.inboundDegreeWithoutSelfLoops = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(t4, '" node in the graph.'));
          var n6 = 0, r5 = 0;
          return "directed" !== this.type && (n6 += e4.undirectedDegree, r5 += 2 * e4.undirectedLoops), "undirected" !== this.type && (n6 += e4.inDegree, r5 += e4.directedLoops), n6 - r5;
        }, i3.outboundDegreeWithoutSelfLoops = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(t4, '" node in the graph.'));
          var n6 = 0, r5 = 0;
          return "directed" !== this.type && (n6 += e4.undirectedDegree, r5 += 2 * e4.undirectedLoops), "undirected" !== this.type && (n6 += e4.outDegree, r5 += e4.directedLoops), n6 - r5;
        }, i3.degreeWithoutSelfLoops = function(t4) {
          t4 = "" + t4;
          var e4 = this._nodes.get(t4);
          if (!e4) throw new F('Graph.degreeWithoutSelfLoops: could not find the "'.concat(t4, '" node in the graph.'));
          var n6 = 0, r5 = 0;
          return "directed" !== this.type && (n6 += e4.undirectedDegree, r5 += 2 * e4.undirectedLoops), "undirected" !== this.type && (n6 += e4.inDegree + e4.outDegree, r5 += 2 * e4.directedLoops), n6 - r5;
        }, i3.source = function(t4) {
          t4 = "" + t4;
          var e4 = this._edges.get(t4);
          if (!e4) throw new F('Graph.source: could not find the "'.concat(t4, '" edge in the graph.'));
          return e4.source.key;
        }, i3.target = function(t4) {
          t4 = "" + t4;
          var e4 = this._edges.get(t4);
          if (!e4) throw new F('Graph.target: could not find the "'.concat(t4, '" edge in the graph.'));
          return e4.target.key;
        }, i3.extremities = function(t4) {
          t4 = "" + t4;
          var e4 = this._edges.get(t4);
          if (!e4) throw new F('Graph.extremities: could not find the "'.concat(t4, '" edge in the graph.'));
          return [e4.source.key, e4.target.key];
        }, i3.opposite = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._edges.get(e4);
          if (!n6) throw new F('Graph.opposite: could not find the "'.concat(e4, '" edge in the graph.'));
          var r5 = n6.source.key, i4 = n6.target.key;
          if (t4 === r5) return i4;
          if (t4 === i4) return r5;
          throw new F('Graph.opposite: the "'.concat(t4, '" node is not attached to the "').concat(e4, '" edge (').concat(r5, ", ").concat(i4, ")."));
        }, i3.hasExtremity = function(t4, e4) {
          t4 = "" + t4, e4 = "" + e4;
          var n6 = this._edges.get(t4);
          if (!n6) throw new F('Graph.hasExtremity: could not find the "'.concat(t4, '" edge in the graph.'));
          return n6.source.key === e4 || n6.target.key === e4;
        }, i3.isUndirected = function(t4) {
          t4 = "" + t4;
          var e4 = this._edges.get(t4);
          if (!e4) throw new F('Graph.isUndirected: could not find the "'.concat(t4, '" edge in the graph.'));
          return e4.undirected;
        }, i3.isDirected = function(t4) {
          t4 = "" + t4;
          var e4 = this._edges.get(t4);
          if (!e4) throw new F('Graph.isDirected: could not find the "'.concat(t4, '" edge in the graph.'));
          return !e4.undirected;
        }, i3.isSelfLoop = function(t4) {
          t4 = "" + t4;
          var e4 = this._edges.get(t4);
          if (!e4) throw new F('Graph.isSelfLoop: could not find the "'.concat(t4, '" edge in the graph.'));
          return e4.source === e4.target;
        }, i3.addNode = function(t4, e4) {
          var n6 = function(t5, e5, n7) {
            if (n7 && !s3(n7)) throw new B('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(n7, '"'));
            if (e5 = "" + e5, n7 = n7 || {}, t5._nodes.has(e5)) throw new I('Graph.addNode: the "'.concat(e5, '" node already exist in the graph.'));
            var r5 = new t5.NodeDataClass(e5, n7);
            return t5._nodes.set(e5, r5), t5.emit("nodeAdded", { key: e5, attributes: n7 }), r5;
          }(this, t4, e4);
          return n6.key;
        }, i3.mergeNode = function(t4, e4) {
          if (e4 && !s3(e4)) throw new B('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(e4, '"'));
          t4 = "" + t4, e4 = e4 || {};
          var n6 = this._nodes.get(t4);
          return n6 ? (e4 && (u4(n6.attributes, e4), this.emit("nodeAttributesUpdated", { type: "merge", key: t4, attributes: n6.attributes, data: e4 })), [t4, false]) : (n6 = new this.NodeDataClass(t4, e4), this._nodes.set(t4, n6), this.emit("nodeAdded", { key: t4, attributes: e4 }), [t4, true]);
        }, i3.updateNode = function(t4, e4) {
          if (e4 && "function" != typeof e4) throw new B('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(e4, '"'));
          t4 = "" + t4;
          var n6 = this._nodes.get(t4);
          if (n6) {
            if (e4) {
              var r5 = n6.attributes;
              n6.attributes = e4(r5), this.emit("nodeAttributesUpdated", { type: "replace", key: t4, attributes: n6.attributes });
            }
            return [t4, false];
          }
          var i4 = e4 ? e4({}) : {};
          return n6 = new this.NodeDataClass(t4, i4), this._nodes.set(t4, n6), this.emit("nodeAdded", { key: t4, attributes: i4 }), [t4, true];
        }, i3.dropNode = function(t4) {
          t4 = "" + t4;
          var e4, n6 = this._nodes.get(t4);
          if (!n6) throw new F('Graph.dropNode: could not find the "'.concat(t4, '" node in the graph.'));
          if ("undirected" !== this.type) {
            for (var r5 in n6.out) {
              e4 = n6.out[r5];
              do {
                Mt(this, e4), e4 = e4.next;
              } while (e4);
            }
            for (var i4 in n6.in) {
              e4 = n6.in[i4];
              do {
                Mt(this, e4), e4 = e4.next;
              } while (e4);
            }
          }
          if ("directed" !== this.type) for (var o4 in n6.undirected) {
            e4 = n6.undirected[o4];
            do {
              Mt(this, e4), e4 = e4.next;
            } while (e4);
          }
          this._nodes.delete(t4), this.emit("nodeDropped", { key: t4, attributes: n6.attributes });
        }, i3.dropEdge = function(t4) {
          var e4;
          if (arguments.length > 1) {
            var n6 = "" + arguments[0], r5 = "" + arguments[1];
            if (!(e4 = d3(this, n6, r5, this.type))) throw new F('Graph.dropEdge: could not find the "'.concat(n6, '" -> "').concat(r5, '" edge in the graph.'));
          } else if (t4 = "" + t4, !(e4 = this._edges.get(t4))) throw new F('Graph.dropEdge: could not find the "'.concat(t4, '" edge in the graph.'));
          return Mt(this, e4), this;
        }, i3.dropDirectedEdge = function(t4, e4) {
          if (arguments.length < 2) throw new I("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");
          if (this.multi) throw new I("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");
          var n6 = d3(this, t4 = "" + t4, e4 = "" + e4, "directed");
          if (!n6) throw new F('Graph.dropDirectedEdge: could not find a "'.concat(t4, '" -> "').concat(e4, '" edge in the graph.'));
          return Mt(this, n6), this;
        }, i3.dropUndirectedEdge = function(t4, e4) {
          if (arguments.length < 2) throw new I("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");
          if (this.multi) throw new I("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");
          var n6 = d3(this, t4, e4, "undirected");
          if (!n6) throw new F('Graph.dropUndirectedEdge: could not find a "'.concat(t4, '" -> "').concat(e4, '" edge in the graph.'));
          return Mt(this, n6), this;
        }, i3.clear = function() {
          this._edges.clear(), this._nodes.clear(), this._resetInstanceCounters(), this.emit("cleared");
        }, i3.clearEdges = function() {
          for (var t4, e4 = this._nodes.values(); true !== (t4 = e4.next()).done; ) t4.value.clear();
          this._edges.clear(), this._resetInstanceCounters(), this.emit("edgesCleared");
        }, i3.getAttribute = function(t4) {
          return this._attributes[t4];
        }, i3.getAttributes = function() {
          return this._attributes;
        }, i3.hasAttribute = function(t4) {
          return this._attributes.hasOwnProperty(t4);
        }, i3.setAttribute = function(t4, e4) {
          return this._attributes[t4] = e4, this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: t4 }), this;
        }, i3.updateAttribute = function(t4, e4) {
          if ("function" != typeof e4) throw new B("Graph.updateAttribute: updater should be a function.");
          var n6 = this._attributes[t4];
          return this._attributes[t4] = e4(n6), this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: t4 }), this;
        }, i3.removeAttribute = function(t4) {
          return delete this._attributes[t4], this.emit("attributesUpdated", { type: "remove", attributes: this._attributes, name: t4 }), this;
        }, i3.replaceAttributes = function(t4) {
          if (!s3(t4)) throw new B("Graph.replaceAttributes: provided attributes are not a plain object.");
          return this._attributes = t4, this.emit("attributesUpdated", { type: "replace", attributes: this._attributes }), this;
        }, i3.mergeAttributes = function(t4) {
          if (!s3(t4)) throw new B("Graph.mergeAttributes: provided attributes are not a plain object.");
          return u4(this._attributes, t4), this.emit("attributesUpdated", { type: "merge", attributes: this._attributes, data: t4 }), this;
        }, i3.updateAttributes = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.updateAttributes: provided updater is not a function.");
          return this._attributes = t4(this._attributes), this.emit("attributesUpdated", { type: "update", attributes: this._attributes }), this;
        }, i3.updateEachNodeAttributes = function(t4, e4) {
          if ("function" != typeof t4) throw new B("Graph.updateEachNodeAttributes: expecting an updater function.");
          if (e4 && !l3(e4)) throw new B("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
          for (var n6, r5, i4 = this._nodes.values(); true !== (n6 = i4.next()).done; ) (r5 = n6.value).attributes = t4(r5.key, r5.attributes);
          this.emit("eachNodeAttributesUpdated", { hints: e4 || null });
        }, i3.updateEachEdgeAttributes = function(t4, e4) {
          if ("function" != typeof t4) throw new B("Graph.updateEachEdgeAttributes: expecting an updater function.");
          if (e4 && !l3(e4)) throw new B("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
          for (var n6, r5, i4, o4, a4 = this._edges.values(); true !== (n6 = a4.next()).done; ) i4 = (r5 = n6.value).source, o4 = r5.target, r5.attributes = t4(r5.key, r5.attributes, i4.key, o4.key, i4.attributes, o4.attributes, r5.undirected);
          this.emit("eachEdgeAttributesUpdated", { hints: e4 || null });
        }, i3.forEachAdjacencyEntry = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.forEachAdjacencyEntry: expecting a callback.");
          xt(false, false, false, this, t4);
        }, i3.forEachAdjacencyEntryWithOrphans = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");
          xt(false, false, true, this, t4);
        }, i3.forEachAssymetricAdjacencyEntry = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");
          xt(false, true, false, this, t4);
        }, i3.forEachAssymetricAdjacencyEntryWithOrphans = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");
          xt(false, true, true, this, t4);
        }, i3.nodes = function() {
          return "function" == typeof Array.from ? Array.from(this._nodes.keys()) : K(this._nodes.keys(), this._nodes.size);
        }, i3.forEachNode = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.forEachNode: expecting a callback.");
          for (var e4, n6, r5 = this._nodes.values(); true !== (e4 = r5.next()).done; ) t4((n6 = e4.value).key, n6.attributes);
        }, i3.findNode = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.findNode: expecting a callback.");
          for (var e4, n6, r5 = this._nodes.values(); true !== (e4 = r5.next()).done; ) if (t4((n6 = e4.value).key, n6.attributes)) return n6.key;
        }, i3.mapNodes = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.mapNode: expecting a callback.");
          for (var e4, n6, r5 = this._nodes.values(), i4 = new Array(this.order), o4 = 0; true !== (e4 = r5.next()).done; ) n6 = e4.value, i4[o4++] = t4(n6.key, n6.attributes);
          return i4;
        }, i3.someNode = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.someNode: expecting a callback.");
          for (var e4, n6, r5 = this._nodes.values(); true !== (e4 = r5.next()).done; ) if (t4((n6 = e4.value).key, n6.attributes)) return true;
          return false;
        }, i3.everyNode = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.everyNode: expecting a callback.");
          for (var e4, n6, r5 = this._nodes.values(); true !== (e4 = r5.next()).done; ) if (!t4((n6 = e4.value).key, n6.attributes)) return false;
          return true;
        }, i3.filterNodes = function(t4) {
          if ("function" != typeof t4) throw new B("Graph.filterNodes: expecting a callback.");
          for (var e4, n6, r5 = this._nodes.values(), i4 = []; true !== (e4 = r5.next()).done; ) t4((n6 = e4.value).key, n6.attributes) && i4.push(n6.key);
          return i4;
        }, i3.reduceNodes = function(t4, e4) {
          if ("function" != typeof t4) throw new B("Graph.reduceNodes: expecting a callback.");
          if (arguments.length < 2) throw new B("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");
          for (var n6, r5, i4 = e4, o4 = this._nodes.values(); true !== (n6 = o4.next()).done; ) i4 = t4(i4, (r5 = n6.value).key, r5.attributes);
          return i4;
        }, i3.nodeEntries = function() {
          var t4 = this._nodes.values();
          return new O(function() {
            var e4 = t4.next();
            if (e4.done) return e4;
            var n6 = e4.value;
            return { value: { node: n6.key, attributes: n6.attributes }, done: false };
          });
        }, i3.export = function() {
          var t4 = this, e4 = new Array(this._nodes.size), n6 = 0;
          this._nodes.forEach(function(t5, r6) {
            e4[n6++] = function(t6, e5) {
              var n7 = { key: t6 };
              return h(e5.attributes) || (n7.attributes = u4({}, e5.attributes)), n7;
            }(r6, t5);
          });
          var r5 = new Array(this._edges.size);
          return n6 = 0, this._edges.forEach(function(e5, i4) {
            r5[n6++] = function(t5, e6, n7) {
              var r6 = { key: e6, source: n7.source.key, target: n7.target.key };
              return h(n7.attributes) || (r6.attributes = u4({}, n7.attributes)), "mixed" === t5 && n7.undirected && (r6.undirected = true), r6;
            }(t4.type, i4, e5);
          }), { options: { type: this.type, multi: this.multi, allowSelfLoops: this.allowSelfLoops }, attributes: this.getAttributes(), nodes: e4, edges: r5 };
        }, i3.import = function(t4) {
          var e4, n6, i4, o4, a4, c3 = this, u5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (t4 instanceof r4) return t4.forEachNode(function(t5, e5) {
            u5 ? c3.mergeNode(t5, e5) : c3.addNode(t5, e5);
          }), t4.forEachEdge(function(t5, e5, n7, r5, i5, o5, a5) {
            u5 ? a5 ? c3.mergeUndirectedEdgeWithKey(t5, n7, r5, e5) : c3.mergeDirectedEdgeWithKey(t5, n7, r5, e5) : a5 ? c3.addUndirectedEdgeWithKey(t5, n7, r5, e5) : c3.addDirectedEdgeWithKey(t5, n7, r5, e5);
          }), this;
          if (!s3(t4)) throw new B("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");
          if (t4.attributes) {
            if (!s3(t4.attributes)) throw new B("Graph.import: invalid attributes. Expecting a plain object.");
            u5 ? this.mergeAttributes(t4.attributes) : this.replaceAttributes(t4.attributes);
          }
          if (t4.nodes) {
            if (i4 = t4.nodes, !Array.isArray(i4)) throw new B("Graph.import: invalid nodes. Expecting an array.");
            for (e4 = 0, n6 = i4.length; e4 < n6; e4++) {
              Et(o4 = i4[e4]);
              var d4 = o4, h2 = d4.key, p3 = d4.attributes;
              u5 ? this.mergeNode(h2, p3) : this.addNode(h2, p3);
            }
          }
          if (t4.edges) {
            var f2 = false;
            if ("undirected" === this.type && (f2 = true), i4 = t4.edges, !Array.isArray(i4)) throw new B("Graph.import: invalid edges. Expecting an array.");
            for (e4 = 0, n6 = i4.length; e4 < n6; e4++) {
              At(a4 = i4[e4]);
              var l4 = a4, g2 = l4.source, y4 = l4.target, w2 = l4.attributes, v2 = l4.undirected, b2 = void 0 === v2 ? f2 : v2;
              "key" in a4 ? (u5 ? b2 ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : b2 ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey).call(this, a4.key, g2, y4, w2) : (u5 ? b2 ? this.mergeUndirectedEdge : this.mergeDirectedEdge : b2 ? this.addUndirectedEdge : this.addDirectedEdge).call(this, g2, y4, w2);
            }
          }
          return this;
        }, i3.nullCopy = function(t4) {
          var e4 = new r4(u4({}, this._options, t4));
          return e4.replaceAttributes(u4({}, this.getAttributes())), e4;
        }, i3.emptyCopy = function(t4) {
          var e4 = this.nullCopy(t4);
          return this._nodes.forEach(function(t5, n6) {
            var r5 = u4({}, t5.attributes);
            t5 = new e4.NodeDataClass(n6, r5), e4._nodes.set(n6, t5);
          }), e4;
        }, i3.copy = function(t4) {
          if ("string" == typeof (t4 = t4 || {}).type && t4.type !== this.type && "mixed" !== t4.type) throw new I('Graph.copy: cannot create an incompatible copy from "'.concat(this.type, '" type to "').concat(t4.type, '" because this would mean losing information about the current graph.'));
          if ("boolean" == typeof t4.multi && t4.multi !== this.multi && true !== t4.multi) throw new I("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");
          if ("boolean" == typeof t4.allowSelfLoops && t4.allowSelfLoops !== this.allowSelfLoops && true !== t4.allowSelfLoops) throw new I("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");
          for (var e4, n6, r5 = this.emptyCopy(t4), i4 = this._edges.values(); true !== (e4 = i4.next()).done; ) jt(r5, "copy", false, (n6 = e4.value).undirected, n6.key, n6.source.key, n6.target.key, u4({}, n6.attributes));
          return r5;
        }, i3.toJSON = function() {
          return this.export();
        }, i3.toString = function() {
          return "[object Graph]";
        }, i3.inspect = function() {
          var e4 = this, n6 = {};
          this._nodes.forEach(function(t4, e5) {
            n6[e5] = t4.attributes;
          });
          var r5 = {}, i4 = {};
          this._edges.forEach(function(t4, n7) {
            var o5, a5 = t4.undirected ? "--" : "->", c3 = "", u5 = t4.source.key, d4 = t4.target.key;
            t4.undirected && u5 > d4 && (o5 = u5, u5 = d4, d4 = o5);
            var s4 = "(".concat(u5, ")").concat(a5, "(").concat(d4, ")");
            n7.startsWith("geid_") ? e4.multi && (void 0 === i4[s4] ? i4[s4] = 0 : i4[s4]++, c3 += "".concat(i4[s4], ". ")) : c3 += "[".concat(n7, "]: "), r5[c3 += s4] = t4.attributes;
          });
          var o4 = {};
          for (var a4 in this) this.hasOwnProperty(a4) && !Ut.has(a4) && "function" != typeof this[a4] && "symbol" !== t3(a4) && (o4[a4] = this[a4]);
          return o4.attributes = this._attributes, o4.nodes = n6, o4.edges = r5, p2(o4, "constructor", this.constructor), o4;
        }, r4;
      }(y3.exports.EventEmitter);
      "undefined" != typeof Symbol && (zt.prototype[Symbol.for("nodejs.util.inspect.custom")] = zt.prototype.inspect), [{ name: function(t4) {
        return "".concat(t4, "Edge");
      }, generateKey: true }, { name: function(t4) {
        return "".concat(t4, "DirectedEdge");
      }, generateKey: true, type: "directed" }, { name: function(t4) {
        return "".concat(t4, "UndirectedEdge");
      }, generateKey: true, type: "undirected" }, { name: function(t4) {
        return "".concat(t4, "EdgeWithKey");
      } }, { name: function(t4) {
        return "".concat(t4, "DirectedEdgeWithKey");
      }, type: "directed" }, { name: function(t4) {
        return "".concat(t4, "UndirectedEdgeWithKey");
      }, type: "undirected" }].forEach(function(t4) {
        ["add", "merge", "update"].forEach(function(e4) {
          var n5 = t4.name(e4), r4 = "add" === e4 ? jt : Ct;
          t4.generateKey ? zt.prototype[n5] = function(i3, o4, a4) {
            return r4(this, n5, true, "undirected" === (t4.type || this.type), null, i3, o4, a4, "update" === e4);
          } : zt.prototype[n5] = function(i3, o4, a4, c3) {
            return r4(this, n5, false, "undirected" === (t4.type || this.type), i3, o4, a4, c3, "update" === e4);
          };
        });
      }), function(t4) {
        Q.forEach(function(e4) {
          var n5 = e4.name, r4 = e4.attacher;
          r4(t4, n5("Node"), 0), r4(t4, n5("Source"), 1), r4(t4, n5("Target"), 2), r4(t4, n5("Opposite"), 3);
        });
      }(zt), function(t4) {
        X.forEach(function(e4) {
          var n5 = e4.name, r4 = e4.attacher;
          r4(t4, n5("Edge"), "mixed"), r4(t4, n5("DirectedEdge"), "directed"), r4(t4, n5("UndirectedEdge"), "undirected");
        });
      }(zt), function(t4) {
        et.forEach(function(e4) {
          !function(t5, e5) {
            var n5 = e5.name, r4 = e5.type, i3 = e5.direction;
            t5.prototype[n5] = function(t6, e6) {
              if ("mixed" !== r4 && "mixed" !== this.type && r4 !== this.type) return [];
              if (!arguments.length) return ut(this, r4);
              if (1 === arguments.length) {
                t6 = "" + t6;
                var o4 = this._nodes.get(t6);
                if (void 0 === o4) throw new F("Graph.".concat(n5, ': could not find the "').concat(t6, '" node in the graph.'));
                return pt(this.multi, "mixed" === r4 ? this.type : r4, i3, o4);
              }
              if (2 === arguments.length) {
                t6 = "" + t6, e6 = "" + e6;
                var a4 = this._nodes.get(t6);
                if (!a4) throw new F("Graph.".concat(n5, ':  could not find the "').concat(t6, '" source node in the graph.'));
                if (!this._nodes.has(e6)) throw new F("Graph.".concat(n5, ':  could not find the "').concat(e6, '" target node in the graph.'));
                return gt(r4, this.multi, i3, a4, e6);
              }
              throw new B("Graph.".concat(n5, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
            };
          }(t4, e4), function(t5, e5) {
            var n5 = e5.name, r4 = e5.type, i3 = e5.direction, o4 = "forEach" + n5[0].toUpperCase() + n5.slice(1, -1);
            t5.prototype[o4] = function(t6, e6, n6) {
              if ("mixed" === r4 || "mixed" === this.type || r4 === this.type) {
                if (1 === arguments.length) return dt(false, this, r4, n6 = t6);
                if (2 === arguments.length) {
                  t6 = "" + t6, n6 = e6;
                  var a5 = this._nodes.get(t6);
                  if (void 0 === a5) throw new F("Graph.".concat(o4, ': could not find the "').concat(t6, '" node in the graph.'));
                  return ht(false, this.multi, "mixed" === r4 ? this.type : r4, i3, a5, n6);
                }
                if (3 === arguments.length) {
                  t6 = "" + t6, e6 = "" + e6;
                  var c4 = this._nodes.get(t6);
                  if (!c4) throw new F("Graph.".concat(o4, ':  could not find the "').concat(t6, '" source node in the graph.'));
                  if (!this._nodes.has(e6)) throw new F("Graph.".concat(o4, ':  could not find the "').concat(e6, '" target node in the graph.'));
                  return lt(false, r4, this.multi, i3, c4, e6, n6);
                }
                throw new B("Graph.".concat(o4, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
              }
            };
            var a4 = "map" + n5[0].toUpperCase() + n5.slice(1);
            t5.prototype[a4] = function() {
              var t6, e6 = Array.prototype.slice.call(arguments), n6 = e6.pop();
              if (0 === e6.length) {
                var i4 = 0;
                "directed" !== r4 && (i4 += this.undirectedSize), "undirected" !== r4 && (i4 += this.directedSize), t6 = new Array(i4);
                var a5 = 0;
                e6.push(function(e7, r5, i5, o5, c4, u6, d4) {
                  t6[a5++] = n6(e7, r5, i5, o5, c4, u6, d4);
                });
              } else t6 = [], e6.push(function(e7, r5, i5, o5, a6, c4, u6) {
                t6.push(n6(e7, r5, i5, o5, a6, c4, u6));
              });
              return this[o4].apply(this, e6), t6;
            };
            var c3 = "filter" + n5[0].toUpperCase() + n5.slice(1);
            t5.prototype[c3] = function() {
              var t6 = Array.prototype.slice.call(arguments), e6 = t6.pop(), n6 = [];
              return t6.push(function(t7, r5, i4, o5, a5, c4, u6) {
                e6(t7, r5, i4, o5, a5, c4, u6) && n6.push(t7);
              }), this[o4].apply(this, t6), n6;
            };
            var u5 = "reduce" + n5[0].toUpperCase() + n5.slice(1);
            t5.prototype[u5] = function() {
              var t6, e6, n6 = Array.prototype.slice.call(arguments);
              if (n6.length < 2 || n6.length > 4) throw new B("Graph.".concat(u5, ": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(n6.length, ")."));
              if ("function" == typeof n6[n6.length - 1] && "function" != typeof n6[n6.length - 2]) throw new B("Graph.".concat(u5, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
              2 === n6.length ? (t6 = n6[0], e6 = n6[1], n6 = []) : 3 === n6.length ? (t6 = n6[1], e6 = n6[2], n6 = [n6[0]]) : 4 === n6.length && (t6 = n6[2], e6 = n6[3], n6 = [n6[0], n6[1]]);
              var r5 = e6;
              return n6.push(function(e7, n7, i4, o5, a5, c4, u6) {
                r5 = t6(r5, e7, n7, i4, o5, a5, c4, u6);
              }), this[o4].apply(this, n6), r5;
            };
          }(t4, e4), function(t5, e5) {
            var n5 = e5.name, r4 = e5.type, i3 = e5.direction, o4 = "find" + n5[0].toUpperCase() + n5.slice(1, -1);
            t5.prototype[o4] = function(t6, e6, n6) {
              if ("mixed" !== r4 && "mixed" !== this.type && r4 !== this.type) return false;
              if (1 === arguments.length) return dt(true, this, r4, n6 = t6);
              if (2 === arguments.length) {
                t6 = "" + t6, n6 = e6;
                var a5 = this._nodes.get(t6);
                if (void 0 === a5) throw new F("Graph.".concat(o4, ': could not find the "').concat(t6, '" node in the graph.'));
                return ht(true, this.multi, "mixed" === r4 ? this.type : r4, i3, a5, n6);
              }
              if (3 === arguments.length) {
                t6 = "" + t6, e6 = "" + e6;
                var c4 = this._nodes.get(t6);
                if (!c4) throw new F("Graph.".concat(o4, ':  could not find the "').concat(t6, '" source node in the graph.'));
                if (!this._nodes.has(e6)) throw new F("Graph.".concat(o4, ':  could not find the "').concat(e6, '" target node in the graph.'));
                return lt(true, r4, this.multi, i3, c4, e6, n6);
              }
              throw new B("Graph.".concat(o4, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
            };
            var a4 = "some" + n5[0].toUpperCase() + n5.slice(1, -1);
            t5.prototype[a4] = function() {
              var t6 = Array.prototype.slice.call(arguments), e6 = t6.pop();
              return t6.push(function(t7, n6, r5, i4, o5, a5, c4) {
                return e6(t7, n6, r5, i4, o5, a5, c4);
              }), !!this[o4].apply(this, t6);
            };
            var c3 = "every" + n5[0].toUpperCase() + n5.slice(1, -1);
            t5.prototype[c3] = function() {
              var t6 = Array.prototype.slice.call(arguments), e6 = t6.pop();
              return t6.push(function(t7, n6, r5, i4, o5, a5, c4) {
                return !e6(t7, n6, r5, i4, o5, a5, c4);
              }), !this[o4].apply(this, t6);
            };
          }(t4, e4), function(t5, e5) {
            var n5 = e5.name, r4 = e5.type, i3 = e5.direction, o4 = n5.slice(0, -1) + "Entries";
            t5.prototype[o4] = function(t6, e6) {
              if ("mixed" !== r4 && "mixed" !== this.type && r4 !== this.type) return O.empty();
              if (!arguments.length) return st(this, r4);
              if (1 === arguments.length) {
                t6 = "" + t6;
                var n6 = this._nodes.get(t6);
                if (!n6) throw new F("Graph.".concat(o4, ': could not find the "').concat(t6, '" node in the graph.'));
                return ft(r4, i3, n6);
              }
              if (2 === arguments.length) {
                t6 = "" + t6, e6 = "" + e6;
                var a4 = this._nodes.get(t6);
                if (!a4) throw new F("Graph.".concat(o4, ':  could not find the "').concat(t6, '" source node in the graph.'));
                if (!this._nodes.has(e6)) throw new F("Graph.".concat(o4, ':  could not find the "').concat(e6, '" target node in the graph.'));
                return yt(r4, i3, a4, e6);
              }
              throw new B("Graph.".concat(o4, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
            };
          }(t4, e4);
        });
      }(zt), function(t4) {
        wt.forEach(function(e4) {
          _t(t4, e4), function(t5, e5) {
            var n5 = e5.name, r4 = e5.type, i3 = e5.direction, o4 = "forEach" + n5[0].toUpperCase() + n5.slice(1, -1);
            t5.prototype[o4] = function(t6, e6) {
              if ("mixed" === r4 || "mixed" === this.type || r4 === this.type) {
                t6 = "" + t6;
                var n6 = this._nodes.get(t6);
                if (void 0 === n6) throw new F("Graph.".concat(o4, ': could not find the "').concat(t6, '" node in the graph.'));
                mt(false, "mixed" === r4 ? this.type : r4, i3, n6, e6);
              }
            };
            var a4 = "map" + n5[0].toUpperCase() + n5.slice(1);
            t5.prototype[a4] = function(t6, e6) {
              var n6 = [];
              return this[o4](t6, function(t7, r5) {
                n6.push(e6(t7, r5));
              }), n6;
            };
            var c3 = "filter" + n5[0].toUpperCase() + n5.slice(1);
            t5.prototype[c3] = function(t6, e6) {
              var n6 = [];
              return this[o4](t6, function(t7, r5) {
                e6(t7, r5) && n6.push(t7);
              }), n6;
            };
            var u5 = "reduce" + n5[0].toUpperCase() + n5.slice(1);
            t5.prototype[u5] = function(t6, e6, n6) {
              if (arguments.length < 3) throw new B("Graph.".concat(u5, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
              var r5 = n6;
              return this[o4](t6, function(t7, n7) {
                r5 = e6(r5, t7, n7);
              }), r5;
            };
          }(t4, e4), function(t5, e5) {
            var n5 = e5.name, r4 = e5.type, i3 = e5.direction, o4 = n5[0].toUpperCase() + n5.slice(1, -1), a4 = "find" + o4;
            t5.prototype[a4] = function(t6, e6) {
              if ("mixed" === r4 || "mixed" === this.type || r4 === this.type) {
                t6 = "" + t6;
                var n6 = this._nodes.get(t6);
                if (void 0 === n6) throw new F("Graph.".concat(a4, ': could not find the "').concat(t6, '" node in the graph.'));
                return mt(true, "mixed" === r4 ? this.type : r4, i3, n6, e6);
              }
            };
            var c3 = "some" + o4;
            t5.prototype[c3] = function(t6, e6) {
              return !!this[a4](t6, e6);
            };
            var u5 = "every" + o4;
            t5.prototype[u5] = function(t6, e6) {
              return !this[a4](t6, function(t7, n6) {
                return !e6(t7, n6);
              });
            };
          }(t4, e4), Gt(t4, e4);
        });
      }(zt);
      var Wt = function(t4) {
        function n5(e4) {
          var n6 = u4({ type: "directed" }, e4);
          if ("multi" in n6 && false !== n6.multi) throw new B("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
          if ("directed" !== n6.type) throw new B('DirectedGraph.from: inconsistent "' + n6.type + '" type in given options!');
          return t4.call(this, n6) || this;
        }
        return e3(n5, t4), n5;
      }(zt), Pt = function(t4) {
        function n5(e4) {
          var n6 = u4({ type: "undirected" }, e4);
          if ("multi" in n6 && false !== n6.multi) throw new B("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
          if ("undirected" !== n6.type) throw new B('UndirectedGraph.from: inconsistent "' + n6.type + '" type in given options!');
          return t4.call(this, n6) || this;
        }
        return e3(n5, t4), n5;
      }(zt), Rt = function(t4) {
        function n5(e4) {
          var n6 = u4({ multi: true }, e4);
          if ("multi" in n6 && true !== n6.multi) throw new B("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");
          return t4.call(this, n6) || this;
        }
        return e3(n5, t4), n5;
      }(zt), Kt = function(t4) {
        function n5(e4) {
          var n6 = u4({ type: "directed", multi: true }, e4);
          if ("multi" in n6 && true !== n6.multi) throw new B("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
          if ("directed" !== n6.type) throw new B('MultiDirectedGraph.from: inconsistent "' + n6.type + '" type in given options!');
          return t4.call(this, n6) || this;
        }
        return e3(n5, t4), n5;
      }(zt), Tt = function(t4) {
        function n5(e4) {
          var n6 = u4({ type: "undirected", multi: true }, e4);
          if ("multi" in n6 && true !== n6.multi) throw new B("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
          if ("undirected" !== n6.type) throw new B('MultiUndirectedGraph.from: inconsistent "' + n6.type + '" type in given options!');
          return t4.call(this, n6) || this;
        }
        return e3(n5, t4), n5;
      }(zt);
      function Bt(t4) {
        t4.from = function(e4, n5) {
          var r4 = u4({}, e4.options, n5), i3 = new t4(r4);
          return i3.import(e4), i3;
        };
      }
      return Bt(zt), Bt(Wt), Bt(Pt), Bt(Rt), Bt(Kt), Bt(Tt), zt.Graph = zt, zt.DirectedGraph = Wt, zt.UndirectedGraph = Pt, zt.MultiGraph = Rt, zt.MultiDirectedGraph = Kt, zt.MultiUndirectedGraph = Tt, zt.InvalidArgumentsGraphError = B, zt.NotFoundGraphError = F, zt.UsageGraphError = I, zt;
    });
  })(graphology_umd_min$1);
  return graphology_umd_min$1.exports;
}
var graphology_umd_minExports = requireGraphology_umd_min();
var Graph = getDefaultExportFromCjs(graphology_umd_minExports);
var topologicalSort$1 = {};
var isGraph;
var hasRequiredIsGraph;
function requireIsGraph() {
  if (hasRequiredIsGraph) return isGraph;
  hasRequiredIsGraph = 1;
  isGraph = function isGraph2(value) {
    return value !== null && typeof value === "object" && typeof value.addUndirectedEdgeWithKey === "function" && typeof value.dropNode === "function" && typeof value.multi === "boolean";
  };
  return isGraph;
}
var iterables = {};
var typedArrays = {};
var hasRequiredTypedArrays;
function requireTypedArrays() {
  if (hasRequiredTypedArrays) return typedArrays;
  hasRequiredTypedArrays = 1;
  (function(exports) {
    var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1, MAX_16BIT_INTEGER = Math.pow(2, 16) - 1, MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
    var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1, MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1, MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
    exports.getPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_8BIT_INTEGER)
        return Uint8Array;
      if (maxIndex <= MAX_16BIT_INTEGER)
        return Uint16Array;
      if (maxIndex <= MAX_32BIT_INTEGER)
        return Uint32Array;
      throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
    };
    exports.getSignedPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
        return Int8Array;
      if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
        return Int16Array;
      if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
        return Int32Array;
      return Float64Array;
    };
    exports.getNumberType = function(value) {
      if (value === (value | 0)) {
        if (Math.sign(value) === -1) {
          if (value <= 127 && value >= -128)
            return Int8Array;
          if (value <= 32767 && value >= -32768)
            return Int16Array;
          return Int32Array;
        } else {
          if (value <= 255)
            return Uint8Array;
          if (value <= 65535)
            return Uint16Array;
          return Uint32Array;
        }
      }
      return Float64Array;
    };
    var TYPE_PRIORITY = {
      Uint8Array: 1,
      Int8Array: 2,
      Uint16Array: 3,
      Int16Array: 4,
      Uint32Array: 5,
      Int32Array: 6,
      Float32Array: 7,
      Float64Array: 8
    };
    exports.getMinimalRepresentation = function(array, getter) {
      var maxType = null, maxPriority = 0, p2, t3, v, i2, l3;
      for (i2 = 0, l3 = array.length; i2 < l3; i2++) {
        v = getter ? getter(array[i2]) : array[i2];
        t3 = exports.getNumberType(v);
        p2 = TYPE_PRIORITY[t3.name];
        if (p2 > maxPriority) {
          maxPriority = p2;
          maxType = t3;
        }
      }
      return maxType;
    };
    exports.isTypedArray = function(value) {
      return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
    };
    exports.concat = function() {
      var length = 0, i2, o3, l3;
      for (i2 = 0, l3 = arguments.length; i2 < l3; i2++)
        length += arguments[i2].length;
      var array = new arguments[0].constructor(length);
      for (i2 = 0, o3 = 0; i2 < l3; i2++) {
        array.set(arguments[i2], o3);
        o3 += arguments[i2].length;
      }
      return array;
    };
    exports.indices = function(length) {
      var PointerArray = exports.getPointerArray(length);
      var array = new PointerArray(length);
      for (var i2 = 0; i2 < length; i2++)
        array[i2] = i2;
      return array;
    };
  })(typedArrays);
  return typedArrays;
}
var hasRequiredIterables;
function requireIterables() {
  if (hasRequiredIterables) return iterables;
  hasRequiredIterables = 1;
  var forEach = requireForeach();
  var typed = requireTypedArrays();
  function isArrayLike(target) {
    return Array.isArray(target) || typed.isTypedArray(target);
  }
  function guessLength(target) {
    if (typeof target.length === "number")
      return target.length;
    if (typeof target.size === "number")
      return target.size;
    return;
  }
  function toArray2(target) {
    var l3 = guessLength(target);
    var array = typeof l3 === "number" ? new Array(l3) : [];
    var i2 = 0;
    forEach(target, function(value) {
      array[i2++] = value;
    });
    return array;
  }
  function toArrayWithIndices(target) {
    var l3 = guessLength(target);
    var IndexArray = typeof l3 === "number" ? typed.getPointerArray(l3) : Array;
    var array = typeof l3 === "number" ? new Array(l3) : [];
    var indices = typeof l3 === "number" ? new IndexArray(l3) : [];
    var i2 = 0;
    forEach(target, function(value) {
      array[i2] = value;
      indices[i2] = i2++;
    });
    return [array, indices];
  }
  iterables.isArrayLike = isArrayLike;
  iterables.guessLength = guessLength;
  iterables.toArray = toArray2;
  iterables.toArrayWithIndices = toArrayWithIndices;
  return iterables;
}
var fixedDeque;
var hasRequiredFixedDeque;
function requireFixedDeque() {
  if (hasRequiredFixedDeque) return fixedDeque;
  hasRequiredFixedDeque = 1;
  var iterables2 = requireIterables(), Iterator = requireIterator();
  function FixedDeque(ArrayClass, capacity) {
    if (arguments.length < 2)
      throw new Error("mnemonist/fixed-deque: expecting an Array class and a capacity.");
    if (typeof capacity !== "number" || capacity <= 0)
      throw new Error("mnemonist/fixed-deque: `capacity` should be a positive number.");
    this.ArrayClass = ArrayClass;
    this.capacity = capacity;
    this.items = new ArrayClass(this.capacity);
    this.clear();
  }
  FixedDeque.prototype.clear = function() {
    this.start = 0;
    this.size = 0;
  };
  FixedDeque.prototype.push = function(item) {
    if (this.size === this.capacity)
      throw new Error("mnemonist/fixed-deque.push: deque capacity (" + this.capacity + ") exceeded!");
    var index = this.start + this.size;
    if (index >= this.capacity)
      index -= this.capacity;
    this.items[index] = item;
    return ++this.size;
  };
  FixedDeque.prototype.unshift = function(item) {
    if (this.size === this.capacity)
      throw new Error("mnemonist/fixed-deque.unshift: deque capacity (" + this.capacity + ") exceeded!");
    var index = this.start - 1;
    if (this.start === 0)
      index = this.capacity - 1;
    this.items[index] = item;
    this.start = index;
    return ++this.size;
  };
  FixedDeque.prototype.pop = function() {
    if (this.size === 0)
      return;
    this.size--;
    var index = this.start + this.size;
    if (index >= this.capacity)
      index -= this.capacity;
    return this.items[index];
  };
  FixedDeque.prototype.shift = function() {
    if (this.size === 0)
      return;
    var index = this.start;
    this.size--;
    this.start++;
    if (this.start === this.capacity)
      this.start = 0;
    return this.items[index];
  };
  FixedDeque.prototype.peekFirst = function() {
    if (this.size === 0)
      return;
    return this.items[this.start];
  };
  FixedDeque.prototype.peekLast = function() {
    if (this.size === 0)
      return;
    var index = this.start + this.size - 1;
    if (index >= this.capacity)
      index -= this.capacity;
    return this.items[index];
  };
  FixedDeque.prototype.get = function(index) {
    if (this.size === 0 || index >= this.capacity)
      return;
    index = this.start + index;
    if (index >= this.capacity)
      index -= this.capacity;
    return this.items[index];
  };
  FixedDeque.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    var c2 = this.capacity, l3 = this.size, i2 = this.start, j = 0;
    while (j < l3) {
      callback.call(scope, this.items[i2], j, this);
      i2++;
      j++;
      if (i2 === c2)
        i2 = 0;
    }
  };
  FixedDeque.prototype.toArray = function() {
    var offset = this.start + this.size;
    if (offset < this.capacity)
      return this.items.slice(this.start, offset);
    var array = new this.ArrayClass(this.size), c2 = this.capacity, l3 = this.size, i2 = this.start, j = 0;
    while (j < l3) {
      array[j] = this.items[i2];
      i2++;
      j++;
      if (i2 === c2)
        i2 = 0;
    }
    return array;
  };
  FixedDeque.prototype.values = function() {
    var items = this.items, c2 = this.capacity, l3 = this.size, i2 = this.start, j = 0;
    return new Iterator(function() {
      if (j >= l3)
        return {
          done: true
        };
      var value = items[i2];
      i2++;
      j++;
      if (i2 === c2)
        i2 = 0;
      return {
        value,
        done: false
      };
    });
  };
  FixedDeque.prototype.entries = function() {
    var items = this.items, c2 = this.capacity, l3 = this.size, i2 = this.start, j = 0;
    return new Iterator(function() {
      if (j >= l3)
        return {
          done: true
        };
      var value = items[i2];
      i2++;
      if (i2 === c2)
        i2 = 0;
      return {
        value: [j++, value],
        done: false
      };
    });
  };
  if (typeof Symbol !== "undefined")
    FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;
  FixedDeque.prototype.inspect = function() {
    var array = this.toArray();
    array.type = this.ArrayClass.name;
    array.capacity = this.capacity;
    Object.defineProperty(array, "constructor", {
      value: FixedDeque,
      enumerable: false
    });
    return array;
  };
  if (typeof Symbol !== "undefined")
    FixedDeque.prototype[Symbol.for("nodejs.util.inspect.custom")] = FixedDeque.prototype.inspect;
  FixedDeque.from = function(iterable, ArrayClass, capacity) {
    if (arguments.length < 3) {
      capacity = iterables2.guessLength(iterable);
      if (typeof capacity !== "number")
        throw new Error("mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.");
    }
    var deque = new FixedDeque(ArrayClass, capacity);
    if (iterables2.isArrayLike(iterable)) {
      var i2, l3;
      for (i2 = 0, l3 = iterable.length; i2 < l3; i2++)
        deque.items[i2] = iterable[i2];
      deque.size = l3;
      return deque;
    }
    iterables2.forEach(iterable, function(value) {
      deque.push(value);
    });
    return deque;
  };
  fixedDeque = FixedDeque;
  return fixedDeque;
}
var hasRequiredTopologicalSort;
function requireTopologicalSort() {
  if (hasRequiredTopologicalSort) return topologicalSort$1;
  hasRequiredTopologicalSort = 1;
  const isGraph2 = requireIsGraph();
  const FixedDeque = requireFixedDeque();
  function simpleInDegree(graph, node) {
    let degree = 0;
    graph.forEachInNeighbor(node, () => {
      degree++;
    });
    return degree;
  }
  function forEachNodeInTopologicalOrder(graph, callback) {
    if (!isGraph2(graph))
      throw new Error(
        "graphology-dag/topological-sort: the given graph is not a valid graphology instance."
      );
    if (graph.type === "undirected" || graph.undirectedSize !== 0)
      throw new Error(
        "graphology-dag/topological-sort: cannot work if graph is not directed."
      );
    if (graph.order === 0) return;
    const queue = new FixedDeque(Array, graph.order);
    const inDegrees = {};
    let total = 0;
    graph.forEachNode((node, attr) => {
      const inDegree = graph.multi ? simpleInDegree(graph, node) : graph.inDegree(node);
      if (inDegree === 0) {
        queue.push([node, attr, 0]);
      } else {
        inDegrees[node] = inDegree;
        total += inDegree;
      }
    });
    let currentGeneration = 0;
    function neighborCallback(neighbor, attr) {
      const neighborInDegree = --inDegrees[neighbor];
      total--;
      if (neighborInDegree === 0)
        queue.push([neighbor, attr, currentGeneration + 1]);
      inDegrees[neighbor] = neighborInDegree;
    }
    while (queue.size !== 0) {
      const [node, attr, gen] = queue.shift();
      currentGeneration = gen;
      callback(node, attr, gen);
      graph.forEachOutNeighbor(node, neighborCallback);
    }
    if (total !== 0)
      throw new Error(
        "graphology-dag/topological-sort: given graph is not acyclic."
      );
  }
  function topologicalSort2(graph) {
    if (!isGraph2(graph))
      throw new Error(
        "graphology-dag/topological-sort: the given graph is not a valid graphology instance."
      );
    const sortedNodes = new Array(graph.order);
    let i2 = 0;
    forEachNodeInTopologicalOrder(graph, (node) => {
      sortedNodes[i2++] = node;
    });
    return sortedNodes;
  }
  function forEachTopologicalGeneration(graph, callback) {
    if (!isGraph2(graph))
      throw new Error(
        "graphology-dag/topological-generations: the given graph is not a valid graphology instance."
      );
    if (graph.order === 0) return;
    let lastGenLevel = 0;
    let lastGen = [];
    forEachNodeInTopologicalOrder(graph, (node, _, gen) => {
      if (gen > lastGenLevel) {
        callback(lastGen);
        lastGenLevel = gen;
        lastGen = [];
      }
      lastGen.push(node);
    });
    callback(lastGen);
  }
  function topologicalGenerations(graph) {
    if (!isGraph2(graph))
      throw new Error(
        "graphology-dag/topological-generations: the given graph is not a valid graphology instance."
      );
    const generations = [];
    forEachTopologicalGeneration(graph, (generation) => {
      generations.push(generation);
    });
    return generations;
  }
  topologicalSort$1.topologicalSort = topologicalSort2;
  topologicalSort$1.forEachNodeInTopologicalOrder = forEachNodeInTopologicalOrder;
  topologicalSort$1.topologicalGenerations = topologicalGenerations;
  topologicalSort$1.forEachTopologicalGeneration = forEachTopologicalGeneration;
  return topologicalSort$1;
}
var topologicalSortExports = requireTopologicalSort();
var willCreateCycle$1;
var hasRequiredWillCreateCycle;
function requireWillCreateCycle() {
  if (hasRequiredWillCreateCycle) return willCreateCycle$1;
  hasRequiredWillCreateCycle = 1;
  const isGraph2 = requireIsGraph();
  willCreateCycle$1 = function willCreateCycle2(graph, source, target) {
    if (!isGraph2(graph))
      throw new Error(
        "graphology-dag/will-create-cycle: the given graph is not a valid graphology instance."
      );
    source = "" + source;
    target = "" + target;
    if (source === target) return true;
    if (!graph.hasNode(source) || !graph.hasNode(target)) return false;
    if (graph.hasDirectedEdge(source, target)) return false;
    if (graph.hasDirectedEdge(target, source)) return true;
    const stack = graph.outNeighbors(target);
    function push(neighbor) {
      stack.push(neighbor);
    }
    while (stack.length !== 0) {
      const node = stack.pop();
      if (node === source) return true;
      graph.forEachOutNeighbor(node, push);
    }
    return false;
  };
  return willCreateCycle$1;
}
var willCreateCycleExports = requireWillCreateCycle();
var willCreateCycle = getDefaultExportFromCjs(willCreateCycleExports);
function ensureParentsFirst(array) {
  const result = [];
  const items = [...array];
  let item;
  while (item = items.shift()) {
    let parent = item.parent;
    if (parent) {
      const ancestors = [];
      while (parent) {
        const parentIndx = items.findIndex((i2) => i2.id === parent);
        if (parentIndx < 0) {
          break;
        }
        const [parentItem] = items.splice(parentIndx, 1);
        if (!parentItem) {
          throw new Error("Invalid state, should not happen");
        }
        ancestors.unshift(parentItem);
        parent = parentItem.parent;
      }
      result.push(...ancestors);
    }
    result.push(item);
  }
  return result;
}
function updateChildren(nodes) {
  nodes.forEach((parent) => {
    if (parent.children.length > 0) {
      parent.children = nodes.reduce((acc, n4) => {
        if (n4.parent === parent.id) {
          acc.push(n4.id);
        }
        return acc;
      }, []);
    }
  });
  return nodes;
}
function topologicalSort(param) {
  let nodes = ensureParentsFirst([...param.nodes.values()]);
  let edges = [...param.edges];
  if (nodes.length < 2 || edges.length === 0) {
    return {
      nodes,
      edges
    };
  }
  const getNode = (id) => nonNullable(param.nodes.get(id));
  const g = new Graph({
    multi: true,
    allowSelfLoops: true,
    type: "directed"
  });
  const enrichedEdges = C(
    edges,
    m((edge, __dirname) => {
      const source = getNode(edge.source), target = getNode(edge.target), parent = edge.parent ? getNode(edge.parent) : null;
      return {
        id: edge.id,
        edge,
        parent,
        source,
        target
      };
    })
    // sortBy(
    //   [prop('sourceIndex'), 'asc'],
    //   // [prop('sourceInCount'), 'asc'],
    //   // [prop('sourceLevel'), 'asc'],
    // ),
  );
  const [edgesBetweenLeafs, edgesWithCompounds] = d$3(
    enrichedEdges,
    ({ source, target }) => source.children.length === 0 && target.children.length === 0
  );
  const sortedEdges = [];
  const addEdgeToGraph = (edge) => {
    g.mergeNode(edge.source);
    g.mergeNode(edge.target);
    sortedEdges.push(edge);
    if (!willCreateCycle(g, edge.source, edge.target)) {
      g.mergeDirectedEdge(edge.source, edge.target);
    }
  };
  for (const { edge, source, target } of edgesBetweenLeafs) {
    addEdgeToGraph(edge);
    if (target.parent && target.parent !== edge.parent) {
      C(
        ancestorsOfNode(target, param.nodes),
        u2((ancestor) => ancestor.inEdges.includes(edge.id)),
        u3((ancestor) => {
          g.mergeNode(ancestor.id);
          if (!willCreateCycle(g, edge.source, ancestor.id)) {
            g.mergeDirectedEdge(edge.source, ancestor.id);
          }
          if (!willCreateCycle(g, ancestor.id, edge.target)) {
            g.mergeDirectedEdge(ancestor.id, edge.target);
          }
        })
      );
    }
    if (source.parent) {
      const sourceParent = getNode(source.parent);
      g.mergeNode(sourceParent.id);
      if (!willCreateCycle(g, sourceParent.id, source.id)) {
        g.mergeDirectedEdge(sourceParent.id, source.id);
      }
      if (target.parent && target.parent !== source.parent) {
        if (!willCreateCycle(g, sourceParent.id, target.parent)) {
          g.mergeDirectedEdge(sourceParent.id, target.parent);
        }
      }
    }
  }
  for (const { edge } of edgesWithCompounds) {
    addEdgeToGraph(edge);
  }
  invariant(sortedEdges.length === edges.length, "Not all edges were added to the graph");
  const sortedIds = topologicalSortExports.topologicalSort(g);
  let sorted = [];
  let unsorted = nodes.slice();
  for (const sortedId of sortedIds) {
    const indx = unsorted.findIndex((n4) => n4.id === sortedId);
    invariant(indx >= 0, `Node "${sortedId}" not found`);
    sorted.push(...unsorted.splice(indx, 1));
  }
  if (unsorted.length > 0 && sorted.length > 0) {
    sorted = sorted.flatMap((node) => {
      if (unsorted.length === 0) {
        return node;
      }
      const wereBefore = nodes.slice(0, nodes.indexOf(node)).filter((n4) => unsorted.includes(n4));
      if (wereBefore.length > 0) {
        unsorted = unsorted.filter((n4) => !wereBefore.includes(n4));
        return [...wereBefore, node];
      }
      return node;
    });
  }
  sorted.push(...unsorted);
  return {
    nodes: updateChildren(
      ensureParentsFirst(sorted)
    ),
    edges: sortedEdges
  };
}
function calcViewLayoutHash(view) {
  const tohash = {
    id: view.id,
    __: view.__ ?? "element",
    autoLayout: view.autoLayout,
    nodes: C(
      view.nodes,
      m(i$6(["id", "title", "description", "technology", "shape", "icon", "children"])),
      l$3(({ id, icon, ...node }) => [id, { ...node, icon: n$1(icon) ? "Y" : "N" }])
    ),
    edges: C(
      view.edges,
      m(i$6(["source", "target", "label", "description", "technology", "dir", "head", "tail", "line"])),
      l$3(({ source, target, ...edge }) => [`${source}:${target}`, edge])
    )
  };
  view.hash = objectHash(tohash);
  return view;
}
var AbstractMemory = class {
  constructor(state) {
    this.state = state;
  }
  /**
   * Provides access to context types
   * !IMPORTANT: Should not be called in runtime
   *
   * @example
   * ```ts
   *   type State = SomeMemory['Ctx']['MutableState']
   * ```
   */
  get Ctx() {
    throw new Error("Should not be called in runtime");
  }
  get elements() {
    return this.state.elements;
  }
  get explicits() {
    return this.state.explicits;
  }
  get final() {
    return this.state.final;
  }
  get connections() {
    return this.state.connections;
  }
  isEmpty() {
    return this.elements.size === 0 && this.connections.length === 0 && this.explicits.size === 0 && this.final.size === 0;
  }
};
var Connection;
((Connection2) => {
  Connection2.isInside = (fqn) => {
    return (connection) => isAncestor(fqn, connection.source.id) && isAncestor(fqn, connection.target.id);
  };
  Connection2.isDirectedBetween = (source, target) => {
    return (connection) => (connection.source.id === source || isAncestor(source, connection.source.id)) && (connection.target.id === target || isAncestor(target, connection.target.id));
  };
  Connection2.isAnyBetween = (source, target) => {
    const forward = (0, Connection2.isDirectedBetween)(source, target), backward = (0, Connection2.isDirectedBetween)(target, source);
    return (connection) => forward(connection) || backward(connection);
  };
  Connection2.isIncoming = (target) => {
    return (connection) => (connection.target.id === target || isAncestor(target, connection.target.id)) && !isAncestor(target, connection.source.id);
  };
  Connection2.isOutgoing = (source) => {
    return (connection) => (connection.source.id === source || isAncestor(source, connection.source.id)) && !isAncestor(source, connection.target.id);
  };
  Connection2.isAnyInOut = (source) => {
    const isIn = (0, Connection2.isIncoming)(source), isOut = (0, Connection2.isOutgoing)(source);
    return (connection) => isIn(connection) || isOut(connection);
  };
})(Connection || (Connection = {}));
var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
var AbstractDeploymentElementModel = class {
  constructor() {
    __publicField(this, "cachedOutgoing", null);
    __publicField(this, "cachedIncoming", null);
  }
  get style() {
    return {
      shape: DefaultElementShape,
      color: DefaultThemeColor,
      size: DefaultShapeSize,
      ...this.$node.style
    };
  }
  get shape() {
    var _a;
    return ((_a = this.$node.style) == null ? void 0 : _a.shape) ?? DefaultElementShape;
  }
  get color() {
    var _a;
    return ((_a = this.$node.style) == null ? void 0 : _a.color) ?? DefaultThemeColor;
  }
  get tags() {
    return this.$node.tags ?? [];
  }
  get description() {
    return this.$node.description ?? null;
  }
  get technology() {
    return this.$node.technology ?? null;
  }
  get links() {
    return this.$node.links ?? [];
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors() {
    return this.$model.ancestors(this);
  }
  /**
   * Returns the common ancestor of this element and another element.
   */
  commonAncestor(another) {
    const common = commonAncestor(this.id, another.id);
    return common ? this.$model.node(common) : null;
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  siblings() {
    return this.$model.siblings(this);
  }
  /**
   * Check if the element is a sibling of another element
   */
  isSibling(other) {
    return this.parent === other.parent;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from closest to root)
   */
  *ascendingSiblings() {
    yield* this.siblings();
    for (const ancestor of this.ancestors()) {
      yield* ancestor.siblings();
    }
    return;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from root to closest)
   */
  *descendingSiblings() {
    for (const ancestor of [...this.ancestors()].reverse()) {
      yield* ancestor.siblings();
    }
    yield* this.siblings();
    return;
  }
  incoming(filter = "all") {
    return this.$model.incoming(this, filter);
  }
  outgoing(filter = "all") {
    return this.$model.outgoing(this, filter);
  }
  *incomers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r3 of this.incoming(filter)) {
      if (unique.has(r3.source.id)) {
        continue;
      }
      unique.add(r3.source.id);
      yield r3.source;
    }
    return;
  }
  *outgoers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r3 of this.outgoing(filter)) {
      if (unique.has(r3.target.id)) {
        continue;
      }
      unique.add(r3.target.id);
      yield r3.target;
    }
    return;
  }
  /**
   * Iterate over all views that include this deployment element.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (!view.isDeploymentView()) {
        continue;
      }
      if (view.includesDeployment(this.id)) {
        yield view;
      }
    }
  }
  // type guard
  isDeploymentNode() {
    return false;
  }
  // type guard
  isInstance() {
    return false;
  }
  get allOutgoing() {
    this.cachedOutgoing ?? (this.cachedOutgoing = RelationshipsAccum.from(
      new Set(this.outgoingModelRelationships()),
      new Set(this.outgoing())
    ));
    return this.cachedOutgoing;
  }
  get allIncoming() {
    this.cachedIncoming ?? (this.cachedIncoming = RelationshipsAccum.from(
      new Set(this.incomingModelRelationships()),
      new Set(this.incoming())
    ));
    return this.cachedIncoming;
  }
};
var DeploymentNodeModel = class extends AbstractDeploymentElementModel {
  constructor($model, $node) {
    super();
    __publicField(this, "id");
    __publicField(this, "title");
    __publicField(this, "hierarchyLevel");
    /**
     * Cached result of relationships from instances
     */
    __publicField(this, "_relationshipsFromInstances", null);
    this.$model = $model;
    this.$node = $node;
    this.id = $node.id;
    this.title = $node.title;
    this.hierarchyLevel = hierarchyLevel($node.id);
  }
  get parent() {
    return this.$model.parent(this);
  }
  get kind() {
    return this.$node.kind;
  }
  children() {
    return this.$model.children(this);
  }
  descendants(sort = "desc") {
    return this.$model.descendants(this, sort);
  }
  isDeploymentNode() {
    return true;
  }
  /**
   * Iterate over all instances nested in this deployment node.
   */
  *instances() {
    for (const nested of this.descendants("desc")) {
      if (nested.isInstance()) {
        yield nested;
      }
    }
    return;
  }
  /**
   * Returns deployed instance inside this deployment node
   * if only there are no more instances
   */
  onlyOneInstance() {
    const children = this.children();
    if (children.size !== 1) {
      return null;
    }
    const child = t$2([...children]);
    return (child == null ? void 0 : child.isInstance()) ? child : null;
  }
  relationshipsFromInstances() {
    if (this._relationshipsFromInstances) {
      return this._relationshipsFromInstances;
    }
    const {
      outgoing,
      incoming
    } = this._relationshipsFromInstances = {
      outgoing: /* @__PURE__ */ new Set(),
      incoming: /* @__PURE__ */ new Set()
    };
    for (const instance of this.instances()) {
      for (const r3 of instance.element.outgoing()) {
        outgoing.add(r3);
      }
      for (const r3 of instance.element.incoming()) {
        incoming.add(r3);
      }
    }
    return this._relationshipsFromInstances;
  }
  /**
   * We return only relationships that are not already present in nested instances
   */
  outgoingModelRelationships() {
    return this.relationshipsFromInstances().outgoing.values();
  }
  /**
   * We return only relationships that are not already present in nested instances
   */
  incomingModelRelationships() {
    return this.relationshipsFromInstances().incoming.values();
  }
  /**
   * Returns an iterator of relationships between nested instances
   */
  internalModelRelationships() {
    const {
      outgoing,
      incoming
    } = this.relationshipsFromInstances();
    return intersection(incoming, outgoing);
  }
};
var DeployedInstanceModel = class extends AbstractDeploymentElementModel {
  constructor($model, $instance, element) {
    super();
    __publicField(this, "id");
    __publicField(this, "title");
    __publicField(this, "hierarchyLevel");
    this.$model = $model;
    this.$instance = $instance;
    this.element = element;
    this.id = $instance.id;
    this.title = $instance.title ?? element.title;
    this.hierarchyLevel = hierarchyLevel($instance.id);
  }
  get $node() {
    return this.$instance;
  }
  get parent() {
    return nonNullable(this.$model.parent(this), `Parent of ${this.id} not found`);
  }
  get style() {
    const { icon, style } = this.element.$element;
    return {
      shape: this.element.shape,
      color: this.element.color,
      size: DefaultShapeSize,
      ...icon && { icon },
      ...style,
      ...this.$instance.style
    };
  }
  get shape() {
    var _a;
    return ((_a = this.$instance.style) == null ? void 0 : _a.shape) ?? this.element.shape;
  }
  get color() {
    var _a;
    return ((_a = this.$instance.style) == null ? void 0 : _a.color) ?? this.element.color;
  }
  get tags() {
    return this.$instance.tags ?? [];
  }
  get kind() {
    return this.element.kind;
  }
  get description() {
    return this.$instance.description ?? this.element.description;
  }
  get technology() {
    return this.$instance.technology ?? this.element.technology;
  }
  get links() {
    return this.$instance.links ?? this.element.links;
  }
  isInstance() {
    return true;
  }
  outgoingModelRelationships() {
    return this.element.outgoing();
  }
  incomingModelRelationships() {
    return this.element.incoming();
  }
  /**
   * Iterate over all views that include this instance.
   * (Some views may include the parent deployment node instead of the instance.)
   */
  *views() {
    for (const view of this.$model.views()) {
      if (!view.isDeploymentView()) {
        continue;
      }
      if (view.includesDeployment(this.id)) {
        yield view;
        continue;
      }
      if (view.includesDeployment(this.parent.id) && this.parent.onlyOneInstance()) {
        yield view;
      }
    }
  }
};
var NestedElementOfDeployedInstanceModel = class {
  constructor(instance, element) {
    this.instance = instance;
    this.element = element;
  }
  get id() {
    return this.instance.id;
  }
  get style() {
    const { icon, style } = this.element.$element;
    return {
      shape: this.element.shape,
      color: this.element.color,
      ...icon && { icon },
      ...style
    };
  }
  get shape() {
    return this.element.shape;
  }
  get color() {
    return this.element.color;
  }
  get title() {
    return this.element.title;
  }
  get description() {
    return this.element.description;
  }
  get technology() {
    return this.element.technology;
  }
  isDeploymentNode() {
    return false;
  }
  isInstance() {
    return false;
  }
};
var DeploymentRelationModel = class {
  constructor($model, $relationship) {
    __publicField(this, "boundary");
    __publicField(this, "source");
    __publicField(this, "target");
    this.$model = $model;
    this.$relationship = $relationship;
    this.source = $model.deploymentRef($relationship.source);
    this.target = $model.deploymentRef($relationship.target);
    const parent = commonAncestor(this.source.id, this.target.id);
    this.boundary = parent ? this.$model.node(parent) : null;
  }
  get id() {
    return this.$relationship.id;
  }
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  get title() {
    if (n3(this.$relationship.title)) {
      return null;
    }
    return this.$relationship.title;
  }
  get technology() {
    if (n3(this.$relationship.technology)) {
      return null;
    }
    return this.$relationship.technology;
  }
  get description() {
    if (n3(this.$relationship.description)) {
      return null;
    }
    return this.$relationship.description;
  }
  get tags() {
    return this.$relationship.tags ?? [];
  }
  get kind() {
    return this.$relationship.kind ?? null;
  }
  get navigateTo() {
    return this.$relationship.navigateTo ? this.$model.$model.view(this.$relationship.navigateTo) : null;
  }
  get links() {
    return this.$relationship.links ?? [];
  }
  get color() {
    return this.$relationship.color ?? DefaultRelationshipColor;
  }
  get line() {
    return this.$relationship.line ?? DefaultLineStyle;
  }
  *views() {
    for (const view of this.$model.views()) {
      if (view.includesRelation(this.id)) {
        yield view;
      }
    }
    return;
  }
  isDeploymentRelation() {
    return true;
  }
};
var RelationshipsAccum = class _RelationshipsAccum {
  /**
   * @param model relationships from logical model
   * @param deployment relationships from deployment model
   */
  constructor(model = /* @__PURE__ */ new Set(), deployment = /* @__PURE__ */ new Set()) {
    this.model = model;
    this.deployment = deployment;
  }
  static empty() {
    return new _RelationshipsAccum();
  }
  static from(model, deployment) {
    return new _RelationshipsAccum(
      new Set(model),
      new Set(deployment)
    );
  }
  get isEmpty() {
    return this.model.size === 0 && this.deployment.size === 0;
  }
  get nonEmpty() {
    return this.model.size > 0 || this.deployment.size > 0;
  }
  get size() {
    return this.model.size + this.deployment.size;
  }
  /**
   * Returns new Accum containing all the elements which are both in this and otherAccum
   */
  intersect(otherAccum) {
    return _RelationshipsAccum.from(
      intersection(this.model, otherAccum.model),
      intersection(this.deployment, otherAccum.deployment)
    );
  }
  /**
   * Returns new Accum containing all the elements which are both in this and otherAccum
   */
  difference(otherAccum) {
    return _RelationshipsAccum.from(
      difference(this.model, otherAccum.model),
      difference(this.deployment, otherAccum.deployment)
    );
  }
  /**
   * Returns new Accum containing all the elements from both
   */
  union(otherAccum) {
    return _RelationshipsAccum.from(
      union(this.model, otherAccum.model),
      union(this.deployment, otherAccum.deployment)
    );
  }
};
var DeploymentConnectionModel = class _DeploymentConnectionModel {
  constructor(source, target, relations) {
    __publicField(this, "id");
    __publicField(this, "_boundary");
    this.source = source;
    this.target = target;
    this.relations = relations;
    this.id = stringHash(`deployment:${source.id}:${target.id}`);
  }
  /**
   * Human readable expression of the connection
   * Mostly used for testing and debugging
   */
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the connection.
   */
  get boundary() {
    this._boundary ?? (this._boundary = this.source.commonAncestor(this.target));
    return this._boundary;
  }
  nonEmpty() {
    return this.relations.nonEmpty;
  }
  [customInspectSymbol](depth, inspectOptions, inspect) {
    const asString = this.toString();
    Object.defineProperty(asString, "constructor", {
      value: _DeploymentConnectionModel,
      enumerable: false
    });
    return asString;
  }
  toString() {
    const model = [...this.relations.model].map((c2) => "    " + c2.expression);
    if (model.length) {
      model.unshift("  model:");
    } else {
      model.unshift("  model: []");
    }
    const deployment = [...this.relations.deployment].map((c2) => "    " + c2.expression);
    if (deployment.length) {
      deployment.unshift("  deployment:");
    } else {
      deployment.unshift("  deployment: []");
    }
    return [
      this.expression,
      ...model,
      ...deployment
    ].join("\n");
  }
  /**
   * Check if connection contains deployment relation,
   * that is directly connected to source or target.
   */
  hasDirectDeploymentRelation() {
    for (const relation of this.relations.deployment) {
      if (relation.source.id === this.source.id || relation.target.id === this.target.id) {
        return true;
      }
    }
    return false;
  }
  *values() {
    yield* this.relations.model;
    yield* this.relations.deployment;
  }
  mergeWith(other) {
    if (Array.isArray(other)) {
      return other.reduce((acc, o3) => acc.mergeWith(o3), this);
    }
    invariant(this.source.id === other.source.id, "Cannot merge connections with different sources");
    invariant(this.target.id === other.target.id, "Cannot merge connections with different targets");
    return new _DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.union(other.relations)
    );
  }
  difference(other) {
    return new _DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.difference(other.relations)
    );
  }
  intersect(other) {
    return new _DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.intersect(other.relations)
    );
  }
  equals(other) {
    invariant(other instanceof _DeploymentConnectionModel, "Other should ne DeploymentConnectionModel");
    return this.id === other.id && this.source.id === other.source.id && this.target.id === other.target.id && equals(this.relations.model, other.relations.model) && equals(this.relations.deployment, other.relations.deployment);
  }
  /**
   * Creates a clone of the current `DeploymentConnectionModel` instance with optional overrides.
   * if `null` is provided in overrides, the corresponding relation set will be empty.
   */
  update(overrides) {
    if (overrides) {
      overrides = {
        model: this.relations.model,
        deployment: this.relations.deployment,
        ...overrides
      };
    }
    return new _DeploymentConnectionModel(
      this.source,
      this.target,
      overrides ? new RelationshipsAccum(
        overrides.model ?? /* @__PURE__ */ new Set(),
        overrides.deployment ?? /* @__PURE__ */ new Set()
      ) : this.relations
    );
  }
};
function isNestedConnection(nested, parent) {
  if (!parent) {
    const p2 = nested;
    return (n4) => isNestedConnection(n4, p2);
  }
  const isSameSource = nested.source === parent.source;
  const isSameTarget = nested.target === parent.target;
  if (isSameSource && isSameTarget) {
    return false;
  }
  const isSourceNested = isAncestor(parent.source.id, nested.source.id);
  const isTargetNested = isAncestor(parent.target.id, nested.target.id);
  return isSourceNested && isTargetNested || isSameSource && isTargetNested || isSameTarget && isSourceNested;
}
function findDeepestNestedConnection(connections, connection) {
  let deepest = connection;
  for (const c2 of connections) {
    if (isNestedConnection(c2, deepest)) {
      deepest = c2;
    }
  }
  return deepest !== connection ? deepest : null;
}
function sortDeepestFirst(connections) {
  const sorted = [];
  const unsorted = connections.slice();
  let next;
  while (next = unsorted.shift()) {
    let deepest;
    while (deepest = findDeepestNestedConnection(unsorted, next)) {
      const index = unsorted.indexOf(deepest);
      sorted.push(unsorted.splice(index, 1)[0]);
    }
    sorted.push(next);
  }
  return sorted;
}
var boundaryHierarchy = (conn) => {
  var _a;
  return ((_a = conn.boundary) == null ? void 0 : _a.id) ? `.${conn.boundary.id}` : "";
};
function sortConnectionsByBoundaryHierarchy(connections, sort) {
  if (!connections || isString(connections)) {
    const dir = connections ?? "asc";
    return (arr) => _sortByBoundary(arr, dir);
  }
  return _sortByBoundary(connections, sort ?? "asc");
}
function _sortByBoundary(connections, order) {
  return C(
    connections,
    m((conn) => ({
      id: boundaryHierarchy(conn),
      conn
    })),
    sortNaturalByFqn(order),
    m(p$1("conn"))
  );
}
function findAscendingConnections(connections, connection) {
  return connections.filter((c2) => isNestedConnection(connection, c2));
}
function findDescendantConnections(connections, connection) {
  return connections.filter(isNestedConnection(connection));
}
function mergeConnections(connections) {
  const map2 = /* @__PURE__ */ new Map();
  for (const conn of connections) {
    const existing = map2.get(conn.id);
    if (existing) {
      map2.set(conn.id, conn.mergeWith(existing));
    } else {
      map2.set(conn.id, conn);
    }
  }
  return [...map2.values()];
}
function differenceConnections(source, exclude) {
  const minus = new Map([...exclude].map((c2) => [c2.id, c2]));
  return [...source].reduce((acc, c2) => {
    const other = minus.get(c2.id);
    if (!other) {
      acc.push(c2);
      return acc;
    }
    const updated = c2.difference(other);
    if (updated.nonEmpty()) {
      acc.push(updated);
    }
    return acc;
  }, []);
}
function hasSameSourceTarget(a3, b) {
  if (b) {
    return a3.source === b.source && a3.target === b.target;
  }
  return (b2) => a3.source === b2.source && a3.target === b2.target;
}
function hasSameSource(a3, b) {
  if (b) {
    return a3.source === b.source;
  }
  return (b2) => a3.source === b2.source;
}
function hasSameTarget(a3, b) {
  if (b) {
    return a3.target === b.target;
  }
  return (b2) => a3.target === b2.target;
}
function isOutgoing(a3, source) {
  if (!source) {
    const _source = a3;
    return (b) => isOutgoing(b, _source);
  }
  const at = a3;
  return isDescendantOf(at.source, source) && !isDescendantOf(at.target, source);
}
function isIncoming(a3, target) {
  if (!target) {
    const _target = a3;
    return (b) => isIncoming(b, _target);
  }
  const at = a3;
  return isDescendantOf(at.target, target) && !isDescendantOf(at.source, target);
}
function isAnyInOut(a3, source) {
  if (!source) {
    const _source = a3;
    return (b) => isAnyInOut(b, _source);
  }
  const at = a3;
  return isDescendantOf(at.source, source) !== isDescendantOf(at.target, source);
}
function findConnection$1(source, target, direction = "directed") {
  if (source === target) {
    return [];
  }
  if (isSameHierarchy(source, target)) {
    return [];
  }
  const directedIntersection = intersection(source.allOutgoing, target.allIncoming);
  const directed = directedIntersection.size > 0 ? new ConnectionModel(
    source,
    target,
    directedIntersection
  ) : null;
  if (direction === "directed") {
    return directed ? [directed] : [];
  }
  const reverseIntersection = intersection(source.allIncoming, target.allOutgoing);
  const reverse = reverseIntersection.size > 0 ? new ConnectionModel(
    target,
    source,
    reverseIntersection
  ) : null;
  if (directed && reverse) {
    return [directed, reverse];
  }
  if (directed) {
    return [directed];
  }
  if (reverse) {
    return [reverse];
  }
  return [];
}
function findConnectionsBetween$1(element, others, direction = "both") {
  if (element.allIncoming.size === 0 && element.allOutgoing.size === 0) {
    return [];
  }
  const outgoing = [];
  const incoming = [];
  for (const _other of others) {
    if (element === _other) {
      continue;
    }
    for (const found of findConnection$1(element, _other, direction)) {
      if (found.source === element) {
        outgoing.push(found);
      } else {
        incoming.push(found);
      }
    }
  }
  return [
    ...outgoing,
    ...incoming
  ];
}
function findConnectionsWithin$1(elements) {
  return [...elements].reduce((acc, el, index, array) => {
    if (index === array.length - 1) {
      return acc;
    }
    acc.push(
      ...findConnectionsBetween$1(el, array.slice(index + 1), "both")
    );
    return acc;
  }, []);
}
var find$1 = {
  __proto__: null,
  findConnection: findConnection$1,
  findConnectionsBetween: findConnectionsBetween$1,
  findConnectionsWithin: findConnectionsWithin$1
};
var ConnectionModel = class _ConnectionModel {
  constructor(source, target, relations = /* @__PURE__ */ new Set()) {
    __publicField(this, "id");
    __publicField(this, "_boundary");
    this.source = source;
    this.target = target;
    this.relations = relations;
    this.id = stringHash(`model:${source.id}:${target.id}`);
  }
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the connection.
   */
  get boundary() {
    return this._boundary ?? (this._boundary = this.source.commonAncestor(this.target));
  }
  /**
   * Human readable expression of the connection
   * Mostly used for testing and debugging
   */
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  /**
   * Returns true if only includes relations between the source and target elements.
   */
  get isDirect() {
    return this.nonEmpty() && !this.isImplicit;
  }
  /**
   * Returns true if includes relations between nested elements of the source and target elements.
   */
  get isImplicit() {
    return this.nonEmpty() && isome(this.relations, o$1(hasSameSourceTarget(this)));
  }
  get directRelations() {
    return new Set(ifilter(this.relations, hasSameSourceTarget(this)));
  }
  nonEmpty() {
    return this.relations.size > 0;
  }
  mergeWith(other) {
    invariant(this.source.id === other.source.id, "Cannot merge connections with different sources");
    invariant(this.target.id === other.target.id, "Cannot merge connections with different targets");
    return new _ConnectionModel(
      this.source,
      this.target,
      union(this.relations, other.relations)
    );
  }
  difference(other) {
    return new _ConnectionModel(
      this.source,
      this.target,
      difference(this.relations, other.relations)
    );
  }
  intersect(other) {
    invariant(other instanceof _ConnectionModel, "Cannot intersect connection with different type");
    return new _ConnectionModel(
      this.source,
      this.target,
      intersection(this.relations, other.relations)
    );
  }
  equals(other) {
    invariant(other instanceof _ConnectionModel, "Cannot merge connection with different type");
    return this.id === other.id && this.source.id === other.source.id && this.target.id === other.target.id && equals(this.relations, other.relations);
  }
  /**
   * Returns a new instance with the updated relations.
   *
   * @param relations - A readonly set of `RelationshipModel` instances representing the new relations.
   * @returns A new `ConnectionModel` instance with the updated relations.
   */
  update(relations) {
    return new _ConnectionModel(
      this.source,
      this.target,
      relations
    );
  }
  [customInspectSymbol](depth, inspectOptions, inspect) {
    const asString = this.toString();
    Object.defineProperty(asString, "constructor", {
      value: _ConnectionModel,
      enumerable: false
    });
    return asString;
  }
  toString() {
    return [
      this.expression,
      this.relations.size ? "  relations:" : "  relations: [ ]",
      ...[...this.relations].map((c2) => "    " + c2.expression)
    ].join("\n");
  }
  /**
   * Creates a new connection with reversed direction (target becomes source and vice versa)
   * @param search - When true, attempts to find an existing connection between the reversed nodes
   */
  reversed(search = false) {
    if (!search) {
      return new _ConnectionModel(this.target, this.source);
    }
    const [found] = findConnection$1(this.target, this.source, "directed");
    return found ?? new _ConnectionModel(this.target, this.source, /* @__PURE__ */ new Set());
  }
};
function findConnection(source, target, direction = "directed") {
  if (source === target) {
    return [];
  }
  if (isSameHierarchy(source, target)) {
    return [];
  }
  const directedIntersection = source.allOutgoing.intersect(target.allIncoming);
  const directed = directedIntersection.nonEmpty ? [
    new DeploymentConnectionModel(
      source,
      target,
      directedIntersection
    )
  ] : [];
  if (direction === "directed") {
    return directed;
  }
  return [
    ...directed,
    ...findConnection(target, source, "directed")
  ];
}
function findConnectionsBetween(element, others, direction = "both") {
  if (element.allIncoming.isEmpty && element.allOutgoing.isEmpty) {
    return [];
  }
  const outgoing = [];
  const incoming = [];
  for (const _other of others) {
    if (element === _other) {
      continue;
    }
    for (const found of findConnection(element, _other, direction)) {
      if (found.source === element) {
        outgoing.push(found);
      } else {
        incoming.push(found);
      }
    }
  }
  return [
    ...outgoing,
    ...incoming
  ];
}
function findConnectionsWithin(elements) {
  return [...elements].reduce((acc, el, index, array) => {
    if (index === array.length - 1) {
      return acc;
    }
    acc.push(
      ...findConnectionsBetween(el, array.slice(index + 1), "both")
    );
    return acc;
  }, []);
}
var find = {
  __proto__: null,
  findConnection,
  findConnectionsBetween,
  findConnectionsWithin
};
var AbstractStageExclude = class {
  constructor(memory, expression) {
    // Removed elements
    __publicField(this, "excluded", {
      elements: /* @__PURE__ */ new Set(),
      connections: []
    });
    __publicField(this, "markedToMoveExplicitToImplicit", false);
    this.memory = memory;
    this.expression = expression;
  }
  _removeElement(element) {
    this.excluded.elements.add(element);
  }
  exclude(element) {
    if (!element) {
      return this;
    }
    if (isIterable(element)) {
      for (const el of element) {
        this._removeElement(el);
      }
      return this;
    }
    this._removeElement(element);
    return this;
  }
  _removeConnection(connection) {
    this.excluded.connections.push(connection);
  }
  /**
   * Excludes from the memory relationships from given connections (still connection may be included, but without given relationships)
   * @param moveExplicitToImplicit - if true, disconnected explicit elements will be moved to implicit
   * @default false
   */
  excludeConnections(connection, moveExplicitToImplicit) {
    if (e2(moveExplicitToImplicit)) {
      invariant(!this.markedToMoveExplicitToImplicit, "Already marked to move explicits");
      this.markedToMoveExplicitToImplicit = moveExplicitToImplicit;
    }
    if (isIterable(connection)) {
      for (const c2 of connection) {
        this._removeConnection(c2);
      }
      return this;
    }
    this._removeConnection(connection);
    return this;
  }
  isDirty() {
    return this.excluded.elements.size > 0 || this.excluded.connections.length > 0;
  }
  isEmpty() {
    return !this.isDirty();
  }
  /**
   * Determines whether disconnected explicits should become implicits.
   * By default moves all disconnected explicits to implicits, if there were operation to exclude elements.
   *
   * Override this method to change the behavior.
   */
  filterForMoveToImplicits(disconnectedExplicits) {
    if (this.markedToMoveExplicitToImplicit || this.excluded.elements.size > 0) {
      return disconnectedExplicits;
    }
    return /* @__PURE__ */ new Set();
  }
  // Check if Leaf EXPLICIT elements are becoming IMPLICIT
  // (it means that they are not connected anymore)
  moveDisconnectedExplicitsToImplicits(state) {
    let disconnected = difference(
      new Set(this.memory.connections.flatMap((c2) => [c2.source, c2.target])),
      new Set(state.connections.flatMap((c2) => [c2.source, c2.target]))
    );
    disconnected = intersection(
      disconnected,
      state.elements
    );
    disconnected = C(
      disconnected,
      ifilter((el) => {
        return state.explicits.has(el) && !isome(state.final, isDescendantOf(el));
      }),
      toSet()
    );
    if (disconnected.size > 0) {
      disconnected = this.filterForMoveToImplicits(disconnected);
      state.explicits = difference(state.explicits, disconnected);
      state.final = difference(state.final, disconnected);
    }
    return state;
  }
  removeElements(state) {
    state.elements = difference(state.elements, this.excluded.elements);
    state.explicits = difference(state.explicits, this.excluded.elements);
    state.final = difference(state.final, this.excluded.elements);
    return state;
  }
  removeConnections(state) {
    const excludedMap = this.excluded.connections.reduce((acc, c2) => {
      const existing = acc.get(c2.id);
      if (existing) {
        acc.set(c2.id, existing.mergeWith(c2));
      } else {
        acc.set(c2.id, c2);
      }
      return acc;
    }, /* @__PURE__ */ new Map());
    let disconnected = /* @__PURE__ */ new Set();
    state.connections = state.connections.reduce((acc, c2) => {
      const excluded = excludedMap.get(c2.id);
      if (excluded) {
        disconnected.add(c2.source);
        disconnected.add(c2.target);
        const diff = c2.difference(excluded);
        if (diff.nonEmpty()) {
          acc.push(diff);
        }
      } else {
        acc.push(c2);
      }
      return acc;
    }, []);
    for (const stillExists of state.connections) {
      disconnected.delete(stillExists.source);
      disconnected.delete(stillExists.target);
      if (stillExists.boundary && state.elements.has(stillExists.boundary)) {
        disconnected.delete(stillExists.boundary);
      }
    }
    if (disconnected.size === 0) {
      return state;
    }
    disconnected = difference(disconnected, state.explicits);
    state.final = difference(state.final, disconnected);
    return state;
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    return state;
  }
  /**
   * Postcommit hook
   */
  postcommit(state) {
    invariant(difference(state.explicits, state.elements).size === 0, "Explicits must be subset of elements");
    invariant(difference(state.final, state.elements).size === 0, "Final elements must be subset of elements");
    return state;
  }
  commit() {
    let state = this.precommit(this.memory.mutableState());
    if (this.excluded.elements.size > 0) {
      const excludedConnections = state.connections.filter((c2) => this.excluded.elements.has(c2.source) || this.excluded.elements.has(c2.target)).flatMap((c2) => [
        c2,
        ...findAscendingConnections(state.connections, c2).map((asc) => asc.intersect(c2))
      ]).filter((asc) => asc.nonEmpty());
      this.excludeConnections(excludedConnections);
    }
    if (this.excluded.connections.length > 0) {
      state = this.removeConnections(state);
    }
    if (this.excluded.elements.size > 0) {
      state = this.removeElements(state);
    }
    return this.memory.update(this.postcommit(state));
  }
};
var AbstractStageInclude = class {
  constructor(memory, expression) {
    // New elements
    __publicField(this, "explicits", /* @__PURE__ */ new Set());
    __publicField(this, "implicits", /* @__PURE__ */ new Set());
    // Ordered Set of explicit and implicit elements
    __publicField(this, "_ordered", /* @__PURE__ */ new Set());
    __publicField(this, "_connections", []);
    this.memory = memory;
    this.expression = expression;
  }
  get elements() {
    return this.explicits;
  }
  /**
   * Connections from this stage
   */
  get connections() {
    return this._connections;
  }
  mergedConnections() {
    return mergeConnections([
      ...this.memory.connections,
      ...this._connections
    ]);
  }
  connectWithExisting(_element, _direction) {
    throw new Error("Method not implements, depends on the model");
  }
  /**
   * Possible to override
   */
  _addExplicit(elements) {
    this._ordered.add(elements);
    this.explicits.add(elements);
    this.implicits.delete(elements);
  }
  addExplicit(element) {
    if (!element) {
      return this;
    }
    if (isIterable(element)) {
      for (const el of element) {
        this._addExplicit(el);
      }
      return this;
    }
    this._addExplicit(element);
    return this;
  }
  /**
   * Possible to override
   */
  _addImplicit(elements) {
    if (this.explicits.has(elements)) {
      return;
    }
    this._ordered.add(elements);
    this.implicits.add(elements);
  }
  addImplicit(elements) {
    if (!elements) {
      return this;
    }
    if (isIterable(elements)) {
      for (const el of elements) {
        this._addImplicit(el);
      }
      return this;
    }
    this._addImplicit(elements);
    return this;
  }
  /**
   * Possible to override
   */
  _addConnection(connection) {
    this._connections.push(connection);
    this._addImplicit(connection.source);
    this._addImplicit(connection.target);
  }
  addConnections(connection) {
    if (isIterable(connection)) {
      for (const c2 of connection) {
        this._addConnection(c2);
      }
      return this;
    }
    this._addConnection(connection);
    return this;
  }
  isDirty() {
    return this.explicits.size > 0 || this.implicits.size > 0 || this._connections.length > 0;
  }
  isEmpty() {
    return !this.isDirty();
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    return state;
  }
  /**
   * Postcommit hook
   */
  postcommit(state) {
    return state;
  }
  processConnections(connections) {
    return connections;
  }
  commit() {
    let state = this.precommit(this.memory.mutableState());
    let fromConnections = /* @__PURE__ */ new Set();
    if (this._connections.length > 0) {
      const [fromKnown, rest] = d$3(
        this._connections,
        (c2) => state.final.has(c2.source)
      );
      state.connections = this.processConnections(
        mergeConnections([
          ...state.connections,
          ...fromKnown,
          ...rest
        ])
      );
      fromConnections = new Set(state.connections.flatMap((c2) => [c2.source, c2.target]));
    }
    state.elements = union(
      state.elements,
      this._ordered,
      this.explicits,
      fromConnections,
      this.implicits
    );
    state.explicits = intersection(
      state.elements,
      union(
        state.explicits,
        this.explicits
      )
    );
    state.final = intersection(
      state.elements,
      union(
        state.final,
        this.explicits,
        fromConnections
      )
    );
    return this.memory.update(this.postcommit(state));
  }
};
function treeFromMemoryState(memory, filter = "final") {
  const sorted = sortParentsFirst(toArray(filter === "final" ? memory.final : memory.elements));
  const connected = new Set(memory.connections.flatMap((c2) => [c2.source, c2.target]));
  const root = new Set(sorted);
  const parents = new DefaultMap(() => null);
  const children = sorted.reduce((acc, parent, index, all) => {
    acc.set(
      parent,
      all.slice(index + 1).filter((e3) => isAncestor(parent, e3)).map((e3) => {
        root.delete(e3);
        return e3;
      }).reduce((acc2, el) => {
        if (!acc2.some((e3) => isAncestor(e3, el))) {
          acc2.push(el);
          parents.set(el, parent);
        }
        return acc2;
      }, [])
    );
    return acc;
  }, new DefaultMap(() => []));
  return {
    root,
    connected,
    hasInOut: (el) => memory.connections.some(Connection.isAnyInOut(el.id)),
    parent: (el) => parents.get(el),
    children: (el) => children.get(el)
  };
}
var StageExclude$1 = class StageExclude extends AbstractStageExclude {
};
T((c2) => c2.nonEmpty());
function findCrossBoundarySameSourceOrTarget(connections) {
  const groupedByRelation = new DefaultMap(() => []);
  for (const conn of connections) {
    for (const relation of conn.relations.model) {
      groupedByRelation.get(relation).push(conn);
    }
  }
  const excludedRelations = new DefaultMap(() => /* @__PURE__ */ new Set());
  for (const [relation, sameRelationGroup] of groupedByRelation) {
    if (!i$1(sameRelationGroup, 2)) {
      continue;
    }
    C(
      sameRelationGroup,
      u$1((conn) => [
        { group: `$source-${conn.source.id}`, conn },
        { group: `$target-${conn.target.id}`, conn }
      ]),
      i$2(p$1("group")),
      r$3(),
      T(i$1(2)),
      u3(
        // In each group, sort by hierarchy, first are deepest
        i$4(
          m(p$1("conn")),
          sortConnectionsByBoundaryHierarchy("desc"),
          // Drop first, as it is the deepest
          // Drop if boundary is same as previous
          m2((conn, i2, all) => i2 === 0 || conn.boundary === all[i2 - 1].boundary),
          // Drop relations from boundaries above
          u3((conn) => {
            excludedRelations.get(conn).add(relation);
          })
        )
      )
    );
  }
  return excludedRelations;
}
function findCrossBoundaryConnections(connections) {
  connections = mergeConnections(connections);
  const excludedRelations = findCrossBoundarySameSourceOrTarget(connections);
  for (const c2 of connections) {
    const { source, target } = c2;
    const connectionModelRelations = c2.relations.model;
    if (source.isDeploymentNode() !== target.isDeploymentNode()) {
      const node = source.isDeploymentNode() ? source : c2.target;
      invariant(node.isDeploymentNode());
      const nodeInternals = node.internalModelRelationships();
      const toExclude = intersection(
        connectionModelRelations,
        nodeInternals
      );
      for (const relation of toExclude) {
        excludedRelations.get(c2).add(relation);
      }
      continue;
    }
    if (source.isDeploymentNode() && target.isDeploymentNode()) {
      const toExclude = union(
        // Exclude node internals (otherwise thay are cross-boundary)
        intersection(
          c2.relations.model,
          source.internalModelRelationships()
        ),
        intersection(
          c2.relations.model,
          target.internalModelRelationships()
        )
      );
      for (const relation of toExclude) {
        excludedRelations.get(c2).add(relation);
      }
    }
  }
  return C(
    excludedRelations.entries(),
    imap(
      ([c2, excluded]) => c2.update({
        model: excluded,
        deployment: null
      })
    ),
    toArray()
  );
}
function cleanCrossBoundary(connections) {
  return differenceConnections(
    connections,
    findCrossBoundaryConnections(connections)
  );
}
function findRedundantConnections$1(connections) {
  return C(
    connections,
    mergeConnections,
    l$5((redundants, connection) => {
      const { source, target, relations } = connection;
      if (source.isInstance() && target.isInstance()) {
        return redundants;
      }
      let redundantAccum = RelationshipsAccum.empty();
      if (source.isDeploymentNode() && target.isDeploymentNode()) {
        const [reversed] = findConnection(target, source, "directed");
        if (reversed) {
          redundantAccum = relations.intersect(reversed.relations);
        }
      }
      for (const c2 of connections) {
        if (isNestedConnection(c2, connection)) {
          redundantAccum = redundantAccum.union(
            relations.intersect(c2.relations)
          );
        }
      }
      if (redundantAccum.nonEmpty) {
        redundants.push(
          new DeploymentConnectionModel(
            source,
            target,
            redundantAccum
          )
        );
      }
      return redundants;
    }, [])
  );
}
function cleanRedundantRelationships(connections) {
  return differenceConnections(
    connections,
    findRedundantConnections$1(connections)
  );
}
var StageInclude$1 = class StageInclude extends AbstractStageInclude {
  /**
   * Connects elements with existing ones in the memory
   */
  connectWithExisting(elements, direction = "both") {
    const before = this._connections.length;
    const hasChanged = () => this._connections.length > before;
    if (!isIterable(elements)) {
      if (direction === "in" || direction === "both") {
        for (const el of this.memory.elements) {
          this.addConnections(
            findConnection(el, elements, "directed")
          );
        }
      }
      if (direction === "out" || direction === "both") {
        this.addConnections(
          findConnectionsBetween(elements, this.memory.elements, "directed")
        );
      }
      return hasChanged();
    }
    const targets = [...elements];
    if (direction === "in" || direction === "both") {
      for (const el of this.memory.elements) {
        this.addConnections(
          findConnectionsBetween(el, targets, "directed")
        );
      }
    }
    if (direction === "out" || direction === "both") {
      for (const el of targets) {
        this.addConnections(
          findConnectionsBetween(el, this.memory.elements, "directed")
        );
      }
    }
    return hasChanged();
  }
  processConnections(connections) {
    const clean = C(
      connections,
      cleanCrossBoundary,
      cleanRedundantRelationships
    );
    C(
      clean,
      // Process only connection from this stage
      // filter(c => this._connections.some(c2 => c2.id === c.id)),
      u3(({ source, target, boundary }) => {
        C(
          d(
            [...toArray(source.ancestors()).reverse(), source],
            [...toArray(target.ancestors()).reverse(), target]
          ),
          // Filter out common ancestors
          m2(([sourceAncestor, targetAncestor]) => sourceAncestor === targetAncestor),
          l$6(1),
          u3(([sourceAncestor, targetAncestor]) => {
            if (source === sourceAncestor && target === targetAncestor) {
              this.addImplicit(boundary);
              return;
            }
            if (sourceAncestor !== source && sourceAncestor.isDeploymentNode() && !sourceAncestor.onlyOneInstance()) {
              this.addImplicit(sourceAncestor);
            }
            if (targetAncestor !== target && targetAncestor.isDeploymentNode() && !targetAncestor.onlyOneInstance()) {
              this.addImplicit(targetAncestor);
            }
          })
        );
      })
    );
    return clean;
  }
};
var Memory$1 = class Memory extends AbstractMemory {
  static empty() {
    return new Memory({
      elements: /* @__PURE__ */ new Set(),
      explicits: /* @__PURE__ */ new Set(),
      final: /* @__PURE__ */ new Set(),
      connections: []
    });
  }
  stageInclude(expr) {
    return new StageInclude$1(this, expr);
  }
  stageExclude(expr) {
    return new StageExclude$1(this, expr);
  }
  mutableState() {
    return {
      elements: new Set(this.state.elements),
      explicits: new Set(this.state.explicits),
      final: new Set(this.state.final),
      connections: [...this.state.connections]
    };
  }
  update(newstate) {
    return new Memory({
      ...this.state,
      ...newstate
    });
  }
  equals(other) {
    return other instanceof Memory && k(this.state, other.state);
  }
  diff(state) {
    const current = this;
    return {
      added: {
        elements: toArray(difference(state.elements, current.elements)),
        explicits: toArray(difference(state.explicits, current.explicits)),
        final: toArray(difference(state.final, current.final)),
        connections: toArray(differenceConnections(state.connections, current.connections))
      },
      removed: {
        elements: toArray(difference(current.elements, state.elements)),
        explicits: toArray(difference(current.explicits, state.explicits)),
        final: toArray(difference(current.final, state.final)),
        connections: differenceConnections(current.connections, state.connections)
      }
    };
  }
  toString() {
    return [
      "final:",
      ...[...this.final].map((e3) => "  " + e3.id),
      "connections:",
      ...this.connections.map((c2) => "  " + c2.expression)
    ].join("\n");
  }
  [customInspectSymbol](_depth, _inspectOptions, _inspect) {
    const asString = this.toString();
    return asString;
  }
};
function elementExprToPredicate(target) {
  if (ModelLayer.FqnExpr.isCustom(target)) {
    return elementExprToPredicate(target.custom.expr);
  }
  if (ModelLayer.FqnExpr.isWhere(target)) {
    const predicate = elementExprToPredicate(target.where.expr);
    const where = whereOperatorAsPredicate(target.where.condition);
    return (n4) => predicate(n4) && where(n4);
  }
  if (ModelLayer.FqnExpr.isElementKindExpr(target)) {
    return target.isEqual ? (n4) => n4.kind === target.elementKind : (n4) => n4.kind !== target.elementKind;
  }
  if (ModelLayer.FqnExpr.isElementTagExpr(target)) {
    return target.isEqual ? ({ tags }) => !!tags && tags.includes(target.elementTag) : ({ tags }) => n2(tags) || !tags.includes(target.elementTag);
  }
  if (ModelLayer.FqnExpr.isWildcard(target)) {
    return () => true;
  }
  if (ModelLayer.FqnExpr.isModelRef(target)) {
    const fqn = ModelLayer.FqnRef.toFqn(target.ref);
    if (target.selector === "expanded") {
      return (n4) => {
        return n4.id === fqn || parentFqn(n4.id) === fqn;
      };
    }
    if (target.selector === "descendants" || target.selector === "children") {
      const fqnWithDot = fqn + ".";
      return (n4) => {
        return n4.id.startsWith(fqnWithDot);
      };
    }
    return (n4) => {
      return n4.id === fqn;
    };
  }
  nonexhaustive(target);
}
function applyViewRuleStyle(rule, predicates, nodes) {
  C(
    nodes,
    T(o$1(ComputedNode.isNodesGroup)),
    T(y(predicates)),
    u3((n4) => {
      n4.shape = rule.style.shape ?? n4.shape;
      n4.color = rule.style.color ?? n4.color;
      if (n(rule.style.icon)) {
        n4.icon = rule.style.icon;
      }
      if (n(rule.notation)) {
        n4.notation = rule.notation;
      }
      let styleOverride;
      if (n(rule.style.border)) {
        styleOverride = { border: rule.style.border };
      }
      if (n(rule.style.opacity)) {
        styleOverride = { ...styleOverride, opacity: rule.style.opacity };
      }
      if (n(rule.style.multiple)) {
        styleOverride = { ...styleOverride, multiple: rule.style.multiple };
      }
      if (n(rule.style.padding)) {
        styleOverride = { ...styleOverride, padding: rule.style.padding };
      }
      if (n(rule.style.size)) {
        styleOverride = { ...styleOverride, size: rule.style.size };
      }
      if (n(rule.style.textSize)) {
        styleOverride = { ...styleOverride, textSize: rule.style.textSize };
      }
      if (styleOverride) {
        n4.style = {
          ...n4.style,
          ...styleOverride
        };
      }
    })
  );
}
function applyViewRuleStyles(rules, nodes) {
  for (const rule of rules) {
    if (!isViewRuleStyle(rule) || rule.targets.length === 0) {
      continue;
    }
    const predicates = rule.targets.map(elementExprToPredicate);
    applyViewRuleStyle(rule, predicates, nodes);
  }
  return nodes;
}
function updateDepthOfAncestors(node, nodes) {
  let parentNd;
  while (!!node.parent && (parentNd = nodes.get(node.parent))) {
    const depth = parentNd.depth ?? 1;
    parentNd.depth = Math.max(depth, (node.depth ?? 0) + 1);
    if (parentNd.depth === depth) {
      break;
    }
    node = parentNd;
  }
}
var modelElementAsNodeSource = (element) => {
  return {
    ...element,
    modelRef: 1
  };
};
function buildComputedNodesFromElements(elements, groups) {
  return buildComputedNodes(elements.map(modelElementAsNodeSource), groups);
}
function buildComputedNodes(elements, groups) {
  const nodesMap = /* @__PURE__ */ new Map();
  const elementToGroup = /* @__PURE__ */ new Map();
  groups == null ? void 0 : groups.forEach(({ id, parent, viewRule, elements: elements2 }) => {
    if (parent) {
      nonNullable(nodesMap.get(parent), `Parent group node ${parent} not found`).children.push(id);
    }
    nodesMap.set(id, {
      id,
      parent,
      kind: ElementKind.Group,
      title: viewRule.title ?? "",
      color: viewRule.color ?? "muted",
      shape: "rectangle",
      children: [],
      inEdges: [],
      outEdges: [],
      level: 0,
      depth: 0,
      description: null,
      technology: null,
      tags: null,
      links: null,
      style: {
        border: viewRule.border ?? "dashed",
        opacity: viewRule.opacity ?? 0,
        size: viewRule.size ?? "md",
        multiple: viewRule.multiple ?? false,
        padding: viewRule.padding ?? "md",
        textSize: viewRule.textSize ?? "md"
      }
    });
    for (const e3 of elements2) {
      elementToGroup.set(e3.id, id);
    }
  });
  Array.from(elements).sort(compareByFqnHierarchically).forEach(({ id, style, kind, title, color, shape, ...el }) => {
    let parent = parentFqn(id);
    let level = 0;
    let parentNd;
    while (parent) {
      parentNd = nodesMap.get(parent);
      if (parentNd) {
        break;
      }
      parent = parentFqn(parent);
    }
    if (!parentNd && elementToGroup.has(id)) {
      parent = elementToGroup.get(id);
      parentNd = nodesMap.get(parent);
    }
    if (parentNd) {
      if (parentNd.children.length == 0) {
        parentNd.depth = 1;
        updateDepthOfAncestors(parentNd, nodesMap);
      }
      parentNd.children.push(id);
      level = parentNd.level + 1;
    }
    const node = {
      id,
      parent,
      kind,
      title,
      level,
      color: color ?? DefaultThemeColor,
      shape: shape ?? DefaultElementShape,
      description: null,
      technology: null,
      tags: null,
      links: null,
      children: [],
      inEdges: [],
      outEdges: [],
      ...el,
      style: {
        ...style
      }
    };
    nodesMap.set(id, node);
  });
  const orderedMap = /* @__PURE__ */ new Map();
  groups == null ? void 0 : groups.forEach(({ id }) => {
    orderedMap.set(id, nonNullable(nodesMap.get(id)));
  });
  elements.forEach(({ id }) => {
    orderedMap.set(id, nonNullable(nodesMap.get(id)));
  });
  return orderedMap;
}
function pickRelationshipProps(relation) {
  const {
    title,
    description = null,
    technology = null,
    kind = null,
    color = null,
    line = null,
    head = null,
    tail = null,
    navigateTo = null
  } = relation;
  return {
    // Pick description only if title is present
    ...title && {
      title,
      description
    },
    technology,
    kind,
    color,
    line,
    head,
    tail,
    navigateTo
  };
}
function mergePropsFromRelationships(relations, prefer) {
  const allprops = C(
    relations,
    l$5(
      (acc, r3) => {
        if (n$1(r3.title) && !acc.title.includes(r3.title)) {
          acc.title.push(r3.title);
        }
        if (n$1(r3.description) && !acc.description.includes(r3.description)) {
          acc.description.push(r3.description);
        }
        if (n$1(r3.technology) && !acc.technology.includes(r3.technology)) {
          acc.technology.push(r3.technology);
        }
        if (n$1(r3.kind) && !acc.kind.includes(r3.kind)) {
          acc.kind.push(r3.kind);
        }
        if (n$1(r3.color) && !acc.color.includes(r3.color)) {
          acc.color.push(r3.color);
        }
        if (n$1(r3.line) && !acc.line.includes(r3.line)) {
          acc.line.push(r3.line);
        }
        if (n$1(r3.head) && !acc.head.includes(r3.head)) {
          acc.head.push(r3.head);
        }
        if (n$1(r3.tail) && !acc.tail.includes(r3.tail)) {
          acc.tail.push(r3.tail);
        }
        if (n$1(r3.navigateTo) && !acc.navigateTo.includes(r3.navigateTo)) {
          acc.navigateTo.push(r3.navigateTo);
        }
        if (r3.tags) {
          acc.tags.push(...r3.tags);
        }
        if (r3.links) {
          acc.links.push(...r3.links);
        }
        return acc;
      },
      {
        title: [],
        description: [],
        technology: [],
        kind: [],
        head: [],
        tail: [],
        color: [],
        tags: [],
        links: [],
        line: [],
        navigateTo: []
      }
    )
  );
  let technology = t$2(allprops.technology);
  let title = t$2(allprops.title) ?? (allprops.title.length > 1 ? "[...]" : null);
  const tags = i$8(allprops.tags);
  let merged = d$2(
    {
      // If there is no title, but there is technology, use technology as title
      title: title ?? (technology ? `[${technology}]` : null),
      description: t$2(allprops.description),
      technology,
      kind: t$2(allprops.kind),
      head: t$2(allprops.head),
      tail: t$2(allprops.tail),
      color: t$2(allprops.color),
      line: t$2(allprops.line),
      navigateTo: t$2(allprops.navigateTo),
      ...isNonEmptyArray(allprops.links) && { links: allprops.links },
      ...isNonEmptyArray(tags) && { tags }
    },
    n$1
  );
  if (prefer) {
    return {
      ...merged,
      ...d$2(pickRelationshipProps(prefer), n$1)
    };
  }
  return merged;
}
function uniqueTags(elements) {
  const tags = C(
    elements,
    u$1((e3) => e3.tags ?? []),
    i$8(),
    m$1(compareNatural)
  );
  return i$1(tags, 1) ? tags : null;
}
function resolveElements$1(model, expr) {
  const ref = model.element(expr.ref.deployment);
  if (ref.isDeploymentNode()) {
    if (expr.selector === "children") {
      return [...ref.children()];
    }
    if (expr.selector === "expanded") {
      return [ref, ...ref.children()];
    }
    if (expr.selector === "descendants") {
      return [...ref.descendants()];
    }
  }
  return [ref];
}
function resolveModelElements(model, expr) {
  const ref = model.$model.element(expr.ref.model);
  if (expr.selector === "children") {
    return [...ref.children()];
  }
  if (expr.selector === "expanded") {
    return [ref, ...ref.children()];
  }
  if (expr.selector === "descendants") {
    return [...ref.descendants()];
  }
  return [ref];
}
function deploymentExpressionToPredicate(target) {
  if (FqnExpr.isWildcard(target)) {
    return () => true;
  }
  if (FqnExpr.isElementTagExpr(target) || FqnExpr.isElementKindExpr(target)) {
    throw new Error("element kind and tag expressions are not supported in deployment view rules");
  }
  if (FqnExpr.isDeploymentRef(target)) {
    const fqn = target.ref.deployment;
    if (target.selector === "expanded") {
      const fqnWithDot = fqn + ".";
      return (n4) => n4.id === fqn || n4.id.startsWith(fqnWithDot);
    }
    if (target.selector === "descendants") {
      const fqnWithDot = fqn + ".";
      return (n4) => n4.id.startsWith(fqnWithDot);
    }
    if (target.selector === "children") {
      return (n4) => parentFqn(n4.id) === fqn;
    }
    return (n4) => n4.id === fqn;
  }
  if (FqnExpr.isModelRef(target)) {
    const modelFqn = (node) => {
      if (t$1(node.modelRef)) {
        return node.modelRef;
      }
      if (e$1(node.modelRef)) {
        return node.id;
      }
      return null;
    };
    const fqn = target.ref.model;
    if (target.selector === "expanded") {
      const fqnWithDot = fqn + ".";
      return (n4) => {
        const m3 = modelFqn(n4);
        if (!m3) {
          return true;
        }
        return m3 === fqn || m3.startsWith(fqnWithDot);
      };
    }
    if (target.selector === "descendants") {
      const fqnWithDot = fqn + ".";
      return (n4) => {
        const m3 = modelFqn(n4);
        if (!m3) {
          return true;
        }
        return m3.startsWith(fqnWithDot);
      };
    }
    if (target.selector === "children") {
      return (n4) => {
        const m3 = modelFqn(n4);
        if (!m3) {
          return true;
        }
        return parentFqn(m3) === fqn;
      };
    }
    return (n4) => {
      const m3 = modelFqn(n4);
      if (!m3) {
        return true;
      }
      return m3 === fqn;
    };
  }
  nonexhaustive(target);
}
function toNodeSource$1(el) {
  var _a, _b, _c;
  if (el.isDeploymentNode()) {
    const onlyOneInstance = el.onlyOneInstance();
    let { title, kind, id, ...$node } = el.$node;
    const { icon: icon2, color: color2, shape: shape2, ...style } = el.$node.style ?? {};
    if (onlyOneInstance && title === nameFromFqn(el.id)) {
      title = onlyOneInstance.title;
    }
    return {
      ...onlyOneInstance && {
        ...toNodeSource$1(onlyOneInstance),
        modelRef: onlyOneInstance.element.id
      },
      title,
      ...$node,
      ...icon2 && { icon: icon2 },
      ...color2 && { color: color2 },
      ...shape2 && { shape: shape2 },
      style: {
        ...style
      },
      deploymentRef: 1,
      kind,
      id
    };
  }
  invariant(el.isInstance(), "Expected Instance");
  const instance = el.$instance;
  const element = el.element.$element;
  const icon = ((_a = instance.style) == null ? void 0 : _a.icon) ?? element.icon;
  const color = ((_b = instance.style) == null ? void 0 : _b.color) ?? element.color;
  const shape = ((_c = instance.style) == null ? void 0 : _c.shape) ?? element.shape;
  const links = [
    ...element.links ?? [],
    ...instance.links ?? []
  ];
  const metadata = {
    ...element.metadata,
    ...instance.metadata
  };
  const notation = instance.notation ?? element.notation;
  return {
    id: el.id,
    kind: "instance",
    title: instance.title ?? element.title,
    description: instance.description ?? element.description,
    technology: instance.technology ?? element.technology,
    tags: uniqueTags([element, instance]),
    links: i$1(links, 1) ? links : null,
    ...icon && { icon },
    ...color && { color },
    ...shape && { shape },
    style: {
      ...element.style,
      ...instance.style
    },
    deploymentRef: el.id === instance.id ? 1 : instance.id,
    modelRef: el.id === element.id ? 1 : element.id,
    ...notation && { notation },
    ...!n3(metadata) && { metadata }
  };
}
function toComputedEdges$1(connections) {
  return connections.reduce((acc, e3) => {
    var _a;
    const relations = [
      ...e3.relations.model,
      ...e3.relations.deployment
    ];
    invariant(i$1(relations, 1), "Edge must have at least one relation");
    const source = e3.source.id;
    const target = e3.target.id;
    const {
      title,
      ...props
    } = mergePropsFromRelationships(relations.map((r3) => r3.$relationship));
    const edge = {
      id: e3.id,
      parent: ((_a = e3.boundary) == null ? void 0 : _a.id) ?? null,
      source,
      target,
      label: title ?? null,
      relations: relations.map((r3) => r3.id),
      ...props
    };
    const existing = acc.find((e22) => e22.source === target && e22.target === source);
    if (existing && edge.label === existing.label) {
      existing.dir = "both";
      const head = existing.head ?? edge.head ?? DefaultArrowType;
      existing.head ?? (existing.head = head);
      existing.tail ?? (existing.tail = head);
      if (edge.color) {
        existing.color ?? (existing.color = edge.color);
      }
      if (edge.line) {
        existing.line ?? (existing.line = edge.line);
      }
      return acc;
    }
    acc.push(edge);
    return acc;
  }, []);
}
function buildNodes$1(memory) {
  return buildComputedNodes([...memory.final].map(toNodeSource$1));
}
function applyDeploymentViewRuleStyles(rules, nodes) {
  for (const rule of rules) {
    if (!isViewRuleStyle(rule) || rule.targets.length === 0) {
      continue;
    }
    const predicates = rule.targets.map(deploymentExpressionToPredicate);
    applyViewRuleStyle(rule, predicates, nodes);
  }
  return nodes;
}
function isDeploymentNode(model) {
  return model.isDeploymentNode();
}
function isDeployedInstance(model) {
  return model.isInstance();
}
function isNestedElementOfDeployedInstanceModel(model) {
  return !model.isInstance() && !model.isDeploymentNode();
}
function isDeploymentElementModel(x) {
  return x instanceof DeploymentNodeModel || x instanceof DeployedInstanceModel;
}
var WhereDeploymentRefPredicate = {
  include: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("include", { expr: expr.where.expr, model, stage, memory, where });
  },
  exclude: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("exclude", { expr: expr.where.expr, model, stage, memory, where });
  }
};
var IncomingRelationPredicate = {
  include: ({ expr, model, memory, stage, where }) => {
    const sources = [...memory.elements];
    if (FqnExpr.isWildcard(expr.incoming)) {
      for (const source of sources) {
        if (source.allOutgoing.isEmpty) {
          continue;
        }
        const targets2 = [...resolveAscendingSiblings(source)];
        const toInclude = applyPredicate(findConnectionsBetween(source, targets2, "directed"), where);
        stage.addConnections(toInclude);
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.incoming), "Only deployment refs are supported in include");
    const targets = resolveElements$1(model, expr.incoming);
    for (const source of sources) {
      const toInclude = applyPredicate(findConnectionsBetween(source, targets, "directed"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.incoming) || FqnExpr.isElementKindExpr(expr.incoming)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.incoming)) {
      const excludedRelations = resolveAllImcomingRelations(model, expr.incoming);
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.incoming)) {
      return stage;
    }
    const isIncoming2 = filterIncomingConnections(resolveElements$1(model, expr.incoming));
    const toExclude = C(
      memory.connections,
      T(isIncoming2),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};
function filterIncomingConnections(targets) {
  return y(
    targets.map((target) => {
      const satisfies = (el) => el === target || isAncestor(target, el);
      return (connection) => {
        return !satisfies(connection.source) && satisfies(connection.target);
      };
    })
  );
}
function resolveAllImcomingRelations(model, moodelRef) {
  const targets = resolveModelElements(model, moodelRef);
  return new Set(targets.flatMap((e3) => [...e3.allIncoming]));
}
var OutgoingRelationPredicate = {
  include: ({ expr, model, memory, stage, where }) => {
    const targets = [...memory.elements];
    if (FqnExpr.isWildcard(expr.outgoing)) {
      for (const target of targets) {
        if (target.allIncoming.isEmpty) {
          continue;
        }
        for (const source of resolveAscendingSiblings(target)) {
          const toInclude = applyPredicate(findConnection(source, target, "directed"), where);
          stage.addConnections(toInclude);
        }
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.outgoing), "Only deployment refs are supported in include");
    const sources = resolveElements$1(model, expr.outgoing);
    for (const source of sources) {
      const toInclude = applyPredicate(findConnectionsBetween(source, targets, "directed"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.outgoing) || FqnExpr.isElementKindExpr(expr.outgoing)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.outgoing)) {
      const excludedRelations = resolveAllOutgoingRelations(model, expr.outgoing);
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.outgoing)) {
      return stage;
    }
    const isOutgoing2 = filterOutgoingConnections(resolveElements$1(model, expr.outgoing));
    const toExclude = C(
      memory.connections,
      T(isOutgoing2),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};
function filterOutgoingConnections(sources) {
  return y(
    sources.map((source) => {
      const satisfies = (el) => el === source || isAncestor(source, el);
      return (connection) => {
        return satisfies(connection.source) && !satisfies(connection.target);
      };
    })
  );
}
function resolveAllOutgoingRelations(model, moodelRef) {
  const targets = resolveModelElements(model, moodelRef);
  return new Set(targets.flatMap((e3) => [...e3.allOutgoing]));
}
var resolveAscendingSiblings = (element) => {
  const siblings = /* @__PURE__ */ new Set();
  for (let sibling of element.descendingSiblings()) {
    siblings.add(sibling);
  }
  return siblings;
};
var DirectRelationPredicate = {
  include: ({ expr: { source, target, isBidirectional = false }, model, stage, where }) => {
    if (FqnExpr.isElementTagExpr(source) || FqnExpr.isElementKindExpr(source)) {
      throw new Error("element kind and tag expressions are not supported in include");
    }
    if (FqnExpr.isElementTagExpr(target) || FqnExpr.isElementKindExpr(target)) {
      throw new Error("element kind and tag expressions are not supported in include");
    }
    invariant(!FqnExpr.isModelRef(source), "Invalid source model ref in direct relation");
    invariant(!FqnExpr.isModelRef(target), "Invalid target model ref in direct relation");
    const sourceIsWildcard = FqnExpr.isWildcard(source);
    const targetIsWildcard = FqnExpr.isWildcard(target);
    const dir = isBidirectional ? "both" : "directed";
    let connections;
    switch (true) {
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        connections = C(
          findConnectionsWithin(model.instances()),
          applyPredicate(where),
          m((c2) => {
            stage.addImplicit(c2.boundary);
            return c2;
          })
        );
        break;
      }
      // source -> *; source <-> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const sources = resolveElements$1(model, source);
        const isSource = filterOutgoingConnections(sources);
        let postFilter = isSource;
        if (isBidirectional) {
          const isTarget = filterIncomingConnections(sources);
          postFilter = (c2) => isSource(c2) !== isTarget(c2);
        }
        connections = C(
          sources,
          u$1((source2) => {
            const targets = resolveAscendingSiblings(source2);
            return findConnectionsBetween(source2, targets, dir);
          }),
          T(postFilter),
          applyPredicate(where)
        );
        break;
      }
      // * -> target; * <-> target
      case (sourceIsWildcard && !targetIsWildcard): {
        const targets = resolveElements$1(model, target);
        const isTarget = filterIncomingConnections(targets);
        let postFilter = isTarget;
        if (isBidirectional) {
          const isSource = filterOutgoingConnections(targets);
          postFilter = (c2) => isSource(c2) !== isTarget(c2);
        }
        connections = C(
          targets,
          u$1((target2) => {
            const sources = resolveAscendingSiblings(target2);
            return [...sources].flatMap((source2) => findConnection(source2, target2, dir));
          }),
          T(postFilter),
          applyPredicate(where)
        );
        break;
      }
      default: {
        invariant(!sourceIsWildcard, "Inferrence failed - source should be a deployment ref");
        invariant(!targetIsWildcard, "Inferrence failed - target should be a deployment ref");
        const sources = resolveElements$1(model, source);
        const targets = resolveElements$1(model, target);
        const isSource = filterOutgoingConnections(sources);
        const isTarget = filterIncomingConnections(targets);
        connections = C(
          sources,
          u$1((s3) => findConnectionsBetween(s3, targets, dir)),
          T((c2) => isSource(c2) && isTarget(c2)),
          applyPredicate(where)
        );
      }
    }
    stage.addConnections(connections);
    if (FqnExpr.isDeploymentRef(source) && l(source.selector)) {
      stage.addImplicit(model.element(source.ref.deployment));
    }
    if (FqnExpr.isDeploymentRef(target) && l(target.selector)) {
      stage.addImplicit(model.element(target.ref.deployment));
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    const isTarget = deploymentExpressionToPredicate(expr.target);
    const isSource = deploymentExpressionToPredicate(expr.source);
    let modelRelationsToExclude;
    switch (true) {
      // * -> *
      case (FqnExpr.isWildcard(expr.source) && FqnExpr.isWildcard(expr.target)):
        stage.excludeConnections(applyPredicate(memory.connections, where));
        return stage;
      // model -> model
      case (FqnExpr.isModelRef(expr.source) && FqnExpr.isModelRef(expr.target)):
        modelRelationsToExclude = resolveRelationsBetweenModelElements({
          source: expr.source,
          target: expr.target,
          expr,
          model
        });
        return excludeModelRelations(modelRelationsToExclude, { stage, memory }, where);
      // model -> *
      case (FqnExpr.isModelRef(expr.source) && FqnExpr.isWildcard(expr.target)):
        modelRelationsToExclude = resolveAllOutgoingRelations(model, expr.source);
        return excludeModelRelations(modelRelationsToExclude, { stage, memory }, where);
      // model -> deployment
      case FqnExpr.isModelRef(expr.source):
        modelRelationsToExclude = resolveAllOutgoingRelations(model, expr.source);
        return excludeModelRelations(
          modelRelationsToExclude,
          { stage, memory },
          where,
          (c2) => isTarget(c2.target)
        );
      // deployment -> model
      case FqnExpr.isModelRef(expr.target):
        modelRelationsToExclude = resolveAllImcomingRelations(model, expr.target);
        return excludeModelRelations(
          modelRelationsToExclude,
          { stage, memory },
          where,
          (c2) => isSource(c2.source)
        );
      // deployment -> deployment
      default:
        const satisfies = (connection) => {
          return isSource(connection.source) && isTarget(connection.target) || expr.isBidirectional === true && isSource(connection.target) && isTarget(connection.source);
        };
        const deploymentRelationsToExclude = C(
          memory.connections,
          T(satisfies),
          applyPredicate(where)
        );
        if (deploymentRelationsToExclude.length === 0) {
          return stage;
        }
        stage.excludeConnections(deploymentRelationsToExclude);
        return stage;
    }
  }
};
function resolveRelationsBetweenModelElements({
  source,
  target,
  expr,
  model
}) {
  const sources = resolveModelElements(model, source);
  const targets = resolveModelElements(model, target);
  const dir = expr.isBidirectional ? "both" : "directed";
  const modelConnections = [];
  for (const source2 of sources) {
    modelConnections.push(...findConnectionsBetween$1(source2, targets, dir));
  }
  return new Set(modelConnections.flatMap((c2) => [...c2.relations]));
}
var InOutRelationPredicate$1 = {
  include: ({ expr, model, memory, stage, where }) => {
    const sources = [...memory.elements];
    if (FqnExpr.isWildcard(expr.inout)) {
      for (const source of sources) {
        const targets2 = [...resolveAscendingSiblings(source)];
        const toInclude = matchConnections(findConnectionsBetween(source, targets2, "both"), where);
        stage.addConnections(toInclude);
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.inout), "Only deployment refs are supported in include");
    const targets = resolveElements$1(model, expr.inout);
    for (const source of sources) {
      const toInclude = matchConnections(findConnectionsBetween(source, targets, "both"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.inout) || FqnExpr.isElementKindExpr(expr.inout)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.inout)) {
      const elements2 = resolveModelElements(model, expr.inout);
      if (elements2.length === 0) {
        return stage;
      }
      const excludedRelations = union(
        /* @__PURE__ */ new Set(),
        ...elements2.flatMap((e3) => [e3.allIncoming, e3.allOutgoing])
      );
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.inout)) {
      return stage;
    }
    const elements = resolveElements$1(model, expr.inout);
    const isIncoming2 = filterIncomingConnections(elements);
    const isOutgoing2 = filterOutgoingConnections(elements);
    const toExclude = C(
      memory.connections,
      T((c2) => isIncoming2(c2) !== isOutgoing2(c2)),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};
var WhereRelationPredicate = {
  include: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("include", { expr: expr.where.expr, model, stage, memory, where });
  },
  exclude: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("exclude", { expr: expr.where.expr, model, stage, memory, where });
  }
};
var WildcardPredicate$1 = {
  include: ({ model, stage, where }) => {
    const children = [];
    const rootElements = C(
      [...model.roots()],
      applyElementPredicate(where),
      m((root) => {
        if (!root.onlyOneInstance()) {
          children.push(...root.children());
        }
        return root;
      })
    );
    stage.addExplicit(rootElements);
    if (children.length > 1) {
      stage.addConnections(findConnectionsWithin([
        ...rootElements,
        ...children
      ]));
    }
    return stage;
  },
  exclude: ({ stage, memory, where }) => {
    const elementsToExclude = C(
      [...memory.elements],
      applyElementPredicate(where)
    );
    stage.exclude(elementsToExclude);
    return stage;
  }
};
function predicateToPatch(op, { expr, where, ...ctx }) {
  switch (true) {
    case FqnExpr.isElementTagExpr(expr):
    case FqnExpr.isElementKindExpr(expr):
      throw new Error("element kind and tag expressions are not supported in deployment view rules");
    case RelationExpr.isCustom(expr):
    case FqnExpr.isCustom(expr):
    case FqnExpr.isModelRef(expr):
      return void 0;
    case FqnExpr.isWhere(expr):
      return WhereDeploymentRefPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isWhere(expr):
      return WhereRelationPredicate[op]({ ...ctx, expr, where });
    case FqnExpr.isDeploymentRef(expr):
      return DeploymentRefPredicate[op]({ ...ctx, expr, where });
    case FqnExpr.isWildcard(expr):
      return WildcardPredicate$1[op]({ ...ctx, expr, where });
    case RelationExpr.isDirect(expr):
      return DirectRelationPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isInOut(expr):
      return InOutRelationPredicate$1[op]({ ...ctx, expr, where });
    case RelationExpr.isOutgoing(expr):
      return OutgoingRelationPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isIncoming(expr):
      return IncomingRelationPredicate[op]({ ...ctx, expr, where });
    default:
      nonexhaustive(expr);
  }
}
function excludeModelRelations(relationsToExclude, { stage, memory }, where, filterConnections = () => true) {
  if (relationsToExclude.size === 0) {
    return stage;
  }
  const toExclude = C(
    memory.connections,
    T((c2) => filterConnections(c2)),
    // Find connections that have at least one relation in common with the excluded relations
    T((c2) => hasIntersection(c2.relations.model, relationsToExclude)),
    m(
      (c2) => c2.update({
        deployment: null,
        model: intersection(c2.relations.model, relationsToExclude)
      })
    ),
    applyPredicate(where),
    T((c2) => c2.nonEmpty())
  );
  if (toExclude.length === 0) {
    return stage;
  }
  return stage.excludeConnections(toExclude);
}
function matchConnection(c2, where) {
  return applyPredicate(c2, where).nonEmpty();
}
function applyPredicate(...args) {
  if (args.length === 1) {
    return (x) => applyPredicate(x, args[0]);
  }
  const [c2, where] = args;
  if (where === null) {
    return c2;
  }
  if (o(c2)) {
    return c2.map((x) => applyPredicate(x, where)).filter((x) => x.nonEmpty());
  }
  return c2.update({
    model: new Set([...c2.relations.model.values()].filter((r3) => where(toFilterableRelation(c2)(r3)))),
    deployment: new Set([...c2.relations.deployment.values()].filter((r3) => where(toFilterableRelation(c2)(r3))))
  });
}
function applyElementPredicate(...args) {
  if (args.length === 1) {
    return (x) => applyElementPredicate(x, args[0]);
  }
  const [c2, where] = args;
  if (o(c2)) {
    return c2.filter((x) => applyElementPredicate(x, where));
  }
  return (where == null ? void 0 : where(toFilterable(c2, c2))) ?? true;
}
function matchConnections(connections, where) {
  if (!where) {
    return connections;
  }
  return C(
    connections,
    T((c2) => matchConnection(c2, where))
  );
}
function toFilterable(relationEndpoint, connectionEndpoint) {
  if (isElementModel(relationEndpoint)) {
    const deployedInstance = isDeploymentElementModel(connectionEndpoint) && isDeployedInstance(connectionEndpoint) ? connectionEndpoint : null;
    return {
      kind: relationEndpoint.kind,
      tags: [...relationEndpoint.tags, ...(deployedInstance == null ? void 0 : deployedInstance.tags) ?? []]
    };
  }
  if (isNestedElementOfDeployedInstanceModel(relationEndpoint)) {
    return i$6(relationEndpoint.element, ["tags", "kind"]);
  }
  if (isDeployedInstance(relationEndpoint)) {
    return {
      kind: relationEndpoint.element.kind,
      tags: [...relationEndpoint.tags, ...relationEndpoint.element.tags]
    };
  }
  if (isDeploymentNode(relationEndpoint)) {
    return i$6(relationEndpoint, ["tags", "kind"]);
  }
  nonexhaustive(relationEndpoint);
}
function toFilterableRelation(c2) {
  return (relation) => ({
    tags: relation.tags,
    kind: relation.kind,
    source: toFilterable(relation.source, c2.source),
    target: toFilterable(relation.target, c2.target)
  });
}
var DeploymentRefPredicate = {
  include: (ctx) => {
    const { expr, where } = ctx;
    const el = ctx.model.element(expr.ref.deployment);
    if (isDeployedInstance(el)) {
      if (applyElementPredicate(el, where)) {
        ctx.stage.addExplicit(el);
        ctx.stage.connectWithExisting(el);
      }
      return ctx.stage;
    }
    switch (true) {
      case expr.selector === "expanded":
        includeDeployedNodeWithExpanded(el, ctx);
        break;
      case expr.selector === "children":
        includeDeployedNodeChildren(el, ctx);
        break;
      case expr.selector === "descendants":
        includeDeployedNodeDescendants(el, ctx);
        break;
      default: {
        if (applyElementPredicate(el, where)) {
          ctx.stage.addExplicit(el);
          ctx.stage.connectWithExisting(el);
        }
      }
    }
    return ctx.stage;
  },
  exclude: ({ expr, stage, memory, where }) => {
    const exprPredicate = deploymentExpressionToPredicate(expr);
    const toExclude = C(
      [...memory.elements],
      T(exprPredicate),
      applyElementPredicate(where)
    );
    stage.exclude(toExclude);
    return stage;
  }
};
function includeDeployedNodeChildren(node, { stage, where }) {
  const children = applyElementPredicate([...node.children()], where);
  if (children.length === 0) {
    return;
  }
  stage.addImplicit(node);
  stage.addConnections(findConnectionsWithin(children));
  stage.connectWithExisting(children);
  stage.addExplicit(children);
}
function includeDeployedNodeWithExpanded(node, { memory, stage, where }) {
  stage.addImplicit(node);
  stage.connectWithExisting(node);
  const children = applyElementPredicate([...node.children()], where);
  let hasConnectionsWithVisible = false;
  for (const child of children) {
    if (findConnectionsBetween(child, memory.elements).length > 0) {
      hasConnectionsWithVisible = true;
      break;
    }
  }
  if (hasConnectionsWithVisible) {
    stage.connectWithExisting(children, "in");
    stage.addConnections(findConnectionsWithin(children));
    stage.connectWithExisting(children, "out");
  }
  stage.addImplicit(children);
  if (stage.connections.length > 0) {
    stage.addExplicit(node);
  }
}
function includeDeployedNodeDescendants(node, { stage, where }) {
  const dfs = (node2) => {
    const children = [];
    for (const child of node2.children()) {
      if (child.isDeploymentNode()) {
        children.push(...dfs(child));
      }
      if (applyElementPredicate(child, where)) {
        children.push(child);
      }
    }
    stage.connectWithExisting(children, "in");
    stage.addConnections(findConnectionsWithin(children));
    stage.addImplicit(children);
    return children;
  };
  const descendants = dfs(node);
  if (descendants.length === 0) {
    return;
  }
  stage.connectWithExisting(descendants, "out");
  const allConnected = findConnectedElements(stage);
  C(
    descendants,
    T((desc) => allConnected.has(desc)),
    u3((desc) => stage.addExplicit(desc))
  );
}
function findConnectedElements(stage) {
  return C(
    stage.mergedConnections(),
    cleanCrossBoundary,
    cleanRedundantRelationships,
    l$5((acc, c2) => {
      acc.add(c2.source);
      acc.add(c2.target);
      return acc;
    }, /* @__PURE__ */ new Set())
  );
}
var StageFinal$1 = class StageFinal {
  constructor(memory) {
    this.memory = memory;
  }
  static for(memory) {
    return new StageFinal(memory);
  }
  step1CleanConnections(memory) {
    if (memory.connections.length < 2) {
      return memory;
    }
    const connections = C(
      memory.connections,
      // Keep connections
      // - between leafs
      // - has direct deployment relation
      // filter(c => {
      //   return (leafs.has(c.source) && leafs.has(c.target)) || c.hasDirectDeploymentRelation()
      // }),
      cleanCrossBoundary,
      cleanRedundantRelationships
    );
    const connectionsToExclude = differenceConnections(
      memory.connections,
      connections
    );
    if (connectionsToExclude.length === 0) {
      return memory;
    }
    const stage = memory.stageExclude({});
    stage.excludeConnections(connectionsToExclude, true);
    return stage.commit();
  }
  step2ProcessImplicits(memory) {
    const implicits = union(this.memory.elements, memory.elements);
    const final = union(memory.final, this.memory.explicits);
    const groupedByRelation = new DefaultMap(() => /* @__PURE__ */ new Set());
    for (const conn of memory.connections) {
      if (conn.boundary) {
        for (const relation of conn.relations.model) {
          groupedByRelation.get(relation).add(conn.boundary);
        }
      }
    }
    for (const [_, boundaries] of groupedByRelation) {
      if (boundaries.size < 2) {
        continue;
      }
      for (const boundary of boundaries) {
        if (implicits.delete(boundary)) {
          final.add(boundary);
        }
      }
    }
    const snapshot = new Set(final);
    const isFinalOrHasIncludedDescendant = (el) => {
      for (const final2 of snapshot) {
        if (el === final2 || isAncestor(el, final2)) {
          return true;
        }
      }
      return false;
    };
    C(
      difference(implicits, snapshot),
      ifilter((e3) => e3.isDeploymentNode()),
      toArray(),
      sortByFqnHierarchically,
      u3((el) => {
        const childrensToWrap = [...el.children()].filter(isFinalOrHasIncludedDescendant).length;
        if (childrensToWrap >= 2) {
          final.add(el);
          return;
        }
        if (childrensToWrap === 1 && isome(el.siblings(), isFinalOrHasIncludedDescendant)) {
          final.add(el);
        }
      })
    );
    return memory.update({ final });
  }
  step3ProcessBoundaries(memory) {
    const boundaries = /* @__PURE__ */ new Set();
    for (const conn of memory.connections) {
      if (conn.boundary) {
        boundaries.add(conn.boundary);
      }
    }
    const tree = treeFromMemoryState(memory, "final");
    const stage = memory.stageExclude({});
    const isRemovable = (el) => !(boundaries.has(el) || memory.explicits.has(el) || tree.hasInOut(el) || tree.root.has(el));
    const singleRoot = t$2([...tree.root]);
    if (singleRoot && !memory.explicits.has(singleRoot)) {
      stage.exclude(singleRoot);
    }
    for (const el of memory.final) {
      const singleChild = t$2(tree.children(el));
      if (singleChild && !tree.hasInOut(singleChild) && isRemovable(el)) {
        stage.exclude(el);
      }
    }
    if (stage.isDirty()) {
      return stage.commit();
    }
    return memory;
  }
  // TODO: Lot of corner cases to cover, skip for now
  // public step3FlatNodes(memory: Memory): Memory {
  //   // final implicits
  //   const explicits = new Set<Elem>([
  //     ...memory.explicits,
  //     ...memory.connections.flatMap(c => [c.source, c.target]),
  //   ])
  //   const sorted = sortParentsFirst(toArray(memory.final))
  //   const toplevel = new Set<Elem>(sorted)
  //   const children = sorted.reduce((acc, el, index, all) => {
  //     acc.set(
  //       el,
  //       new Set(
  //         all
  //           .slice(index + 1)
  //           .filter(e => isAncestor(el, e))
  //           .reduce((acc, el) => {
  //             if (!acc.some(e => isAncestor(e, el))) {
  //               toplevel.delete(el)
  //               acc.push(el)
  //             }
  //             return acc
  //           }, [] as Elem[]),
  //       ),
  //     )
  //     return acc
  //   }, new DefaultMap<Elem, Set<Elem>>(() => new Set()))
  //   const state = memory.mutableState()
  //   function flattenNode(node: Elem) {
  //     const _children = [...children.get(node)]
  //     if (_children.length > 1) {
  //       for (const child of _children) {
  //         flattenNode(child)
  //       }
  //       return !explicits.has(node)
  //     }
  //     if (hasAtLeast(_children, 1)) {
  //       if (flattenNode(_children[0])) {
  //         state.final.delete(_children[0])
  //       }
  //     }
  //     return !explicits.has(node)
  //   }
  //   const root = [...toplevel]
  //   for (const node of root) {
  //     flattenNode(node)
  //     if (!explicits.has(node) && children.get(node).size === 1) {
  //       state.final.delete(node)
  //     }
  //   }
  //   if (root.length === 1 && !explicits.has(root[0]!)) {
  //     state.final.delete(root[0]!)
  //   }
  //   return memory.update(state)
  // }
  commit() {
    const step1 = this.step1CleanConnections(this.memory);
    const step2 = this.step2ProcessImplicits(step1);
    return this.step3ProcessBoundaries(step2);
  }
};
function processPredicates$1(model, rules) {
  let memory = Memory$1.empty();
  for (const rule of rules) {
    if (isViewRulePredicate(rule)) {
      const op = "include" in rule ? "include" : "exclude";
      const exprs = rule.include ?? rule.exclude;
      for (const expr of exprs) {
        let stage = op === "include" ? memory.stageInclude(expr) : memory.stageExclude(expr);
        const ctx = { expr, model, stage, memory, where: null };
        stage = predicateToPatch(op, ctx) ?? stage;
        memory = stage.commit();
      }
    }
  }
  return StageFinal$1.for(memory).commit();
}
function computeDeploymentView(likec4model, {
  docUri: _docUri,
  // exclude docUri
  rules,
  // exclude rules
  ...view
}) {
  const memory = processPredicates$1(likec4model.deployment, rules);
  const nodesMap = buildNodes$1(memory);
  const computedEdges = toComputedEdges$1(memory.connections);
  linkNodesWithEdges(nodesMap, computedEdges);
  const sorted = topologicalSort({
    nodes: nodesMap,
    edges: computedEdges
  });
  const nodes = applyDeploymentViewRuleStyles(
    rules,
    sorted.nodes
  );
  const autoLayoutRule = o2(rules, isViewRuleAutoLayout);
  const elementNotations = buildElementNotations(nodes);
  return calcViewLayoutHash({
    ...view,
    autoLayout: {
      direction: (autoLayoutRule == null ? void 0 : autoLayoutRule.direction) ?? "TB",
      ...(autoLayoutRule == null ? void 0 : autoLayoutRule.nodeSep) && { nodeSep: autoLayoutRule.nodeSep },
      ...(autoLayoutRule == null ? void 0 : autoLayoutRule.rankSep) && { rankSep: autoLayoutRule.rankSep }
    },
    edges: sorted.edges,
    nodes: m(nodes, (n4) => {
      if (n4.icon === "none") {
        delete n4.icon;
      }
      return n4;
    }),
    ...elementNotations.length > 0 && {
      notation: {
        elements: elementNotations
      }
    }
  });
}
function flattenGroupRules(guard) {
  return (rule) => {
    if (isViewRuleGroup(rule)) {
      return rule.groupRules.flatMap(flattenGroupRules(guard));
    }
    if (isViewRulePredicate(rule)) {
      return "include" in rule ? rule.include.filter(guard) : [];
    }
    return [];
  };
}
function applyCustomElementProperties(_rules, _nodes2) {
  const rules = _rules.flatMap(flattenGroupRules(ModelLayer.FqnExpr.isCustom));
  if (rules.length === 0) {
    return _nodes2;
  }
  const nodes = [..._nodes2];
  for (const {
    custom: { expr, ...props }
  } of rules) {
    const {
      border,
      opacity,
      multiple,
      padding,
      size,
      textSize,
      ...rest
    } = d$1(props, n2);
    const notEmpty = !n3(rest);
    const satisfies = elementExprToPredicate(expr);
    nodes.forEach((node, i2) => {
      if (ComputedNode.isNodesGroup(node) || !satisfies(node)) {
        return;
      }
      if (notEmpty) {
        node = {
          ...node,
          isCustomized: true,
          ...rest
        };
      }
      let styleOverride;
      if (border !== void 0) {
        styleOverride = { border };
      }
      if (opacity !== void 0) {
        styleOverride = { ...styleOverride, opacity };
      }
      if (multiple !== void 0) {
        styleOverride = { ...styleOverride, multiple };
      }
      if (padding !== void 0) {
        styleOverride = { ...styleOverride, padding };
      }
      if (size !== void 0) {
        styleOverride = { ...styleOverride, size };
      }
      if (textSize !== void 0) {
        styleOverride = { ...styleOverride, textSize };
      }
      if (styleOverride) {
        node = {
          ...node,
          isCustomized: true,
          style: {
            ...node.style,
            ...styleOverride
          }
        };
      }
      nodes[i2] = node;
    });
  }
  return nodes;
}
function resolveGlobalRulesInElementView(rules, globals) {
  return rules.reduce((acc, rule) => {
    if (isViewRuleGlobalPredicateRef(rule)) {
      const globalPredicates = globals.predicates[rule.predicateId];
      if (n2(globalPredicates)) {
        return acc;
      }
      return acc.concat(globalPredicates);
    }
    if (isViewRuleGlobalStyle(rule)) {
      const globalStyles = globals.styles[rule.styleId];
      if (n2(globalStyles)) {
        return acc;
      }
      return acc.concat(globalStyles);
    }
    acc.push(rule);
    return acc;
  }, []);
}
function resolveGlobalRulesInDynamicView(rules, globals) {
  return rules.reduce((acc, rule) => {
    if (isViewRuleGlobalPredicateRef(rule)) {
      const globalPredicates = globals.dynamicPredicates[rule.predicateId];
      if (n2(globalPredicates)) {
        return acc;
      }
      return acc.concat(globalPredicates);
    }
    if (isViewRuleGlobalStyle(rule)) {
      const globalStyles = globals.styles[rule.styleId];
      if (n2(globalStyles)) {
        return acc;
      }
      return acc.concat(globalStyles);
    }
    acc.push(rule);
    return acc;
  }, []);
}
var DynamicViewCompute = class {
  constructor(model, view) {
    // Intermediate state
    __publicField(this, "explicits", /* @__PURE__ */ new Set());
    __publicField(this, "steps", []);
    this.model = model;
    this.view = view;
  }
  addStep({
    source: stepSource,
    target: stepTarget,
    title: stepTitle,
    isBackward,
    navigateTo: stepNavigateTo,
    ...step
  }, index, parent) {
    const id = parent ? stepEdgeId(parent, index) : stepEdgeId(index);
    const source = this.model.element(stepSource);
    const target = this.model.element(stepTarget);
    this.explicits.add(source);
    this.explicits.add(target);
    const {
      title,
      relations,
      tags,
      navigateTo: derivedNavigateTo,
      color,
      line
    } = this.findRelations(source, target);
    const navigateTo = n$1(stepNavigateTo) && stepNavigateTo !== this.view.id ? stepNavigateTo : derivedNavigateTo;
    this.steps.push({
      id,
      ...step,
      source,
      target,
      title: stepTitle ?? title,
      relations: relations ?? [],
      isBackward: isBackward ?? false,
      ...navigateTo ? { navigateTo } : {},
      ...tags ? { tags } : {},
      ...color ? { color } : {},
      ...line ? { line } : {}
    });
  }
  compute() {
    const {
      docUri: _docUri,
      // exclude docUri
      rules: _rules,
      // exclude rules
      steps: viewSteps,
      ...view
    } = this.view;
    let stepNum = 1;
    for (const step of viewSteps) {
      if (isDynamicViewParallelSteps(step)) {
        if (step.__parallel.length === 0) {
          continue;
        }
        if (step.__parallel.length === 1) {
          this.addStep(step.__parallel[0], stepNum);
        } else {
          step.__parallel.forEach((s3, i2) => this.addStep(s3, i2 + 1, stepNum));
        }
      } else {
        this.addStep(step, stepNum);
      }
      stepNum++;
    }
    const rules = resolveGlobalRulesInDynamicView(_rules, this.model.globals());
    for (const rule of rules) {
      if (isViewRulePredicate(rule)) {
        for (const expr of rule.include) {
          const satisfies = elementExprToPredicate(expr);
          for (const e3 of this.model.elements()) {
            if (satisfies(e3)) {
              this.explicits.add(e3);
            }
          }
        }
      }
    }
    const elements = [...this.explicits].map((e3) => e3.$element);
    const nodesMap = buildComputedNodesFromElements(elements);
    const edges = this.steps.map(({ source, target, relations, title, isBackward, ...step }) => {
      var _a, _b;
      const sourceNode = nonNullable(nodesMap.get(source.id), `Source node ${source.id} not found`);
      const targetNode = nonNullable(nodesMap.get(target.id), `Target node ${target.id} not found`);
      const edge = {
        parent: commonAncestor(source.id, target.id),
        source: source.id,
        target: target.id,
        label: title,
        relations,
        color: DefaultRelationshipColor,
        line: DefaultLineStyle,
        head: DefaultArrowType,
        ...step
      };
      if (isBackward) {
        edge.dir = "back";
      }
      while (edge.parent && !nodesMap.has(edge.parent)) {
        edge.parent = parentFqn(edge.parent);
      }
      sourceNode.outEdges.push(edge.id);
      targetNode.inEdges.push(edge.id);
      for (const sourceAncestor of ancestorsFqn(edge.source)) {
        if (sourceAncestor === edge.parent) {
          break;
        }
        (_a = nodesMap.get(sourceAncestor)) == null ? void 0 : _a.outEdges.push(edge.id);
      }
      for (const targetAncestor of ancestorsFqn(edge.target)) {
        if (targetAncestor === edge.parent) {
          break;
        }
        (_b = nodesMap.get(targetAncestor)) == null ? void 0 : _b.inEdges.push(edge.id);
      }
      return edge;
    });
    const nodes = applyCustomElementProperties(
      rules,
      applyViewRuleStyles(
        rules,
        // Keep order of elements
        elements.map((e3) => nonNullable(nodesMap.get(e3.id)))
      )
    );
    const autoLayoutRule = o2(rules, isViewRuleAutoLayout);
    const elementNotations = buildElementNotations(nodes);
    return calcViewLayoutHash({
      ...view,
      autoLayout: {
        direction: (autoLayoutRule == null ? void 0 : autoLayoutRule.direction) ?? "LR",
        ...(autoLayoutRule == null ? void 0 : autoLayoutRule.nodeSep) && { nodeSep: autoLayoutRule.nodeSep },
        ...(autoLayoutRule == null ? void 0 : autoLayoutRule.rankSep) && { rankSep: autoLayoutRule.rankSep }
      },
      nodes: m(nodes, (n4) => {
        if (n4.icon === "none") {
          delete n4.icon;
        }
        return n4;
      }),
      edges,
      ...elementNotations.length > 0 && {
        notation: {
          elements: elementNotations
        }
      }
    });
  }
  findRelations(source, target) {
    const relationships = findConnection$1(source, target, "directed").flatMap((r3) => [...r3.relations]);
    if (relationships.length === 0) {
      return {
        title: null,
        tags: null,
        relations: null,
        navigateTo: null,
        color: null,
        line: null
      };
    }
    const alltags = C(
      relationships,
      u$1((r3) => r3.tags),
      T(n$1),
      i$8()
    );
    const tags = i$1(alltags, 1) ? alltags : null;
    const relations = i$1(relationships, 1) ? m(relationships, (r3) => r3.id) : null;
    const relation = t$2(relationships) || relationships.find((r3) => r3.source === source && r3.target === target);
    const relationNavigateTo = (relation == null ? void 0 : relation.$relationship.navigateTo) ?? null;
    const navigateTo = relationNavigateTo && relationNavigateTo !== this.view.id ? relationNavigateTo : C(
      relationships,
      m((r3) => r3.$relationship.navigateTo),
      T(n$1),
      T((v) => v !== this.view.id),
      i$8(),
      t$2()
    );
    const commonProperties = C(
      relationships,
      l$5((acc, { title, $relationship: r3 }) => {
        n$1(title) && acc.title.add(title);
        n$1(r3.color) && acc.color.add(r3.color);
        n$1(r3.line) && acc.line.add(r3.line);
        return acc;
      }, {
        color: /* @__PURE__ */ new Set(),
        line: /* @__PURE__ */ new Set(),
        title: /* @__PURE__ */ new Set()
      })
    );
    return {
      tags,
      relations,
      navigateTo: navigateTo ?? null,
      title: t$2([...commonProperties.title]) ?? null,
      color: t$2([...commonProperties.color]) ?? null,
      line: t$2([...commonProperties.line]) ?? null
    };
  }
};
function computeDynamicView(model, view) {
  return new DynamicViewCompute(model, view).compute();
}
function relationExpressionToPredicates(expr) {
  switch (true) {
    case ModelLayer.RelationExpr.isCustom(expr): {
      return relationExpressionToPredicates(expr.customRelation.expr);
    }
    case ModelLayer.RelationExpr.isWhere(expr): {
      const predicate = relationExpressionToPredicates(expr.where.expr);
      const where = whereOperatorAsPredicate(expr.where.condition);
      return (e3) => predicate(e3) && where({
        source: { tags: e3.source.tags, kind: e3.source.kind },
        target: { tags: e3.target.tags, kind: e3.target.kind },
        ...e3.tags && { tags: e3.tags },
        ...e3.kind && { kind: e3.kind }
      });
    }
    case ModelLayer.RelationExpr.isDirect(expr): {
      const isSource = elementExprToPredicate(expr.source);
      const isTarget = elementExprToPredicate(expr.target);
      return (edge) => {
        return isSource(edge.source) && isTarget(edge.target) || !!expr.isBidirectional && isSource(edge.target) && isTarget(edge.source);
      };
    }
    case ModelLayer.RelationExpr.isInOut(expr): {
      const isInOut = elementExprToPredicate(expr.inout);
      return (edge) => isInOut(edge.source) || isInOut(edge.target);
    }
    case ModelLayer.RelationExpr.isIncoming(expr): {
      const isTarget = elementExprToPredicate(expr.incoming);
      return (edge) => isTarget(edge.target);
    }
    case ModelLayer.RelationExpr.isOutgoing(expr): {
      const isSource = elementExprToPredicate(expr.outgoing);
      return (edge) => isSource(edge.source);
    }
    default:
      nonexhaustive(expr);
  }
}
function applyCustomRelationProperties(_rules, nodes, _edges2) {
  const rules = _rules.flatMap(flattenGroupRules(ModelLayer.RelationExpr.isCustom));
  const edges = Array.from(_edges2);
  if (rules.length === 0 || edges.length === 0) {
    return edges;
  }
  for (const {
    customRelation: {
      expr,
      title,
      ...customprops
    }
  } of rules) {
    const props = d$1(customprops, n2);
    const satisfies = relationExpressionToPredicates(expr);
    edges.forEach((edge, i2) => {
      const source = nodes.find((n4) => n4.id === edge.source);
      const target = nodes.find((n4) => n4.id === edge.target);
      if (!source || !target) {
        return;
      }
      if (satisfies({ source, target, ...i$6(edge, ["kind", "tags"]) })) {
        edges[i2] = {
          ...edge,
          ...props,
          label: title ?? edge.label,
          isCustomized: true
        };
      }
    });
  }
  return edges;
}
var _NodesGroup = class _NodesGroup {
  constructor(id, viewRule, parent = null, elements = /* @__PURE__ */ new Set()) {
    this.id = id;
    this.viewRule = viewRule;
    this.parent = parent;
    this.elements = elements;
  }
  isEmpty() {
    return this.elements.size === 0;
  }
  update(elements) {
    return new _NodesGroup(
      this.id,
      this.viewRule,
      this.parent,
      elements
    );
  }
  clone() {
    return new _NodesGroup(this.id, this.viewRule, this.parent, new Set(this.elements));
  }
};
__publicField(_NodesGroup, "kind", ElementKind.Group);
var NodesGroup = _NodesGroup;
var StageExclude2 = class extends AbstractStageExclude {
  excludeRelations(excluded) {
    C(
      this.memory.connections,
      T((c2) => hasIntersection(c2.relations, excluded)),
      u3((c2) => {
        this.excludeConnections(
          c2.update(intersection(c2.relations, excluded))
        );
      })
    );
    return this;
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    if (this.excluded.elements.size > 0) {
      const excludeRelationships = new Set(
        [...this.excluded.elements].flatMap((el) => [
          ...el.incoming("direct"),
          ...el.outgoing("direct")
        ])
      );
      this.excludeRelations(excludeRelationships);
    }
    return state;
  }
  postcommit(state) {
    const leftExplicits = difference(this.memory.explicits, state.explicits);
    for (const explicit of leftExplicits) {
      state.explicitFirstSeenIn.delete(explicit);
    }
    const left = difference(this.memory.elements, state.elements);
    for (const el of left) {
      state.lastSeenIn.delete(el);
    }
    return state;
  }
};
var ActiveGroupStageExclude = class extends StageExclude2 {
  constructor(memory, expression) {
    super(memory, expression);
    this.memory = memory;
    this.expression = expression;
  }
};
var StageInclude2 = class extends AbstractStageInclude {
  /**
   * Connects elements with existing ones in the memory
   */
  connectWithExisting(elements, direction = "both") {
    const before = this._connections.length;
    const hasChanged = () => this._connections.length > before;
    if (!isIterable(elements)) {
      if (direction === "in" || direction === "both") {
        for (const el of this.memory.elements) {
          this.addConnections(
            findConnection$1(el, elements, "directed")
          );
        }
      }
      if (direction === "out" || direction === "both") {
        this.addConnections(
          findConnectionsBetween$1(elements, this.memory.elements, "directed")
        );
      }
      return hasChanged();
    }
    const targets = [...elements];
    if (direction === "in" || direction === "both") {
      for (const el of this.memory.elements) {
        this.addConnections(
          findConnectionsBetween$1(el, targets, "directed")
        );
      }
    }
    if (direction === "out" || direction === "both") {
      for (const el of targets) {
        this.addConnections(
          findConnectionsBetween$1(el, this.memory.elements, "directed")
        );
      }
    }
    return hasChanged();
  }
  addImplicitWithinScope(element) {
    if (!element) {
      return;
    }
    if (!this.memory.scope || isAncestor(this.memory.scope, element)) {
      this.addImplicit(element);
    }
  }
  processConnections(connections) {
    if (ModelLayer.isAnyRelationExpr(this.expression)) {
      return connections;
    }
    C(
      connections,
      u3(({ source, target, boundary }) => {
        C(
          d(
            [...toArray(source.ancestors()).reverse(), source],
            [...toArray(target.ancestors()).reverse(), target]
          ),
          // Filter out common ancestors
          m2(([sourceAncestor, targetAncestor]) => sourceAncestor === targetAncestor),
          l$6(1),
          u3(([sourceAncestor, targetAncestor]) => {
            if (sourceAncestor === source && targetAncestor === target) {
              this.addImplicitWithinScope(boundary);
              return;
            }
            if (sourceAncestor !== source) {
              this.addImplicitWithinScope(sourceAncestor);
            }
            if (targetAncestor !== target) {
              this.addImplicitWithinScope(targetAncestor);
            }
          })
        );
      })
    );
    return connections;
  }
  postcommit(state) {
    const newExplicits = difference(state.explicits, this.memory.explicits);
    for (const explicit of newExplicits) {
      state.explicitFirstSeenIn.set(explicit, "@root");
    }
    return state;
  }
};
var ActiveGroupStageInclude = class extends StageInclude2 {
  constructor(memory, expression) {
    super(memory, expression);
    this.memory = memory;
    this.expression = expression;
  }
  postcommit(state) {
    const newExplicits = difference(state.explicits, this.memory.explicits);
    for (const explicit of newExplicits) {
      state.explicitFirstSeenIn.set(explicit, this.memory.activeGroupId);
    }
    for (const implicit of [...this.explicits, ...this.implicits]) {
      state.lastSeenIn.set(implicit, this.memory.activeGroupId);
    }
    return state;
  }
};
var Memory2 = class _Memory extends AbstractMemory {
  constructor(state, scope) {
    super(state);
    this.state = state;
    this.scope = scope;
  }
  static empty(scope) {
    return new _Memory({
      elements: /* @__PURE__ */ new Set(),
      explicits: /* @__PURE__ */ new Set(),
      final: /* @__PURE__ */ new Set(),
      connections: [],
      groups: [],
      explicitFirstSeenIn: /* @__PURE__ */ new Map(),
      lastSeenIn: /* @__PURE__ */ new Map()
    }, scope);
  }
  get groups() {
    return this.state.groups;
  }
  get explicitFirstSeenIn() {
    return this.state.explicitFirstSeenIn;
  }
  get lastSeenIn() {
    return this.state.lastSeenIn;
  }
  stageInclude(expr) {
    return new StageInclude2(this, expr);
  }
  stageExclude(expr) {
    return new StageExclude2(this, expr);
  }
  mutableState() {
    return {
      elements: new Set(this.state.elements),
      explicits: new Set(this.state.explicits),
      final: new Set(this.state.final),
      connections: [...this.state.connections],
      groups: this.state.groups.map((g) => g.clone()),
      explicitFirstSeenIn: new Map(this.state.explicitFirstSeenIn),
      lastSeenIn: new Map(this.state.lastSeenIn)
    };
  }
  update(newstate) {
    return new _Memory({
      ...this.state,
      ...newstate
    }, this.scope);
  }
};
var ActiveGroupMemory = class _ActiveGroupMemory extends Memory2 {
  constructor(state, scope, stack) {
    super(state, scope);
    this.state = state;
    this.scope = scope;
    this.stack = stack;
  }
  static enter(memory, rule) {
    const groupId = `@gr${memory.groups.length + 1}`;
    if (memory instanceof _ActiveGroupMemory) {
      const stack2 = Stack.from([...memory.stack].reverse());
      const state2 = memory.mutableState();
      state2.groups.push(new NodesGroup(groupId, rule, memory.activeGroupId));
      stack2.push(groupId);
      return new _ActiveGroupMemory(state2, memory.scope, stack2);
    }
    const state = memory.mutableState();
    state.groups.push(new NodesGroup(groupId, rule, null));
    const stack = Stack.of(groupId);
    return new _ActiveGroupMemory(state, memory.scope, stack);
  }
  get activeGroupId() {
    return nonNullable(this.stack.peek(), "Stack must not be empty");
  }
  mutableState() {
    const state = super.mutableState();
    return {
      ...state
      // activeGroup: this.findActiveGroup(state.groups)
    };
  }
  // private findActiveGroup(groups: NodesGroup[]): NodesGroup {
  //   return nonNullable(groups.find(g => g.id === this.activeGroup.id), 'Active group not found in groups')
  // }
  update(newstate) {
    const nextstate = {
      ...this.state,
      ...newstate
    };
    return new _ActiveGroupMemory(nextstate, this.scope, this.stack);
  }
  stageInclude(expr) {
    return new ActiveGroupStageInclude(this, expr);
  }
  stageExclude(expr) {
    return new ActiveGroupStageExclude(this, expr);
  }
  leave() {
    const state = this.mutableState();
    this.stack.pop();
    const prevgroup = this.stack.peek();
    if (prevgroup) {
      return new _ActiveGroupMemory(state, this.scope, this.stack);
    }
    return new Memory2(state, this.scope);
  }
};
function findRedundantConnections(connections) {
  return C(
    [...connections],
    mergeConnections,
    l$5((reducedConnections, connection, _, all) => {
      const descendants = findDescendantConnections(all, connection);
      const nestedRelations = union(
        ...descendants.map(p$1("relations"))
      );
      let accum = intersection(connection.relations, nestedRelations);
      if (descendants.length > 0) {
        accum = union(accum, connection.directRelations);
      }
      if (findDeepestNestedConnection(all, connection.reversed(false))) {
        accum = union(accum, connection.directRelations);
      }
      if (accum.size < connection.relations.size) {
        const isSourceExpanded = all.some(isAnyInOut(connection.source));
        const isTargetExpanded = all.some(isAnyInOut(connection.target));
        if (isSourceExpanded) {
          accum = union(
            accum,
            toSet(
              ifilter(
                connection.relations,
                isOutgoing(connection.source)
              )
            )
          );
        }
        if (isTargetExpanded) {
          accum = union(
            accum,
            toSet(
              ifilter(
                connection.relations,
                isIncoming(connection.target)
              )
            )
          );
        }
      }
      if (accum.size > 0) {
        reducedConnections.push(connection.update(accum));
      }
      return reducedConnections;
    }, [])
  );
}
var StageFinal2 = class _StageFinal {
  constructor(memory) {
    this.memory = memory;
  }
  static for(memory) {
    return new _StageFinal(memory);
  }
  step1CleanConnections(memory) {
    if (memory.connections.length < 2) {
      return memory;
    }
    const connectionsToExclude = findRedundantConnections(memory.connections);
    if (connectionsToExclude.length === 0) {
      return memory;
    }
    const stage = memory.stageExclude({});
    stage.excludeConnections(connectionsToExclude, true);
    return stage.commit();
  }
  step2ProcessImplicits(memory) {
    const implicits = union(this.memory.elements, memory.elements);
    const final = union(memory.final, this.memory.explicits);
    const snapshot = new Set(final);
    const isFinalOrHasIncludedDescendant = (el) => {
      for (const final2 of snapshot) {
        if (el === final2 || isAncestor(el, final2)) {
          return true;
        }
      }
      return false;
    };
    C(
      difference(implicits, snapshot),
      toArray(),
      sortByFqnHierarchically,
      u3((el) => {
        const childrensToWrap = [...el.children()].filter(isFinalOrHasIncludedDescendant).length;
        if (childrensToWrap >= 2) {
          final.add(el);
          return;
        }
        if (childrensToWrap === 1 && isome(el.siblings(), isFinalOrHasIncludedDescendant)) {
          final.add(el);
        }
      })
    );
    return memory.update({ final });
  }
  step3ProcessBoundaries(memory) {
    const boundaries = /* @__PURE__ */ new Set();
    for (const conn of memory.connections) {
      if (conn.boundary && conn.boundary !== conn.source && conn.boundary !== conn.target) {
        boundaries.add(conn.boundary);
      }
    }
    const tree = treeFromMemoryState(memory, "final");
    const stage = memory.stageExclude({});
    const isRemovable = (el) => !(boundaries.has(el) || memory.explicits.has(el) || tree.hasInOut(el) || tree.root.has(el));
    const singleRoot = t$2([...tree.root]);
    if (singleRoot && !memory.explicits.has(singleRoot)) {
      stage.exclude(singleRoot);
    }
    for (const el of memory.final) {
      const singleChild = t$2(tree.children(el));
      if (singleChild && !tree.hasInOut(singleChild) && isRemovable(el)) {
        stage.exclude(el);
      }
    }
    if (stage.isDirty()) {
      return stage.commit();
    }
    return memory;
  }
  commit() {
    const step1 = this.step1CleanConnections(this.memory);
    const step2 = this.step2ProcessImplicits(step1);
    return this.step3ProcessBoundaries(step2);
  }
};
function resolveElements(model, expr) {
  switch (true) {
    case ModelLayer.FqnExpr.isElementKindExpr(expr): {
      return [...ifilter(model.elements(), (el) => {
        return expr.isEqual === (el.kind === expr.elementKind);
      })];
    }
    case ModelLayer.FqnExpr.isElementTagExpr(expr): {
      return [...ifilter(model.elements(), (el) => {
        return expr.isEqual === el.tags.includes(expr.elementTag);
      })];
    }
    case expr.selector === "expanded": {
      const element = model.element(ModelLayer.FqnRef.toFqn(expr.ref));
      return [
        element,
        ...element.children()
      ];
    }
    case expr.selector === "children":
    case expr.selector === "descendants": {
      const element = model.element(ModelLayer.FqnRef.toFqn(expr.ref));
      let children = expr.selector === "children" ? toArray(element.children()) : toArray(element.descendants());
      return children && children.length > 0 ? children : [element];
    }
    case ModelLayer.FqnExpr.isModelRef(expr): {
      return [model.element(ModelLayer.FqnRef.toFqn(expr.ref))];
    }
    default:
      nonexhaustive(expr);
  }
}
function includeDescendantsFromMemory(elements, memory) {
  if (memory.isEmpty() || elements.length === 0) {
    return elements;
  }
  const descedantsOf = y(elements.map((e3) => isDescendantOf(e3)));
  const fromMemory = toArray(
    ifilter(
      memory.elements,
      (el) => !elements.includes(el) && descedantsOf(el)
    )
  );
  return [
    ...elements,
    ...fromMemory
  ];
}
function resolveAndIncludeFromMemory(nonWildcard, { memory, model }) {
  const resolved = resolveElements(model, nonWildcard);
  if (ModelLayer.FqnExpr.isModelRef(nonWildcard)) {
    if (nonWildcard.selector === "descendants") {
      return resolved;
    }
    return includeDescendantsFromMemory(resolved, memory);
  }
  return resolved;
}
var ExpandedElementPredicate = {
  include: ({ expr, model, stage, where }) => {
    const parent = model.element(ModelLayer.FqnRef.toFqn(expr.ref));
    if (where(parent)) {
      stage.addExplicit(parent);
      stage.connectWithExisting(parent);
    }
    const children = [...parent.children()].filter(where);
    const expanded = [];
    for (const child of children) {
      stage.addImplicit(child);
      if (stage.connectWithExisting(child)) {
        expanded.push(child);
      }
    }
    stage.addConnections(findConnectionsWithin$1(expanded));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};
var ElementKindOrTagPredicate = {
  include: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    if (elements.length === 0) {
      return;
    }
    stage.addExplicit(elements);
    stage.connectWithExisting(elements);
    stage.addConnections(findConnectionsWithin$1(elements));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};
var ElementRefPredicate = {
  include: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    if (elements.length === 0) {
      return;
    }
    stage.addExplicit(elements);
    stage.connectWithExisting(elements);
    stage.addConnections(findConnectionsWithin$1(elements));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};
var NoWhere = () => true;
var NoFilter = (x) => x;
function toNodeSource(el) {
  return {
    ...el.$element,
    modelRef: 1
  };
}
function toComputedEdges(connections) {
  return connections.reduce((acc, e3) => {
    var _a, _b;
    const relations = [
      ...e3.relations
    ];
    invariant(i$1(relations, 1), "Edge must have at least one relation");
    const source = e3.source.id;
    const target = e3.target.id;
    const {
      title,
      ...props
    } = mergePropsFromRelationships(
      relations.map((r3) => r3.$relationship),
      // Prefer only single relationship
      // https://github.com/likec4/likec4/issues/1423
      (_a = t$2(
        T(relations, (r3) => r3.source.id === source && r3.target.id === target)
      )) == null ? void 0 : _a.$relationship
    );
    const edge = {
      id: e3.id,
      parent: ((_b = e3.boundary) == null ? void 0 : _b.id) ?? null,
      source,
      target,
      label: title ?? null,
      relations: relations.map((r3) => r3.id),
      ...props
    };
    acc.push(edge);
    return acc;
  }, []);
}
function buildNodes(memory) {
  return buildComputedNodes([...memory.final].map(toNodeSource), memory.groups);
}
var isWildcard = ModelLayer.FqnExpr.isWildcard;
var DirectRelationExprPredicate = {
  include: ({ expr: { source, target, isBidirectional = false }, memory, model, stage, where, filterWhere }) => {
    const sourceIsWildcard = isWildcard(source);
    const targetIsWildcard = isWildcard(target);
    const connections = [];
    switch (true) {
      // This is a special case, we look for all relationships that satisfy the where clause
      // * -> * ; Empty memory; Where clause
      case (sourceIsWildcard && targetIsWildcard && memory.isEmpty() && where !== NoWhere): {
        const connections2 = C(
          model.relationships(),
          ifilter(where),
          toArray(),
          m((r3) => new ConnectionModel(r3.source, r3.target, /* @__PURE__ */ new Set([r3])))
        );
        stage.addConnections(connections2);
        return stage;
      }
      // This is a special case, we look for all relationships between elements that satisfy the where clause
      // * -> *; Not empty memory; Where clause
      case (sourceIsWildcard && targetIsWildcard && !memory.isEmpty() && where !== NoWhere): {
        connections.push(
          ...findConnectionsWithin$1(memory.elements)
        );
        break;
      }
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        connections.push(
          ...findConnectionsWithin$1(model.roots())
        );
        break;
      }
      // This is a special case, we look for all relationships that satisfy the where clause
      // element -> *; Where clause
      case (!sourceIsWildcard && targetIsWildcard && where !== NoWhere): {
        const sources = resolveElements(model, source);
        const connections2 = C(
          sources,
          u$1(
            (source2) => C(
              source2,
              d$5(r2(isBidirectional === true), {
                onTrue: (s3) => union(s3.allIncoming, s3.allOutgoing),
                onFalse: (s3) => s3.allOutgoing
              }),
              ifilter(where),
              iunique(),
              toArray(),
              d$3((r3) => r3.source === source2),
              ([outgoing, incoming]) => a2(
                C(
                  outgoing,
                  m(
                    (outgoing2) => new ConnectionModel(
                      source2,
                      outgoing2.target,
                      /* @__PURE__ */ new Set([outgoing2])
                    )
                  )
                ),
                C(
                  incoming,
                  m(
                    (incoming2) => new ConnectionModel(
                      incoming2.source,
                      source2,
                      /* @__PURE__ */ new Set([incoming2])
                    )
                  )
                )
              )
            )
          )
        );
        stage.addConnections(connections2);
        return stage;
      }
      // element -> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const [sources, targets] = resolveWildcard(source, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween$1(source2, targets, dir)
          );
        }
        break;
      }
      // This is a special case, we look for all relationships that satisfy the where clause
      // * -> element; Where clause
      case (sourceIsWildcard && !targetIsWildcard && where !== NoWhere): {
        const targets = resolveElements(model, target);
        const connections2 = C(
          targets,
          u$1(
            (target2) => C(
              target2,
              d$5(r2(isBidirectional === true), {
                onTrue: (s3) => union(s3.allIncoming, s3.allOutgoing),
                onFalse: (s3) => s3.allIncoming
              }),
              ifilter(where),
              toArray(),
              d$3((r3) => r3.target === target2),
              ([incoming, outgoing]) => a2(
                C(
                  outgoing,
                  m(
                    (outgoing2) => new ConnectionModel(
                      target2,
                      outgoing2.target,
                      /* @__PURE__ */ new Set([outgoing2])
                    )
                  )
                ),
                C(
                  incoming,
                  m(
                    (incoming2) => new ConnectionModel(
                      incoming2.source,
                      target2,
                      /* @__PURE__ */ new Set([incoming2])
                    )
                  )
                )
              )
            )
          )
        );
        stage.addConnections(connections2);
        return stage;
      }
      // * -> element
      case (sourceIsWildcard && !targetIsWildcard): {
        const [targets, sources] = resolveWildcard(target, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween$1(source2, targets, dir)
          );
        }
        break;
      }
      default: {
        invariant(!isWildcard(source), "Inference failed - source must be not a wildcard");
        invariant(!isWildcard(target), "Inference failed - target must be not a wildcard");
        const sources = resolveAndIncludeFromMemory(source, { memory, model });
        const targets = resolveAndIncludeFromMemory(target, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween$1(source2, targets, dir)
          );
        }
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { source, target, isBidirectional }, model, memory, stage, where }) => {
    const sourceIsWildcard = isWildcard(source);
    const targetIsWildcard = isWildcard(target);
    let relations;
    switch (true) {
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        relations = C(
          memory.connections,
          u$1(i$4(
            p$1("relations"),
            ifilter(where),
            toArray()
          )),
          toSet()
        );
        break;
      }
      // element -> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const sources = resolveElements(model, source);
        relations = C(
          sources,
          u$1(
            (source2) => C(
              source2,
              d$5(r2(isBidirectional === true), {
                onTrue: (s3) => union(s3.allIncoming, s3.allOutgoing),
                onFalse: (s3) => s3.allOutgoing
              }),
              ifilter(where),
              toArray()
            )
          ),
          toSet()
        );
        break;
      }
      // * -> element
      case (sourceIsWildcard && !targetIsWildcard): {
        const targets = resolveElements(model, target);
        relations = C(
          targets,
          u$1(
            (target2) => C(
              target2,
              d$5(r2(isBidirectional === true), {
                onTrue: (s3) => union(s3.allIncoming, s3.allOutgoing),
                onFalse: (s3) => s3.allIncoming
              }),
              ifilter(where),
              toArray()
            )
          ),
          toSet()
        );
        break;
      }
      default: {
        invariant(!isWildcard(source), "Inferrence failed - source must be not a wildcard");
        invariant(!isWildcard(target), "Inferrence failed - target must be not a wildcard");
        const sources = resolveElements(model, source);
        const targets = resolveElements(model, target);
        let accum = /* @__PURE__ */ new Set();
        for (const source2 of sources) {
          for (const target2 of targets) {
            if (isSameHierarchy(source2, target2)) {
              continue;
            }
            accum = union(
              accum,
              intersection(source2.allOutgoing, target2.allIncoming),
              isBidirectional ? intersection(target2.allOutgoing, source2.allIncoming) : /* @__PURE__ */ new Set()
            );
          }
        }
        relations = toSet(ifilter(accum, where));
      }
    }
    stage.excludeRelations(relations);
    return stage;
  }
};
function resolveWildcard(nonWildcard, { memory, model }) {
  let sources = resolveElements(model, nonWildcard);
  if (!i$1(sources, 1)) {
    return [[], []];
  }
  if (ModelLayer.FqnExpr.isModelRef(nonWildcard)) {
    const parent = model.element(ModelLayer.FqnRef.toFqn(nonWildcard.ref));
    const targets2 = toArray(parent.ascendingSiblings());
    return [
      includeDescendantsFromMemory(sources, memory),
      includeDescendantsFromMemory(targets2, memory)
    ];
  }
  const targets = C(
    sources,
    m((el) => el.ascendingSiblings()),
    iflat(),
    iunique(),
    toArray(),
    (all) => includeDescendantsFromMemory(all, memory)
  );
  return [sources, targets];
}
var IncomingExprPredicate = {
  include: ({ expr, scope, model, memory, stage, filterWhere }) => {
    const target = expr.incoming;
    const connections = [];
    if (ModelLayer.FqnExpr.isWildcard(target)) {
      if (!scope) {
        return;
      }
      for (const sibling of scope.ascendingSiblings()) {
        connections.push(
          ...findConnection$1(
            sibling,
            scope,
            "directed"
          )
        );
      }
    } else {
      const targets = resolveAndIncludeFromMemory(target, { memory, model });
      const visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements.push(
          ...i$8(
            targets.flatMap((el) => [...el.ascendingSiblings()])
          )
        );
      }
      const ensureIncoming = incomingConnectionPredicate(model, target);
      for (const visible of visibleElements) {
        connections.push(
          ...findConnectionsBetween$1(
            visible,
            targets,
            "directed"
          ).filter(ensureIncoming)
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { incoming }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelLayer.FqnExpr.isWildcard(incoming)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allIncoming);
    } else {
      const elements = resolveElements(model, incoming);
      excluded.push(
        ...elements.flatMap((e3) => [...e3.allIncoming])
      );
    }
    stage.excludeRelations(new Set(excluded.filter(where)));
    return stage;
  }
};
function incomingConnectionPredicate(model, expr) {
  switch (true) {
    case ModelLayer.FqnExpr.isElementKindExpr(expr):
    case ModelLayer.FqnExpr.isElementTagExpr(expr): {
      const isElement = elementExprToPredicate(expr);
      return (connection) => isElement(connection.target);
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "children"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y(
        [...model.children(fqn)].map(
          (el) => Connection.isIncoming(el.id)
        )
      );
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "descendants"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y([
        Connection.isInside(fqn),
        ...[...model.children(fqn)].map(
          (el) => Connection.isIncoming(el.id)
        )
      ]);
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y([
        Connection.isIncoming(fqn),
        Connection.isInside(fqn)
      ]);
    }
    case ModelLayer.FqnExpr.isModelRef(expr): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return Connection.isIncoming(fqn);
    }
    default:
      nonexhaustive(expr);
  }
}
var InOutRelationPredicate = {
  include: ({ expr: { inout }, scope, model, memory, stage, filterWhere }) => {
    const connections = [];
    if (ModelLayer.FqnExpr.isWildcard(inout)) {
      if (!scope) {
        return;
      }
      connections.push(
        ...findConnectionsBetween$1(
          scope,
          scope.ascendingSiblings()
        )
      );
    } else {
      const elements = resolveAndIncludeFromMemory(inout, { memory, model });
      let visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements = i$8(
          elements.flatMap((el) => toArray(el.ascendingSiblings()))
        );
      }
      for (const el of elements) {
        connections.push(
          ...findConnectionsBetween$1(
            el,
            visibleElements
          )
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { inout }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelLayer.FqnExpr.isWildcard(inout)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allOutgoing);
      excluded.push(...scope.allIncoming);
    } else {
      const elements = resolveElements(model, inout);
      excluded.push(
        ...elements.flatMap((e3) => [...e3.allOutgoing, ...e3.allIncoming])
      );
    }
    stage.excludeRelations(toSet(excluded.filter(where)));
    return stage;
  }
};
var OutgoingExprPredicate = {
  include: ({ expr, scope, model, memory, stage, filterWhere }) => {
    const target = expr.outgoing;
    const connections = [];
    if (ModelLayer.FqnExpr.isWildcard(target)) {
      if (!scope) {
        return;
      }
      connections.push(
        ...findConnectionsBetween$1(
          scope,
          scope.ascendingSiblings(),
          "directed"
        )
      );
    } else {
      const elements = resolveAndIncludeFromMemory(target, { memory, model });
      const visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements.push(
          ...i$8(
            elements.flatMap((el) => [...el.ascendingSiblings()])
          )
        );
      }
      const ensureOutgoing = outgoingConnectionPredicate(model, target);
      for (const source of elements) {
        connections.push(
          ...findConnectionsBetween$1(
            source,
            visibleElements,
            "directed"
          ).filter(ensureOutgoing)
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { outgoing }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelLayer.FqnExpr.isWildcard(outgoing)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allOutgoing);
    } else {
      const elements = resolveElements(model, outgoing);
      excluded.push(
        ...elements.flatMap((e3) => [...e3.allOutgoing])
      );
    }
    stage.excludeRelations(
      toSet(excluded.filter(where))
    );
    return stage;
  }
};
function outgoingConnectionPredicate(model, expr) {
  switch (true) {
    case ModelLayer.FqnExpr.isElementKindExpr(expr):
    case ModelLayer.FqnExpr.isElementTagExpr(expr): {
      const isElement = elementExprToPredicate(expr);
      return (connection) => isElement(connection.source);
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "children"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y(
        [...model.children(fqn)].map(
          (el) => Connection.isOutgoing(el.id)
        )
      );
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "descendants"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y([
        Connection.isInside(fqn),
        ...[...model.children(fqn)].map(
          (el) => Connection.isOutgoing(el.id)
        )
      ]);
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y([
        Connection.isOutgoing(fqn),
        Connection.isInside(fqn)
      ]);
    }
    case ModelLayer.FqnExpr.isModelRef(expr): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return Connection.isOutgoing(fqn);
    }
    default:
      nonexhaustive(expr);
  }
}
var WildcardPredicate = {
  include: ({ scope, model, stage, memory, where }) => {
    if (!scope) {
      const rootElements = [...model.roots()].filter(where);
      if (rootElements.length === 0) {
        return;
      }
      stage.addExplicit(rootElements);
      stage.addConnections(findConnectionsWithin$1(rootElements));
      stage.connectWithExisting(rootElements);
      return stage;
    }
    const root = where(scope) ? scope : null;
    const children = toArray(ifilter(scope.children(), where));
    const hasChildren = children.length > 0;
    if (!hasChildren) {
      if (!root) {
        return stage;
      } else {
        const edgesWithSiblings = findConnectionsBetween$1(root, root.siblings());
        if (edgesWithSiblings.length === 0) {
          const parent = root.parent;
          if (parent && where(parent)) {
            stage.addExplicit(parent);
          }
        }
        children.push(root);
      }
    }
    if (root) {
      stage.addExplicit(root);
    }
    const neighbours = toSet([
      ...memory.elements,
      ...scope.descendingSiblings()
    ]);
    for (const neighbour of neighbours) {
      stage.addConnections(findConnectionsBetween$1(neighbour, children, "directed"));
    }
    if (hasChildren) {
      stage.addConnections(findConnectionsWithin$1(children));
      stage.addExplicit(children);
    }
    for (const child of children) {
      stage.addConnections(findConnectionsBetween$1(child, neighbours, "directed"));
    }
    return stage;
  },
  exclude: ({ scope, memory, stage, where }) => {
    if (where !== NoWhere) {
      stage.exclude(
        T(
          [...memory.elements],
          where
        )
      );
      return stage;
    }
    if (scope) {
      stage.exclude([scope, ...scope.descendants()]);
      return stage;
    }
    return Memory2.empty(memory.scope).stageExclude(stage.expression);
  }
};
function processElementPredicate(expr, op, ctx) {
  switch (true) {
    case ModelLayer.FqnExpr.isCustom(expr): {
      if (op === "include") {
        return processElementPredicate(expr.custom.expr, op, ctx);
      }
      return ctx.stage;
    }
    case ModelLayer.FqnExpr.isWhere(expr): {
      const where = whereOperatorAsPredicate(expr.where.condition);
      const filterWhere = T(where);
      return processElementPredicate(expr.where.expr, op, { ...ctx, where, filterWhere });
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      return ExpandedElementPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.FqnExpr.isWildcard(expr): {
      return WildcardPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.FqnExpr.isElementKindExpr(expr):
    case ModelLayer.FqnExpr.isElementTagExpr(expr): {
      return ElementKindOrTagPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.FqnExpr.isModelRef(expr): {
      return ElementRefPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    default:
      nonexhaustive(expr);
  }
}
function processRelationtPredicate(expr, op, ctx) {
  switch (true) {
    case ModelLayer.RelationExpr.isCustom(expr): {
      if (op === "include") {
        return processRelationtPredicate(expr.customRelation.expr, op, ctx);
      }
      return ctx.stage;
    }
    case ModelLayer.RelationExpr.isWhere(expr): {
      const where = whereOperatorAsPredicate(expr.where.condition);
      const filterRelations = (relations) => {
        return new Set(T([...relations], where));
      };
      const filterWhere = (connections) => {
        return C(
          connections,
          m((c2) => new ConnectionModel(c2.source, c2.target, filterRelations(c2.relations))),
          T((c2) => c2.nonEmpty())
        );
      };
      return processRelationtPredicate(expr.where.expr, op, {
        ...ctx,
        where,
        filterWhere
      });
    }
    case ModelLayer.RelationExpr.isInOut(expr): {
      return InOutRelationPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.RelationExpr.isDirect(expr): {
      return DirectRelationExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.RelationExpr.isOutgoing(expr): {
      return OutgoingExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.RelationExpr.isIncoming(expr): {
      return IncomingExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    default:
      nonexhaustive(expr);
  }
}
function processPredicates(model, memory, rules) {
  const ctx = {
    model,
    scope: memory.scope,
    where: NoWhere,
    filterWhere: NoFilter
  };
  for (const rule of rules) {
    if (isViewRuleGroup(rule)) {
      const groupMemory = ActiveGroupMemory.enter(memory, rule);
      memory = processPredicates(model, groupMemory, rule.groupRules);
      invariant(memory instanceof ActiveGroupMemory, "processPredicates must return ActiveGroupMemory");
      memory = memory.leave();
      continue;
    }
    if (isViewRulePredicate(rule)) {
      const op = "include" in rule ? "include" : "exclude";
      const exprs = rule.include ?? rule.exclude;
      for (const expr of exprs) {
        let stage = op === "include" ? memory.stageInclude(expr) : memory.stageExclude(expr);
        switch (true) {
          case ModelLayer.isAnyFqnExpr(expr):
            stage = processElementPredicate(expr, op, {
              ...ctx,
              stage,
              memory
            }) ?? stage;
            break;
          case ModelLayer.isAnyRelationExpr(expr):
            stage = processRelationtPredicate(expr, op, {
              ...ctx,
              stage,
              memory
            }) ?? stage;
            break;
          default:
            nonexhaustive(expr);
        }
        memory = stage.commit();
      }
    }
  }
  return StageFinal2.for(memory).commit();
}
function computeElementView(likec4model, {
  docUri: _docUri,
  // exclude docUri
  rules,
  // exclude rules
  ...view
}) {
  rules = resolveGlobalRulesInElementView(rules, likec4model.globals());
  const scope = view.viewOf ? likec4model.element(view.viewOf) : null;
  let memory = processPredicates(
    likec4model,
    Memory2.empty(scope),
    rules
  );
  if (memory.isEmpty() && scope) {
    memory = memory.update({
      final: /* @__PURE__ */ new Set([scope])
    });
  }
  memory = assignElementsToGroups(memory);
  const nodesMap = buildNodes(memory);
  const computedEdges = toComputedEdges(memory.connections);
  linkNodesWithEdges(nodesMap, computedEdges);
  const sorted = topologicalSort({
    nodes: nodesMap,
    edges: computedEdges
  });
  const nodes = applyCustomElementProperties(
    rules,
    applyViewRuleStyles(
      rules,
      sorted.nodes
    )
  );
  const autoLayoutRule = o2(rules, isViewRuleAutoLayout);
  const elementNotations = buildElementNotations(nodes);
  return calcViewLayoutHash({
    ...view,
    autoLayout: {
      direction: (autoLayoutRule == null ? void 0 : autoLayoutRule.direction) ?? "TB",
      ...(autoLayoutRule == null ? void 0 : autoLayoutRule.nodeSep) && { nodeSep: autoLayoutRule.nodeSep },
      ...(autoLayoutRule == null ? void 0 : autoLayoutRule.rankSep) && { rankSep: autoLayoutRule.rankSep }
    },
    edges: applyCustomRelationProperties(rules, nodes, sorted.edges),
    nodes: m(nodes, (n4) => {
      if (n4.icon === "none") {
        delete n4.icon;
      }
      return n4;
    }),
    ...elementNotations.length > 0 && {
      notation: {
        elements: elementNotations
      }
    }
  });
}
function assignElementsToGroups(memory) {
  if (memory.groups.length === 0) {
    return memory;
  }
  const groupAssignments = new DefaultMap(() => /* @__PURE__ */ new Set());
  const assignedTo = /* @__PURE__ */ new Map();
  const isAncestorAssigned = (el) => {
    for (const parent of el.ancestors()) {
      const groupId = assignedTo.get(parent);
      if (groupId) {
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
        return true;
      }
    }
    return false;
  };
  const isDescendantAssigned = (el) => {
    for (const descendant of el.descendants("asc")) {
      const groupId = assignedTo.get(descendant);
      if (groupId) {
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
        return true;
      }
    }
    return false;
  };
  C(
    sortParentsFirst([...memory.explicitFirstSeenIn.keys()]),
    u3((el) => {
      if (!isAncestorAssigned(el)) {
        const groupId = nonNullable(memory.explicitFirstSeenIn.get(el));
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
      }
    })
  );
  C(
    sortParentsFirst([...memory.lastSeenIn.keys()]),
    T((el) => !assignedTo.has(el)),
    u3((el) => {
      if (isAncestorAssigned(el)) {
        return;
      }
      if (isDescendantAssigned(el)) {
        return;
      }
      const groupId = nonNullable(memory.lastSeenIn.get(el));
      assignedTo.set(el, groupId);
      groupAssignments.get(groupId).add(el);
    })
  );
  if (groupAssignments.size === 0) {
    return memory;
  }
  let groups = memory.groups.map((group) => {
    const explicits = groupAssignments.get(group.id);
    if (!explicits) {
      return group;
    }
    return group.update(explicits);
  });
  return memory.update({ groups });
}
function unsafeComputeView(viewsource, likec4model) {
  switch (true) {
    case isDeploymentView(viewsource): {
      return computeDeploymentView(likec4model, viewsource);
    }
    case isDynamicView(viewsource):
      return computeDynamicView(likec4model, viewsource);
    case isElementView(viewsource):
      return computeElementView(likec4model, viewsource);
    default:
      nonexhaustive(viewsource);
  }
}
function computeView(viewsource, likec4model) {
  try {
    return {
      isSuccess: true,
      view: unsafeComputeView(viewsource, likec4model)
    };
  } catch (e3) {
    return {
      isSuccess: false,
      error: e3 instanceof Error ? e3 : new Error(`Unknown error: ${e3}`),
      view: void 0
    };
  }
}
function computeViews(parsed) {
  const { views, ...rest } = parsed;
  const likec4model = LikeC4Model.create({
    ...rest,
    views: {}
  });
  const compute = (source) => {
    const result = computeView(source, likec4model);
    if (result.isSuccess) {
      return result.view;
    } else {
      throw result.error;
    }
  };
  return {
    ...rest,
    __: "computed",
    views: i$3(parsed.views, compute)
  };
}
function getId(element) {
  return isString(element) ? element : element.id;
}
var _elements, _parents, _children, _instancesOf, _rootElements, _relations, _incoming, _outgoing, _internal, _allTags, _nestedElementsOfDeployment;
var LikeC4DeploymentModel = class {
  constructor($model, $deployments) {
    __privateAdd(this, _elements, /* @__PURE__ */ new Map());
    // Parent element for given FQN
    __privateAdd(this, _parents, /* @__PURE__ */ new Map());
    // Children elements for given FQN
    __privateAdd(this, _children, new DefaultMap(() => /* @__PURE__ */ new Set()));
    // Keep track of instances of the logical element
    __privateAdd(this, _instancesOf, new DefaultMap(() => /* @__PURE__ */ new Set()));
    __privateAdd(this, _rootElements, /* @__PURE__ */ new Set());
    __privateAdd(this, _relations, /* @__PURE__ */ new Map());
    // Incoming to an element or its descendants
    __privateAdd(this, _incoming, new DefaultMap(() => /* @__PURE__ */ new Set()));
    // Outgoing from an element or its descendants
    __privateAdd(this, _outgoing, new DefaultMap(() => /* @__PURE__ */ new Set()));
    // Relationships inside the element, among descendants
    __privateAdd(this, _internal, new DefaultMap(() => /* @__PURE__ */ new Set()));
    // readonly #views = new Map<ViewID, LikeC4ViewModel<M>>()
    __privateAdd(this, _allTags, new DefaultMap(
      () => /* @__PURE__ */ new Set()
    ));
    __privateAdd(this, _nestedElementsOfDeployment, /* @__PURE__ */ new Map());
    this.$model = $model;
    this.$deployments = $deployments;
    for (const element of sortParentsFirst(r$3($deployments.elements))) {
      const el = this.addElement(element);
      for (const tag of el.tags) {
        __privateGet(this, _allTags).get(tag).add(el);
      }
      if (el.isInstance()) {
        __privateGet(this, _instancesOf).get(el.element.id).add(el);
      }
    }
    for (const relation of r$3($deployments.relations)) {
      const el = this.addRelation(relation);
      for (const tag of el.tags) {
        __privateGet(this, _allTags).get(tag).add(el);
      }
    }
  }
  element(el) {
    if (el instanceof DeploymentNodeModel || el instanceof DeployedInstanceModel) {
      return el;
    }
    const id = getId(el);
    return nonNullable(__privateGet(this, _elements).get(id), `Element ${id} not found`);
  }
  findElement(el) {
    return __privateGet(this, _elements).get(el) ?? null;
  }
  node(el) {
    const element = this.element(el);
    invariant(element.isDeploymentNode(), `Element ${element.id} is not a deployment node`);
    return element;
  }
  findNode(el) {
    const element = this.findElement(el);
    if (!element) {
      return null;
    }
    invariant(element.isDeploymentNode(), `Element ${element == null ? void 0 : element.id} is not a deployment node`);
    return element;
  }
  instance(el) {
    const element = this.element(el);
    invariant(element.isInstance(), `Element ${element.id} is not a deployed instance`);
    return element;
  }
  findInstance(el) {
    const element = this.findElement(el);
    if (!element) {
      return null;
    }
    invariant(element.isInstance(), `Element ${element == null ? void 0 : element.id} is not a deployed instance`);
    return element;
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return __privateGet(this, _rootElements).values();
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return __privateGet(this, _elements).values();
  }
  /**
   * Returns all elements in the model.
   */
  *nodes() {
    for (const element of __privateGet(this, _elements).values()) {
      if (element.isDeploymentNode()) {
        yield element;
      }
    }
    return;
  }
  *instances() {
    for (const element of __privateGet(this, _elements).values()) {
      if (element.isInstance()) {
        yield element;
      }
    }
    return;
  }
  /**
   * Iterate over all instances of the given logical element.
   */
  *instancesOf(element) {
    const id = getId(element);
    const instances = __privateGet(this, _instancesOf).get(id);
    if (instances) {
      yield* instances;
    }
    return;
  }
  deploymentRef(ref) {
    if ("element" in ref) {
      const { id, element } = ref;
      return getOrCreate(__privateGet(this, _nestedElementsOfDeployment), `${id}@${element}`, () => {
        return new NestedElementOfDeployedInstanceModel(this.instance(id), this.$model.element(element));
      });
    }
    return this.element(ref);
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return __privateGet(this, _relations).values();
  }
  /**
   * Returns a specific relationship by its ID.
   */
  relationship(id) {
    return nonNullable(__privateGet(this, _relations).get(id), `DeploymentRelationModel ${id} not found`);
  }
  findRelationship(id) {
    return __privateGet(this, _relations).get(id) ?? null;
  }
  /**
   * Returns all deployment views in the model.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (view.isDeploymentView()) {
        yield view;
      }
    }
    return;
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id = getId(element);
    return __privateGet(this, _parents).get(id) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id = getId(element);
    return __privateGet(this, _children).get(id);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  *siblings(element) {
    var _a;
    const id = getId(element);
    const siblings = ((_a = this.parent(element)) == null ? void 0 : _a.children()) ?? this.roots();
    for (const sibling of siblings) {
      if (sibling.id !== id) {
        yield sibling;
      }
    }
    return;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors(element) {
    let id = isString(element) ? element : element.id;
    let parent;
    while (parent = __privateGet(this, _parents).get(id)) {
      yield parent;
      id = parent.id;
    }
    return;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  *descendants(element, sort = "desc") {
    for (const child of this.children(element)) {
      if (sort === "asc") {
        yield child;
        yield* this.descendants(child.id);
      } else {
        yield* this.descendants(child.id);
        yield child;
      }
    }
    return;
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  *incoming(element, filter = "all") {
    const id = getId(element);
    for (const rel of __privateGet(this, _incoming).get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.target.id === id):
        case (filter === "to-descendants" && rel.target.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  *outgoing(element, filter = "all") {
    const id = getId(element);
    for (const rel of __privateGet(this, _outgoing).get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.source.id === id):
        case (filter === "from-descendants" && rel.source.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  addElement(element) {
    if (__privateGet(this, _elements).has(element.id)) {
      throw new Error(`Element ${element.id} already exists`);
    }
    const el = DeploymentElement.isDeploymentNode(element) ? new DeploymentNodeModel(this, Object.freeze(element)) : new DeployedInstanceModel(this, Object.freeze(element), this.$model.element(element.element));
    __privateGet(this, _elements).set(el.id, el);
    const parentId = parentFqn(el.id);
    if (parentId) {
      invariant(__privateGet(this, _elements).has(parentId), `Parent ${parentId} of ${el.id} not found`);
      __privateGet(this, _parents).set(el.id, this.node(parentId));
      __privateGet(this, _children).get(parentId).add(el);
    } else {
      invariant(el.isDeploymentNode(), `Root element ${el.id} is not a deployment node`);
      __privateGet(this, _rootElements).add(el);
    }
    return el;
  }
  addRelation(relation) {
    var _a;
    if (__privateGet(this, _relations).has(relation.id)) {
      throw new Error(`Relation ${relation.id} already exists`);
    }
    const rel = new DeploymentRelationModel(
      this,
      Object.freeze(relation)
    );
    __privateGet(this, _relations).set(rel.id, rel);
    __privateGet(this, _incoming).get(rel.target.id).add(rel);
    __privateGet(this, _outgoing).get(rel.source.id).add(rel);
    const relParent = ((_a = rel.boundary) == null ? void 0 : _a.id) ?? null;
    if (relParent) {
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)]) {
        __privateGet(this, _internal).get(ancestor).add(rel);
      }
    }
    for (const sourceAncestor of ancestorsFqn(rel.source.id)) {
      if (sourceAncestor === relParent) {
        break;
      }
      __privateGet(this, _outgoing).get(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(rel.target.id)) {
      if (targetAncestor === relParent) {
        break;
      }
      __privateGet(this, _incoming).get(targetAncestor).add(rel);
    }
    return rel;
  }
};
_elements = new WeakMap();
_parents = new WeakMap();
_children = new WeakMap();
_instancesOf = new WeakMap();
_rootElements = new WeakMap();
_relations = new WeakMap();
_incoming = new WeakMap();
_outgoing = new WeakMap();
_internal = new WeakMap();
_allTags = new WeakMap();
_nestedElementsOfDeployment = new WeakMap();
var RelationshipModel = class {
  constructor(model, $relationship) {
    __publicField(this, "source");
    __publicField(this, "target");
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the Relation.
     */
    __publicField(this, "boundary");
    this.model = model;
    this.$relationship = $relationship;
    this.source = model.element($relationship.source);
    this.target = model.element($relationship.target);
    const parent = commonAncestor(this.source.id, this.target.id);
    this.boundary = parent ? this.model.element(parent) : null;
  }
  get id() {
    return this.$relationship.id;
  }
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  get title() {
    if (n3(this.$relationship.title)) {
      return null;
    }
    return this.$relationship.title;
  }
  get technology() {
    if (n3(this.$relationship.technology)) {
      return null;
    }
    return this.$relationship.technology;
  }
  get description() {
    if (n3(this.$relationship.description)) {
      return null;
    }
    return this.$relationship.description;
  }
  get navigateTo() {
    return this.$relationship.navigateTo ? this.model.view(this.$relationship.navigateTo) : null;
  }
  get tags() {
    return this.$relationship.tags ?? [];
  }
  get kind() {
    return this.$relationship.kind ?? null;
  }
  get links() {
    return this.$relationship.links ?? [];
  }
  get color() {
    return this.$relationship.color ?? DefaultRelationshipColor;
  }
  get line() {
    return this.$relationship.line ?? DefaultLineStyle;
  }
  /**
   * Iterate over all views that include this relationship.
   */
  *views() {
    for (const view of this.model.views()) {
      if (view.includesRelation(this.id)) {
        yield view;
      }
    }
    return;
  }
  isDeploymentRelation() {
    return false;
  }
};
var EdgeModel = class {
  constructor(view, $edge, source, target) {
    this.view = view;
    this.$edge = $edge;
    this.source = source;
    this.target = target;
  }
  get id() {
    return this.$edge.id;
  }
  get parent() {
    return this.$edge.parent ? this.view.node(this.$edge.parent) : null;
  }
  get label() {
    return this.$edge.label;
  }
  get description() {
    return this.$edge.description ?? null;
  }
  get technology() {
    return this.$edge.technology ?? null;
  }
  hasParent() {
    return this.$edge.parent !== null;
  }
  get tags() {
    return this.$edge.tags ?? [];
  }
  get stepNumber() {
    return this.isStep() ? extractStep(this.id) : null;
  }
  get navigateTo() {
    return this.$edge.navigateTo ? this.view.$model.view(this.$edge.navigateTo) : null;
  }
  get color() {
    return this.$edge.color ?? "gray";
  }
  get line() {
    return this.$edge.line ?? "dashed";
  }
  isStep() {
    return isStepEdgeId(this.id);
  }
  *relationships(type) {
    for (const id of this.$edge.relations) {
      if (type) {
        const rel = this.view.$model.findRelationship(id, type);
        if (rel) {
          yield rel;
        }
      } else {
        yield this.view.$model.relationship(id);
      }
    }
    return;
  }
  includesRelation(rel) {
    return this.$edge.relations.includes(rel);
  }
};
var NodeModel = class {
  constructor($view, $node) {
    this.$view = $view;
    this.$node = $node;
  }
  get id() {
    return this.$node.id;
  }
  get title() {
    return this.$node.title;
  }
  get kind() {
    return this.$node.kind;
  }
  get description() {
    return this.$node.description;
  }
  get technology() {
    return this.$node.technology;
  }
  get parent() {
    return this.$node.parent ? this.$view.node(this.$node.parent) : null;
  }
  get element() {
    const modelRef = ComputedNode.modelRef(this.$node);
    return modelRef ? this.$view.$model.element(modelRef) : null;
  }
  get deployment() {
    const modelRef = ComputedNode.deploymentRef(this.$node);
    return modelRef ? this.$view.$model.deployment.element(modelRef) : null;
  }
  get shape() {
    return this.$node.shape;
  }
  get color() {
    return this.$node.color;
  }
  get icon() {
    return this.$node.icon ?? null;
  }
  get tags() {
    return this.$node.tags ?? [];
  }
  get links() {
    return this.$node.links ?? [];
  }
  get navigateTo() {
    return this.$node.navigateTo ? this.$view.$model.view(this.$node.navigateTo) : null;
  }
  get style() {
    return this.$node.style;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors() {
    let parent = this.parent;
    while (parent) {
      yield parent;
      parent = parent.parent;
    }
    return;
  }
  *children() {
    for (const child of this.$node.children) {
      yield this.$view.node(child);
    }
    return;
  }
  *sublings() {
    var _a;
    const sublings = ((_a = this.parent) == null ? void 0 : _a.children()) ?? this.$view.roots();
    for (const subling of sublings) {
      if (subling.id !== this.id) {
        yield subling;
      }
    }
    return;
  }
  *incoming(filter = "all") {
    for (const edgeId of this.$node.inEdges) {
      const edge = this.$view.edge(edgeId);
      switch (true) {
        case filter === "all":
        case (filter === "direct" && edge.target.id === this.id):
        case (filter === "to-descendants" && edge.target.id !== this.id):
          yield edge;
          break;
      }
    }
    return;
  }
  *incomers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r3 of this.incoming(filter)) {
      if (unique.has(r3.source.id)) {
        continue;
      }
      unique.add(r3.source.id);
      yield r3.source;
    }
    return;
  }
  *outgoing(filter = "all") {
    for (const edgeId of this.$node.outEdges) {
      const edge = this.$view.edge(edgeId);
      switch (true) {
        case filter === "all":
        case (filter === "direct" && edge.source.id === this.id):
        case (filter === "from-descendants" && edge.source.id !== this.id):
          yield edge;
          break;
      }
    }
    return;
  }
  *outgoers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r3 of this.outgoing(filter)) {
      if (unique.has(r3.target.id)) {
        continue;
      }
      unique.add(r3.target.id);
      yield r3.target;
    }
    return;
  }
  isDiagramNode() {
    return "width" in this.$node && "height" in this.$node;
  }
  hasChildren() {
    return this.$node.children.length > 0;
  }
  hasParent() {
    return this.$node.parent !== null;
  }
  /**
   * Check if this node references to logical model element.
   */
  hasElement() {
    return ComputedNode.modelRef(this.$node) !== null;
  }
  /**
   * Check if this node references to deployment element (Node or Instance).
   */
  hasDeployment() {
    return ComputedNode.deploymentRef(this.$node) !== null;
  }
  /**
   * Check if this node references to deployed instance
   * Deployed instance always references to element and deployment element.
   */
  hasDeployedInstance() {
    return this.hasElement() && this.hasDeployment();
  }
  isGroup() {
    return ComputedNode.isNodesGroup(this.$node);
  }
};
var _rootnodes, _nodes, _edges, _includeElements, _includeDeployments, _includeRelations, _allTags2;
var LikeC4ViewModel = class {
  constructor($model, $view) {
    __privateAdd(this, _rootnodes, /* @__PURE__ */ new Set());
    __privateAdd(this, _nodes, /* @__PURE__ */ new Map());
    __privateAdd(this, _edges, /* @__PURE__ */ new Map());
    __privateAdd(this, _includeElements, /* @__PURE__ */ new Set());
    __privateAdd(this, _includeDeployments, /* @__PURE__ */ new Set());
    __privateAdd(this, _includeRelations, /* @__PURE__ */ new Set());
    __privateAdd(this, _allTags2, new DefaultMap((_key) => /* @__PURE__ */ new Set()));
    this.$model = $model;
    this.$view = $view;
    for (const node of $view.nodes) {
      const el = new NodeModel(this, Object.freeze(node));
      __privateGet(this, _nodes).set(node.id, el);
      if (!node.parent) {
        __privateGet(this, _rootnodes).add(el);
      }
      if (el.hasDeployment()) {
        __privateGet(this, _includeDeployments).add(el.deployment.id);
      }
      if (el.hasElement()) {
        __privateGet(this, _includeElements).add(el.element.id);
      }
      for (const tag of el.tags) {
        __privateGet(this, _allTags2).get(tag).add(el);
      }
    }
    for (const edge of $view.edges) {
      const edgeModel = new EdgeModel(
        this,
        Object.freeze(edge),
        this.node(edge.source),
        this.node(edge.target)
      );
      for (const tag of edgeModel.tags) {
        __privateGet(this, _allTags2).get(tag).add(edgeModel);
      }
      for (const rel of edge.relations) {
        __privateGet(this, _includeRelations).add(rel);
      }
      __privateGet(this, _edges).set(edge.id, edgeModel);
    }
  }
  get __() {
    return this.$view.__ ?? "element";
  }
  get id() {
    return this.$view.id;
  }
  get title() {
    return this.$view.title;
  }
  get tags() {
    return this.$view.tags ?? [];
  }
  get links() {
    return this.$view.links ?? [];
  }
  get viewOf() {
    const v = this.$view;
    if (isScopedElementView(v)) {
      return this.$model.element(v.viewOf);
    }
    return null;
  }
  /**
   * All tags from nodes and edges.
   */
  get includedTags() {
    return [...__privateGet(this, _allTags2).keys()];
  }
  roots() {
    return __privateGet(this, _rootnodes).values();
  }
  /**
   * Iterate over all nodes that have children.
   */
  *compounds() {
    for (const node of __privateGet(this, _nodes).values()) {
      if (node.hasChildren()) {
        yield node;
      }
    }
    return;
  }
  /**
   * Get node by id.
   * @throws Error if node is not found.
   */
  node(node) {
    const nodeId = getId(node);
    return nonNullable(__privateGet(this, _nodes).get(nodeId), `Node ${nodeId} not found in view ${this.$view.id}`);
  }
  /**
   * Find node by id.
   */
  findNode(node) {
    return __privateGet(this, _nodes).get(getId(node)) ?? null;
  }
  findNodeWithElement(fqn) {
    const nd = ifind(__privateGet(this, _nodes).values(), (node) => {
      var _a;
      return ((_a = node.element) == null ? void 0 : _a.id) === fqn;
    }) ?? null;
    return nd && nd.hasElement() ? nd : null;
  }
  /**
   * Iterate over all nodes.
   */
  nodes() {
    return __privateGet(this, _nodes).values();
  }
  /**
   * Find edge by id.
   * @param edge Edge or id
   * @returns EdgeModel
   */
  edge(edge) {
    const edgeId = getId(edge);
    return nonNullable(__privateGet(this, _edges).get(edgeId), `Edge ${edgeId} not found in view ${this.$view.id}`);
  }
  findEdge(edge) {
    return __privateGet(this, _edges).get(getId(edge)) ?? null;
  }
  /**
   * Iterate over all edges.
   */
  edges() {
    return __privateGet(this, _edges).values();
  }
  /**
   * Iterate over all edges.
   */
  *edgesWithRelation(relation) {
    for (const edge of __privateGet(this, _edges).values()) {
      if (edge.includesRelation(relation)) {
        yield edge;
      }
    }
    return;
  }
  /**
   * Nodes that have references to elements from logical model.
   */
  *elements() {
    for (const node of __privateGet(this, _nodes).values()) {
      if (node.hasElement()) {
        yield node;
      }
    }
    return;
  }
  includesElement(elementId) {
    return __privateGet(this, _includeElements).has(elementId);
  }
  includesDeployment(deploymentId) {
    return __privateGet(this, _includeDeployments).has(deploymentId);
  }
  includesRelation(relationId) {
    return __privateGet(this, _includeRelations).has(relationId);
  }
  /**
   * Below are type guards.
   */
  isComputed() {
    return true;
  }
  isDiagram() {
    return "bounds" in this.$view;
  }
  isElementView() {
    return isElementView(this.$view);
  }
  isDeploymentView() {
    return isDeploymentView(this.$view);
  }
  isDynamicView() {
    return isDynamicView(this.$view);
  }
};
_rootnodes = new WeakMap();
_nodes = new WeakMap();
_edges = new WeakMap();
_includeElements = new WeakMap();
_includeDeployments = new WeakMap();
_includeRelations = new WeakMap();
_allTags2 = new WeakMap();
var _elements2, _parents2, _children2, _rootElements2, _relations2, _incoming2, _outgoing2, _internal2, _views, _allTags3;
var _LikeC4Model = class _LikeC4Model {
  constructor($model) {
    /**
     * Don't use in runtime, only for type inference
     */
    __publicField(this, "Aux", {});
    __privateAdd(this, _elements2, /* @__PURE__ */ new Map());
    // Parent element for given FQN
    __privateAdd(this, _parents2, /* @__PURE__ */ new Map());
    // Children elements for given FQN
    __privateAdd(this, _children2, new DefaultMap(() => /* @__PURE__ */ new Set()));
    __privateAdd(this, _rootElements2, /* @__PURE__ */ new Set());
    __privateAdd(this, _relations2, /* @__PURE__ */ new Map());
    // Incoming to an element or its descendants
    __privateAdd(this, _incoming2, new DefaultMap(() => /* @__PURE__ */ new Set()));
    // Outgoing from an element or its descendants
    __privateAdd(this, _outgoing2, new DefaultMap(() => /* @__PURE__ */ new Set()));
    // Relationships inside the element, among descendants
    __privateAdd(this, _internal2, new DefaultMap(() => /* @__PURE__ */ new Set()));
    __privateAdd(this, _views, /* @__PURE__ */ new Map());
    __privateAdd(this, _allTags3, new DefaultMap(
      () => /* @__PURE__ */ new Set()
    ));
    __publicField(this, "deployment");
    this.$model = $model;
    for (const element of r$3($model.elements)) {
      const el = this.addElement(element);
      for (const tag of el.tags) {
        __privateGet(this, _allTags3).get(tag).add(el);
      }
    }
    for (const [projectId, elements] of t$12($model.imports ?? {})) {
      for (const element of sortParentsFirst(elements)) {
        const el = this.addImportedElement(projectId, element);
        for (const tag of el.tags) {
          __privateGet(this, _allTags3).get(tag).add(el);
        }
      }
    }
    for (const relation of r$3($model.relations)) {
      const el = this.addRelation(relation);
      for (const tag of el.tags) {
        __privateGet(this, _allTags3).get(tag).add(el);
      }
    }
    this.deployment = new LikeC4DeploymentModel(this, $model.deployments);
    const views = C(
      r$3($model.views),
      m$1((a3, b) => compareNatural(a3.title ?? "untitled", b.title ?? "untitled"))
    );
    for (const view of views) {
      const vm = new LikeC4ViewModel(this, Object.freeze(view));
      __privateGet(this, _views).set(view.id, vm);
      for (const tag of vm.tags) {
        __privateGet(this, _allTags3).get(tag).add(vm);
      }
    }
  }
  /**
   * Computes views from the parsed model
   * Creates a new LikeC4Model instance from a parsed model.
   *
   * May throw an error if the model is invalid.
   *
   * @typeParam M - The type of the parsed LikeC4 model, must extend ParsedLikeC4Model
   * @param parsed - The parsed LikeC4 model to compute from
   * @returns A new LikeC4Model instance with computed relationships and structure
   */
  static compute(parsed) {
    let { views, ...rest } = parsed;
    const model = new _LikeC4Model({ ...rest, views: {} });
    return new _LikeC4Model({
      ...rest,
      views: i$3(views, (view) => unsafeComputeView(view, model))
    });
  }
  /**
   * Creates a function that computes a view using the data from the model.
   *
   * @example
   * const compute = LikeC4Model.makeCompute(parsedModel);
   * const result = compute(viewSource);
   */
  static makeCompute(parsed) {
    let { views, ...rest } = parsed;
    const model = new _LikeC4Model({ ...rest, views: {} });
    return (viewsource) => computeView(viewsource, model);
  }
  /**
   * Creates a new LikeC4Model instance from the provided model data.
   *
   * @typeParam M - Type parameter constrained to AnyLikeC4Model
   * @param model - The model data to create a LikeC4Model from
   * @returns A new LikeC4Model instance with the type derived from the input model
   */
  static create(model) {
    return new _LikeC4Model(model);
  }
  /**
   * Creates a new LikeC4Model instance from a model dump.
   *
   * @typeParam M - A constant type parameter extending LikeC4ModelDump
   * @param dump - The model dump to create the instance from
   * @returns A new LikeC4Model instance with types inferred from the dump
   */
  static fromDump(dump) {
    return new _LikeC4Model(dump);
  }
  get type() {
    return this.$model.__ ?? "computed";
  }
  element(el) {
    if (el instanceof ElementModel) {
      return el;
    }
    const id = getId(el);
    return nonNullable(this.findElement(id), `Element ${getId(el)} not found`);
  }
  findElement(el) {
    return __privateGet(this, _elements2).get(el) ?? null;
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return __privateGet(this, _rootElements2).values();
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return __privateGet(this, _elements2).values();
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return __privateGet(this, _relations2).values();
  }
  relationship(id, type) {
    if (type === "deployment") {
      return this.deployment.relationship(id);
    }
    let model = __privateGet(this, _relations2).get(id) ?? null;
    if (model || type === "model") {
      return nonNullable(model, `Model relation ${id} not found`);
    }
    return nonNullable(this.deployment.findRelationship(id), `No model/deployment relation ${id} not found`);
  }
  findRelationship(id, type) {
    if (type === "deployment") {
      return this.deployment.findRelationship(id);
    }
    let model = __privateGet(this, _relations2).get(id) ?? null;
    if (model || type === "model") {
      return model;
    }
    return this.deployment.findRelationship(id);
  }
  /**
   * Returns all views in the model.
   */
  views() {
    return __privateGet(this, _views).values();
  }
  /**
   * Returns a specific view by its ID.
   */
  view(viewId) {
    return nonNullable(__privateGet(this, _views).get(viewId), `View ${viewId} not found`);
  }
  findView(viewId) {
    return __privateGet(this, _views).get(viewId) ?? null;
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id = getId(element);
    return __privateGet(this, _parents2).get(id) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id = getId(element);
    return __privateGet(this, _children2).get(id);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  *siblings(element) {
    const id = getId(element);
    const parent = __privateGet(this, _parents2).get(id);
    const siblings = parent ? __privateGet(this, _children2).get(parent.id).values() : this.roots();
    for (const sibling of siblings) {
      if (sibling.id !== id) {
        yield sibling;
      }
    }
    return;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors(element) {
    let id = getId(element);
    let parent;
    while (parent = __privateGet(this, _parents2).get(id)) {
      yield parent;
      id = parent.id;
    }
    return;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  *descendants(element) {
    for (const child of this.children(element)) {
      yield child;
      yield* this.descendants(child.id);
    }
    return;
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  *incoming(element, filter = "all") {
    const id = getId(element);
    for (const rel of __privateGet(this, _incoming2).get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.target.id === id):
        case (filter === "to-descendants" && rel.target.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  *outgoing(element, filter = "all") {
    const id = getId(element);
    for (const rel of __privateGet(this, _outgoing2).get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.source.id === id):
        case (filter === "from-descendants" && rel.source.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  globals() {
    var _a, _b, _c;
    return {
      predicates: {
        ...(_a = this.$model.globals) == null ? void 0 : _a.predicates
      },
      dynamicPredicates: {
        ...(_b = this.$model.globals) == null ? void 0 : _b.dynamicPredicates
      },
      styles: {
        ...(_c = this.$model.globals) == null ? void 0 : _c.styles
      }
    };
  }
  allTags() {
    return Array.from(__privateGet(this, _allTags3).keys());
  }
  addElement(element) {
    if (__privateGet(this, _elements2).has(element.id)) {
      throw new Error(`Element ${element.id} already exists`);
    }
    const el = new ElementModel(this, Object.freeze(element));
    __privateGet(this, _elements2).set(el.id, el);
    const parentId = parentFqn(el.id);
    if (parentId) {
      invariant(__privateGet(this, _elements2).has(parentId), `Parent ${parentId} of ${el.id} not found`);
      __privateGet(this, _parents2).set(el.id, this.element(parentId));
      __privateGet(this, _children2).get(parentId).add(el);
    } else {
      __privateGet(this, _rootElements2).add(el);
    }
    return el;
  }
  addImportedElement(projectId, element) {
    invariant(!isGlobalFqn(element.id), `Imported element already has global FQN`);
    const id = GlobalFqn(projectId, element.id);
    if (__privateGet(this, _elements2).has(id)) {
      throw new Error(`Element ${id} already exists`);
    }
    const el = new ElementModel(
      this,
      Object.freeze({
        ...element,
        id
      })
    );
    __privateGet(this, _elements2).set(el.id, el);
    let parentId = parentFqn(el.id);
    while (parentId) {
      if (parentId.includes(".") && __privateGet(this, _elements2).has(parentId)) {
        __privateGet(this, _parents2).set(el.id, this.element(parentId));
        __privateGet(this, _children2).get(parentId).add(el);
        return el;
      }
      parentId = parentFqn(parentId);
    }
    __privateGet(this, _rootElements2).add(el);
    return el;
  }
  addRelation(relation) {
    if (__privateGet(this, _relations2).has(relation.id)) {
      throw new Error(`Relation ${relation.id} already exists`);
    }
    const rel = new RelationshipModel(
      this,
      Object.freeze(relation)
    );
    const { source, target } = rel;
    __privateGet(this, _relations2).set(rel.id, rel);
    __privateGet(this, _incoming2).get(target.id).add(rel);
    __privateGet(this, _outgoing2).get(source.id).add(rel);
    const relParent = commonAncestor(source.id, target.id);
    if (relParent) {
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)]) {
        __privateGet(this, _internal2).get(ancestor).add(rel);
      }
    }
    for (const sourceAncestor of ancestorsFqn(relation.source)) {
      if (sourceAncestor === relParent) {
        break;
      }
      __privateGet(this, _outgoing2).get(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(relation.target)) {
      if (targetAncestor === relParent) {
        break;
      }
      __privateGet(this, _incoming2).get(targetAncestor).add(rel);
    }
    return rel;
  }
};
_elements2 = new WeakMap();
_parents2 = new WeakMap();
_children2 = new WeakMap();
_rootElements2 = new WeakMap();
_relations2 = new WeakMap();
_incoming2 = new WeakMap();
_outgoing2 = new WeakMap();
_internal2 = new WeakMap();
_views = new WeakMap();
_allTags3 = new WeakMap();
var LikeC4Model = _LikeC4Model;
((LikeC4Model2) => {
  LikeC4Model2.EMPTY = LikeC4Model2.create({
    projectId: "default",
    specification: {
      elements: {},
      relationships: {},
      deployments: {},
      tags: []
    },
    globals: {
      predicates: {},
      dynamicPredicates: {},
      styles: {}
    },
    deployments: {
      elements: {},
      relations: {}
    },
    elements: {},
    relations: {},
    views: {},
    imports: {}
  });
})(LikeC4Model || (LikeC4Model = {}));

export {
  BorderStyles,
  ElementKind,
  ElementShapes,
  DefaultThemeColor,
  DefaultElementShape,
  DefaultShapeSize,
  DefaultPaddingSize,
  DefaultTextSize,
  AsFqn,
  GlobalFqn,
  isGlobalFqn,
  splitGlobalFqn,
  DeploymentElement,
  FqnRef,
  FqnExpr,
  RelationExpr,
  ExpressionV2,
  ModelLayer,
  isTagEqual,
  isKindEqual,
  isParticipantOperator,
  isNotOperator,
  isAndOperator,
  isOrOperator,
  whereOperatorAsPredicate,
  DefaultLineStyle,
  DefaultArrowType,
  DefaultRelationshipColor,
  isViewRulePredicate,
  isViewRuleGlobalPredicateRef,
  isViewRuleStyle,
  isViewRuleGlobalStyle,
  isAutoLayoutDirection,
  isViewRuleAutoLayout,
  isViewRuleGroup,
  isDynamicViewParallelSteps,
  isDeploymentView,
  isDynamicView,
  isElementView,
  isExtendsElementView,
  isScopedElementView,
  stepEdgeId,
  isStepEdgeId,
  extractStep,
  getParallelStepsPrefix,
  ComputedNode,
  ComputedView,
  getBBoxCenter,
  DiagramNode,
  ElementModel,
  Connection,
  DeploymentNodeModel,
  DeployedInstanceModel,
  DeploymentRelationModel,
  DeploymentConnectionModel,
  isNestedConnection,
  findDeepestNestedConnection,
  sortDeepestFirst,
  sortConnectionsByBoundaryHierarchy,
  findAscendingConnections,
  findDescendantConnections,
  mergeConnections,
  differenceConnections,
  hasSameSourceTarget,
  hasSameSource,
  hasSameTarget,
  isOutgoing,
  isIncoming,
  isAnyInOut,
  find$1,
  ConnectionModel,
  find,
  isDeploymentNode,
  isDeployedInstance,
  unsafeComputeView,
  computeView,
  computeViews,
  LikeC4DeploymentModel,
  RelationshipModel,
  EdgeModel,
  NodeModel,
  LikeC4ViewModel,
  LikeC4Model
};
//# sourceMappingURL=chunk-3V3NVM2A.js.map
