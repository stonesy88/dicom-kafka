import * as c4 from '@likec4/core';
import { Fqn, EdgeId, ComputedView, DiagramView, OverviewGraph, MultiMap as MultiMap$1, ProjectId, NonEmptyArray, NonEmptyReadonlyArray, LikeC4Model, ViewId, RelationId, ViewChange } from '@likec4/core';
import { Tagged, ValueOf, ConditionalPick, Writable, Simplify, MergeExclusive } from 'type-fest';
import picomatch from '/home/runner/work/likec4/likec4/node_modules/.pnpm/@types+picomatch@4.0.0/node_modules/@types/picomatch/posix.d.ts';
import { ProjectId as ProjectId$1, Fqn as Fqn$1 } from '@likec4/core/types';
import { DefaultWeakMap, MultiMap as MultiMap$2 } from '@likec4/core/utils';

/**
 * A tagging type for string properties that are actually document URIs.
 */
type DocumentUri$1 = string;
declare namespace DocumentUri$1 {
    function is(value: any): value is DocumentUri$1;
}
/**
 * A tagging type for string properties that are actually URIs
 *
 * @since 3.16.0
 */
type URI$1 = string;
declare namespace URI$1 {
    function is(value: any): value is URI$1;
}
/**
 * Defines an integer in the range of -2^31 to 2^31 - 1.
 */
type integer = number;
declare namespace integer {
    const MIN_VALUE = -2147483648;
    const MAX_VALUE = 2147483647;
    function is(value: any): value is integer;
}
/**
 * Defines an unsigned integer in the range of 0 to 2^31 - 1.
 */
type uinteger = number;
declare namespace uinteger {
    const MIN_VALUE = 0;
    const MAX_VALUE = 2147483647;
    function is(value: any): value is uinteger;
}
/**
 * Defines a decimal number. Since decimal numbers are very
 * rare in the language server specification we denote the
 * exact range with every decimal using the mathematics
 * interval notations (e.g. [0, 1] denotes all decimals d with
 * 0 <= d <= 1.
 */
type decimal = number;
/**
 * The LSP any type.
 *
 * In the current implementation we map LSPAny to any. This is due to the fact
 * that the TypeScript compilers can't infer string access signatures for
 * interface correctly (it can though for types). See the following issue for
 * details: https://github.com/microsoft/TypeScript/issues/15300.
 *
 * When the issue is addressed LSPAny can be defined as follows:
 *
 * ```ts
 * export type LSPAny = LSPObject | LSPArray | string | integer | uinteger | decimal | boolean | null | undefined;
 * export type LSPObject = { [key: string]: LSPAny };
 * export type LSPArray = LSPAny[];
 * ```
 *
 * Please note that strictly speaking a property with the value `undefined`
 * can't be converted into JSON preserving the property name. However for
 * convenience it is allowed and assumed that all these properties are
 * optional as well.
 *
 * @since 3.17.0
 */
type LSPAny = any;
type LSPObject = object;
/**
 * Position in a text document expressed as zero-based line and character
 * offset. Prior to 3.17 the offsets were always based on a UTF-16 string
 * representation. So a string of the form `a𐐀b` the character offset of the
 * character `a` is 0, the character offset of `𐐀` is 1 and the character
 * offset of b is 3 since `𐐀` is represented using two code units in UTF-16.
 * Since 3.17 clients and servers can agree on a different string encoding
 * representation (e.g. UTF-8). The client announces it's supported encoding
 * via the client capability [`general.positionEncodings`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#clientCapabilities).
 * The value is an array of position encodings the client supports, with
 * decreasing preference (e.g. the encoding at index `0` is the most preferred
 * one). To stay backwards compatible the only mandatory encoding is UTF-16
 * represented via the string `utf-16`. The server can pick one of the
 * encodings offered by the client and signals that encoding back to the
 * client via the initialize result's property
 * [`capabilities.positionEncoding`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#serverCapabilities). If the string value
 * `utf-16` is missing from the client's capability `general.positionEncodings`
 * servers can safely assume that the client supports UTF-16. If the server
 * omits the position encoding in its initialize result the encoding defaults
 * to the string value `utf-16`. Implementation considerations: since the
 * conversion from one encoding into another requires the content of the
 * file / line the conversion is best done where the file is read which is
 * usually on the server side.
 *
 * Positions are line end character agnostic. So you can not specify a position
 * that denotes `\r|\n` or `\n|` where `|` represents the character offset.
 *
 * @since 3.17.0 - support for negotiated position encoding.
 */
interface Position$1 {
    /**
     * Line position in a document (zero-based).
     *
     * If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.
     * If a line number is negative, it defaults to 0.
     */
    line: uinteger;
    /**
     * Character offset on a line in a document (zero-based).
     *
     * The meaning of this offset is determined by the negotiated
     * `PositionEncodingKind`.
     *
     * If the character value is greater than the line length it defaults back to the
     * line length.
     */
    character: uinteger;
}
/**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */
declare namespace Position$1 {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line: uinteger, character: uinteger): Position$1;
    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */
    function is(value: any): value is Position$1;
}
/**
 * A range in a text document expressed as (zero-based) start and end positions.
 *
 * If you want to specify a range that contains a line including the line ending
 * character(s) then use an end position denoting the start of the next line.
 * For example:
 * ```ts
 * {
 *     start: { line: 5, character: 23 }
 *     end : { line 6, character : 0 }
 * }
 * ```
 */
interface Range$1 {
    /**
     * The range's start position.
     */
    start: Position$1;
    /**
     * The range's end position.
     */
    end: Position$1;
}
/**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */
declare namespace Range$1 {
    /**
     * Create a new Range literal.
     * @param start The range's start position.
     * @param end The range's end position.
     */
    function create(start: Position$1, end: Position$1): Range$1;
    /**
     * Create a new Range literal.
     * @param startLine The start line number.
     * @param startCharacter The start character.
     * @param endLine The end line number.
     * @param endCharacter The end character.
     */
    function create(startLine: uinteger, startCharacter: uinteger, endLine: uinteger, endCharacter: uinteger): Range$1;
    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */
    function is(value: any): value is Range$1;
}
/**
 * Represents a location inside a resource, such as a line
 * inside a text file.
 */
interface Location {
    uri: DocumentUri$1;
    range: Range$1;
}
/**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */
declare namespace Location {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri: DocumentUri$1, range: Range$1): Location;
    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */
    function is(value: any): value is Location;
}
/**
     * Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},
     * including an origin range.
 */
interface LocationLink {
    /**
     * Span of the origin of this link.
     *
     * Used as the underlined span for mouse interaction. Defaults to the word range at
     * the definition position.
     */
    originSelectionRange?: Range$1;
    /**
     * The target resource identifier of this link.
     */
    targetUri: DocumentUri$1;
    /**
     * The full target range of this link. If the target for example is a symbol then target range is the
     * range enclosing this symbol not including leading/trailing whitespace but everything else
     * like comments. This information is typically used to highlight the range in the editor.
     */
    targetRange: Range$1;
    /**
     * The range that should be selected and revealed when this link is being followed, e.g the name of a function.
     * Must be contained by the `targetRange`. See also `DocumentSymbol#range`
     */
    targetSelectionRange: Range$1;
}
/**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */
declare namespace LocationLink {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri: DocumentUri$1, targetRange: Range$1, targetSelectionRange: Range$1, originSelectionRange?: Range$1): LocationLink;
    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */
    function is(value: any): value is LocationLink;
}
/**
 * Represents a color in RGBA space.
 */
interface Color {
    /**
     * The red component of this color in the range [0-1].
     */
    readonly red: decimal;
    /**
     * The green component of this color in the range [0-1].
     */
    readonly green: decimal;
    /**
     * The blue component of this color in the range [0-1].
     */
    readonly blue: decimal;
    /**
     * The alpha component of this color in the range [0-1].
     */
    readonly alpha: decimal;
}
/**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */
declare namespace Color {
    /**
     * Creates a new Color literal.
     */
    function create(red: decimal, green: decimal, blue: decimal, alpha: decimal): Color;
    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */
    function is(value: any): value is Color;
}
/**
 * Represents a color range from a document.
 */
interface ColorInformation {
    /**
     * The range in the document where this color appears.
     */
    range: Range$1;
    /**
     * The actual color value for this color range.
     */
    color: Color;
}
/**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */
declare namespace ColorInformation {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range: Range$1, color: Color): ColorInformation;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value: any): value is ColorInformation;
}
interface ColorPresentation {
    /**
     * The label of this color presentation. It will be shown on the color
     * picker header. By default this is also the text that is inserted when selecting
     * this color presentation.
     */
    label: string;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this presentation for the color.  When `falsy` the {@link ColorPresentation.label label}
     * is used.
     */
    textEdit?: TextEdit$1;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this color presentation. Edits must not overlap with the main {@link ColorPresentation.textEdit edit} nor with themselves.
     */
    additionalTextEdits?: TextEdit$1[];
}
/**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */
declare namespace ColorPresentation {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label: string, textEdit?: TextEdit$1, additionalTextEdits?: TextEdit$1[]): ColorPresentation;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value: any): value is ColorPresentation;
}
/**
 * A set of predefined range kinds.
 */
declare namespace FoldingRangeKind {
    /**
     * Folding range for a comment
     */
    const Comment = "comment";
    /**
     * Folding range for an import or include
     */
    const Imports = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    const Region = "region";
}
/**
 * A predefined folding range kind.
 *
 * The type is a string since the value set is extensible
 */
type FoldingRangeKind = string;
/**
 * Represents a folding range. To be valid, start and end line must be bigger than zero and smaller
 * than the number of lines in the document. Clients are free to ignore invalid ranges.
 */
interface FoldingRange {
    /**
     * The zero-based start line of the range to fold. The folded area starts after the line's last character.
     * To be valid, the end must be zero or larger and smaller than the number of lines in the document.
     */
    startLine: uinteger;
    /**
     * The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.
     */
    startCharacter?: uinteger;
    /**
     * The zero-based end line of the range to fold. The folded area ends with the line's last character.
     * To be valid, the end must be zero or larger and smaller than the number of lines in the document.
     */
    endLine: uinteger;
    /**
     * The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.
     */
    endCharacter?: uinteger;
    /**
     * Describes the kind of the folding range such as `comment' or 'region'. The kind
     * is used to categorize folding ranges and used by commands like 'Fold all comments'.
     * See {@link FoldingRangeKind} for an enumeration of standardized kinds.
     */
    kind?: FoldingRangeKind;
    /**
     * The text that the client should show when the specified range is
     * collapsed. If not defined or not supported by the client, a default
     * will be chosen by the client.
     *
     * @since 3.17.0
     */
    collapsedText?: string;
}
/**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */
declare namespace FoldingRange {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine: uinteger, endLine: uinteger, startCharacter?: uinteger, endCharacter?: uinteger, kind?: FoldingRangeKind, collapsedText?: string): FoldingRange;
    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */
    function is(value: any): value is FoldingRange;
}
/**
 * Represents a related message and source code location for a diagnostic. This should be
 * used to point to code locations that cause or related to a diagnostics, e.g when duplicating
 * a symbol in a scope.
 */
interface DiagnosticRelatedInformation {
    /**
     * The location of this related diagnostic information.
     */
    location: Location;
    /**
     * The message of this related diagnostic information.
     */
    message: string;
}
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */
declare namespace DiagnosticRelatedInformation {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location: Location, message: string): DiagnosticRelatedInformation;
    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */
    function is(value: any): value is DiagnosticRelatedInformation;
}
/**
 * The diagnostic's severity.
 */
declare namespace DiagnosticSeverity {
    /**
     * Reports an error.
     */
    const Error: 1;
    /**
     * Reports a warning.
     */
    const Warning: 2;
    /**
     * Reports an information.
     */
    const Information: 3;
    /**
     * Reports a hint.
     */
    const Hint: 4;
}
type DiagnosticSeverity = 1 | 2 | 3 | 4;
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
declare namespace DiagnosticTag {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    const Unnecessary: 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    const Deprecated: 2;
}
type DiagnosticTag = 1 | 2;
/**
 * Structure to capture a description for an error code.
 *
 * @since 3.16.0
 */
interface CodeDescription {
    /**
     * An URI to open with more information about the diagnostic error.
     */
    href: URI$1;
}
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
declare namespace CodeDescription {
    function is(value: any): value is CodeDescription;
}
/**
 * Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
 * are only valid in the scope of a resource.
 */
interface Diagnostic {
    /**
     * The range at which the message applies
     */
    range: Range$1;
    /**
     * The diagnostic's severity. Can be omitted. If omitted it is up to the
     * client to interpret diagnostics as error, warning, info or hint.
     */
    severity?: DiagnosticSeverity;
    /**
     * The diagnostic's code, which usually appear in the user interface.
     */
    code?: integer | string;
    /**
     * An optional property to describe the error code.
     * Requires the code field (above) to be present/not null.
     *
     * @since 3.16.0
     */
    codeDescription?: CodeDescription;
    /**
     * A human-readable string describing the source of this
     * diagnostic, e.g. 'typescript' or 'super lint'. It usually
     * appears in the user interface.
     */
    source?: string;
    /**
     * The diagnostic's message. It usually appears in the user interface
     */
    message: string;
    /**
     * Additional metadata about the diagnostic.
     *
     * @since 3.15.0
     */
    tags?: DiagnosticTag[];
    /**
     * An array of related diagnostic information, e.g. when symbol-names within
     * a scope collide all definitions can be marked via this property.
     */
    relatedInformation?: DiagnosticRelatedInformation[];
    /**
     * A data entry field that is preserved between a `textDocument/publishDiagnostics`
     * notification and `textDocument/codeAction` request.
     *
     * @since 3.16.0
     */
    data?: LSPAny;
}
/**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */
declare namespace Diagnostic {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range: Range$1, message: string, severity?: DiagnosticSeverity, code?: integer | string, source?: string, relatedInformation?: DiagnosticRelatedInformation[]): Diagnostic;
    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */
    function is(value: any): value is Diagnostic;
}
/**
 * Represents a reference to a command. Provides a title which
 * will be used to represent a command in the UI and, optionally,
 * an array of arguments which will be passed to the command handler
 * function when invoked.
 */
interface Command {
    /**
     * Title of the command, like `save`.
     */
    title: string;
    /**
     * The identifier of the actual command handler.
     */
    command: string;
    /**
     * Arguments that the command handler should be
     * invoked with.
     */
    arguments?: LSPAny[];
}
/**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */
declare namespace Command {
    /**
     * Creates a new Command literal.
     */
    function create(title: string, command: string, ...args: any[]): Command;
    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */
    function is(value: any): value is Command;
}
/**
 * A text edit applicable to a text document.
 */
interface TextEdit$1 {
    /**
     * The range of the text document to be manipulated. To insert
     * text into a document create a range where start === end.
     */
    range: Range$1;
    /**
     * The string to be inserted. For delete operations use an
     * empty string.
     */
    newText: string;
}
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
declare namespace TextEdit$1 {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range: Range$1, newText: string): TextEdit$1;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position: Position$1, newText: string): TextEdit$1;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range: Range$1): TextEdit$1;
    function is(value: any): value is TextEdit$1;
}
/**
 * Additional information that describes document changes.
 *
 * @since 3.16.0
 */
interface ChangeAnnotation {
    /**
     * A human-readable string describing the actual change. The string
     * is rendered prominent in the user interface.
     */
    label: string;
    /**
     * A flag which indicates that user confirmation is needed
     * before applying the change.
     */
    needsConfirmation?: boolean;
    /**
     * A human-readable string which is rendered less prominent in
     * the user interface.
     */
    description?: string;
}
declare namespace ChangeAnnotation {
    function create(label: string, needsConfirmation?: boolean, description?: string): ChangeAnnotation;
    function is(value: any): value is ChangeAnnotation;
}
declare namespace ChangeAnnotationIdentifier {
    function is(value: any): value is ChangeAnnotationIdentifier;
}
/**
 * An identifier to refer to a change annotation stored with a workspace edit.
 */
type ChangeAnnotationIdentifier = string;
/**
 * A special text edit with an additional change annotation.
 *
 * @since 3.16.0.
 */
interface AnnotatedTextEdit extends TextEdit$1 {
    /**
     * The actual identifier of the change annotation
     */
    annotationId: ChangeAnnotationIdentifier;
}
declare namespace AnnotatedTextEdit {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range: Range$1, newText: string, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position: Position$1, newText: string, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range: Range$1, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    function is(value: any): value is AnnotatedTextEdit;
}
/**
 * Describes textual changes on a text document. A TextDocumentEdit describes all changes
 * on a document version Si and after they are applied move the document to version Si+1.
 * So the creator of a TextDocumentEdit doesn't need to sort the array of edits or do any
 * kind of ordering. However the edits must be non overlapping.
 */
interface TextDocumentEdit {
    /**
     * The text document to change.
     */
    textDocument: OptionalVersionedTextDocumentIdentifier;
    /**
     * The edits to be applied.
     *
     * @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
     * client capability.
     */
    edits: (TextEdit$1 | AnnotatedTextEdit)[];
}
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
declare namespace TextDocumentEdit {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument: OptionalVersionedTextDocumentIdentifier, edits: (TextEdit$1 | AnnotatedTextEdit)[]): TextDocumentEdit;
    function is(value: any): value is TextDocumentEdit;
}
/**
 * A generic resource operation.
 */
interface ResourceOperation {
    /**
     * The resource operation kind.
     */
    kind: string;
    /**
     * An optional annotation identifier describing the operation.
     *
     * @since 3.16.0
     */
    annotationId?: ChangeAnnotationIdentifier;
}
/**
 * Options to create a file.
 */
interface CreateFileOptions {
    /**
     * Overwrite existing file. Overwrite wins over `ignoreIfExists`
     */
    overwrite?: boolean;
    /**
     * Ignore if exists.
     */
    ignoreIfExists?: boolean;
}
/**
 * Create file operation.
 */
interface CreateFile extends ResourceOperation {
    /**
     * A create
     */
    kind: 'create';
    /**
     * The resource to create.
     */
    uri: DocumentUri$1;
    /**
     * Additional options
     */
    options?: CreateFileOptions;
}
declare namespace CreateFile {
    function create(uri: DocumentUri$1, options?: CreateFileOptions, annotation?: ChangeAnnotationIdentifier): CreateFile;
    function is(value: any): value is CreateFile;
}
/**
 * Rename file options
 */
interface RenameFileOptions {
    /**
     * Overwrite target if existing. Overwrite wins over `ignoreIfExists`
     */
    overwrite?: boolean;
    /**
     * Ignores if target exists.
     */
    ignoreIfExists?: boolean;
}
/**
 * Rename file operation
 */
interface RenameFile extends ResourceOperation {
    /**
     * A rename
     */
    kind: 'rename';
    /**
     * The old (existing) location.
     */
    oldUri: DocumentUri$1;
    /**
     * The new location.
     */
    newUri: DocumentUri$1;
    /**
     * Rename options.
     */
    options?: RenameFileOptions;
}
declare namespace RenameFile {
    function create(oldUri: DocumentUri$1, newUri: DocumentUri$1, options?: RenameFileOptions, annotation?: ChangeAnnotationIdentifier): RenameFile;
    function is(value: any): value is RenameFile;
}
/**
 * Delete file options
 */
interface DeleteFileOptions {
    /**
     * Delete the content recursively if a folder is denoted.
     */
    recursive?: boolean;
    /**
     * Ignore the operation if the file doesn't exist.
     */
    ignoreIfNotExists?: boolean;
}
/**
 * Delete file operation
 */
interface DeleteFile extends ResourceOperation {
    /**
     * A delete
     */
    kind: 'delete';
    /**
     * The file to delete.
     */
    uri: DocumentUri$1;
    /**
     * Delete options.
     */
    options?: DeleteFileOptions;
}
declare namespace DeleteFile {
    function create(uri: DocumentUri$1, options?: DeleteFileOptions, annotation?: ChangeAnnotationIdentifier): DeleteFile;
    function is(value: any): value is DeleteFile;
}
/**
 * A workspace edit represents changes to many resources managed in the workspace. The edit
 * should either provide `changes` or `documentChanges`. If documentChanges are present
 * they are preferred over `changes` if the client can handle versioned document edits.
 *
 * Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
 * operations are present clients need to execute the operations in the order in which they
 * are provided. So a workspace edit for example can consist of the following two changes:
 * (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.
 *
 * An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
 * cause failure of the operation. How the client recovers from the failure is described by
 * the client capability: `workspace.workspaceEdit.failureHandling`
 */
interface WorkspaceEdit {
    /**
     * Holds changes to existing resources.
     */
    changes?: {
        [uri: DocumentUri]: TextEdit$1[];
    };
    /**
     * Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
     * are either an array of `TextDocumentEdit`s to express changes to n different text documents
     * where each text document edit addresses a specific version of a text document. Or it can contain
     * above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
     *
     * Whether a client supports versioned document edits is expressed via
     * `workspace.workspaceEdit.documentChanges` client capability.
     *
     * If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
     * only plain `TextEdit`s using the `changes` property are supported.
     */
    documentChanges?: (TextDocumentEdit | CreateFile | RenameFile | DeleteFile)[];
    /**
     * A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
     * delete file / folder operations.
     *
     * Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.
     *
     * @since 3.16.0
     */
    changeAnnotations?: {
        [id: ChangeAnnotationIdentifier]: ChangeAnnotation;
    };
}
declare namespace WorkspaceEdit {
    function is(value: any): value is WorkspaceEdit;
}
/**
 * A literal to identify a text document in the client.
 */
interface TextDocumentIdentifier {
    /**
     * The text document's uri.
     */
    uri: DocumentUri$1;
}
/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */
declare namespace TextDocumentIdentifier {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri: DocumentUri$1): TextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */
    function is(value: any): value is TextDocumentIdentifier;
}
/**
 * A text document identifier to denote a specific version of a text document.
 */
interface VersionedTextDocumentIdentifier extends TextDocumentIdentifier {
    /**
     * The version number of this document.
     */
    version: integer;
}
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */
declare namespace VersionedTextDocumentIdentifier {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri: DocumentUri$1, version: integer): VersionedTextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */
    function is(value: any): value is VersionedTextDocumentIdentifier;
}
/**
 * A text document identifier to optionally denote a specific version of a text document.
 */
interface OptionalVersionedTextDocumentIdentifier extends TextDocumentIdentifier {
    /**
     * The version number of this document. If a versioned text document identifier
     * is sent from the server to the client and the file is not open in the editor
     * (the server has not received an open notification before) the server can send
     * `null` to indicate that the version is unknown and the content on disk is the
     * truth (as specified with document content ownership).
     */
    version: integer | null;
}
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */
declare namespace OptionalVersionedTextDocumentIdentifier {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri: DocumentUri$1, version: integer | null): OptionalVersionedTextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */
    function is(value: any): value is OptionalVersionedTextDocumentIdentifier;
}
/**
 * An item to transfer a text document from the client to the
 * server.
 */
interface TextDocumentItem {
    /**
     * The text document's uri.
     */
    uri: DocumentUri$1;
    /**
     * The text document's language identifier.
     */
    languageId: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     */
    version: integer;
    /**
     * The content of the opened text document.
     */
    text: string;
}
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */
declare namespace TextDocumentItem {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri: DocumentUri$1, languageId: string, version: integer, text: string): TextDocumentItem;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */
    function is(value: any): value is TextDocumentItem;
}
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
declare namespace MarkupKind {
    /**
     * Plain text is supported as a content format
     */
    const PlainText: 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    const Markdown: 'markdown';
    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */
    function is(value: any): value is MarkupKind;
}
type MarkupKind = 'plaintext' | 'markdown';
/**
 * A `MarkupContent` literal represents a string value which content is interpreted base on its
 * kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.
 *
 * If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
 * See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
 *
 * Here is an example how such a string can be constructed using JavaScript / TypeScript:
 * ```ts
 * let markdown: MarkdownContent = {
 *  kind: MarkupKind.Markdown,
 *  value: [
 *    '# Header',
 *    'Some text',
 *    '```typescript',
 *    'someCode();',
 *    '```'
 *  ].join('\n')
 * };
 * ```
 *
 * *Please Note* that clients might sanitize the return markdown. A client could decide to
 * remove HTML from the markdown to avoid script execution.
 */
interface MarkupContent {
    /**
     * The type of the Markup
     */
    kind: MarkupKind;
    /**
     * The content itself
     */
    value: string;
}
declare namespace MarkupContent {
    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */
    function is(value: any): value is MarkupContent;
}
/**
 * The kind of a completion entry.
 */
declare namespace CompletionItemKind {
    const Text: 1;
    const Method: 2;
    const Function: 3;
    const Constructor: 4;
    const Field: 5;
    const Variable: 6;
    const Class: 7;
    const Interface: 8;
    const Module: 9;
    const Property: 10;
    const Unit: 11;
    const Value: 12;
    const Enum: 13;
    const Keyword: 14;
    const Snippet: 15;
    const Color: 16;
    const File: 17;
    const Reference: 18;
    const Folder: 19;
    const EnumMember: 20;
    const Constant: 21;
    const Struct: 22;
    const Event: 23;
    const Operator: 24;
    const TypeParameter: 25;
}
type CompletionItemKind = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25;
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
declare namespace InsertTextFormat {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    const PlainText: 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    const Snippet: 2;
}
type InsertTextFormat = 1 | 2;
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
declare namespace CompletionItemTag {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    const Deprecated = 1;
}
type CompletionItemTag = 1;
/**
 * A special text edit to provide an insert and a replace operation.
 *
 * @since 3.16.0
 */
interface InsertReplaceEdit {
    /**
     * The string to be inserted.
     */
    newText: string;
    /**
     * The range if the insert is requested
     */
    insert: Range$1;
    /**
     * The range if the replace is requested.
     */
    replace: Range$1;
}
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
declare namespace InsertReplaceEdit {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText: string, insert: Range$1, replace: Range$1): InsertReplaceEdit;
    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */
    function is(value: TextEdit$1 | InsertReplaceEdit): value is InsertReplaceEdit;
}
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
declare namespace InsertTextMode {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    const asIs: 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    const adjustIndentation: 2;
}
type InsertTextMode = 1 | 2;
/**
 * Additional details for a completion item label.
 *
 * @since 3.17.0
 */
interface CompletionItemLabelDetails {
    /**
     * An optional string which is rendered less prominently directly after {@link CompletionItem.label label},
     * without any spacing. Should be used for function signatures and type annotations.
     */
    detail?: string;
    /**
     * An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used
     * for fully qualified names and file paths.
     */
    description?: string;
}
declare namespace CompletionItemLabelDetails {
    function is(value: any): value is CompletionItemLabelDetails;
}
/**
 * A completion item represents a text snippet that is
 * proposed to complete text that is being typed.
 */
interface CompletionItem {
    /**
     * The label of this completion item.
     *
     * The label property is also by default the text that
     * is inserted when selecting this completion.
     *
     * If label details are provided the label itself should
     * be an unqualified name of the completion item.
     */
    label: string;
    /**
     * Additional details for the label
     *
     * @since 3.17.0
     */
    labelDetails?: CompletionItemLabelDetails;
    /**
     * The kind of this completion item. Based of the kind
     * an icon is chosen by the editor.
     */
    kind?: CompletionItemKind;
    /**
     * Tags for this completion item.
     *
     * @since 3.15.0
     */
    tags?: CompletionItemTag[];
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;
    /**
     * A human-readable string that represents a doc-comment.
     */
    documentation?: string | MarkupContent;
    /**
     * Indicates if this item is deprecated.
     * @deprecated Use `tags` instead.
     */
    deprecated?: boolean;
    /**
     * Select this item when showing.
     *
     * *Note* that only one completion item can be selected and that the
     * tool / client decides which item that is. The rule is that the *first*
     * item of those that match best is selected.
     */
    preselect?: boolean;
    /**
     * A string that should be used when comparing this item
     * with other items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    sortText?: string;
    /**
     * A string that should be used when filtering a set of
     * completion items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    filterText?: string;
    /**
     * A string that should be inserted into a document when selecting
     * this completion. When `falsy` the {@link CompletionItem.label label}
     * is used.
     *
     * The `insertText` is subject to interpretation by the client side.
     * Some tools might not take the string literally. For example
     * VS Code when code complete is requested in this example
     * `con<cursor position>` and a completion item with an `insertText` of
     * `console` is provided it will only insert `sole`. Therefore it is
     * recommended to use `textEdit` instead since it avoids additional client
     * side interpretation.
     */
    insertText?: string;
    /**
     * The format of the insert text. The format applies to both the
     * `insertText` property and the `newText` property of a provided
     * `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
     *
     * Please note that the insertTextFormat doesn't apply to
     * `additionalTextEdits`.
     */
    insertTextFormat?: InsertTextFormat;
    /**
     * How whitespace and indentation is handled during completion
     * item insertion. If not provided the clients default value depends on
     * the `textDocument.completion.insertTextMode` client capability.
     *
     * @since 3.16.0
     */
    insertTextMode?: InsertTextMode;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this completion. When an edit is provided the value of
     * {@link CompletionItem.insertText insertText} is ignored.
     *
     * Most editors support two different operations when accepting a completion
     * item. One is to insert a completion text and the other is to replace an
     * existing text with a completion text. Since this can usually not be
     * predetermined by a server it can report both ranges. Clients need to
     * signal support for `InsertReplaceEdits` via the
     * `textDocument.completion.insertReplaceSupport` client capability
     * property.
     *
     * *Note 1:* The text edit's range as well as both ranges from an insert
     * replace edit must be a [single line] and they must contain the position
     * at which completion has been requested.
     * *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range
     * must be a prefix of the edit's replace range, that means it must be
     * contained and starting at the same position.
     *
     * @since 3.16.0 additional type `InsertReplaceEdit`
     */
    textEdit?: TextEdit$1 | InsertReplaceEdit;
    /**
     * The edit text used if the completion item is part of a CompletionList and
     * CompletionList defines an item default for the text edit range.
     *
     * Clients will only honor this property if they opt into completion list
     * item defaults using the capability `completionList.itemDefaults`.
     *
     * If not provided and a list's default range is provided the label
     * property is used as a text.
     *
     * @since 3.17.0
     */
    textEditText?: string;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this completion. Edits must not overlap (including the same insert position)
     * with the main {@link CompletionItem.textEdit edit} nor with themselves.
     *
     * Additional text edits should be used to change text unrelated to the current cursor position
     * (for example adding an import statement at the top of the file if the completion item will
     * insert an unqualified type).
     */
    additionalTextEdits?: TextEdit$1[];
    /**
     * An optional set of characters that when pressed while this completion is active will accept it first and
     * then type that character. *Note* that all commit characters should have `length=1` and that superfluous
     * characters will be ignored.
     */
    commitCharacters?: string[];
    /**
     * An optional {@link Command command} that is executed *after* inserting this completion. *Note* that
     * additional modifications to the current document should be described with the
     * {@link CompletionItem.additionalTextEdits additionalTextEdits}-property.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a completion item between a
     * {@link CompletionRequest} and a {@link CompletionResolveRequest}.
     */
    data?: LSPAny;
}
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
declare namespace CompletionItem {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label: string): CompletionItem;
}
/**
 * Represents a collection of {@link CompletionItem completion items} to be presented
 * in the editor.
 */
interface CompletionList {
    /**
     * This list it not complete. Further typing results in recomputing this list.
     *
     * Recomputed lists have all their items replaced (not appended) in the
     * incomplete completion sessions.
     */
    isIncomplete: boolean;
    /**
     * In many cases the items of an actual completion result share the same
     * value for properties like `commitCharacters` or the range of a text
     * edit. A completion list can therefore define item defaults which will
     * be used if a completion item itself doesn't specify the value.
     *
     * If a completion list specifies a default value and a completion item
     * also specifies a corresponding value the one from the item is used.
     *
     * Servers are only allowed to return default values if the client
     * signals support for this via the `completionList.itemDefaults`
     * capability.
     *
     * @since 3.17.0
     */
    itemDefaults?: {
        /**
         * A default commit character set.
         *
         * @since 3.17.0
         */
        commitCharacters?: string[];
        /**
         * A default edit range.
         *
         * @since 3.17.0
         */
        editRange?: Range$1 | {
            insert: Range$1;
            replace: Range$1;
        };
        /**
         * A default insert text format.
         *
         * @since 3.17.0
         */
        insertTextFormat?: InsertTextFormat;
        /**
         * A default insert text mode.
         *
         * @since 3.17.0
         */
        insertTextMode?: InsertTextMode;
        /**
         * A default data value.
         *
         * @since 3.17.0
         */
        data?: LSPAny;
    };
    /**
     * The completion items.
     */
    items: CompletionItem[];
}
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
declare namespace CompletionList {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items?: CompletionItem[], isIncomplete?: boolean): CompletionList;
}
/**
 * MarkedString can be used to render human readable text. It is either a markdown string
 * or a code-block that provides a language and a code snippet. The language identifier
 * is semantically equal to the optional language identifier in fenced code blocks in GitHub
 * issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
 *
 * The pair of a language and a value is an equivalent to markdown:
 * ```${language}
 * ${value}
 * ```
 *
 * Note that markdown strings will be sanitized - that means html will be escaped.
 * @deprecated use MarkupContent instead.
 */
type MarkedString = string | {
    language: string;
    value: string;
};
declare namespace MarkedString {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText: string): string;
    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */
    function is(value: any): value is MarkedString;
}
/**
 * The result of a hover request.
 */
interface Hover {
    /**
     * The hover's content
     */
    contents: MarkupContent | MarkedString | MarkedString[];
    /**
     * An optional range inside the text document that is used to
     * visualize the hover, e.g. by changing the background color.
     */
    range?: Range$1;
}
declare namespace Hover {
    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */
    function is(value: any): value is Hover;
}
/**
 * Represents a parameter of a callable-signature. A parameter can
 * have a label and a doc-comment.
 */
interface ParameterInformation {
    /**
     * The label of this parameter information.
     *
     * Either a string or an inclusive start and exclusive end offsets within its containing
     * signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
     * string representation as `Position` and `Range` does.
     *
     * *Note*: a label of type string should be a substring of its containing signature label.
     * Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.
     */
    label: string | [uinteger, uinteger];
    /**
     * The human-readable doc-comment of this parameter. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | MarkupContent;
}
/**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */
declare namespace ParameterInformation {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label: string | [uinteger, uinteger], documentation?: string): ParameterInformation;
}
/**
 * Represents the signature of something callable. A signature
 * can have a label, like a function-name, a doc-comment, and
 * a set of parameters.
 */
interface SignatureInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string;
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | MarkupContent;
    /**
     * The parameters of this signature.
     */
    parameters?: ParameterInformation[];
    /**
     * The index of the active parameter.
     *
     * If provided, this is used in place of `SignatureHelp.activeParameter`.
     *
     * @since 3.16.0
     */
    activeParameter?: uinteger;
}
/**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */
declare namespace SignatureInformation {
    function create(label: string, documentation?: string, ...parameters: ParameterInformation[]): SignatureInformation;
}
/**
 * Signature help represents the signature of something
 * callable. There can be multiple signature but only one
 * active and only one active parameter.
 */
interface SignatureHelp {
    /**
     * One or more signatures.
     */
    signatures: SignatureInformation[];
    /**
     * The active signature. If omitted or the value lies outside the
     * range of `signatures` the value defaults to zero or is ignored if
     * the `SignatureHelp` has no signatures.
     *
     * Whenever possible implementors should make an active decision about
     * the active signature and shouldn't rely on a default value.
     *
     * In future version of the protocol this property might become
     * mandatory to better express this.
     */
    activeSignature?: uinteger;
    /**
     * The active parameter of the active signature. If omitted or the value
     * lies outside the range of `signatures[activeSignature].parameters`
     * defaults to 0 if the active signature has parameters. If
     * the active signature has no parameters it is ignored.
     * In future version of the protocol this property might become
     * mandatory to better express the active parameter if the
     * active signature does have any.
     */
    activeParameter?: uinteger;
}
/**
 * The definition of a symbol represented as one or many {@link Location locations}.
 * For most programming languages there is only one location at which a symbol is
 * defined.
 *
 * Servers should prefer returning `DefinitionLink` over `Definition` if supported
 * by the client.
 */
type Definition = Location | Location[];
/**
 * Information about where a symbol is defined.
 *
 * Provides additional metadata over normal {@link Location location} definitions, including the range of
 * the defining symbol
 */
type DefinitionLink = LocationLink;
/**
 * The declaration of a symbol representation as one or many {@link Location locations}.
 */
type Declaration = Location | Location[];
/**
 * Information about where a symbol is declared.
 *
 * Provides additional metadata over normal {@link Location location} declarations, including the range of
 * the declaring symbol.
 *
 * Servers should prefer returning `DeclarationLink` over `Declaration` if supported
 * by the client.
 */
type DeclarationLink = LocationLink;
/**
 * Value-object that contains additional information when
 * requesting references.
 */
interface ReferenceContext {
    /**
     * Include the declaration of the current symbol.
     */
    includeDeclaration: boolean;
}
/**
 * A document highlight kind.
 */
declare namespace DocumentHighlightKind {
    /**
     * A textual occurrence.
     */
    const Text: 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    const Read: 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    const Write: 3;
}
type DocumentHighlightKind = 1 | 2 | 3;
/**
 * A document highlight is a range inside a text document which deserves
 * special attention. Usually a document highlight is visualized by changing
 * the background color of its range.
 */
interface DocumentHighlight {
    /**
     * The range this highlight applies to.
     */
    range: Range$1;
    /**
     * The highlight kind, default is {@link DocumentHighlightKind.Text text}.
     */
    kind?: DocumentHighlightKind;
}
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */
declare namespace DocumentHighlight {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range: Range$1, kind?: DocumentHighlightKind): DocumentHighlight;
}
/**
 * A symbol kind.
 */
declare namespace SymbolKind {
    const File: 1;
    const Module: 2;
    const Namespace: 3;
    const Package: 4;
    const Class: 5;
    const Method: 6;
    const Property: 7;
    const Field: 8;
    const Constructor: 9;
    const Enum: 10;
    const Interface: 11;
    const Function: 12;
    const Variable: 13;
    const Constant: 14;
    const String: 15;
    const Number: 16;
    const Boolean: 17;
    const Array: 18;
    const Object: 19;
    const Key: 20;
    const Null: 21;
    const EnumMember: 22;
    const Struct: 23;
    const Event: 24;
    const Operator: 25;
    const TypeParameter: 26;
}
type SymbolKind = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26;
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
declare namespace SymbolTag {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    const Deprecated: 1;
}
type SymbolTag = 1;
/**
 * A base for all symbol information.
 */
interface BaseSymbolInformation {
    /**
     * The name of this symbol.
     */
    name: string;
    /**
     * The kind of this symbol.
     */
    kind: SymbolKind;
    /**
     * Tags for this symbol.
     *
     * @since 3.16.0
     */
    tags?: SymbolTag[];
    /**
     * The name of the symbol containing this symbol. This information is for
     * user interface purposes (e.g. to render a qualifier in the user interface
     * if necessary). It can't be used to re-infer a hierarchy for the document
     * symbols.
     */
    containerName?: string;
}
/**
 * Represents information about programming constructs like variables, classes,
 * interfaces etc.
 */
interface SymbolInformation extends BaseSymbolInformation {
    /**
     * Indicates if this symbol is deprecated.
     *
     * @deprecated Use tags instead
     */
    deprecated?: boolean;
    /**
     * The location of this symbol. The location's range is used by a tool
     * to reveal the location in the editor. If the symbol is selected in the
     * tool the range's start information is used to position the cursor. So
     * the range usually spans more than the actual symbol's name and does
     * normally include things like visibility modifiers.
     *
     * The range doesn't have to denote a node range in the sense of an abstract
     * syntax tree. It can therefore not be used to re-construct a hierarchy of
     * the symbols.
     */
    location: Location;
}
declare namespace SymbolInformation {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name: string, kind: SymbolKind, range: Range$1, uri: DocumentUri$1, containerName?: string): SymbolInformation;
}
/**
 * A special workspace symbol that supports locations without a range.
 *
 * See also SymbolInformation.
 *
 * @since 3.17.0
 */
interface WorkspaceSymbol extends BaseSymbolInformation {
    /**
     * The location of the symbol. Whether a server is allowed to
     * return a location without a range depends on the client
     * capability `workspace.symbol.resolveSupport`.
     *
     * See SymbolInformation#location for more details.
     */
    location: Location | {
        uri: DocumentUri$1;
    };
    /**
     * A data entry field that is preserved on a workspace symbol between a
     * workspace symbol request and a workspace symbol resolve request.
     */
    data?: LSPAny;
}
declare namespace WorkspaceSymbol {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name: string, kind: SymbolKind, uri: DocumentUri$1, range?: Range$1): WorkspaceSymbol;
}
/**
 * Represents programming constructs like variables, classes, interfaces etc.
 * that appear in a document. Document symbols can be hierarchical and they
 * have two ranges: one that encloses its definition and one that points to
 * its most interesting range, e.g. the range of an identifier.
 */
interface DocumentSymbol {
    /**
     * The name of this symbol. Will be displayed in the user interface and therefore must not be
     * an empty string or a string only consisting of white spaces.
     */
    name: string;
    /**
     * More detail for this symbol, e.g the signature of a function.
     */
    detail?: string;
    /**
     * The kind of this symbol.
     */
    kind: SymbolKind;
    /**
     * Tags for this document symbol.
     *
     * @since 3.16.0
     */
    tags?: SymbolTag[];
    /**
     * Indicates if this symbol is deprecated.
     *
     * @deprecated Use tags instead
     */
    deprecated?: boolean;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace but everything else
     * like comments. This information is typically used to determine if the clients cursor is
     * inside the symbol to reveal in the symbol in the UI.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
     * Must be contained by the `range`.
     */
    selectionRange: Range$1;
    /**
     * Children of this symbol, e.g. properties of a class.
     */
    children?: DocumentSymbol[];
}
declare namespace DocumentSymbol {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name: string, detail: string | undefined, kind: SymbolKind, range: Range$1, selectionRange: Range$1, children?: DocumentSymbol[]): DocumentSymbol;
    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */
    function is(value: any): value is DocumentSymbol;
}
/**
 * The kind of a code action.
 *
 * Kinds are a hierarchical list of identifiers separated by `.`, e.g. `"refactor.extract.function"`.
 *
 * The set of kinds is open and client needs to announce the kinds it supports to the server during
 * initialization.
 */
type CodeActionKind = string;
/**
 * A set of predefined code action kinds
 */
declare namespace CodeActionKind {
    /**
     * Empty kind.
     */
    const Empty: '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    const QuickFix: 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    const Refactor: 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    const RefactorExtract: 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    const RefactorInline: 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    const RefactorRewrite: 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    const Source: 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    const SourceOrganizeImports: 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    const SourceFixAll: 'source.fixAll';
}
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
declare namespace CodeActionTriggerKind {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    const Invoked: 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    const Automatic: 2;
}
type CodeActionTriggerKind = 1 | 2;
/**
 * Contains additional diagnostic information about the context in which
 * a {@link CodeActionProvider.provideCodeActions code action} is run.
 */
interface CodeActionContext {
    /**
     * An array of diagnostics known on the client side overlapping the range provided to the
     * `textDocument/codeAction` request. They are provided so that the server knows which
     * errors are currently presented to the user for the given range. There is no guarantee
     * that these accurately reflect the error state of the resource. The primary parameter
     * to compute code actions is the provided range.
     */
    diagnostics: Diagnostic[];
    /**
     * Requested kind of actions to return.
     *
     * Actions not of this kind are filtered out by the client before being shown. So servers
     * can omit computing them.
     */
    only?: CodeActionKind[];
    /**
     * The reason why code actions were requested.
     *
     * @since 3.17.0
     */
    triggerKind?: CodeActionTriggerKind;
}
/**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */
declare namespace CodeActionContext {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics: Diagnostic[], only?: CodeActionKind[], triggerKind?: CodeActionTriggerKind): CodeActionContext;
    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */
    function is(value: any): value is CodeActionContext;
}
/**
 * A code action represents a change that can be performed in code, e.g. to fix a problem or
 * to refactor code.
 *
 * A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.
 */
interface CodeAction {
    /**
     * A short, human-readable, title for this code action.
     */
    title: string;
    /**
     * The kind of the code action.
     *
     * Used to filter code actions.
     */
    kind?: CodeActionKind;
    /**
     * The diagnostics that this code action resolves.
     */
    diagnostics?: Diagnostic[];
    /**
     * Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
     * by keybindings.
     *
     * A quick fix should be marked preferred if it properly addresses the underlying error.
     * A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
     *
     * @since 3.15.0
     */
    isPreferred?: boolean;
    /**
     * Marks that the code action cannot currently be applied.
     *
     * Clients should follow the following guidelines regarding disabled code actions:
     *
     *   - Disabled code actions are not shown in automatic [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
     *     code action menus.
     *
     *   - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type
     *     of code action, such as refactorings.
     *
     *   - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
     *     that auto applies a code action and only disabled code actions are returned, the client should show the user an
     *     error message with `reason` in the editor.
     *
     * @since 3.16.0
     */
    disabled?: {
        /**
         * Human readable description of why the code action is currently disabled.
         *
         * This is displayed in the code actions UI.
         */
        reason: string;
    };
    /**
     * The workspace edit this code action performs.
     */
    edit?: WorkspaceEdit;
    /**
     * A command this code action executes. If a code action
     * provides an edit and a command, first the edit is
     * executed and then the command.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a code action between
     * a `textDocument/codeAction` and a `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    data?: LSPAny;
}
declare namespace CodeAction {
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param kind The kind of the code action.
     */
    function create(title: string, kind?: CodeActionKind): CodeAction;
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param command The command to execute.
     * @param kind The kind of the code action.
     */
    function create(title: string, command: Command, kind?: CodeActionKind): CodeAction;
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param edit The edit to perform.
     * @param kind The kind of the code action.
     */
    function create(title: string, edit: WorkspaceEdit, kind?: CodeActionKind): CodeAction;
    function is(value: any): value is CodeAction;
}
/**
 * A code lens represents a {@link Command command} that should be shown along with
 * source text, like the number of references, a way to run tests, etc.
 *
 * A code lens is _unresolved_ when no command is associated to it. For performance
 * reasons the creation of a code lens and resolving should be done in two stages.
 */
interface CodeLens {
    /**
     * The range in which this code lens is valid. Should only span a single line.
     */
    range: Range$1;
    /**
     * The command this code lens represents.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a code lens item between
     * a {@link CodeLensRequest} and a {@link CodeLensResolveRequest}
     */
    data?: LSPAny;
}
/**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */
declare namespace CodeLens {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range: Range$1, data?: LSPAny): CodeLens;
    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */
    function is(value: any): value is CodeLens;
}
/**
 * Value-object describing what options formatting should use.
 */
interface FormattingOptions {
    /**
     * Size of a tab in spaces.
     */
    tabSize: uinteger;
    /**
     * Prefer spaces over tabs.
     */
    insertSpaces: boolean;
    /**
     * Trim trailing whitespace on a line.
     *
     * @since 3.15.0
     */
    trimTrailingWhitespace?: boolean;
    /**
     * Insert a newline character at the end of the file if one does not exist.
     *
     * @since 3.15.0
     */
    insertFinalNewline?: boolean;
    /**
     * Trim all newlines after the final newline at the end of the file.
     *
     * @since 3.15.0
     */
    trimFinalNewlines?: boolean;
    /**
     * Signature for further properties.
     */
    [key: string]: boolean | integer | string | undefined;
}
/**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */
declare namespace FormattingOptions {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize: uinteger, insertSpaces: boolean): FormattingOptions;
    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */
    function is(value: any): value is FormattingOptions;
}
/**
 * A document link is a range in a text document that links to an internal or external resource, like another
 * text document or a web site.
 */
interface DocumentLink {
    /**
     * The range this link applies to.
     */
    range: Range$1;
    /**
     * The uri this link points to. If missing a resolve request is sent later.
     */
    target?: URI$1;
    /**
     * The tooltip text when you hover over this link.
     *
     * If a tooltip is provided, is will be displayed in a string that includes instructions on how to
     * trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
     * user settings, and localization.
     *
     * @since 3.15.0
     */
    tooltip?: string;
    /**
     * A data entry field that is preserved on a document link between a
     * DocumentLinkRequest and a DocumentLinkResolveRequest.
     */
    data?: LSPAny;
}
/**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */
declare namespace DocumentLink {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range: Range$1, target?: string, data?: LSPAny): DocumentLink;
    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */
    function is(value: any): value is DocumentLink;
}
/**
 * A selection range represents a part of a selection hierarchy. A selection range
 * may have a parent selection range that contains it.
 */
interface SelectionRange {
    /**
     * The {@link Range range} of this selection range.
     */
    range: Range$1;
    /**
     * The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.
     */
    parent?: SelectionRange;
}
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
declare namespace SelectionRange {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range: Range$1, parent?: SelectionRange): SelectionRange;
    function is(value: any): value is SelectionRange;
}
/**
 * Represents programming constructs like functions or constructors in the context
 * of call hierarchy.
 *
 * @since 3.16.0
 */
interface CallHierarchyItem {
    /**
     * The name of this item.
     */
    name: string;
    /**
     * The kind of this item.
     */
    kind: SymbolKind;
    /**
     * Tags for this item.
     */
    tags?: SymbolTag[];
    /**
     * More detail for this item, e.g. the signature of a function.
     */
    detail?: string;
    /**
     * The resource identifier of this item.
     */
    uri: DocumentUri$1;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
     * Must be contained by the {@link CallHierarchyItem.range `range`}.
     */
    selectionRange: Range$1;
    /**
     * A data entry field that is preserved between a call hierarchy prepare and
     * incoming calls or outgoing calls requests.
     */
    data?: LSPAny;
}
/**
 * Represents an incoming call, e.g. a caller of a method or constructor.
 *
 * @since 3.16.0
 */
interface CallHierarchyIncomingCall {
    /**
     * The item that makes the call.
     */
    from: CallHierarchyItem;
    /**
     * The ranges at which the calls appear. This is relative to the caller
     * denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
     */
    fromRanges: Range$1[];
}
/**
 * Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
 *
 * @since 3.16.0
 */
interface CallHierarchyOutgoingCall {
    /**
     * The item that is called.
     */
    to: CallHierarchyItem;
    /**
     * The range at which this item is called. This is the range relative to the caller, e.g the item
     * passed to {@link CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls `provideCallHierarchyOutgoingCalls`}
     * and not {@link CallHierarchyOutgoingCall.to `this.to`}.
     */
    fromRanges: Range$1[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensLegend {
    /**
     * The token types a server uses.
     */
    tokenTypes: string[];
    /**
     * The token modifiers a server uses.
     */
    tokenModifiers: string[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokens {
    /**
     * An optional result id. If provided and clients support delta updating
     * the client will include the result id in the next semantic token request.
     * A server can then instead of computing all semantic tokens again simply
     * send a delta.
     */
    resultId?: string;
    /**
     * The actual tokens.
     */
    data: uinteger[];
}
/**
 * @since 3.16.0
 */
declare namespace SemanticTokens {
    function is(value: any): value is SemanticTokens;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensEdit {
    /**
     * The start offset of the edit.
     */
    start: uinteger;
    /**
     * The count of elements to remove.
     */
    deleteCount: uinteger;
    /**
     * The elements to insert.
     */
    data?: uinteger[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDelta {
    readonly resultId?: string;
    /**
     * The semantic token edits to transform a previous result into a new result.
     */
    edits: SemanticTokensEdit[];
}
/**
 * @since 3.17.0
 */
type TypeHierarchyItem = {
    /**
     * The name of this item.
     */
    name: string;
    /**
     * The kind of this item.
     */
    kind: SymbolKind;
    /**
     * Tags for this item.
     */
    tags?: SymbolTag[];
    /**
     * More detail for this item, e.g. the signature of a function.
     */
    detail?: string;
    /**
     * The resource identifier of this item.
     */
    uri: DocumentUri$1;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace
     * but everything else, e.g. comments and code.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being
     * picked, e.g. the name of a function. Must be contained by the
     * {@link TypeHierarchyItem.range `range`}.
     */
    selectionRange: Range$1;
    /**
     * A data entry field that is preserved between a type hierarchy prepare and
     * supertypes or subtypes requests. It could also be used to identify the
     * type hierarchy in the server, helping improve the performance on
     * resolving supertypes and subtypes.
     */
    data?: LSPAny;
};
/**
 * Provide inline value as text.
 *
 * @since 3.17.0
 */
type InlineValueText = {
    /**
     * The document range for which the inline value applies.
     */
    range: Range$1;
    /**
     * The text of the inline value.
     */
    text: string;
};
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
declare namespace InlineValueText {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range: Range$1, text: string): InlineValueText;
    function is(value: InlineValue | undefined | null): value is InlineValueText;
}
/**
 * Provide inline value through a variable lookup.
 * If only a range is specified, the variable name will be extracted from the underlying document.
 * An optional variable name can be used to override the extracted name.
 *
 * @since 3.17.0
 */
type InlineValueVariableLookup = {
    /**
     * The document range for which the inline value applies.
     * The range is used to extract the variable name from the underlying document.
     */
    range: Range$1;
    /**
     * If specified the name of the variable to look up.
     */
    variableName?: string;
    /**
     * How to perform the lookup.
     */
    caseSensitiveLookup: boolean;
};
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
declare namespace InlineValueVariableLookup {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range: Range$1, variableName: string | undefined, caseSensitiveLookup: boolean): InlineValueVariableLookup;
    function is(value: InlineValue | undefined | null): value is InlineValueVariableLookup;
}
/**
 * Provide an inline value through an expression evaluation.
 * If only a range is specified, the expression will be extracted from the underlying document.
 * An optional expression can be used to override the extracted expression.
 *
 * @since 3.17.0
 */
type InlineValueEvaluatableExpression = {
    /**
     * The document range for which the inline value applies.
     * The range is used to extract the evaluatable expression from the underlying document.
     */
    range: Range$1;
    /**
     * If specified the expression overrides the extracted expression.
     */
    expression?: string;
};
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
declare namespace InlineValueEvaluatableExpression {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range: Range$1, expression: string | undefined): InlineValueEvaluatableExpression;
    function is(value: InlineValue | undefined | null): value is InlineValueEvaluatableExpression;
}
/**
 * Inline value information can be provided by different means:
 * - directly as a text value (class InlineValueText).
 * - as a name to use for a variable lookup (class InlineValueVariableLookup)
 * - as an evaluatable expression (class InlineValueEvaluatableExpression)
 * The InlineValue types combines all inline value types into one type.
 *
 * @since 3.17.0
 */
type InlineValue = InlineValueText | InlineValueVariableLookup | InlineValueEvaluatableExpression;
/**
 * @since 3.17.0
 */
type InlineValueContext = {
    /**
     * The stack frame (as a DAP Id) where the execution has stopped.
     */
    frameId: integer;
    /**
     * The document range where execution has stopped.
     * Typically the end position of the range denotes the line where the inline values are shown.
     */
    stoppedLocation: Range$1;
};
/**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */
declare namespace InlineValueContext {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId: integer, stoppedLocation: Range$1): InlineValueContext;
    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */
    function is(value: any): value is InlineValueContext;
}
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
declare namespace InlayHintKind {
    /**
     * An inlay hint that for a type annotation.
     */
    const Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    const Parameter = 2;
    function is(value: number): value is InlayHintKind;
}
type InlayHintKind = 1 | 2;
/**
 * An inlay hint label part allows for interactive and composite labels
 * of inlay hints.
 *
 * @since 3.17.0
 */
type InlayHintLabelPart = {
    /**
     * The value of this label part.
     */
    value: string;
    /**
     * The tooltip text when you hover over this label part. Depending on
     * the client capability `inlayHint.resolveSupport` clients might resolve
     * this property late using the resolve request.
     */
    tooltip?: string | MarkupContent;
    /**
     * An optional source code location that represents this
     * label part.
     *
     * The editor will use this location for the hover and for code navigation
     * features: This part will become a clickable link that resolves to the
     * definition of the symbol at the given location (not necessarily the
     * location itself), it shows the hover that shows at the given location,
     * and it shows a context menu with further code navigation commands.
     *
     * Depending on the client capability `inlayHint.resolveSupport` clients
     * might resolve this property late using the resolve request.
     */
    location?: Location;
    /**
     * An optional command for this label part.
     *
     * Depending on the client capability `inlayHint.resolveSupport` clients
     * might resolve this property late using the resolve request.
     */
    command?: Command;
};
declare namespace InlayHintLabelPart {
    function create(value: string): InlayHintLabelPart;
    function is(value: any): value is InlayHintLabelPart;
}
/**
 * Inlay hint information.
 *
 * @since 3.17.0
 */
type InlayHint = {
    /**
     * The position of this hint.
     */
    position: Position$1;
    /**
     * The label of this hint. A human readable string or an array of
     * InlayHintLabelPart label parts.
     *
     * *Note* that neither the string nor the label part can be empty.
     */
    label: string | InlayHintLabelPart[];
    /**
     * The kind of this hint. Can be omitted in which case the client
     * should fall back to a reasonable default.
     */
    kind?: InlayHintKind;
    /**
     * Optional text edits that are performed when accepting this inlay hint.
     *
     * *Note* that edits are expected to change the document so that the inlay
     * hint (or its nearest variant) is now part of the document and the inlay
     * hint itself is now obsolete.
     */
    textEdits?: TextEdit$1[];
    /**
     * The tooltip text when you hover over this item.
     */
    tooltip?: string | MarkupContent;
    /**
     * Render padding before the hint.
     *
     * Note: Padding should use the editor's background color, not the
     * background color of the hint itself. That means padding can be used
     * to visually align/separate an inlay hint.
     */
    paddingLeft?: boolean;
    /**
     * Render padding after the hint.
     *
     * Note: Padding should use the editor's background color, not the
     * background color of the hint itself. That means padding can be used
     * to visually align/separate an inlay hint.
     */
    paddingRight?: boolean;
    /**
     * A data entry field that is preserved on an inlay hint between
     * a `textDocument/inlayHint` and a `inlayHint/resolve` request.
     */
    data?: LSPAny;
};
declare namespace InlayHint {
    function create(position: Position$1, label: string | InlayHintLabelPart[], kind?: InlayHintKind): InlayHint;
    function is(value: any): value is InlayHint;
}
/**
 * A workspace folder inside a client.
 */
interface WorkspaceFolder {
    /**
     * The associated URI for this workspace folder.
     */
    uri: URI$1;
    /**
     * The name of the workspace folder. Used to refer to this
     * workspace folder in the user interface.
     */
    name: string;
}
declare namespace WorkspaceFolder {
    function is(value: any): value is WorkspaceFolder;
}

type ParserMethod<ARGS extends unknown[], R> = (...args: ARGS) => R;

/**
 * This class does not actually exist nor is exposed at runtime.
 * This is just a helper to avoid duplications in the Type Definitions
 * Of `CstParser` and `EmbeddedActionsParser`
 */
declare abstract class BaseParser$2 {
  /**
   * This must be called at the end of a Parser constructor.
   * See: http://chevrotain.io/docs/tutorial/step2_parsing.html#under-the-hood
   */
  protected performSelfAnalysis(): void;

  /**
   * It is recommended to reuse the same Parser instance
   * by passing an empty array to the input argument
   * and only later setting the input by using the input property.
   * See: http://chevrotain.io/docs/FAQ.html#major-performance-benefits
   *
   * @param tokenVocabulary - A data structure containing all the Tokens used by the Parser.
   * @param config - The Parser's configuration.
   */
  constructor(tokenVocabulary: TokenVocabulary, config?: IParserConfig);

  errors: IRecognitionException[];

  /**
   * Flag indicating the Parser is at the recording phase.
   * Can be used to implement methods similar to {@link BaseParser.ACTION}
   * Or any other logic to requires knowledge of the recording phase.
   * See:
   *   - https://chevrotain.io/docs/guide/internals.html#grammar-recording
   * to learn more on the recording phase and how Chevrotain works.
   */
  RECORDING_PHASE: boolean;

  /**
   * Resets the parser state, should be overridden for custom parsers which "carry" additional state.
   * When overriding, remember to also invoke the super implementation!
   */
  reset(): void;

  getBaseCstVisitorConstructor<IN = any, OUT = any>(): {
    new (...args: any[]): ICstVisitor<IN, OUT>;
  };

  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(): {
    new (...args: any[]): ICstVisitor<IN, OUT>;
  };

  getGAstProductions(): Record<string, Rule>;

  getSerializedGastProductions(): ISerializedGast[];

  /**
   * @param startRuleName
   * @param precedingInput - The token vector up to (not including) the content assist point
   */
  computeContentAssist(
    startRuleName: string,
    precedingInput: IToken[],
  ): ISyntacticContentAssistPath[];

  /**
   * @param grammarRule - The rule to try and parse in backtracking mode.
   * @param args - argument to be passed to the grammar rule execution
   *
   * @return a lookahead function that will try to parse the given grammarRule and will return true if succeed.
   */
  protected BACKTRACK<T>(
    grammarRule: (...args: any[]) => T,
    args?: any[],
  ): () => boolean;

  /**
   * The Semantic Actions wrapper.
   * Should be used to wrap semantic actions that either:
   * - May fail when executing in "recording phase".
   * - Have global side effects that should be avoided during "recording phase".
   *
   * For more information see:
   *   - https://chevrotain.io/docs/guide/internals.html#grammar-recording
   */
  protected ACTION<T>(impl: () => T): T;

  /**
   * Like `CONSUME` with the numerical suffix as a parameter, e.g:
   * consume(0, X) === CONSUME(X)
   * consume(1, X) === CONSUME1(X)
   * consume(2, X) === CONSUME2(X)
   * ...
   * @see CONSUME
   */
  protected consume(
    idx: number,
    tokType: TokenType,
    options?: ConsumeMethodOpts,
  ): IToken;

  /**
   * Like `OPTION` with the numerical suffix as a parameter, e.g:
   * option(0, X) === OPTION(X)
   * option(1, X) === OPTION1(X)
   * option(2, X) === OPTION2(X)
   * ...
   * @see OPTION
   */
  protected option<OUT>(
    idx: number,
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * Like `OR` with the numerical suffix as a parameter, e.g:
   * or(0, X) === OR(X)
   * or(1, X) === OR1(X)
   * or(2, X) === OR2(X)
   * ...
   * @see OR
   */
  protected or(idx: number, altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;
  protected or<T>(idx: number, altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;

  /**
   * Like `MANY` with the numerical suffix as a parameter, e.g:
   * many(0, X) === MANY(X)
   * many(1, X) === MANY1(X)
   * many(2, X) === MANY2(X)
   * ...
   * @see MANY
   */
  protected many(
    idx: number,
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * Like `AT_LEAST_ONE` with the numerical suffix as a parameter, e.g:
   * atLeastOne(0, X) === AT_LEAST_ONE(X)
   * atLeastOne(1, X) === AT_LEAST_ONE1(X)
   * atLeastOne(2, X) === AT_LEAST_ONE2(X)
   * ...
   * @see AT_LEAST_ONE
   */
  protected atLeastOne(
    idx: number,
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   *
   * A Parsing DSL method use to consume a single Token.
   * In EBNF terms this is equivalent to a Terminal.
   *
   * A Token will be consumed, IFF the next token in the token vector matches `tokType`.
   * otherwise the parser may attempt to perform error recovery (if enabled).
   *
   * The index in the method name indicates the unique occurrence of a terminal consumption
   * inside a the top level rule. What this means is that if a terminal appears
   * more than once in a single rule, each appearance must have a **different** index.
   *
   * For example:
   * ```
   *   this.RULE("qualifiedName", () => {
   *   this.CONSUME1(Identifier);
   *     this.MANY(() => {
   *       this.CONSUME1(Dot);
   *       // here we use CONSUME2 because the terminal
   *       // 'Identifier' has already appeared previously in the
   *       // the rule 'parseQualifiedName'
   *       this.CONSUME2(Identifier);
   *     });
   *   })
   * ```
   *
   * - See more details on the [unique suffixes requirement](http://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES).
   *
   * @param tokType - The Type of the token to be consumed.
   * @param options - optional properties to modify the behavior of CONSUME.
   */
  protected CONSUME(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME1(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME2(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME3(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME4(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME5(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME6(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME7(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME8(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME9(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * Parsing DSL Method that Indicates an Optional production.
   * in EBNF notation this is equivalent to: "[...]".
   *
   * Note that there are two syntax forms:
   * - Passing the grammar action directly:
   *   ```
   *     this.OPTION(() => {
   *       this.CONSUME(Digit)}
   *     );
   *   ```
   *
   * - using an "options" object:
   *   ```
   *     this.OPTION({
   *       GATE:predicateFunc,
   *       DEF: () => {
   *         this.CONSUME(Digit)
   *     }});
   *   ```
   *
   * The optional 'GATE' property in "options" object form can be used to add constraints
   * to invoking the grammar action.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the optional production in it's top rule.
   *
   * @param  actionORMethodDef - The grammar action to optionally invoke once
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   * @returns The `GrammarAction` return value (OUT) if the optional syntax is encountered
   *          or `undefined` if not.
   */
  protected OPTION<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION1<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION2<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION3<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION4<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION5<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION6<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION7<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION8<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION9<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * Parsing DSL method that indicates a choice between a set of alternatives must be made.
   * This is equivalent to an EBNF alternation (A | B | C | D ...), except
   * that the alternatives are ordered like in a PEG grammar.
   * This means that the **first** matching alternative is always chosen.
   *
   * There are several forms for the inner alternatives array:
   *
   * - Passing alternatives array directly:
   *   ```
   *     this.OR([
   *       { ALT:() => { this.CONSUME(One) }},
   *       { ALT:() => { this.CONSUME(Two) }},
   *       { ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - Passing alternative array directly with predicates (GATE):
   *   ```
   *     this.OR([
   *       { GATE: predicateFunc1, ALT:() => { this.CONSUME(One) }},
   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Two) }},
   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - These syntax forms can also be mixed:
   *   ```
   *     this.OR([
   *       {
   *         GATE: predicateFunc1,
   *         ALT:() => { this.CONSUME(One) }
   *       },
   *       { ALT:() => { this.CONSUME(Two) }},
   *       { ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - Additionally an "options" object may be used:
   *   ```
   *     this.OR({
   *       DEF:[
   *         { ALT:() => { this.CONSUME(One) }},
   *         { ALT:() => { this.CONSUME(Two) }},
   *         { ALT:() => { this.CONSUME(Three) }}
   *       ],
   *       // OPTIONAL property
   *       ERR_MSG: "A Number"
   *     })
   *   ```
   *
   * The 'predicateFuncX' in the long form can be used to add constraints to choosing the alternative.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the alternation production in it's top rule.
   *
   * @param altsOrOpts - A set of alternatives or an "OPTIONS" object describing the alternatives and optional properties.
   *
   * @returns The result of invoking the chosen alternative.
   */
  protected OR<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR1<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR1(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR2<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR2(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR3<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR3(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR4<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR4(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR5<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR5(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR6<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR6(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR7<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR7(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR8<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR8(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR9<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR9(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * Parsing DSL method, that indicates a repetition of zero or more.
   * This is equivalent to EBNF repetition \{...\}.
   *
   * Note that there are two syntax forms:
   * - Passing the grammar action directly:
   *   ```
   *     this.MANY(() => {
   *       this.CONSUME(Comma)
   *       this.CONSUME(Digit)
   *      })
   *   ```
   *
   * - using an "options" object:
   *   ```
   *     this.MANY({
   *       GATE: predicateFunc,
   *       DEF: () => {
   *              this.CONSUME(Comma)
   *              this.CONSUME(Digit)
   *            }
   *     });
   *   ```
   *
   * The optional 'GATE' property in "options" object form can be used to add constraints
   * to invoking the grammar action.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the repetition production in it's top rule.
   *
   * @param actionORMethodDef - The grammar action to optionally invoke multiple times
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   */
  protected MANY(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY1(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY2(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY3(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY4(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY5(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY6(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY7(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY8(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY9(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * Parsing DSL method, that indicates a repetition of zero or more with a separator
   * Token between the repetitions.
   *
   * Example:
   *
   * ```
   *     this.MANY_SEP({
   *         SEP:Comma,
   *         DEF: () => {
   *             this.CONSUME(Number};
   *             // ...
   *         })
   * ```
   *
   * Note that because this DSL method always requires more than one argument the options object is always required
   * and it is not possible to use a shorter form like in the MANY DSL method.
   *
   * Note that for the purposes of deciding on whether or not another iteration exists
   * Only a single Token is examined (The separator). Therefore if the grammar being implemented is
   * so "crazy" to require multiple tokens to identify an item separator please use the more basic DSL methods
   * to implement it.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the repetition production in it's top rule.
   *
   * @param options - An object defining the grammar of each iteration and the separator between iterations
   *
   */
  protected MANY_SEP(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP1(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP2(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP3(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP4(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP5(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP6(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP7(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP8(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP9(options: ManySepMethodOpts<any>): void;

  /**
   * Convenience method, same as MANY but the repetition is of one or more.
   * failing to match at least one repetition will result in a parsing error and
   * cause a parsing error.
   *
   * @see MANY
   *
   * @param actionORMethodDef  - The grammar action to optionally invoke multiple times
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   */
  protected AT_LEAST_ONE(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE1(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE2(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE3(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE4(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE5(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE6(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE7(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE8(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE9(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * Convenience method, same as MANY_SEP but the repetition is of one or more.
   * failing to match at least one repetition will result in a parsing error and
   * cause the parser to attempt error recovery.
   *
   * Note that an additional optional property ERR_MSG can be used to provide custom error messages.
   *
   * @see MANY_SEP
   *
   * @param options - An object defining the grammar of each iteration and the separator between iterations
   *
   * @return {ISeparatedIterationResult<OUT>}
   */
  protected AT_LEAST_ONE_SEP(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP1(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP2(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP3(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP4(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP5(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP6(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP7(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP8(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP9(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * Returns an "imaginary" Token to insert when Single Token Insertion is done
   * Override this if you require special behavior in your grammar.
   * For example if an IntegerToken is required provide one with the image '0' so it would be valid syntactically.
   */
  protected getTokenToInsert(tokType: TokenType): IToken;

  /**
   * By default, all tokens type may be inserted. This behavior may be overridden in inheriting Recognizers
   * for example: One may decide that only punctuation tokens may be inserted automatically as they have no additional
   * semantic value. (A mandatory semicolon has no additional semantic meaning, but an Integer may have additional meaning
   * depending on its int value and context (Inserting an integer 0 in cardinality: "[1..]" will cause semantic issues
   * as the max of the cardinality will be greater than the min value (and this is a false error!).
   */
  protected canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean;

  /**
   * By default, all token types may be deleted. This behavior may be overridden in inheriting parsers.
   * The method receives the expected token type. The token that would be deleted can be received with {@link LA}.
   */
  protected canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean;

  /**
   * @deprecated - will be removed in the future
   */
  protected getNextPossibleTokenTypes(
    grammarPath: ITokenGrammarPath,
  ): TokenType[];

  input: IToken[];

  /**
   * Will consume a single token and return the **next** token, meaning
   * the token **after** the skipped token.
   */
  protected SKIP_TOKEN(): IToken;

  /**
   * Look-Ahead for the Token Vector
   * LA(1) is the next Token ahead.
   * LA(n) is the nth Token ahead.
   * LA(0) is the previously consumed Token.
   *
   * Looking beyond the end of the Token Vector or before its begining
   * will return in an IToken of type EOF {@link EOF}.
   * This behavior can be used to avoid infinite loops.
   *
   * This is often used to implement custom lookahead logic for GATES.
   * https://chevrotain.io/docs/features/gates.html
   */
  protected LA(howMuch: number): IToken;
}

/**
 * A Parser that relies on end user's embedded actions to control its output.
 * For more details see:
 *   - https://chevrotain.io/docs/tutorial/step3_adding_actions_root.html#alternatives
 *   - https://chevrotain.io/docs/tutorial/step3b_adding_actions_embedded.html#simple-example
 */
declare class EmbeddedActionsParser extends BaseParser$2 {
  /**
   * Creates a Grammar Rule
   *
   * Note that any parameters of your implementation must be optional as it will
   * be called without parameters during the grammar recording phase.
   */
  protected RULE<F extends (...args: any[]) => any>(
    name: string,
    implementation: F,
    config?: IRuleConfig<ReturnType<F>>,
  ): ParserMethod<Parameters<F>, ReturnType<F>>;

  /**
   * Overrides a Grammar Rule
   * See usage example in: https://github.com/chevrotain/chevrotain/blob/master/examples/parser/versioning/versioning.js
   */
  protected OVERRIDE_RULE<F extends (...args: any[]) => any>(
    name: string,
    implementation: F,
    config?: IRuleConfig<ReturnType<F>>,
  ): ParserMethod<Parameters<F>, ReturnType<F>>;

  /**
   * Like `SUBRULE` with the numerical suffix as a parameter, e.g:
   * subrule(0, X) === SUBRULE(X)
   * subrule(1, X) === SUBRULE1(X)
   * subrule(2, X) === SUBRULE2(X)
   * ...
   * @see SUBRULE
   */
  protected subrule<ARGS extends unknown[], R>(
    idx: number,
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * The Parsing DSL Method is used by one rule to call another.
   * It is equivalent to a non-Terminal in EBNF notation.
   *
   * This may seem redundant as it does not actually do much.
   * However using it is **mandatory** for all sub rule invocations.
   *
   * Calling another rule without wrapping in SUBRULE(...)
   * will cause errors/mistakes in the Parser's self analysis phase,
   * which will lead to errors in error recovery/automatic lookahead calculation
   * and any other functionality relying on the Parser's self analysis
   * output.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the sub rule invocation in its rule.
   *
   */
  protected SUBRULE<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE1<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE2<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE3<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE4<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE5<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE6<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE7<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE8<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE9<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;
}

interface ILexingError {
  offset: number;
  line: number | undefined;
  column: number | undefined;
  length: number;
  message: string;
}

interface ILexerErrorMessageProvider {
  /**
   * An Unexpected Character Error occurs when the lexer is unable to match a range of one or more
   * characters in the input text against any of the Token Types in it's Lexer definition
   *
   * @param fullText - Full original input text.
   *
   * @param startOffset - Offset in input text where error starts.
   *
   * @param length - Error length.
   *
   * @param line - Line number where the error occurred. (optional)
   *                    Will not be provided when lexer is not defined to track lines/columns
   *
   * @param column - Column number where the error occurred. (optional)
   *                    Will not be provided when lexer is not defined to track lines/columns
   */
  buildUnexpectedCharactersMessage(
    fullText: string,
    startOffset: number,
    length: number,
    line?: number,
    column?: number,
  ): string;

  /**
   * Unable To Pop Lexer Mode Error happens when lexer tries to pop the last remaining mode from the mode stack
   * so that there is no longer any active lexer mode
   * This error only relevant for multi-mode lexers
   *
   * @param token - The Token that requested pop mode.
   */
  buildUnableToPopLexerModeMessage(token: IToken): string;
}

type TokenPattern =
  | RegExp
  | string
  | CustomPatternMatcherFunc
  | ICustomPattern;

/**
 *  API #1 [Custom Token Patterns](http://chevrotain.io/docs/guide/custom_token_patterns.html).
 */
declare type CustomPatternMatcherFunc = (
  /**
   * The full input string.
   */
  text: string,
  /**
   * The offset at which to attempt a match
   */
  offset: number,
  /**
   * Previously scanned Tokens
   */
  tokens: IToken[],
  /**
   * Token Groups
   */
  groups: {
    [groupName: string]: IToken[];
  },
) => CustomPatternMatcherReturn | RegExpExecArray | null; // RegExpExecArray included for legacy reasons

type CustomPatternMatcherReturn = [string] & { payload?: any };

interface TokenType {
  name: string;
  GROUP?: string;
  PATTERN?: TokenPattern;
  LABEL?: string;
  LONGER_ALT?: TokenType | TokenType[];
  POP_MODE?: boolean;
  PUSH_MODE?: string;
  LINE_BREAKS?: boolean;
  CATEGORIES?: TokenType[];
  tokenTypeIdx?: number;
  categoryMatches?: number[];
  categoryMatchesMap?: {
    [tokType: number]: boolean;
  };
  isParent?: boolean;
  START_CHARS_HINT?: (string | number)[];
}

/**
 *  API #2 for [Custom Token Patterns](http://chevrotain.io/docs/guide/custom_token_patterns.html).
 */
interface ICustomPattern {
  exec: CustomPatternMatcherFunc;
}

/**
 * Things to note:
 *  - The offset range is inclusive to exclusive.
 *
 * - A lineTerminator as the last character does not effect the Token's line numbering.
 *   In other words a new line only starts **after** a line terminator.
 *
 * - A Token's image is it's **literal** text.
 *   e.g unicode escaping is untouched.
 */
interface IToken {
  /** The textual representation of the Token as it appeared in the text. */
  image: string;
  /** Offset of the first character of the Token. 0-indexed. */
  startOffset: number;
  /** Line of the first character of the Token. 1-indexed. */
  startLine?: number;
  /**
   * Column of the first character of the Token. 1-indexed.
   *
   * For token foo in the following line, startColumn will be 3 and endColumn will be 5.
   * ```
   * a foo
   * 123456
   * ```
   */
  startColumn?: number;
  /**
   * Offset of the last character of the Token. 0-indexed.
   * Note that this points at the last character, not the end of the token, so the original image would be
   * `input.substring(token.startOffset, token.endOffset + 1)`.
   */
  endOffset?: number;
  /** Line of the last character of the Token. 1-indexed. Will be the same as startLine for single-line tokens.*/
  endLine?: number;
  /** Column of the last character of the Token. 1-indexed. See also startColumn. */
  endColumn?: number;
  /** this marks if a Token does not really exist and has been inserted "artificially" during parsing in rule error recovery. */
  isInsertedInRecovery?: boolean;
  /** An number index representing the type of the Token use <getTokenConstructor> to get the Token Type from a token "instance"  */
  tokenTypeIdx: number;
  /**
   * The actual Token Type of this Token "instance"
   * This is the same Object returned by the "createToken" API.
   * This property is very useful for debugging the Lexing and Parsing phases.
   */
  tokenType: TokenType;

  /**
   * Custom Payload value, this is an optional feature of Custom Token Patterns
   * For additional details see the docs:
   * https://chevrotain.io/docs/guide/custom_token_patterns.html#custom-payloads
   */
  payload?: any;
}

declare type MultiModesDefinition = {
  [modeName: string]: TokenType[];
};

interface IMultiModeLexerDefinition {
  modes: MultiModesDefinition;
  defaultMode: string;
}

type TokenTypeDictionary = { [tokenName: string]: TokenType };

declare type TokenVocabulary =
  | TokenTypeDictionary
  | TokenType[]
  | IMultiModeLexerDefinition;

interface IRuleConfig<T> {
  /**
   * The function which will be invoked to produce the returned value for a production that have not been
   * successfully executed and the parser recovered from.
   */
  recoveryValueFunc?: (e: IRecognitionException) => T;
  /**
   * Enable/Disable re-sync error recovery for this specific production.
   */
  resyncEnabled?: boolean;
}

interface DSLMethodOpts<T> {
  /**
   * The Grammar to process in this method.
   */
  DEF: GrammarAction<T>;
  /**
   * A semantic constraint on this DSL method
   * @see https://github.com/chevrotain/chevrotain/blob/master/examples/parser/predicate_lookahead/predicate_lookahead.js
   * For farther details.
   */
  GATE?: () => boolean;

  /**
   * Maximum number of "following tokens" which would be used to
   * Choose between the alternatives.
   *
   * By default this value is determined by the {@link IParserConfig.maxLookahead} value.
   * A Higher value may be used for a specific DSL method to resolve ambiguities
   * And a lower value may be used to resolve slow initialization times issues.
   *
   * TODO: create full docs and link
   */
  MAX_LOOKAHEAD?: number;
}

interface DSLMethodOptsWithErr<T> extends DSLMethodOpts<T> {
  /**
   *  Short title/classification to what is being matched.
   *  Will be used in the error message,.
   *  If none is provided, the error message will include the names of the expected
   *  Tokens sequences which start the method's inner grammar
   */
  ERR_MSG?: string;
}

interface OrMethodOpts<T> {
  /**
   * The set of alternatives,
   * See detailed description in {@link BaseParser.OR}
   */
  DEF: IOrAlt<T>[];
  /**
   * A description for the alternatives used in error messages
   * If none is provided, the error message will include the names of the expected
   * Tokens sequences which may start each alternative.
   */
  ERR_MSG?: string;

  /**
   * A Flag indicating that **all** ambiguities in this alternation should
   * be ignored.
   *
   * This flag should only be used in rare circumstances,
   * As normally alternation ambiguities should be resolved in other ways:
   * - Re-ordering the alternatives.
   * - Re-factoring the grammar to extract common prefixes before alternation.
   * - Using gates {@link IOrAlt.GATE} to implement custom lookahead logic.
   * - Using the more granular {@link IOrAlt.IGNORE_AMBIGUITIES} on a **specific** alternative.
   */
  IGNORE_AMBIGUITIES?: boolean;

  /**
   * Maximum number of "following tokens" which would be used to
   * Choose between the alternatives.
   *
   * By default this value is determined by the {@link IParserConfig.maxLookahead} value.
   * A Higher value may be used for a specific DSL method to resolve ambiguities
   * And a lower value may be used to resolve slow initialization times issues.
   *
   * TODO: create full docs and link
   */
  MAX_LOOKAHEAD?: number;
}

interface ManySepMethodOpts<T> {
  /**
   * The grammar to process in each iteration.
   */
  DEF: GrammarAction<T>;
  /**
   * The separator between each iteration.
   */
  SEP: TokenType;

  /**
   * @see DSLMethodOpts.MAX_LOOKAHEAD
   */
  MAX_LOOKAHEAD?: number;
}

interface AtLeastOneSepMethodOpts<T> extends ManySepMethodOpts<T> {
  /**
   *  Short title/classification to what is being matched.
   *  Will be used in the error message,.
   *  If none is provided, the error message will include the names of the expected
   *  Tokens sequences which start the method's inner grammar.
   */
  ERR_MSG?: string;
}

interface ConsumeMethodOpts {
  /**
   *  A custom Error message if the Token could not be consumed.
   *  This will override any error message provided by the parser's "errorMessageProvider"
   */
  ERR_MSG?: string;
  /**
   * A label to be used instead of the TokenType name in the created CST.
   */
  LABEL?: string;
}

interface SubruleMethodOpts<ARGS> {
  /**
   * The arguments to parameterized rules, see:
   * https://github.com/chevrotain/chevrotain/blob/master/examples/parser/parametrized_rules/parametrized.js
   */
  ARGS?: ARGS;
  /**
   * A label to be used instead of the subrule's name in the created CST.
   */
  LABEL?: string;
}

declare type GrammarAction<OUT> = () => OUT;

interface IOrAlt<T> {
  GATE?: () => boolean;
  ALT: () => T;
  /**
   * A Flag indicating that any ambiguities involving this
   * specific alternative Should be ignored.
   *
   * This flag will be **implicitly** enabled if a GATE is used
   * as the assumption is that the GATE is used to resolve an ambiguity.
   */
  IGNORE_AMBIGUITIES?: boolean;
}

interface ICstVisitor<IN, OUT> {
  visit(cstNode: CstNode$1 | CstNode$1[], param?: IN): OUT;

  /**
   * Will throw an error if the visitor is missing any required methods
   * - `visitXYZ` for each `XYZ` grammar rule.
   */
  validateVisitor(): void;
}

/**
 * A [Concrete Syntax Tree](http://chevrotain.io/docs/guide/concrete_syntax_tree.html) Node.
 * This structure represents the whole parse tree of the grammar
 * This means that information on each and every Token is present.
 * This is unlike an AST (Abstract Syntax Tree) where some of the syntactic information is missing.
 *
 * For example given an ECMAScript grammar, an AST would normally not contain information on the location
 * of Commas, Semi colons, redundant parenthesis ect, however a CST would have that information.
 */
interface CstNode$1 {
  readonly name: string;
  readonly children: CstChildrenDictionary;
  /**
   * A flag indicating the whole CSTNode has been recovered during **re-sync** error recovery.
   * This means that some of the node's children may be missing.
   * - Note that single token insertion/deletion recovery would not activate this flag.
   *   This flag would only be activated in **re-sync** recovery when the rule's
   *   grammar cannot be fully parsed.
   * - See: https://chevrotain.io/docs/tutorial/step4_fault_tolerance.html
   *   for more info on error recovery and fault tolerance.
   */
  readonly recoveredNode?: boolean;

  /**
   * Will only be present if the {@link IParserConfig.nodeLocationTracking} is
   * **not** set to "none".
   * See: https://chevrotain.io/docs/guide/concrete_syntax_tree.html#cstnodes-location
   * For more details.
   */
  readonly location?: CstNodeLocation;
}

/**
 *  The Column/Line properties will only be present when
 *  The {@link IParserConfig.nodeLocationTracking} is set to "full".
 */
interface CstNodeLocation {
  startOffset: number;
  startLine?: number;
  startColumn?: number;
  endOffset?: number;
  endLine?: number;
  endColumn?: number;
}

declare type CstChildrenDictionary = {
  [identifier: string]: CstElement[];
};

declare type CstElement = IToken | CstNode$1;

declare type nodeLocationTrackingOptions =
  | "full"
  | "onlyOffset"
  | "none";

interface IParserConfig {
  /**
   * Is the error recovery / fault tolerance of the Chevrotain Parser enabled.
   */
  recoveryEnabled?: boolean;
  /**
   * Maximum number of tokens the parser will use to choose between alternatives.
   * By default this value is `4`.
   * In the future it may be reduced to `3` due to performance considerations.
   */
  maxLookahead?: number;
  /**
   * Enable This Flag to to support Dynamically defined Tokens.
   * This will disable performance optimizations which cannot work if the whole Token vocabulary is not known
   * During Parser initialization.
   *
   * See [runnable example](https://github.com/chevrotain/chevrotain/tree/master/examples/parser/dynamic_tokens)
   */
  dynamicTokensEnabled?: boolean;
  /**
   * Enable computation of CST nodes location.
   * By default this is set to "none", meaning this feature is disabled.
   * See: http://chevrotain.io/docs/guide/concrete_syntax_tree.html#cstnode-location
   * For more details.
   */
  nodeLocationTracking?: nodeLocationTrackingOptions;
  /**
   * A custom error message provider.
   * Can be used to override the default error messages.
   * For example:
   *   - Translating the error messages to a different languages.
   *   - Changing the formatting.
   *   - Providing special error messages under certain conditions, e.g: missing semicolons.
   */
  errorMessageProvider?: IParserErrorMessageProvider;
  /**
   * Enabling this flag will print performance tracing logs during parser
   * Initialization (constructor invocation), this is useful to narrow down the cause
   * of the initialization performance problem.
   *
   * You can also pass a numerical value which affects the verbosity
   * of the traces, this number is the maximum nesting level of the traces, e.g:
   * 0: Traces disabled === 'false'
   * 1: Top Level traces only.
   * 2: One level of nested inner traces.
   * ...
   *
   * Note that passing the boolean `true` is identical to passing the numerical value `infinity`
   */
  traceInitPerf?: boolean | number;
  /**
   * This flag will avoid running the grammar validations during Parser initialization.
   *
   * This can substantially improve the Parser's initialization (constructor) time.
   * @see IParserConfig.traceInitPerf to measure the grammar validations cost for your parser.
   *
   * Note that the grammar validations are **extremely useful** during development time,
   * e.g: detecting ambiguities / left recursion.
   * So they should not be skipped during development flows.
   *   - For example: via a conditional that checks an env variable.
   */
  skipValidations?: boolean;
  /**
   * @experimental
   *
   * A custom lookahead strategy.
   * Can be used to override the default LL(*k*) lookahead behavior.
   *
   * Note that the default lookahead strategy is very well optimized and using a custom lookahead
   * strategy might lead to massively reduced performance.
   */
  lookaheadStrategy?: ILookaheadStrategy;
}

/**
 * A set of methods used to customize parsing error messages.
 * Call {@link defaultParserErrorProvider} to implement the default behavior
 */
interface IParserErrorMessageProvider {
  /**
   * Mismatched Token Error happens when the parser attempted to consume a terminal and failed.
   * It corresponds to a failed {@link BaseParser.CONSUME} in Chevrotain DSL terms.
   *
   * @param options.expected - The expected Token Type.
   *
   * @param options.actual - The actual Token "instance".
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildMismatchTokenMessage(options: {
    expected: TokenType;
    actual: IToken;
    previous: IToken;
    ruleName: string;
  }): string;
  /**
   * A Redundant Input Error happens when the parser has completed parsing but there
   * is still unprocessed input remaining.
   *
   * @param options.firstRedundant - The first unprocessed token "instance".
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildNotAllInputParsedMessage(options: {
    firstRedundant: IToken;
    ruleName: string;
  }): string;
  /**
   * A No Viable Alternative Error happens when the parser cannot detect any valid alternative in an alternation.
   * It corresponds to a failed {@link BaseParser.OR} in Chevrotain DSL terms.
   *
   * @param options.expectedPathsPerAlt - First level of the array represents each alternative
   *                           The next two levels represent valid (expected) paths in each alternative.
   *
   * @param options.actual - The actual sequence of tokens encountered.
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.customUserDescription - A user may provide custom error message descriptor in the {@link BaseParser.AT_LEAST_ONE_SEP} DSL method
   *                                        options parameter, this is that custom message.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildNoViableAltMessage(options: {
    expectedPathsPerAlt: TokenType[][][];
    actual: IToken[];
    previous: IToken;
    customUserDescription?: string;
    ruleName: string;
  }): string;
  /**
   * An Early Exit Error happens when the parser cannot detect the first mandatory iteration of a repetition.
   * It corresponds to a failed {@link BaseParser.AT_LEAST_ONE_SEP} or {@link BaseParser.AT_LEAST_ONE_SEP} in Chevrotain DSL terms.
   *
   * @param options.expectedIterationPaths - The valid (expected) paths in the first iteration.
   *
   * @param options.actual - The actual sequence of tokens encountered.
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.customUserDescription - A user may provide custom error message descriptor in the {@link BaseParser.AT_LEAST_ONE_SEP} DSL method
   *                                        options parameter, this is that custom message.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildEarlyExitMessage(options: {
    expectedIterationPaths: TokenType[][];
    actual: IToken[];
    previous: IToken;
    customUserDescription?: string;
    ruleName: string;
  }): string;
}

/**
 * @experimental
 */
interface ILookaheadStrategy {
  /**
   * Performs validations on the grammar specific to this lookahead strategy.
   * This method is not called if parser validations are disabled.
   *
   * @param options.rules All parser rules of the grammar.
   *
   * @param options.tokenTypes All token types of the grammar.
   *
   * @param options.grammarName The name of the grammar.
   */
  validate(options: {
    rules: Rule[];
    tokenTypes: TokenType[];
    grammarName: string;
  }): ILookaheadValidationError[];

  /**
   * Initializes the lookahead for a grammar.
   *
   * Note that this method does not build the lookahead functions.
   * It only initializes the internal state of the strategy based on all grammar rules.
   *
   * @param options.rules All parser rules of the grammar.
   */
  initialize?(options: { rules: Rule[] }): void;

  /**
   * Builds a lookahead function for alternations/`OR` parser methods.
   *
   * @param options.prodOccurrence The occurrence number of this `OR` within its rule.
   *
   * @param options.rule The rule that contains this `OR`.
   *
   * @param options.maxLookahead The maximum amount of lookahead for this `OR`.
   *
   * @param options.hasPredicates Whether any of the alternatives contain a predicate.
   *
   * @param options.dynamicTokensEnabled Whether dynamic tokens are enabled for this parser.
   *
   * @returns A function that is able to compute which of the alternatives to choose while parsing.
   */
  buildLookaheadForAlternation(options: {
    prodOccurrence: number;
    rule: Rule;
    maxLookahead: number;
    hasPredicates: boolean;
    dynamicTokensEnabled: boolean;
  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined;

  /**
   * Builds a lookahead function for optional productions.
   *
   * @param options.prodOccurrence The occurrence number of this production within its rule.
   *
   * @param options.prodType The type of this production.
   *
   * @param options.rule The rule that contains this production.
   *
   * @param options.maxLookahead The maximum amount of lookahead for this production.
   *
   * @param options.dynamicTokensEnabled Whether dynamic tokens are enabled for this parser.
   *
   * @returns A function is able to compute whether to parse the production or to continue with the rest of the parser rule.
   */
  buildLookaheadForOptional(options: {
    prodOccurrence: number;
    prodType: OptionalProductionType;
    rule: Rule;
    maxLookahead: number;
    dynamicTokensEnabled: boolean;
  }): () => boolean;
}

interface ILookaheadValidationError {
  message: string;
  ruleName?: string;
}

type OptionalProductionType =
  | "Option"
  | "RepetitionMandatory"
  | "RepetitionMandatoryWithSeparator"
  | "Repetition"
  | "RepetitionWithSeparator";

type LookaheadProductionType = OptionalProductionType | "Alternation";

interface IRecognizerContext {
  /**
   * A copy of the parser's rule stack at the "time" the RecognitionException occurred.
   * This can be used to help debug parsing errors (How did we get here?).
   */
  ruleStack: string[];
  /**
   * A copy of the parser's rule occurrence stack at the "time" the RecognitionException occurred.
   * This can be used to help debug parsing errors (How did we get here?).
   */
  ruleOccurrenceStack: number[];
}

interface ISerializedGast {
  type: ProductionType;
  definition?: ISerializedGast[];
}

type ProductionType =
  | LookaheadProductionType
  | "NonTerminal"
  | "Alternative"
  | "Terminal"
  | "Rule";

/**
 * Structure for the path the parser "took" to reach a certain position
 * in the grammar.
 */
interface IGrammarPath {
  /**
   * The Grammar rules invoked and still unterminated to reach this Grammar Path.
   */
  ruleStack: string[];
  /**
   * The occurrence index (SUBRULE1/2/3/5/...) of each Grammar rule invoked and still unterminated.
   * Used to distinguish between **different** invocations of the same subrule at the same top level rule.
   */
  occurrenceStack: number[];
}

interface ISyntacticContentAssistPath extends IGrammarPath {
  nextTokenType: TokenType;
  nextTokenOccurrence: number;
}

interface ITokenGrammarPath extends IGrammarPath {
  lastTok: TokenType;
  lastTokOccurrence: number;
}

/**
 * A Chevrotain Parser runtime exception.
 */
interface IRecognitionException extends Error {
  name: string;
  message: string;
  /**
   * The token which caused the parser error.
   */
  token: IToken;
  /**
   * Additional tokens which have been re-synced in error recovery due to the original error.
   * This information can be used the calculate the whole text area which has been skipped due to an error.
   * For example for displaying with a red underline in a text editor.
   */
  resyncedTokens: IToken[];
  context: IRecognizerContext;
}

interface IProduction {
  accept(visitor: IGASTVisitor): void;
}

/**
 * The Grammar AST class representing a top level {@link CstParser.RULE} or {@link EmbeddedActionsParser.RULE} call.
 */
declare class Rule {
  name: string;
  orgText: string;
  definition: IProduction[];

  constructor(options: {
    name: string;
    definition: IProduction[];
    orgText?: string;
  });

  accept(visitor: IGASTVisitor): void;
}

interface IGASTVisitor {
  visit(prod: IProduction): any;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface GrammarConfig {
    /**
     * Lists all rule names which are classified as multiline comment rules
     */
    multilineCommentRules: string[];
    /**
     * A regular expression which matches characters of names
     */
    nameRegexp: RegExp;
}

/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
declare class URI implements UriComponents {
    static isUri(thing: any): thing is URI;
    /**
     * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.
     * The part before the first colon.
     */
    readonly scheme: string;
    /**
     * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.
     * The part between the first double slashes and the next slash.
     */
    readonly authority: string;
    /**
     * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly path: string;
    /**
     * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly query: string;
    /**
     * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly fragment: string;
    /**
     * @internal
     */
    protected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);
    /**
     * @internal
     */
    protected constructor(components: UriComponents);
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath(): string;
    with(change: {
        scheme?: string;
        authority?: string | null;
        path?: string | null;
        query?: string | null;
        fragment?: string | null;
    }): URI;
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value: string, _strict?: boolean): URI;
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path: string): URI;
    static from(components: {
        scheme: string;
        authority?: string;
        path?: string;
        query?: string;
        fragment?: string;
    }): URI;
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding?: boolean): string;
    toJSON(): UriComponents;
    static revive(data: UriComponents | URI): URI;
    static revive(data: UriComponents | URI | undefined): URI | undefined;
    static revive(data: UriComponents | URI | null): URI | null;
    static revive(data: UriComponents | URI | undefined | null): URI | undefined | null;
}
interface UriComponents {
    scheme: string;
    authority: string;
    path: string;
    query: string;
    fragment: string;
}

/******************************************************************************
 * This file was generated by langium-cli 3.4.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

type AbstractRule = ParserRule | TerminalRule;
declare const AbstractRule = "AbstractRule";
type AbstractType = InferredType | Interface | ParserRule | Type;
declare const AbstractType = "AbstractType";
type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;
declare const Condition = "Condition";
type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;
type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';
type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;
declare const TypeDefinition = "TypeDefinition";
type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;
declare const ValueLiteral = "ValueLiteral";
interface AbstractElement extends AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?';
    lookahead?: '?!' | '?<!' | '?<=' | '?=';
}
declare const AbstractElement = "AbstractElement";
interface ArrayLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'ArrayLiteral';
    elements: Array<ValueLiteral>;
}
declare const ArrayLiteral = "ArrayLiteral";
interface ArrayType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition;
}
declare const ArrayType = "ArrayType";
interface BooleanLiteral extends AstNode {
    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;
    readonly $type: 'BooleanLiteral';
    true: boolean;
}
declare const BooleanLiteral = "BooleanLiteral";
interface Conjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition;
    right: Condition;
}
declare const Conjunction = "Conjunction";
interface Disjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition;
    right: Condition;
}
declare const Disjunction = "Disjunction";
interface Grammar extends AstNode {
    readonly $type: 'Grammar';
    definesHiddenTokens: boolean;
    hiddenTokens: Array<Reference<AbstractRule>>;
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name?: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
    usedGrammars: Array<Reference<Grammar>>;
}
declare const Grammar = "Grammar";
interface GrammarImport extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string;
}
declare const GrammarImport = "GrammarImport";
interface InferredType extends AstNode {
    readonly $container: Action | ParserRule;
    readonly $type: 'InferredType';
    name: string;
}
declare const InferredType = "InferredType";
interface Interface extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<Reference<AbstractType>>;
}
declare const Interface = "Interface";
interface NamedArgument extends AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean;
    parameter?: Reference<Parameter>;
    value: Condition;
}
declare const NamedArgument = "NamedArgument";
interface Negation extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition;
}
declare const Negation = "Negation";
interface NumberLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'NumberLiteral';
    value: number;
}
declare const NumberLiteral = "NumberLiteral";
interface Parameter extends AstNode {
    readonly $container: ParserRule;
    readonly $type: 'Parameter';
    name: string;
}
declare const Parameter = "Parameter";
interface ParameterReference extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: Reference<Parameter>;
}
declare const ParameterReference = "ParameterReference";
interface ParserRule extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType;
    definesHiddenTokens: boolean;
    definition: AbstractElement;
    entry: boolean;
    fragment: boolean;
    hiddenTokens: Array<Reference<AbstractRule>>;
    inferredType?: InferredType;
    name: string;
    parameters: Array<Parameter>;
    returnType?: Reference<AbstractType>;
    wildcard: boolean;
}
declare const ParserRule = "ParserRule";
interface ReferenceType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    referenceType: TypeDefinition;
}
declare const ReferenceType = "ReferenceType";
interface ReturnType$1 extends AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string;
}
declare const ReturnType$1 = "ReturnType";
interface SimpleType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType;
    stringType?: string;
    typeRef?: Reference<AbstractType>;
}
declare const SimpleType = "SimpleType";
interface StringLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'StringLiteral';
    value: string;
}
declare const StringLiteral = "StringLiteral";
interface TerminalRule extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: AbstractElement;
    fragment: boolean;
    hidden: boolean;
    name: string;
    type?: ReturnType$1;
}
declare const TerminalRule = "TerminalRule";
interface Type extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string;
    type: TypeDefinition;
}
declare const Type = "Type";
interface TypeAttribute extends AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    defaultValue?: ValueLiteral;
    isOptional: boolean;
    name: FeatureName;
    type: TypeDefinition;
}
declare const TypeAttribute = "TypeAttribute";
interface UnionType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>;
}
declare const UnionType = "UnionType";
interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName;
    inferredType?: InferredType;
    operator?: '+=' | '=';
    type?: Reference<AbstractType>;
}
declare const Action = "Action";
interface CharacterRange extends AbstractElement {
    readonly $type: 'CharacterRange';
    left: Keyword;
    right?: Keyword;
}
declare const CharacterRange = "CharacterRange";
interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean;
    terminal?: AbstractElement;
    type: Reference<AbstractType>;
}
declare const CrossReference = "CrossReference";
interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>;
    guardCondition?: Condition;
}
declare const Group = "Group";
interface Keyword extends AbstractElement {
    readonly $container: CharacterRange;
    readonly $type: 'Keyword';
    value: string;
}
declare const Keyword = "Keyword";
interface RuleCall extends AbstractElement {
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>;
    rule: Reference<AbstractRule>;
}
declare const RuleCall = "RuleCall";

/**
 * A tagging type for string properties that are actually URIs.
 */
type DocumentUri = string;
/**
 * Position in a text document expressed as zero-based line and character offset.
 * The offsets are based on a UTF-16 string representation. So a string of the form
 * `a𐐀b` the character offset of the character `a` is 0, the character offset of `𐐀`
 * is 1 and the character offset of b is 3 since `𐐀` is represented using two code
 * units in UTF-16.
 *
 * Positions are line end character agnostic. So you can not specify a position that
 * denotes `\r|\n` or `\n|` where `|` represents the character offset.
 */
interface Position {
    /**
     * Line position in a document (zero-based).
     *
     * If a line number is greater than the number of lines in a document, it
     * defaults back to the number of lines in the document.
     * If a line number is negative, it defaults to 0.
     *
     * The above two properties are implementation specific.
     */
    line: number;
    /**
     * Character offset on a line in a document (zero-based).
     *
     * The meaning of this offset is determined by the negotiated
     * `PositionEncodingKind`.
     *
     * If the character value is greater than the line length it defaults back
     * to the line length. This property is implementation specific.
     */
    character: number;
}
/**
 * A range in a text document expressed as (zero-based) start and end positions.
 *
 * If you want to specify a range that contains a line including the line ending
 * character(s) then use an end position denoting the start of the next line.
 * For example:
 * ```ts
 * {
 *     start: { line: 5, character: 23 }
 *     end : { line 6, character : 0 }
 * }
 * ```
 */
interface Range {
    /**
     * The range's start position.
     */
    start: Position;
    /**
     * The range's end position.
     */
    end: Position;
}
/**
 * A text edit applicable to a text document.
 */
interface TextEdit {
    /**
     * The range of the text document to be manipulated. To insert
     * text into a document create a range where start === end.
     */
    range: Range;
    /**
     * The string to be inserted. For delete operations use an
     * empty string.
     */
    newText: string;
}
/**
 * An event describing a change to a text document. If range and rangeLength are omitted
 * the new text is considered to be the full content of the document.
 */
type TextDocumentContentChangeEvent$1 = {
    /**
     * The range of the document that changed.
     */
    range: Range;
    /**
     * The optional length of the range that got replaced.
     *
     * @deprecated use range instead.
     */
    rangeLength?: number;
    /**
     * The new text for the provided range.
     */
    text: string;
} | {
    /**
     * The new text of the whole document.
     */
    text: string;
};
/**
 * A simple text document. Not to be implemented. The document keeps the content
 * as string.
 */
interface TextDocument {
    /**
     * The associated URI for this document. Most documents have the __file__-scheme, indicating that they
     * represent files on disk. However, some documents may have other schemes indicating that they are not
     * available on disk.
     *
     * @readonly
     */
    readonly uri: DocumentUri;
    /**
     * The identifier of the language associated with this document.
     *
     * @readonly
     */
    readonly languageId: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     *
     * @readonly
     */
    readonly version: number;
    /**
     * Get the text of this document. A substring can be retrieved by
     * providing a range.
     *
     * @param range (optional) An range within the document to return.
     * If no range is passed, the full content is returned.
     * Invalid range positions are adjusted as described in {@link Position.line}
     * and {@link Position.character}.
     * If the start range position is greater than the end range position,
     * then the effect of getText is as if the two positions were swapped.

     * @return The text of this document or a substring of the text if a
     *         range is provided.
     */
    getText(range?: Range): string;
    /**
     * Converts a zero-based offset to a position.
     *
     * @param offset A zero-based offset.
     * @return A valid {@link Position position}.
     * @example The text document "ab\ncd" produces:
     * * position { line: 0, character: 0 } for `offset` 0.
     * * position { line: 0, character: 1 } for `offset` 1.
     * * position { line: 0, character: 2 } for `offset` 2.
     * * position { line: 1, character: 0 } for `offset` 3.
     * * position { line: 1, character: 1 } for `offset` 4.
     */
    positionAt(offset: number): Position;
    /**
     * Converts the position to a zero-based offset.
     * Invalid positions are adjusted as described in {@link Position.line}
     * and {@link Position.character}.
     *
     * @param position A position.
     * @return A valid zero-based offset.
     */
    offsetAt(position: Position): number;
    /**
     * The number of lines in this document.
     *
     * @readonly
     */
    readonly lineCount: number;
}
declare namespace TextDocument {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri: DocumentUri, languageId: string, version: number, content: string): TextDocument;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document: TextDocument, changes: TextDocumentContentChangeEvent$1[], version: number): TextDocument;
    function applyEdits(document: TextDocument, edits: TextEdit[]): string;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface FileSystemNode {
    readonly isFile: boolean;
    readonly isDirectory: boolean;
    readonly uri: URI;
}
/**
 * Provides methods to interact with an abstract file system. The default implementation is based on the node.js `fs` API.
 */
interface FileSystemProvider {
    /**
     * Reads a document asynchronously from a given URI.
     * @returns The string content of the file with the specified URI.
     */
    readFile(uri: URI): Promise<string>;
    /**
     * Reads the directory information for the given URI.
     * @returns The list of file system entries that are contained within the specified directory.
     */
    readDirectory(uri: URI): Promise<FileSystemNode[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * A stream is a read-only sequence of values. While the contents of an array can be accessed
 * both sequentially and randomly (via index), a stream allows only sequential access.
 *
 * The advantage of this is that a stream can be evaluated lazily, so it does not require
 * to store intermediate values. This can boost performance when a large sequence is
 * processed via filtering, mapping etc. and accessed at most once. However, lazy
 * evaluation means that all processing is repeated when you access the sequence multiple
 * times; in such a case, it may be better to store the resulting sequence into an array.
 */
interface Stream<T> extends Iterable<T> {
    /**
     * Returns an iterator for this stream. This is the same as calling the `Symbol.iterator` function property.
     */
    iterator(): IterableIterator<T>;
    /**
     * Determines whether this stream contains no elements.
     */
    isEmpty(): boolean;
    /**
     * Determines the number of elements in this stream.
     */
    count(): number;
    /**
     * Collects all elements of this stream into an array.
     */
    toArray(): T[];
    /**
     * Collects all elements of this stream into a Set.
     */
    toSet(): Set<T>;
    /**
     * Collects all elements of this stream into a Map, applying the provided functions to determine keys and values.
     *
     * @param keyFn The function to derive map keys. If omitted, the stream elements are used as keys.
     * @param valueFn The function to derive map values. If omitted, the stream elements are used as values.
     */
    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V>;
    /**
     * Returns a string representation of a stream.
     */
    toString(): string;
    /**
     * Combines two streams by returning a new stream that yields all elements of this stream and the other stream.
     *
     * @param other Stream to be concatenated with this one.
     */
    concat<T2>(other: Iterable<T2>): Stream<T | T2>;
    /**
     * Adds all elements of the stream into a string, separated by the specified separator string.
     *
     * @param separator A string used to separate one element of the stream from the next in the resulting string.
     *        If omitted, the steam elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns the index of the first occurrence of a value in the stream, or -1 if it is not present.
     *
     * @param searchElement The value to locate in the array.
     * @param fromIndex The stream index at which to begin the search. If fromIndex is omitted, the search
     *        starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all members of the stream satisfy the specified test.
     *
     * @param predicate This method calls the predicate function for each element in the stream until the
     *        predicate returns a value which is coercible to the Boolean value `false`, or until the end
     *        of the stream.
     */
    every<S extends T>(predicate: (value: T) => value is S): this is Stream<S>;
    every(predicate: (value: T) => unknown): boolean;
    /**
     * Determines whether any member of the stream satisfies the specified test.
     *
     * @param predicate This method calls the predicate function for each element in the stream until the
     *        predicate returns a value which is coercible to the Boolean value `true`, or until the end
     *        of the stream.
     */
    some(predicate: (value: T) => unknown): boolean;
    /**
     * Performs the specified action for each element in the stream.
     *
     * @param callbackfn Function called once for each element in the stream.
     */
    forEach(callbackfn: (value: T, index: number) => void): void;
    /**
     * Returns a stream that yields the results of calling the specified callback function on each element
     * of the stream. The function is called when the resulting stream elements are actually accessed, so
     * accessing the resulting stream multiple times means the function is also called multiple times for
     * each element of the stream.
     *
     * @param callbackfn Lazily evaluated function mapping stream elements.
     */
    map<U>(callbackfn: (value: T) => U): Stream<U>;
    /**
     * Returns the elements of the stream that meet the condition specified in a callback function.
     * The function is called when the resulting stream elements are actually accessed, so accessing the
     * resulting stream multiple times means the function is also called multiple times for each element
     * of the stream.
     *
     * @param predicate Lazily evaluated function checking a condition on stream elements.
     */
    filter<S extends T>(predicate: (value: T) => value is S): Stream<S>;
    filter(predicate: (value: T) => unknown): Stream<T>;
    /**
     * Returns the elements of the stream that are _non-nullable_, which means they are neither `undefined`
     * nor `null`.
     */
    nonNullable(): Stream<NonNullable<T>>;
    /**
     * Calls the specified callback function for all elements in the stream. The return value of the
     * callback function is the accumulated result, and is provided as an argument in the next call to
     * the callback function.
     *
     * @param callbackfn This method calls the function once for each element in the stream, providing
     *        the previous and current values of the reduction.
     * @param initialValue If specified, `initialValue` is used as the initial value to start the
     *        accumulation. The first call to the function provides this value as an argument instead
     *        of a stream value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;
    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all elements in the stream, in descending order.
     * The return value of the callback function is the accumulated result, and is provided as an
     * argument in the next call to the callback function.
     *
     * @param callbackfn This method calls the function once for each element in the stream, providing
     *        the previous and current values of the reduction.
     * @param initialValue If specified, `initialValue` is used as the initial value to start the
     *        accumulation. The first call to the function provides this value as an argument instead
     *        of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;
    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;
    /**
     * Returns the value of the first element in the stream that meets the condition, or `undefined`
     * if there is no such element.
     *
     * @param predicate This method calls `predicate` once for each element of the stream, in ascending
     *        order, until it finds one where `predicate` returns a value which is coercible to the
     *        Boolean value `true`.
     */
    find<S extends T>(predicate: (value: T) => value is S): S | undefined;
    find(predicate: (value: T) => unknown): T | undefined;
    /**
     * Returns the index of the first element in the stream that meets the condition, or `-1`
     * if there is no such element.
     *
     * @param predicate This method calls `predicate` once for each element of the stream, in ascending
     *        order, until it finds one where `predicate` returns a value which is coercible to the
     *        Boolean value `true`.
     */
    findIndex(predicate: (value: T) => unknown): number;
    /**
     * Determines whether the stream includes a certain element, returning `true` or `false` as appropriate.
     *
     * @param searchElement The element to search for.
     */
    includes(searchElement: T): boolean;
    /**
     * Calls a defined callback function on each element of the stream and then flattens the result into
     * a new stream. This is identical to a `map` followed by `flat` with depth 1.
     *
     * @param callbackfn Lazily evaluated function mapping stream elements.
     */
    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U>;
    /**
     * Returns a new stream with all sub-stream or sub-array elements concatenated into it recursively up
     * to the specified depth.
     *
     * @param depth The maximum recursion depth. Defaults to 1.
     */
    flat<D extends number = 1>(depth?: D): FlatStream<T, D>;
    /**
     * Returns the first element in the stream, or `undefined` if the stream is empty.
     */
    head(): T | undefined;
    /**
     * Returns a stream that skips the first `skipCount` elements from this stream.
     *
     * @param skipCount The number of elements to skip. If this is larger than the number of elements in
     *        the stream, an empty stream is returned. Defaults to 1.
     */
    tail(skipCount?: number): Stream<T>;
    /**
     * Returns a stream consisting of the elements of this stream, truncated to be no longer than `maxSize`
     * in length.
     *
     * @param maxSize The number of elements the stream should be limited to
     */
    limit(maxSize: number): Stream<T>;
    /**
     * Returns a stream containing only the distinct elements from this stream.
     * Equality is determined with the same rules as a standard `Set`.
     *
     * @param by A function returning the key used to check equality with a previous stream element.
     *        If omitted, the stream elements themselves are used for comparison.
     */
    distinct<Key = T>(by?: (element: T) => Key): Stream<T>;
    /**
     * Returns a stream that contains all elements that don't exist in the {@link other} iterable.
     * Equality is determined with the same rules as a standard `Set`.
     * @param other The elements that should be exluded from this stream.
     * @param key A function returning the key used to check quality.
     *        If omitted, the stream elements themselves are used for comparison.
     */
    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T>;
}
type FlatStream<T, Depth extends number> = {
    'done': Stream<T>;
    'recur': T extends Iterable<infer Content> ? FlatStream<Content, MinusOne<Depth>> : Stream<T>;
}[Depth extends 0 ? 'done' : 'recur'];
type MinusOne<N extends number> = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20][N];

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface TokenBuilderOptions {
    caseInsensitive?: boolean;
}
interface TokenBuilder {
    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary;
    /**
     * Produces a lexing report for the given text that was just tokenized using the tokens provided by this builder.
     *
     * @param text The text that was tokenized.
     */
    flushLexingReport?(text: string): LexingReport;
}
/**
 * A custom lexing report that can be produced by the token builder during the lexing process.
 * Adopters need to ensure that the any custom fields are serializable so they can be sent across worker threads.
 */
interface LexingReport {
    diagnostics: LexingDiagnostic[];
}
type LexingDiagnosticSeverity = 'error' | 'warning' | 'info' | 'hint';
interface LexingDiagnostic extends ILexingError {
    severity?: LexingDiagnosticSeverity;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface LexerResult {
    /**
     * A list of all tokens that were lexed from the input.
     *
     * Note that Langium requires the optional properties
     * `startLine`, `startColumn`, `endOffset`, `endLine` and `endColumn` to be set on each token.
     */
    tokens: IToken[];
    /**
     * Contains hidden tokens, usually comments.
     */
    hidden: IToken[];
    errors: ILexingError[];
    report?: LexingReport;
}
type TokenizeMode = 'full' | 'partial';
interface TokenizeOptions {
    mode?: TokenizeMode;
}
interface Lexer {
    readonly definition: TokenTypeDictionary;
    tokenize(text: string, options?: TokenizeOptions): LexerResult;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type ParseResult<T = AstNode> = {
    value: T;
    parserErrors: IRecognitionException[];
    lexerErrors: ILexingError[];
    lexerReport?: LexingReport;
};
type RuleResult = (args: Args) => any;
type Args = Record<string, boolean>;
type RuleImpl = (args: Args) => any;
/**
 * Base interface for all parsers. Mainly used by the `parser-builder-base.ts` to perform work on different kinds of parsers.
 * The main use cases are:
 * * AST parser: Based on a string, create an AST for the current grammar
 * * Completion parser: Based on a partial string, identify the current position of the input within the grammar
 */
interface BaseParser$1 {
    /**
     * Adds a new parser rule to the parser
     */
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    /**
     * Returns the executable rule function for the specified rule name
     */
    getRule(name: string): RuleResult | undefined;
    /**
     * Performs alternatives parsing (the `|` operation in EBNF/Langium)
     */
    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;
    /**
     * Parses the callback as optional (the `?` operation in EBNF/Langium)
     */
    optional(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Parses the callback 0 or more times (the `*` operation in EBNF/Langium)
     */
    many(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Parses the callback 1 or more times (the `+` operation in EBNF/Langium)
     */
    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Consumes a specific token type from the token input stream.
     * Requires a unique index within the rule for a specific token type.
     */
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    /**
     * Invokes the executable function for a given parser rule.
     * Requires a unique index within the rule for a specific sub rule.
     * Arguments can be supplied to the rule invocation for semantic predicates
     */
    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;
    /**
     * Executes a grammar action that modifies the currently active AST node
     */
    action($type: string, action: Action): void;
    /**
     * Finishes construction of the current AST node. Only used by the AST parser.
     */
    construct(): unknown;
    /**
     * Whether the parser is currently actually in use or in "recording mode".
     * Recording mode is activated once when the parser is analyzing itself.
     * During this phase, no input exists and therefore no AST should be constructed
     */
    isRecording(): boolean;
    /**
     * Current state of the unordered groups
     */
    get unorderedGroups(): Map<string, boolean[]>;
    /**
     * The rule stack indicates the indices of rules that are currently invoked,
     * in order of their invocation.
     */
    getRuleStack(): number[];
}
declare abstract class AbstractLangiumParser implements BaseParser$1 {
    protected readonly lexer: Lexer;
    protected readonly wrapper: ChevrotainWrapper;
    protected _unorderedGroups: Map<string, boolean[]>;
    protected allRules: Map<string, RuleResult>;
    protected mainRule: RuleResult;
    constructor(services: LangiumCoreServices);
    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;
    optional(idx: number, callback: DSLMethodOpts<unknown>): void;
    many(idx: number, callback: DSLMethodOpts<unknown>): void;
    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
    abstract rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    abstract consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    abstract subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;
    abstract action($type: string, action: Action): void;
    abstract construct(): unknown;
    getRule(name: string): RuleResult | undefined;
    isRecording(): boolean;
    get unorderedGroups(): Map<string, boolean[]>;
    getRuleStack(): number[];
    finalize(): void;
}
interface ParserOptions {
    rule?: string;
}
declare class LangiumParser extends AbstractLangiumParser {
    private readonly linker;
    private readonly converter;
    private readonly astReflection;
    private readonly nodeBuilder;
    private lexerResult?;
    private stack;
    private assignmentMap;
    private get current();
    constructor(services: LangiumCoreServices);
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    private computeRuleType;
    parse<T extends AstNode = AstNode>(input: string, options?: ParserOptions): ParseResult<T>;
    private startImplementation;
    private extractHiddenTokens;
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    /**
     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:
     *
     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed
     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.
     */
    private isValidToken;
    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;
    private performSubruleAssignment;
    action($type: string, action: Action): void;
    construct(): unknown;
    private getAssignment;
    private assign;
    private assignWithoutOverride;
    get definitionErrors(): IParserDefinitionError[];
}
interface IParserDefinitionError {
    message: string;
    type: number;
    ruleName?: string;
}
interface CompletionParserResult {
    tokens: IToken[];
    elementStack: AbstractElement[];
    tokenIndex: number;
}
declare class LangiumCompletionParser extends AbstractLangiumParser {
    private tokens;
    private elementStack;
    private lastElementStack;
    private nextTokenIndex;
    private stackSize;
    action(): void;
    construct(): unknown;
    parse(input: string): CompletionParserResult;
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    private resetState;
    private startImplementation;
    private removeUnexpectedElements;
    keepStackSize(): number;
    resetStackSize(size: number): void;
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;
    before(element: AbstractElement): void;
    after(element: AbstractElement): void;
    get currIdx(): number;
}
/**
 * This class wraps the embedded actions parser of chevrotain and exposes protected methods.
 * This way, we can build the `LangiumParser` as a composition.
 */
declare class ChevrotainWrapper extends EmbeddedActionsParser {
    definitionErrors: IParserDefinitionError[];
    constructor(tokens: TokenVocabulary, config: IParserConfig);
    get IS_RECORDING(): boolean;
    DEFINE_RULE(name: string, impl: RuleImpl): RuleResult;
    wrapSelfAnalysis(): void;
    wrapConsume(idx: number, tokenType: TokenType): IToken;
    wrapSubrule(idx: number, rule: RuleResult, args: Args): unknown;
    wrapOr(idx: number, choices: Array<IOrAlt<any>>): void;
    wrapOption(idx: number, callback: DSLMethodOpts<unknown>): void;
    wrapMany(idx: number, callback: DSLMethodOpts<unknown>): void;
    wrapAtLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The service registry provides access to the language-specific {@link LangiumCoreServices} optionally including LSP-related services.
 * These are resolved via the URI of a text document.
 */
interface ServiceRegistry {
    /**
     * Register a language via its injected services.
     */
    register(language: LangiumCoreServices): void;
    /**
     * Retrieve the language-specific services for the given URI. In case only one language is
     * registered, it may be used regardless of the URI format.
     */
    getServices(uri: URI): LangiumCoreServices;
    /**
     * Check whether services are available for the given URI.
     */
    hasServices(uri: URI): boolean;
    /**
     * The full set of registered language services.
     */
    readonly all: readonly LangiumCoreServices[];
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A multimap is a variation of a Map that has potentially multiple values for every key.
 */
declare class MultiMap<K, V> {
    private map;
    constructor();
    constructor(elements: Array<[K, V]>);
    /**
     * The total number of values in the multimap.
     */
    get size(): number;
    /**
     * Clear all entries in the multimap.
     */
    clear(): void;
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method deletes the specific key / value pair from the multimap.
     *  * Without a value, all values associated with the given key are deleted.
     *
     * @returns `true` if a value existed and has been removed, or `false` if the specified
     *     key / value does not exist.
     */
    delete(key: K, value?: V): boolean;
    /**
     * Returns an array of all values associated with the given key. If no value exists,
     * an empty array is returned.
     *
     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
     * value and `delete` to remove a value from the multimap.
     */
    get(key: K): readonly V[];
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
     *  * Without a value, this method returns `true` if the given key is present in the multimap.
     */
    has(key: K, value?: V): boolean;
    /**
     * Add the given key / value pair to the multimap.
     */
    add(key: K, value: V): this;
    /**
     * Add the given set of key / value pairs to the multimap.
     */
    addAll(key: K, values: Iterable<V>): this;
    /**
     * Invokes the given callback function for every key / value pair in the multimap.
     */
    forEach(callbackfn: (value: V, key: K, map: this) => void): void;
    /**
     * Returns an iterator of key, value pairs for every entry in the map.
     */
    [Symbol.iterator](): Iterator<[K, V]>;
    /**
     * Returns a stream of key, value pairs for every entry in the map.
     */
    entries(): Stream<[K, V]>;
    /**
     * Returns a stream of keys in the map.
     */
    keys(): Stream<K>;
    /**
     * Returns a stream of values in the map.
     */
    values(): Stream<V>;
    /**
     * Returns a stream of key, value set pairs for every key in the map.
     */
    entriesGroupedByKey(): Stream<[K, V[]]>;
}

interface Disposable$1 {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
declare namespace Disposable$1 {
    function create(func: () => void): Disposable$1;
}

/**
 * Represents a typed event.
 */
interface Event<T> {
    /**
     *
     * @param listener The listener function will be called when the event happens.
     * @param thisArgs The 'this' which will be used when calling the event listener.
     * @param disposables An array to which a {{IDisposable}} will be added.
     * @return
    */
    (listener: (e: T) => any, thisArgs?: any, disposables?: Disposable$1[]): Disposable$1;
}
declare namespace Event {
    const None: Event<any>;
}

/**
 * Defines a CancellationToken. This interface is not
 * intended to be implemented. A CancellationToken must
 * be created via a CancellationTokenSource.
 */
interface CancellationToken {
    /**
     * Is `true` when the token has been cancelled, `false` otherwise.
     */
    readonly isCancellationRequested: boolean;
    /**
     * An {@link Event event} which fires upon cancellation.
     */
    readonly onCancellationRequested: Event<any>;
}
declare namespace CancellationToken {
    const None: CancellationToken;
    const Cancelled: CancellationToken;
    function is(value: any): value is CancellationToken;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,
 *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,
 *  the overhead is very small, just a few kilobytes.
 * Everything else of that package (at the time contributing) is also defined
 *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.
 */

/**
 * A Langium document holds the parse result (AST and CST) and any additional state that is derived
 * from the AST, e.g. the result of scope precomputation.
 */
interface LangiumDocument<T extends AstNode = AstNode> {
    /** The Uniform Resource Identifier (URI) of the document */
    readonly uri: URI;
    /** The text document used to convert between offsets and positions */
    readonly textDocument: TextDocument;
    /** The current state of the document */
    state: DocumentState;
    /** The parse result holds the Abstract Syntax Tree (AST) and potentially also parser / lexer errors */
    parseResult: ParseResult<T>;
    /** Result of the scope precomputation phase */
    precomputedScopes?: PrecomputedScopes;
    /** An array of all cross-references found in the AST while linking */
    references: Reference[];
    /** Result of the validation phase */
    diagnostics?: Diagnostic[];
}
/**
 * A document is subject to several phases that are run in predefined order. Any state value implies that
 * smaller state values are finished as well.
 */
declare enum DocumentState {
    /**
     * The text content has changed and needs to be parsed again. The AST held by this outdated
     * document instance is no longer valid.
     */
    Changed = 0,
    /**
     * An AST has been created from the text content. The document structure can be traversed,
     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated
     * at this stage as a preprocessing step.
     */
    Parsed = 1,
    /**
     * The `IndexManager` service has processed AST nodes of this document. This means the
     * exported symbols are available in the global scope and can be resolved from other documents.
     */
    IndexedContent = 2,
    /**
     * The `ScopeComputation` service has processed this document. This means the local symbols
     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.
     * Once a document has reached this state, you may follow every reference - it will lazily
     * resolve its `ref` property and yield either the target AST node or `undefined` in case
     * the target is not in scope.
     */
    ComputedScopes = 3,
    /**
     * The `Linker` service has processed this document. All outgoing references have been
     * resolved or marked as erroneous.
     */
    Linked = 4,
    /**
     * The `IndexManager` service has processed AST node references of this document. This is
     * necessary to determine which documents are affected by a change in one of the workspace
     * documents.
     */
    IndexedReferences = 5,
    /**
     * The `DocumentValidator` service has processed this document. The language server listens
     * to the results of this phase and sends diagnostics to the client.
     */
    Validated = 6
}
/**
 * Result of the scope precomputation phase (`ScopeComputation` service).
 * It maps every AST node to the set of symbols that are visible in the subtree of that node.
 */
type PrecomputedScopes = MultiMap<AstNode, AstNodeDescription>;
interface DocumentSegment {
    readonly range: Range$1;
    readonly offset: number;
    readonly length: number;
    readonly end: number;
}
/**
 * Surrogate definition of the `TextDocuments` interface from the `vscode-languageserver` package.
 * No implementation object is expected to be offered by `LangiumCoreServices`, but only by `LangiumLSPServices`.
 */
type TextDocumentProvider = {
    get(uri: string | URI): TextDocument | undefined;
};
/**
 * Shared service for creating `LangiumDocument` instances.
 *
 * Register a custom implementation if special (additional) behavior is required for your language(s).
 * Note: If you specialize {@link fromString} or {@link fromTextDocument} you probably might want to
 * specialize {@link update}, too!
 */
interface LangiumDocumentFactory {
    /**
     * Create a Langium document from a `TextDocument` (usually associated with a file).
     */
    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, options?: ParserOptions): LangiumDocument<T>;
    /**
     * Create a Langium document from a `TextDocument` asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.
     */
    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI | undefined, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;
    /**
     * Create an Langium document from an in-memory string.
     */
    fromString<T extends AstNode = AstNode>(text: string, uri: URI, options?: ParserOptions): LangiumDocument<T>;
    /**
     * Create a Langium document from an in-memory string asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.
     */
    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;
    /**
     * Create an Langium document from a model that has been constructed in memory.
     */
    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T>;
    /**
     * Create an Langium document from a specified `URI`. The factory will use the `FileSystemAccess` service to read the file.
     */
    fromUri<T extends AstNode = AstNode>(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument<T>>;
    /**
     * Update the given document after changes in the corresponding textual representation.
     * Method is called by the document builder after it has been requested to build an existing
     * document and the document's state is {@link DocumentState.Changed}.
     * The text parsing is expected to be done the same way as in {@link fromTextDocument}
     * and {@link fromString}.
     */
    update<T extends AstNode = AstNode>(document: LangiumDocument<T>, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;
}
/**
 * Shared service for managing Langium documents.
 */
interface LangiumDocuments$1 {
    /**
     * A stream of all documents managed under this service.
     */
    readonly all: Stream<LangiumDocument>;
    /**
     * Manage a new document under this service.
     * @throws an error if a document with the same URI is already present.
     */
    addDocument(document: LangiumDocument): void;
    /**
     * Retrieve the document with the given URI, if present. Otherwise returns `undefined`.
     */
    getDocument(uri: URI): LangiumDocument | undefined;
    /**
     * Retrieve the document with the given URI. If not present, a new one will be created using the file system access.
     * The new document will be added to the list of documents managed under this service.
     */
    getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument>;
    /**
     * Creates a new document with the given URI and text content.
     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.
     *
     * @throws an error if a document with the same URI is already present.
     */
    createDocument(uri: URI, text: string): LangiumDocument;
    /**
     * Creates a new document with the given URI and text content asynchronously.
     * The process can be interrupted with a cancellation token.
     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.
     *
     * @throws an error if a document with the same URI is already present.
     */
    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;
    /**
     * Returns `true` if a document with the given URI is managed under this service.
     */
    hasDocument(uri: URI): boolean;
    /**
     * Flag the document with the given URI as `Changed`, if present, meaning that its content
     * is no longer valid. The content (parseResult) stays untouched, while internal data may
     * be dropped to reduce memory footprint.
     *
     * @returns the affected {@link LangiumDocument} if existing for convenience
     */
    invalidateDocument(uri: URI): LangiumDocument | undefined;
    /**
     * Remove the document with the given URI, if present, and mark it as `Changed`, meaning
     * that its content is no longer valid. The next call to `getOrCreateDocument` with the same
     * URI will create a new document instance.
     *
     * @returns the affected {@link LangiumDocument} if existing for convenience
     */
    deleteDocument(uri: URI): LangiumDocument | undefined;
}
declare class DefaultLangiumDocuments implements LangiumDocuments$1 {
    protected readonly langiumDocumentFactory: LangiumDocumentFactory;
    protected readonly serviceRegistry: ServiceRegistry;
    protected readonly documentMap: Map<string, LangiumDocument>;
    constructor(services: LangiumSharedCoreServices);
    get all(): Stream<LangiumDocument>;
    addDocument(document: LangiumDocument): void;
    getDocument(uri: URI): LangiumDocument | undefined;
    getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument>;
    createDocument(uri: URI, text: string): LangiumDocument;
    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;
    hasDocument(uri: URI): boolean;
    invalidateDocument(uri: URI): LangiumDocument | undefined;
    deleteDocument(uri: URI): LangiumDocument | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A node in the Abstract Syntax Tree (AST).
 */
interface AstNode {
    /** Every AST node has a type corresponding to what was specified in the grammar declaration. */
    readonly $type: string;
    /** The container node in the AST; every node except the root node has a container. */
    readonly $container?: AstNode;
    /** The property of the `$container` node that contains this node. This is either a direct reference or an array. */
    readonly $containerProperty?: string;
    /** In case `$containerProperty` is an array, the array index is stored here. */
    readonly $containerIndex?: number;
    /** The Concrete Syntax Tree (CST) node of the text range from which this node was parsed. */
    readonly $cstNode?: CstNode;
    /** The document containing the AST; only the root node has a direct reference to the document. */
    readonly $document?: LangiumDocument;
}
type SpecificNodeProperties<N extends AstNode> = keyof Omit<N, keyof AstNode | number | symbol>;
/**
 * The property names of a given AST node type.
 */
type Properties<N extends AstNode> = SpecificNodeProperties<N> extends never ? string : SpecificNodeProperties<N>;
/**
 * A cross-reference in the AST. Cross-references may or may not be successfully resolved.
 */
interface Reference<T extends AstNode = AstNode> {
    /**
     * The target AST node of this reference. Accessing this property may trigger cross-reference
     * resolution by the `Linker` in case it has not been done yet. If the reference cannot be resolved,
     * the value is `undefined`.
     */
    readonly ref?: T;
    /** If any problem occurred while resolving the reference, it is described by this property. */
    readonly error?: LinkingError;
    /** The CST node from which the reference was parsed */
    readonly $refNode?: CstNode;
    /** The actual text used to look up in the surrounding scope */
    readonly $refText: string;
    /** The node description for the AstNode returned by `ref`  */
    readonly $nodeDescription?: AstNodeDescription;
}
/**
 * A description of an AST node is used when constructing scopes and looking up cross-reference targets.
 */
interface AstNodeDescription {
    /** The target node; should be present only for local references (linking to the same document). */
    node?: AstNode;
    /**
     * The document segment that represents the range of the name of the AST node.
     */
    nameSegment?: DocumentSegment;
    /**
     * The document segment that represents the full range of the AST node.
     */
    selectionSegment?: DocumentSegment;
    /** `$type` property value of the AST node */
    type: string;
    /** Name of the AST node; this is usually determined by the `NameProvider` service. */
    name: string;
    /** URI to the document containing the AST node */
    documentUri: URI;
    /** Navigation path inside the document */
    path: string;
}
/**
 * Information about a cross-reference. This is used when traversing references in an AST or to describe
 * unresolved references.
 */
interface ReferenceInfo {
    reference: Reference;
    container: AstNode;
    property: string;
    index?: number;
}
/**
 * Used to collect information when the `Linker` service fails to resolve a cross-reference.
 */
interface LinkingError extends ReferenceInfo {
    message: string;
    targetDescription?: AstNodeDescription;
}
/**
 * Service used for generic access to the structure of the AST. This service is shared between
 * all involved languages, so it operates on the superset of types of these languages.
 */
interface AstReflection {
    getAllTypes(): string[];
    getAllSubTypes(type: string): string[];
    getReferenceType(refInfo: ReferenceInfo): string;
    getTypeMetaData(type: string): TypeMetaData;
    isInstance(node: unknown, type: string): boolean;
    isSubtype(subtype: string, supertype: string): boolean;
}
/**
 * Represents runtime meta data about a meta model type.
 */
interface TypeMetaData {
    /** The name of this meta model type. Corresponds to the `AstNode.$type` value. */
    name: string;
    /** A list of properties. They can contain default values for their respective property in the AST. */
    properties: TypeProperty[];
}
/**
 * Describes the meta data of a property of an AST node.
 *
 * The optional `defaultValue` indicates that the property is mandatory in the AST node.
 * For example, if an AST node contains an array, but no elements of this array have been parsed, we still expect an empty array instead of `undefined`.
 */
interface TypeProperty {
    name: string;
    defaultValue?: PropertyType;
}
/**
 * Represents a default value for an AST property.
 */
type PropertyType = number | string | boolean | PropertyType[];
/**
 * A node in the Concrete Syntax Tree (CST).
 */
interface CstNode extends DocumentSegment {
    /** The container node in the CST */
    readonly container?: CompositeCstNode;
    /** @deprecated use `container` instead. */
    readonly parent?: CompositeCstNode;
    /** The actual text */
    readonly text: string;
    /** The root CST node */
    readonly root: RootCstNode;
    /** The grammar element from which this node was parsed */
    readonly grammarSource?: AbstractElement;
    /** @deprecated use `grammarSource` instead. */
    readonly feature?: AbstractElement;
    /** The AST node created from this CST node */
    readonly astNode: AstNode;
    /** @deprecated use `astNode` instead. */
    readonly element: AstNode;
    /** Whether the token is hidden, i.e. not explicitly part of the containing grammar rule */
    readonly hidden: boolean;
}
/**
 * A composite CST node contains other nodes, but no directly associated token.
 */
interface CompositeCstNode extends CstNode {
    readonly content: CstNode[];
    /** @deprecated use `content` instead. */
    readonly children: CstNode[];
}
interface RootCstNode extends CompositeCstNode {
    readonly fullText: string;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provides comments for AST nodes.
 */
interface CommentProvider {
    /**
     * Returns the comment associated with the specified AST node.
     * @param node The AST node to get the comment for.
     * @returns The comment associated with the specified AST node or `undefined` if there is no comment.
     */
    getComment(node: AstNode): string | undefined;
}

interface AsyncDisposable {
    /**
     * Dispose this object.
     */
    dispose(): Promise<void>;
}
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
interface Disposable {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
declare namespace Disposable {
    function create(callback: () => Promise<void>): AsyncDisposable;
    function create(callback: () => void): Disposable;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

declare abstract class DisposableCache implements Disposable {
    protected toDispose: Disposable[];
    protected isDisposed: boolean;
    onDispose(disposable: Disposable): void;
    dispose(): void;
    protected throwIfDisposed(): void;
    abstract clear(): void;
}
declare class SimpleCache<K, V> extends DisposableCache {
    protected readonly cache: Map<K, V>;
    has(key: K): boolean;
    set(key: K, value: V): void;
    get(key: K): V | undefined;
    get(key: K, provider: () => V): V;
    delete(key: K): boolean;
    clear(): void;
}
declare class ContextCache<Context, Key, Value, ContextKey = Context> extends DisposableCache {
    private readonly cache;
    private readonly converter;
    constructor(converter?: (input: Context) => ContextKey);
    has(contextKey: Context, key: Key): boolean;
    set(contextKey: Context, key: Key, value: Value): void;
    get(contextKey: Context, key: Key): Value | undefined;
    get(contextKey: Context, key: Key, provider: () => Value): Value;
    delete(contextKey: Context, key: Key): boolean;
    clear(): void;
    clear(contextKey: Context): void;
    protected cacheForContext(contextKey: Context): Map<Key, Value>;
}
/**
 * Every key/value pair in this cache is scoped to the whole workspace.
 * If any document in the workspace is added, changed or deleted, the whole cache is evicted.
 */
declare class WorkspaceCache<K, V> extends SimpleCache<K, V> {
    /**
     * Creates a new workspace cache.
     *
     * @param sharedServices Service container instance to hook into document lifecycle events.
     * @param state Optional document state on which the cache should evict.
     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.
     * *Deleted* documents are considered in both cases.
     */
    constructor(sharedServices: LangiumSharedCoreServices, state?: DocumentState);
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Utility service for retrieving the `name` of an `AstNode` or the `CstNode` containing a `name`.
 */
interface NameProvider {
    /**
     * Returns the `name` of a given AstNode.
     * @param node Specified `AstNode` whose name node shall be retrieved.
     */
    getName(node: AstNode): string | undefined;
    /**
     * Returns the `CstNode` which contains the parsed value of the `name` assignment.
     * @param node Specified `AstNode` whose name node shall be retrieved.
     */
    getNameNode(node: AstNode): CstNode | undefined;
}
declare class DefaultNameProvider implements NameProvider {
    getName(node: AstNode): string | undefined;
    getNameNode(node: AstNode): CstNode | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for locating an `AstNode` in a document.
 */
interface AstNodeLocator {
    /**
     * Creates a path represented by a `string` that identifies an `AstNode` inside its document.
     * It must be possible to retrieve exactly the same `AstNode` from the document using this path.
     *
     * @param node The `AstNode` for which to create the path.
     * @returns a path represented by a `string` that identifies `node` inside its document.
     * @see AstNodeLocator.getAstNode
     */
    getAstNodePath(node: AstNode): string;
    /**
     * Locates an `AstNode` inside another node by following the given path.
     *
     * @param node Parent element.
     * @param path Describes how to locate the `AstNode` inside the given `node`.
     * @returns The `AstNode` located under the given path, or `undefined` if the path cannot be resolved.
     * @see AstNodeLocator.getAstNodePath
     */
    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for creating descriptions of AST nodes to be used for cross-reference resolutions.
 */
interface AstNodeDescriptionProvider {
    /**
     * Create a description for the given AST node. This service method is typically used while indexing
     * the contents of a document and during scope computation.
     *
     * @param node An AST node.
     * @param name The name to be used to refer to the AST node. By default, this is determined by the
     *     `NameProvider` service, but alternative names may be provided according to the semantics
     *     of your language.
     * @param document The document containing the AST node. If omitted, it is taken from the root AST node.
     */
    createDescription(node: AstNode, name: string | undefined, document?: LangiumDocument): AstNodeDescription;
}
/**
 * Describes a cross-reference within a document or between two documents.
 */
interface ReferenceDescription {
    /** URI of the document that holds a reference */
    sourceUri: URI;
    /** Path to AstNode that holds a reference */
    sourcePath: string;
    /** Target document uri */
    targetUri: URI;
    /** Path to the target AstNode inside the document */
    targetPath: string;
    /** Segment of the reference text. */
    segment: DocumentSegment;
    /** Marks a local reference i.e. a cross reference inside a document.   */
    local?: boolean;
}
/**
 * Language-specific service to create descriptions of all cross-references in a document. These are used by the `IndexManager`
 * to determine which documents are affected and should be rebuilt when a document is changed.
 */
interface ReferenceDescriptionProvider {
    /**
     * Create descriptions of all cross-references found in the given document. These descriptions are
     * gathered by the `IndexManager` and stored in the global index so they can be considered when
     * a document change is reported by the client.
     *
     * @param document The document in which to gather cross-references.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    createDescriptions(document: LangiumDocument, cancelToken?: CancellationToken): Promise<ReferenceDescription[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The index manager is responsible for keeping metadata about symbols and cross-references
 * in the workspace. It is used to look up symbols in the global scope, mostly during linking
 * and completion. This service is shared between all languages of a language server.
 */
interface IndexManager$1 {
    /**
     * Removes the specified document URI from the index.
     * Necessary when documents are deleted and not referenceable anymore.
     *
     * @param uri The URI of the document for which index data shall be removed
     */
    remove(uri: URI): void;
    /**
     * Updates the information about the exportable content of a document inside the index.
     *
     * @param document Document to be updated
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    updateContent(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    /**
     * Updates the information about the cross-references of a document inside the index.
     *
     * @param document Document to be updated
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    /**
     * Determine whether the given document could be affected by changes of the documents
     * identified by the given URIs (second parameter). The document is typically regarded as
     * affected if it contains a reference to any of the changed files.
     *
     * @param document Document to check whether it's affected
     * @param changedUris URIs of the changed documents
     */
    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;
    /**
     * Compute a list of all exported elements, optionally filtered using a type identifier and document URIs.
     *
     * @param nodeType The type to filter with, or `undefined` to return descriptions of all types.
     * @param uris If specified, only returns elements from the given URIs.
     * @returns a `Stream` containing all globally visible nodes (of a given type).
     */
    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;
    /**
     * Returns all known references that are pointing to the given `targetNode`.
     *
     * @param targetNode the `AstNode` to look up references for
     * @param astNodePath the path that points to the `targetNode` inside the document. See also `AstNodeLocator`
     *
     * @returns a `Stream` of references that are targeting the `targetNode`
     */
    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;
}
declare class DefaultIndexManager implements IndexManager$1 {
    protected readonly serviceRegistry: ServiceRegistry;
    protected readonly documents: LangiumDocuments$1;
    protected readonly astReflection: AstReflection;
    /**
     * The symbol index stores all `AstNodeDescription` items exported by a document.
     * The key used in this map is the string representation of the specific document URI.
     */
    protected readonly symbolIndex: Map<string, AstNodeDescription[]>;
    /**
     * This is a cache for the `allElements()` method.
     * It caches the descriptions from `symbolIndex` grouped by types.
     */
    protected readonly symbolByTypeIndex: ContextCache<string, string, AstNodeDescription[], string>;
    /**
     * This index keeps track of all `ReferenceDescription` items exported by a document.
     * This is used to compute which elements are affected by a document change
     * and for finding references to an AST node.
     */
    protected readonly referenceIndex: Map<string, ReferenceDescription[]>;
    constructor(services: LangiumSharedCoreServices);
    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;
    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;
    protected getFileDescriptions(uri: string, nodeType?: string): AstNodeDescription[];
    remove(uri: URI): void;
    updateContent(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provides documentation for AST nodes.
 */
interface DocumentationProvider {
    /**
     * Returns a markdown documentation string for the specified AST node.
     *
     * The default implementation `JSDocDocumentationProvider` will inspect the comment associated with the specified node.
     */
    getDocumentation(node: AstNode): string | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * Metadata of a language.
 */
interface LanguageMetaData {
    languageId: string;
    fileExtensions: readonly string[];
    caseInsensitive: boolean;
    /**
     * Mode used to optimize code for development or production environments.
     *
     * In production mode, all Chevrotain lexer/parser validations are disabled.
     */
    mode: 'development' | 'production';
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A scope describes what target elements are visible from a specific cross-reference context.
 */
interface Scope {
    /**
     * Find a target element matching the given name. If no element is found, `undefined` is returned.
     * If multiple matching elements are present, the selection of the returned element should be done
     * according to the semantics of your language. Usually it is the element that is most closely defined.
     *
     * @param name Name of the cross-reference target as it appears in the source text.
     */
    getElement(name: string): AstNodeDescription | undefined;
    /**
     * Create a stream of all elements in the scope. This is used to compute completion proposals to be
     * shown in the editor.
     */
    getAllElements(): Stream<AstNodeDescription>;
}
interface ScopeOptions {
    caseInsensitive?: boolean;
}

/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for determining the scope of target elements visible in a specific cross-reference context.
 */
interface ScopeProvider {
    /**
     * Return a scope describing what elements are visible for the given AST node and cross-reference
     * identifier.
     *
     * @param context Information about the reference for which a scope is requested.
     */
    getScope(context: ReferenceInfo): Scope;
}
declare class DefaultScopeProvider implements ScopeProvider {
    protected readonly reflection: AstReflection;
    protected readonly nameProvider: NameProvider;
    protected readonly descriptions: AstNodeDescriptionProvider;
    protected readonly indexManager: IndexManager$1;
    protected readonly globalScopeCache: WorkspaceCache<string, Scope>;
    constructor(services: LangiumCoreServices);
    getScope(context: ReferenceInfo): Scope;
    /**
     * Create a scope for the given collection of AST node descriptions.
     */
    protected createScope(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions): Scope;
    /**
     * Create a scope for the given collection of AST nodes, which need to be transformed into respective
     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
     */
    protected createScopeForNodes(elements: Iterable<AstNode>, outerScope?: Scope, options?: ScopeOptions): Scope;
    /**
     * Create a global scope filtered for the given reference type.
     */
    protected getGlobalScope(referenceType: string, _context: ReferenceInfo): Scope;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for resolving cross-references in the AST.
 */
interface Linker {
    /**
     * Links all cross-references within the specified document. The default implementation loads only target
     * elements from documents that are present in the `LangiumDocuments` service. The linked references are
     * stored in the document's `references` property.
     *
     * @param document A LangiumDocument that shall be linked.
     * @param cancelToken A token for cancelling the operation.
     *
     * @throws `OperationCancelled` if a cancellation event is detected
     */
    link(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    /**
     * Unlinks all references within the specified document and removes them from the list of `references`.
     *
     * @param document A LangiumDocument that shall be unlinked.
     */
    unlink(document: LangiumDocument): void;
    /**
     * Determines a candidate AST node description for linking the given reference.
     *
     * @param refInfo Information about the reference.
     */
    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError;
    /**
     * Creates a cross reference node being aware of its containing AstNode, the corresponding CstNode,
     * the cross reference text denoting the target AstNode being already extracted of the document text,
     * as well as the unique cross reference identifier.
     *
     * Default behavior:
     *  - The returned Reference's 'ref' property pointing to the target AstNode is populated lazily on its
     *    first visit.
     *  - If the target AstNode cannot be resolved on the first visit, an error indicator will be installed
     *    and further resolution attempts will *not* be performed.
     *
     * @param node The containing AST node
     * @param property The AST node property being referenced
     * @param refNode The corresponding CST node
     * @param refText The cross reference text denoting the target AstNode
     * @returns the desired Reference node, whose behavior wrt. resolving the cross reference is implementation specific.
     */
    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference;
}

/******************************************************************************
 * Copyright 2024 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The hydrator service is responsible for allowing AST parse results to be sent across worker threads.
 */
interface Hydrator {
    /**
     * Converts a parse result to a plain object. The resulting object can be sent across worker threads.
     */
    dehydrate(result: ParseResult<AstNode>): ParseResult<object>;
    /**
     * Converts a plain object to a parse result. The included AST node can then be used in the main thread.
     * Calling this method on objects that have not been dehydrated first will result in undefined behavior.
     */
    hydrate<T extends AstNode = AstNode>(result: ParseResult<object>): ParseResult<T>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type MaybePromise$1<T> = T | Promise<T>;
/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
declare class Deferred<T = void> {
    resolve: (value: T) => this;
    reject: (err?: unknown) => this;
    promise: Promise<T>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Async parser that allows cancellation of the current parsing process.
 *
 * @remarks
 * The sync parser implementation is blocking the event loop, which can become quite problematic for large files.
 * The default implementation is not actually async. It just wraps the sync parser in a promise. A real implementation would create worker threads or web workers to offload the parsing work.
 */
interface AsyncParser {
    /**
     * Parses the given text and returns the parse result.
     *
     * @param text The text to parse.
     * @param cancelToken A cancellation token that can be used to cancel the parsing process.
     * @returns A promise that resolves to the parse result.
     *
     * @throws `OperationCancelled` if the parsing process is cancelled.
     */
    parse<T extends AstNode>(text: string, cancelToken: CancellationToken): Promise<ParseResult<T>>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type ValueType = string | number | boolean | bigint | Date;
/**
 * Language-specific service for converting string values from the source text format into a value to be held in the AST.
 */
interface ValueConverter {
    /**
     * Converts a string value from the source text format into a value to be held in the AST.
     */
    convert(input: string, cstNode: CstNode): ValueType;
}
declare namespace ValueConverter {
    function convertString(input: string): string;
    function convertID(input: string): string;
    function convertInt(input: string): number;
    function convertBigint(input: string): bigint;
    function convertDate(input: string): Date;
    function convertNumber(input: string): number;
    function convertBoolean(input: string): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for finding references and declaration of a given `CstNode`.
 */
interface References {
    /**
     * If the CstNode is a reference node the target CstNode will be returned.
     * If the CstNode is a significant node of the CstNode this CstNode will be returned.
     *
     * @param sourceCstNode CstNode that points to a AstNode
     */
    findDeclaration(sourceCstNode: CstNode): AstNode | undefined;
    /**
     * If the CstNode is a reference node the target CstNode will be returned.
     * If the CstNode is a significant node of the CstNode this CstNode will be returned.
     *
     * @param sourceCstNode CstNode that points to a AstNode
     */
    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined;
    /**
     * Finds all references to the target node as references (local references) or reference descriptions.
     *
     * @param targetNode Specified target node whose references should be returned
     */
    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription>;
}
interface FindReferencesOptions {
    /**
     * @deprecated Since v1.2.0. Please use `documentUri` instead.
     */
    onlyLocal?: boolean;
    /**
     * When set, the `findReferences` method will only return references/declarations from the specified document.
     */
    documentUri?: URI;
    /**
     * Whether the returned list of references should include the declaration.
     */
    includeDeclaration?: boolean;
}

/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for precomputing global and local scopes. The service methods are executed
 * as the first and second phase in the `DocumentBuilder`.
 */
interface ScopeComputation {
    /**
     * Creates descriptions of all AST nodes that shall be exported into the _global_ scope from the given
     * document. These descriptions are gathered by the `IndexManager` and stored in the global index so
     * they can be referenced from other documents.
     *
     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference resolution
     * depends on the scope computation phase to be completed (`computeScope` method), which runs after the
     * initial indexing where this method is used.
     *
     * @param document The document from which to gather exported AST nodes.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    computeExports(document: LangiumDocument, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
    /**
     * Precomputes the _local_ scopes for a document, which are necessary for the default way of
     * resolving references to symbols in the same document. The result is a multimap assigning a
     * set of AST node descriptions to every level of the AST. These data are used by the `ScopeProvider`
     * service to determine which target nodes are visible in the context of a specific cross-reference.
     *
     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference
     * resolution depends on the scope computation phase to be completed.
     *
     * @param document The document in which to compute scopes.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken): Promise<PrecomputedScopes>;
}
/**
 * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the
 * _global_ scope from the given document. By default those are the document's root AST node and its directly
 * contained child nodes.
 *
 * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them
 * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,
 * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)
 * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)
 * are _invisible_ by default, but that can be changed by customizing this service.
 */
declare class DefaultScopeComputation implements ScopeComputation {
    protected readonly nameProvider: NameProvider;
    protected readonly descriptions: AstNodeDescriptionProvider;
    constructor(services: LangiumCoreServices);
    computeExports(document: LangiumDocument, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
    /**
     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
     * The list of children to be considered is determined by the function parameter {@link children}.
     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
     *
     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
     * @param document The document containing the AST node to be exported.
     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCancelled` if a user action occurs during execution.
     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
     */
    computeExportsForNode(parentNode: AstNode, document: LangiumDocument<AstNode>, children?: (root: AstNode) => Iterable<AstNode>, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
    /**
     * Add a single node to the list of exports if it has a name. Override this method to change how
     * symbols are exported, e.g. by modifying their exported name.
     */
    protected exportNode(node: AstNode, exports: AstNodeDescription[], document: LangiumDocument): void;
    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken): Promise<PrecomputedScopes>;
    /**
     * Process a single node during scopes computation. The default implementation makes the node visible
     * in the subtree of its container (if the node has a name). Override this method to change this,
     * e.g. by increasing the visibility to a higher level in the AST.
     */
    protected processNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface JsonSerializeOptions {
    /** The space parameter for `JSON.stringify`, controlling whether and how to pretty-print the output. */
    space?: string | number;
    /** Whether to include the `$refText` property for references (the name used to identify the target node). */
    refText?: boolean;
    /** Whether to include the `$sourceText` property, which holds the full source text from which an AST node was parsed. */
    sourceText?: boolean;
    /** Whether to include the `$textRegion` property, which holds information to trace AST node properties to their respective source text regions. */
    textRegions?: boolean;
    /** Whether to include the `$comment` property, which holds comments according to the CommentProvider service. */
    comments?: boolean;
    /** The replacer parameter for `JSON.stringify`; the default replacer given as parameter should be used to apply basic replacements. */
    replacer?: (key: string, value: unknown, defaultReplacer: (key: string, value: unknown) => unknown) => unknown;
    /** Used to convert and serialize URIs when the target of a cross-reference is in a different document. */
    uriConverter?: (uri: URI, reference: Reference) => string;
}
interface JsonDeserializeOptions {
    /** Used to parse and convert URIs when the target of a cross-reference is in a different document. */
    uriConverter?: (uri: string) => URI;
}
/**
 * Utility service for transforming an `AstNode` into a JSON string and vice versa.
 */
interface JsonSerializer {
    /**
     * Serialize an `AstNode` into a JSON `string`.
     * @param node The `AstNode` to be serialized.
     * @param options Serialization options
     */
    serialize(node: AstNode, options?: JsonSerializeOptions): string;
    /**
     * Deserialize (parse) a JSON `string` into an `AstNode`.
     */
    deserialize<T extends AstNode = AstNode>(content: string, options?: JsonDeserializeOptions): T;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type DiagnosticInfo<N extends AstNode, P extends string = Properties<N>> = {
    /** The AST node to which the diagnostic is attached. */
    node: N;
    /** If a property name is given, the diagnostic is restricted to the corresponding text region. */
    property?: P;
    /** If the value of a keyword is given, the diagnostic will appear at its corresponding text region */
    keyword?: string;
    /** In case of a multi-value property (array), an index can be given to select a specific element. */
    index?: number;
    /** If you want to create a diagnostic independent to any property, use the range property. */
    range?: Range$1;
    /** The diagnostic's code, which usually appear in the user interface. */
    code?: integer | string;
    /** An optional property to describe the error code. */
    codeDescription?: CodeDescription;
    /** Additional metadata about the diagnostic. */
    tags?: DiagnosticTag[];
    /** An array of related diagnostic information, e.g. when symbol-names within a scope collide all definitions can be marked via this property. */
    relatedInformation?: DiagnosticRelatedInformation[];
    /** A data entry field that is preserved between a `textDocument/publishDiagnostics` notification and `textDocument/codeAction` request. */
    data?: unknown;
};
type ValidationSeverity = 'error' | 'warning' | 'info' | 'hint';
type ValidationAcceptor = <N extends AstNode>(severity: ValidationSeverity, message: string, info: DiagnosticInfo<N>) => void;
type ValidationCheck<T extends AstNode = AstNode> = (node: T, accept: ValidationAcceptor, cancelToken: CancellationToken) => MaybePromise$1<void>;
/**
 * A utility type for describing functions which will be called once before or after all the AstNodes of an AST/Langium document are validated.
 *
 * The AST is represented by its root AstNode.
 *
 * The given validation acceptor helps to report some early or lately detected issues.
 *
 * The 'categories' indicate, which validation categories are executed for all the AstNodes.
 * This helps to tailor the preparations/tear-down logic to the actually executed checks on the nodes.
 *
 * It is recommended to support interrupts during long-running logic with 'interruptAndCheck(cancelToken)'.
 */
type ValidationPreparation = (rootNode: AstNode, accept: ValidationAcceptor, categories: ValidationCategory[], cancelToken: CancellationToken) => MaybePromise$1<void>;
/**
 * A utility type for associating non-primitive AST types to corresponding validation checks. For example:
 *
 * ```ts
 *   const checks: ValidationChecks<StatemachineAstType> = {
 *       State: validator.checkStateNameStartsWithCapital
 *    };
 * ```
 *
 * If an AST type does not extend AstNode, e.g. if it describes a union of string literals, that type's name must not occur as a key in objects of type `ValidationCheck<...>`.
 *
 * @param T a type definition mapping language specific type names (keys) to the corresponding types (values)
 */
type ValidationChecks<T> = {
    [K in keyof T]?: T[K] extends AstNode ? ValidationCheck<T[K]> | Array<ValidationCheck<T[K]>> : never;
} & {
    AstNode?: ValidationCheck<AstNode> | Array<ValidationCheck<AstNode>>;
};
/**
 * `fast` checks can be executed after every document change (i.e. as the user is typing). If a check
 * is too slow it can delay the response to document changes, yielding bad user experience. By marking
 * it as `slow`, it will be skipped for normal as-you-type validation. Then it's up to you when to
 * schedule these long-running checks: after the fast checks are done, or after saving a document,
 * or with an explicit command, etc.
 *
 * `built-in` checks are errors produced by the lexer, the parser, or the linker. They cannot be used
 * for custom validation checks.
 */
type ValidationCategory = 'fast' | 'slow' | 'built-in';
declare namespace ValidationCategory {
    const all: readonly ValidationCategory[];
}
type ValidationCheckEntry = {
    check: ValidationCheck;
    category: ValidationCategory;
};
/**
 * Manages a set of `ValidationCheck`s to be applied when documents are validated.
 */
declare class ValidationRegistry {
    private readonly entries;
    private readonly reflection;
    private entriesBefore;
    private entriesAfter;
    constructor(services: LangiumCoreServices);
    /**
     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)
     * or an array of validation checks.
     *
     * @param checksRecord Set of validation checks to register.
     * @param category Optional category for the validation checks (defaults to `'fast'`).
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    register<T>(checksRecord: ValidationChecks<T>, thisObj?: ThisParameterType<unknown>, category?: ValidationCategory): void;
    protected wrapValidationException(check: ValidationCheck, thisObj: unknown): ValidationCheck;
    protected handleException(functionality: () => MaybePromise$1<void>, messageContext: string, accept: ValidationAcceptor, node: AstNode): Promise<void>;
    protected addEntry(type: string, entry: ValidationCheckEntry): void;
    getChecks(type: string, categories?: ValidationCategory[]): Stream<ValidationCheck>;
    /**
     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.
     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.
     *
     * As an example, for validating unique fully-qualified names of nodes in the AST,
     * here the map for mapping names to nodes could be established.
     * During the usual checks on the nodes, they are put into this map with their name.
     *
     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
     * Therefore it is recommended to clear stored information
     * _before_ validating an AST to validate each AST unaffected from other ASTs
     * AND _after_ validating the AST to free memory by information which are no longer used.
     *
     * @param checkBefore a set-up function which will be called once before actually validating an AST
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    registerBeforeDocument(checkBefore: ValidationPreparation, thisObj?: ThisParameterType<unknown>): void;
    /**
     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.
     * This helps to finally evaluate information which are collected during the checks on the AstNodes.
     *
     * As an example, for validating unique fully-qualified names of nodes in the AST,
     * here the map with all the collected nodes and their names is checked
     * and validation hints are created for all nodes with the same name.
     *
     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
     * Therefore it is recommended to clear stored information
     * _before_ validating an AST to validate each AST unaffected from other ASTs
     * AND _after_ validating the AST to free memory by information which are no longer used.
     *
     * @param checkBefore a set-up function which will be called once before actually validating an AST
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    registerAfterDocument(checkAfter: ValidationPreparation, thisObj?: ThisParameterType<unknown>): void;
    protected wrapPreparationException(check: ValidationPreparation, messageContext: string, thisObj: unknown): ValidationPreparation;
    get checksBefore(): ValidationPreparation[];
    get checksAfter(): ValidationPreparation[];
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ValidationOptions {
    /**
     * If this is set, only the checks associated with these categories are executed; otherwise
     * all checks are executed. The default category if not specified to the registry is `'fast'`.
     */
    categories?: ValidationCategory[];
    /** If true, no further diagnostics are reported if there are lexing errors. */
    stopAfterLexingErrors?: boolean;
    /** If true, no further diagnostics are reported if there are parsing errors. */
    stopAfterParsingErrors?: boolean;
    /** If true, no further diagnostics are reported if there are linking errors. */
    stopAfterLinkingErrors?: boolean;
}
/**
 * Language-specific service for validating `LangiumDocument`s.
 */
interface DocumentValidator {
    /**
     * Validates the whole specified document.
     *
     * @param document specified document to validate
     * @param options options to control the validation process
     * @param cancelToken allows to cancel the current operation
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    validateDocument(document: LangiumDocument, options?: ValidationOptions, cancelToken?: CancellationToken): Promise<Diagnostic[]>;
}
declare namespace DocumentValidator {
    const LexingError = "lexing-error";
    const LexingWarning = "lexing-warning";
    const LexingInfo = "lexing-info";
    const LexingHint = "lexing-hint";
    const ParsingError = "parsing-error";
    const LinkingError = "linking-error";
}

interface ResponseErrorLiteral<D = void> {
    /**
     * A number indicating the error type that occurred.
     */
    code: number;
    /**
     * A string providing a short description of the error.
     */
    message: string;
    /**
     * A Primitive or Structured value that contains additional
     * information about the error. Can be omitted.
     */
    data?: D;
}
/**
 * An error object return in a response in case a request
 * has failed.
 */
declare class ResponseError<D = void> extends Error {
    readonly code: number;
    readonly data: D | undefined;
    constructor(code: number, message: string, data?: D);
    toJson(): ResponseErrorLiteral<D>;
}
declare class ParameterStructures {
    private readonly kind;
    /**
     * The parameter structure is automatically inferred on the number of parameters
     * and the parameter type in case of a single param.
     */
    static readonly auto: ParameterStructures;
    /**
     * Forces `byPosition` parameter structure. This is useful if you have a single
     * parameter which has a literal type.
     */
    static readonly byPosition: ParameterStructures;
    /**
     * Forces `byName` parameter structure. This is only useful when having a single
     * parameter. The library will report errors if used with a different number of
     * parameters.
     */
    static readonly byName: ParameterStructures;
    private constructor();
    static is(value: any): value is ParameterStructures;
    toString(): string;
}
/**
 * An interface to type messages.
 */
interface MessageSignature {
    readonly method: string;
    readonly numberOfParams: number;
    readonly parameterStructures: ParameterStructures;
}
/**
 * An abstract implementation of a MessageType.
 */
declare abstract class AbstractMessageSignature implements MessageSignature {
    readonly method: string;
    readonly numberOfParams: number;
    constructor(method: string, numberOfParams: number);
    get parameterStructures(): ParameterStructures;
}
/**
 * End marker interface for request and notification types.
 */
interface _EM {
    _$endMarker$_: number;
}
/**
 * Classes to type request response pairs
 */
declare class RequestType0<R, E> extends AbstractMessageSignature {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [R, E, _EM] | undefined;
    constructor(method: string);
}
declare class RequestType<P, R, E> extends AbstractMessageSignature {
    private _parameterStructures;
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [P, R, E, _EM] | undefined;
    constructor(method: string, _parameterStructures?: ParameterStructures);
    get parameterStructures(): ParameterStructures;
}
declare class NotificationType<P> extends AbstractMessageSignature {
    private _parameterStructures;
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [P, _EM] | undefined;
    constructor(method: string, _parameterStructures?: ParameterStructures);
    get parameterStructures(): ParameterStructures;
}
declare class NotificationType0 extends AbstractMessageSignature {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [_EM] | undefined;
    constructor(method: string);
}

type ProgressToken = number | string;
declare namespace ProgressToken {
    function is(value: any): value is number | string;
}
declare class ProgressType<PR> {
    /**
     * Clients must not use these properties. They are here to ensure correct typing.
     * in TypeScript
     */
    readonly __: [PR, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor();
}
type HandlerResult<R, E> = R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>> | Thenable<R | ResponseError<E>>;
interface StarRequestHandler {
    (method: string, params: any[] | object | undefined, token: CancellationToken): HandlerResult<any, any>;
}
interface GenericRequestHandler<R, E> {
    (...params: any[]): HandlerResult<R, E>;
}
interface RequestHandler0<R, E> {
    (token: CancellationToken): HandlerResult<R, E>;
}
interface RequestHandler<P, R, E> {
    (params: P, token: CancellationToken): HandlerResult<R, E>;
}
interface StarNotificationHandler {
    (method: string, params: any[] | object | undefined): void;
}
interface GenericNotificationHandler {
    (...params: any[]): void;
}
interface NotificationHandler0 {
    (): void;
}
interface NotificationHandler<P> {
    (params: P): void;
}
interface NotificationHandler1<P1> {
    (p1: P1): void;
}
declare namespace TraceValues {
    /**
     * Turn tracing off.
     */
    const Off: 'off';
    /**
     * Trace messages only.
     */
    const Messages: 'messages';
    /**
     * Compact message tracing.
     */
    const Compact: 'compact';
    /**
     * Verbose message tracing.
     */
    const Verbose: 'verbose';
}
type TraceValues = 'off' | 'messages' | 'compact' | 'verbose';

declare class RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ____: [RO, _EM] | undefined;
    readonly method: string;
    constructor(method: string);
}
declare class ProtocolRequestType0<R, PR, E, RO> extends RequestType0<R, E> implements ProgressType<PR>, RegistrationType<RO> {
    /**
     * Clients must not use these properties. They are here to ensure correct typing.
     * in TypeScript
     */
    readonly __: [PR, _EM] | undefined;
    readonly ___: [PR, RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor(method: string);
}
declare class ProtocolRequestType<P, R, PR, E, RO> extends RequestType<P, R, E> implements ProgressType<PR>, RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly __: [PR, _EM] | undefined;
    readonly ___: [PR, RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor(method: string);
}
declare class ProtocolNotificationType0<RO> extends NotificationType0 implements RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ___: [RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    constructor(method: string);
}
declare class ProtocolNotificationType<P, RO> extends NotificationType<P> implements RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ___: [RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    constructor(method: string);
}

/**
 * @since 3.6.0
 */
interface ImplementationClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `ImplementationRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * @since 3.14.0
     */
    linkSupport?: boolean;
}
interface ImplementationOptions extends WorkDoneProgressOptions {
}
interface ImplementationRegistrationOptions extends TextDocumentRegistrationOptions, ImplementationOptions, StaticRegistrationOptions {
}
interface ImplementationParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

/**
 * Since 3.6.0
 */
interface TypeDefinitionClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `TypeDefinitionRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * Since 3.14.0
     */
    linkSupport?: boolean;
}
interface TypeDefinitionOptions extends WorkDoneProgressOptions {
}
interface TypeDefinitionRegistrationOptions extends TextDocumentRegistrationOptions, TypeDefinitionOptions, StaticRegistrationOptions {
}
interface TypeDefinitionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

interface WorkspaceFoldersInitializeParams {
    /**
     * The workspace folders configured in the client when the server starts.
     *
     * This property is only available if the client supports workspace folders.
     * It can be `null` if the client supports workspace folders but none are
     * configured.
     *
     * @since 3.6.0
     */
    workspaceFolders?: WorkspaceFolder[] | null;
}
interface WorkspaceFoldersServerCapabilities {
    /**
     * The server has support for workspace folders
     */
    supported?: boolean;
    /**
     * Whether the server wants to receive workspace folder
     * change notifications.
     *
     * If a string is provided the string is treated as an ID
     * under which the notification is registered on the client
     * side. The ID can be used to unregister for these events
     * using the `client/unregisterCapability` request.
     */
    changeNotifications?: string | boolean;
}
/**
 * The workspace folder change event.
 */
interface WorkspaceFoldersChangeEvent {
    /**
     * The array of added workspace folders
     */
    added: WorkspaceFolder[];
    /**
     * The array of the removed workspace folders
     */
    removed: WorkspaceFolder[];
}

interface ConfigurationItem {
    /**
     * The scope to get the configuration section for.
     */
    scopeUri?: URI$1;
    /**
     * The configuration section asked for.
     */
    section?: string;
}

interface DocumentColorClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `DocumentColorRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface DocumentColorOptions extends WorkDoneProgressOptions {
}
interface DocumentColorRegistrationOptions extends TextDocumentRegistrationOptions, StaticRegistrationOptions, DocumentColorOptions {
}
/**
 * Parameters for a {@link DocumentColorRequest}.
 */
interface DocumentColorParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Parameters for a {@link ColorPresentationRequest}.
 */
interface ColorPresentationParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The color to request presentations for.
     */
    color: Color;
    /**
     * The range where the color would be inserted. Serves as a context.
     */
    range: Range$1;
}

interface FoldingRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration for folding range
     * providers. If this is set to `true` the client supports the new
     * `FoldingRangeRegistrationOptions` return value for the corresponding
     * server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The maximum number of folding ranges that the client prefers to receive
     * per document. The value serves as a hint, servers are free to follow the
     * limit.
     */
    rangeLimit?: uinteger;
    /**
     * If set, the client signals that it only supports folding complete lines.
     * If set, client will ignore specified `startCharacter` and `endCharacter`
     * properties in a FoldingRange.
     */
    lineFoldingOnly?: boolean;
    /**
     * Specific options for the folding range kind.
     *
     * @since 3.17.0
     */
    foldingRangeKind?: {
        /**
         * The folding range kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         */
        valueSet?: FoldingRangeKind[];
    };
    /**
     * Specific options for the folding range.
     *
     * @since 3.17.0
     */
    foldingRange?: {
        /**
        * If set, the client signals that it supports setting collapsedText on
        * folding ranges to display custom labels instead of the default text.
        *
        * @since 3.17.0
        */
        collapsedText?: boolean;
    };
}
/**
 * Client workspace capabilities specific to folding ranges
 *
 * @since 3.18.0
 * @proposed
 */
interface FoldingRangeWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * folding ranges currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     *
     * @since 3.18.0
     * @proposed
     */
    refreshSupport?: boolean;
}
interface FoldingRangeOptions extends WorkDoneProgressOptions {
}
interface FoldingRangeRegistrationOptions extends TextDocumentRegistrationOptions, FoldingRangeOptions, StaticRegistrationOptions {
}
/**
 * Parameters for a {@link FoldingRangeRequest}.
 */
interface FoldingRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}

/**
 * @since 3.14.0
 */
interface DeclarationClientCapabilities {
    /**
     * Whether declaration supports dynamic registration. If this is set to `true`
     * the client supports the new `DeclarationRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of declaration links.
     */
    linkSupport?: boolean;
}
interface DeclarationOptions extends WorkDoneProgressOptions {
}
interface DeclarationRegistrationOptions extends DeclarationOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions {
}
interface DeclarationParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

interface SelectionRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
     * the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
     * capability as well.
     */
    dynamicRegistration?: boolean;
}
interface SelectionRangeOptions extends WorkDoneProgressOptions {
}
interface SelectionRangeRegistrationOptions extends SelectionRangeOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions {
}
/**
 * A parameter literal used in selection range requests.
 */
interface SelectionRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The positions inside the text document.
     */
    positions: Position$1[];
}

/**
 * @since 3.16.0
 */
interface CallHierarchyClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
/**
 * Call hierarchy options used during static registration.
 *
 * @since 3.16.0
 */
interface CallHierarchyOptions extends WorkDoneProgressOptions {
}
/**
 * Call hierarchy options used during static or dynamic registration.
 *
 * @since 3.16.0
 */
interface CallHierarchyRegistrationOptions extends TextDocumentRegistrationOptions, CallHierarchyOptions, StaticRegistrationOptions {
}
/**
 * The parameter of a `textDocument/prepareCallHierarchy` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyPrepareParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * The parameter of a `callHierarchy/incomingCalls` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyIncomingCallsParams extends WorkDoneProgressParams, PartialResultParams {
    item: CallHierarchyItem;
}
/**
 * The parameter of a `callHierarchy/outgoingCalls` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyOutgoingCallsParams extends WorkDoneProgressParams, PartialResultParams {
    item: CallHierarchyItem;
}

/**
 * @since 3.16.0
 */
interface SemanticTokensPartialResult {
    data: uinteger[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDeltaPartialResult {
    edits: SemanticTokensEdit[];
}
declare namespace TokenFormat {
    const Relative: 'relative';
}
type TokenFormat = 'relative';
/**
 * @since 3.16.0
 */
interface SemanticTokensClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * Which requests the client supports and might send to the server
     * depending on the server's capability. Please note that clients might not
     * show semantic tokens or degrade some of the user experience if a range
     * or full request is advertised by the client but not provided by the
     * server. If for example the client capability `requests.full` and
     * `request.range` are both set to true but the server only provides a
     * range provider the client might not render a minimap correctly or might
     * even decide to not show any semantic tokens at all.
     */
    requests: {
        /**
         * The client will send the `textDocument/semanticTokens/range` request if
         * the server provides a corresponding handler.
         */
        range?: boolean | {};
        /**
         * The client will send the `textDocument/semanticTokens/full` request if
         * the server provides a corresponding handler.
         */
        full?: boolean | {
            /**
             * The client will send the `textDocument/semanticTokens/full/delta` request if
             * the server provides a corresponding handler.
             */
            delta?: boolean;
        };
    };
    /**
     * The token types that the client supports.
     */
    tokenTypes: string[];
    /**
     * The token modifiers that the client supports.
     */
    tokenModifiers: string[];
    /**
     * The token formats the clients supports.
     */
    formats: TokenFormat[];
    /**
     * Whether the client supports tokens that can overlap each other.
     */
    overlappingTokenSupport?: boolean;
    /**
     * Whether the client supports tokens that can span multiple lines.
     */
    multilineTokenSupport?: boolean;
    /**
     * Whether the client allows the server to actively cancel a
     * semantic token request, e.g. supports returning
     * LSPErrorCodes.ServerCancelled. If a server does the client
     * needs to retrigger the request.
     *
     * @since 3.17.0
     */
    serverCancelSupport?: boolean;
    /**
     * Whether the client uses semantic tokens to augment existing
     * syntax tokens. If set to `true` client side created syntax
     * tokens and semantic tokens are both used for colorization. If
     * set to `false` the client only uses the returned semantic tokens
     * for colorization.
     *
     * If the value is `undefined` then the client behavior is not
     * specified.
     *
     * @since 3.17.0
     */
    augmentsSyntaxTokens?: boolean;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensOptions extends WorkDoneProgressOptions {
    /**
     * The legend used by the server
     */
    legend: SemanticTokensLegend;
    /**
     * Server supports providing semantic tokens for a specific range
     * of a document.
     */
    range?: boolean | {};
    /**
     * Server supports providing semantic tokens for a full document.
     */
    full?: boolean | {
        /**
         * The server supports deltas for full documents.
         */
        delta?: boolean;
    };
}
/**
 * @since 3.16.0
 */
interface SemanticTokensRegistrationOptions extends TextDocumentRegistrationOptions, SemanticTokensOptions, StaticRegistrationOptions {
}
/**
 * @since 3.16.0
 */
interface SemanticTokensParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDeltaParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The result id of a previous response. The result Id can either point to a full response
     * or a delta response depending on what was received last.
     */
    previousResultId: string;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range the semantic tokens are requested for.
     */
    range: Range$1;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * semantic tokens currently shown. It should be used with absolute care
     * and is useful for situation where a server for example detects a project
     * wide change that requires such a calculation.
     */
    refreshSupport?: boolean;
}

/**
 * Client capabilities for the showDocument request.
 *
 * @since 3.16.0
 */
interface ShowDocumentClientCapabilities {
    /**
     * The client has support for the showDocument
     * request.
     */
    support: boolean;
}
/**
 * Params to show a resource in the UI.
 *
 * @since 3.16.0
 */
interface ShowDocumentParams {
    /**
     * The uri to show.
     */
    uri: URI$1;
    /**
     * Indicates to show the resource in an external program.
     * To show, for example, `https://code.visualstudio.com/`
     * in the default WEB browser set `external` to `true`.
     */
    external?: boolean;
    /**
     * An optional property to indicate whether the editor
     * showing the document should take focus or not.
     * Clients might ignore this property if an external
     * program is started.
     */
    takeFocus?: boolean;
    /**
     * An optional selection range if the document is a text
     * document. Clients might ignore the property if an
     * external program is started or the file is not a text
     * file.
     */
    selection?: Range$1;
}
/**
 * The result of a showDocument request.
 *
 * @since 3.16.0
 */
interface ShowDocumentResult {
    /**
     * A boolean indicating if the show was successful.
     */
    success: boolean;
}

/**
 * Client capabilities for the linked editing range request.
 *
 * @since 3.16.0
 */
interface LinkedEditingRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface LinkedEditingRangeParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
interface LinkedEditingRangeOptions extends WorkDoneProgressOptions {
}
interface LinkedEditingRangeRegistrationOptions extends TextDocumentRegistrationOptions, LinkedEditingRangeOptions, StaticRegistrationOptions {
}
/**
 * The result of a linked editing range request.
 *
 * @since 3.16.0
 */
interface LinkedEditingRanges {
    /**
     * A list of ranges that can be edited together. The ranges must have
     * identical length and contain identical text content. The ranges cannot overlap.
     */
    ranges: Range$1[];
    /**
     * An optional word pattern (regular expression) that describes valid contents for
     * the given ranges. If no pattern is provided, the client configuration's word
     * pattern will be used.
     */
    wordPattern?: string;
}

/**
 * Options for notifications/requests for user operations on files.
 *
 * @since 3.16.0
 */
interface FileOperationOptions {
    /**
    * The server is interested in receiving didCreateFiles notifications.
    */
    didCreate?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willCreateFiles requests.
    */
    willCreate?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving didRenameFiles notifications.
    */
    didRename?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willRenameFiles requests.
    */
    willRename?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving didDeleteFiles file notifications.
    */
    didDelete?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willDeleteFiles file requests.
    */
    willDelete?: FileOperationRegistrationOptions;
}
/**
 * The options to register for file operations.
 *
 * @since 3.16.0
 */
interface FileOperationRegistrationOptions {
    /**
     * The actual filters.
     */
    filters: FileOperationFilter[];
}
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
declare namespace FileOperationPatternKind {
    /**
     * The pattern matches a file only.
     */
    const file: 'file';
    /**
     * The pattern matches a folder only.
     */
    const folder: 'folder';
}
type FileOperationPatternKind = 'file' | 'folder';
/**
 * Matching options for the file operation pattern.
 *
 * @since 3.16.0
 */
interface FileOperationPatternOptions {
    /**
     * The pattern should be matched ignoring casing.
     */
    ignoreCase?: boolean;
}
/**
 * A pattern to describe in which file operation requests or notifications
 * the server is interested in receiving.
 *
 * @since 3.16.0
 */
interface FileOperationPattern {
    /**
     * The glob pattern to match. Glob patterns can have the following syntax:
     * - `*` to match one or more characters in a path segment
     * - `?` to match on one character in a path segment
     * - `**` to match any number of path segments, including none
     * - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
     * - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
     * - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
     */
    glob: string;
    /**
     * Whether to match files or folders with this pattern.
     *
     * Matches both if undefined.
     */
    matches?: FileOperationPatternKind;
    /**
     * Additional options used during matching.
     */
    options?: FileOperationPatternOptions;
}
/**
 * A filter to describe in which file operation requests or notifications
 * the server is interested in receiving.
 *
 * @since 3.16.0
 */
interface FileOperationFilter {
    /**
     * A Uri scheme like `file` or `untitled`.
     */
    scheme?: string;
    /**
     * The actual file operation pattern.
     */
    pattern: FileOperationPattern;
}
/**
 * Capabilities relating to events from file operations by the user in the client.
 *
 * These events do not come from the file system, they come from user operations
 * like renaming a file in the UI.
 *
 * @since 3.16.0
 */
interface FileOperationClientCapabilities {
    /**
     * Whether the client supports dynamic registration for file requests/notifications.
     */
    dynamicRegistration?: boolean;
    /**
     * The client has support for sending didCreateFiles notifications.
     */
    didCreate?: boolean;
    /**
     * The client has support for sending willCreateFiles requests.
     */
    willCreate?: boolean;
    /**
     * The client has support for sending didRenameFiles notifications.
     */
    didRename?: boolean;
    /**
     * The client has support for sending willRenameFiles requests.
     */
    willRename?: boolean;
    /**
     * The client has support for sending didDeleteFiles notifications.
     */
    didDelete?: boolean;
    /**
     * The client has support for sending willDeleteFiles requests.
     */
    willDelete?: boolean;
}
/**
 * The parameters sent in notifications/requests for user-initiated creation of
 * files.
 *
 * @since 3.16.0
 */
interface CreateFilesParams {
    /**
     * An array of all files/folders created in this operation.
     */
    files: FileCreate[];
}
/**
 * Represents information on a file/folder create.
 *
 * @since 3.16.0
 */
interface FileCreate {
    /**
     * A file:// URI for the location of the file/folder being created.
     */
    uri: string;
}
/**
 * The parameters sent in notifications/requests for user-initiated renames of
 * files.
 *
 * @since 3.16.0
 */
interface RenameFilesParams {
    /**
     * An array of all files/folders renamed in this operation. When a folder is renamed, only
     * the folder will be included, and not its children.
     */
    files: FileRename[];
}
/**
 * Represents information on a file/folder rename.
 *
 * @since 3.16.0
 */
interface FileRename {
    /**
     * A file:// URI for the original location of the file/folder being renamed.
     */
    oldUri: string;
    /**
     * A file:// URI for the new location of the file/folder being renamed.
     */
    newUri: string;
}
/**
 * The parameters sent in notifications/requests for user-initiated deletes of
 * files.
 *
 * @since 3.16.0
 */
interface DeleteFilesParams {
    /**
     * An array of all files/folders deleted in this operation.
     */
    files: FileDelete[];
}
/**
 * Represents information on a file/folder delete.
 *
 * @since 3.16.0
 */
interface FileDelete {
    /**
     * A file:// URI for the location of the file/folder being deleted.
     */
    uri: string;
}

/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
declare namespace UniquenessLevel {
    /**
     * The moniker is only unique inside a document
     */
    const document = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    const project = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    const group = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    const scheme = "scheme";
    /**
     * The moniker is globally unique
     */
    const global = "global";
}
type UniquenessLevel = 'document' | 'project' | 'group' | 'scheme' | 'global';
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
declare namespace MonikerKind {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    const $import = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    const $export = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    const local = "local";
}
type MonikerKind = 'import' | 'export' | 'local';
/**
 * Moniker definition to match LSIF 0.5 moniker definition.
 *
 * @since 3.16.0
 */
interface Moniker {
    /**
     * The scheme of the moniker. For example tsc or .Net
     */
    scheme: string;
    /**
     * The identifier of the moniker. The value is opaque in LSIF however
     * schema owners are allowed to define the structure if they want.
     */
    identifier: string;
    /**
     * The scope in which the moniker is unique
     */
    unique: UniquenessLevel;
    /**
     * The moniker kind if known.
     */
    kind?: MonikerKind;
}
/**
 * Client capabilities specific to the moniker request.
 *
 * @since 3.16.0
 */
interface MonikerClientCapabilities {
    /**
     * Whether moniker supports dynamic registration. If this is set to `true`
     * the client supports the new `MonikerRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface MonikerOptions extends WorkDoneProgressOptions {
}
interface MonikerRegistrationOptions extends TextDocumentRegistrationOptions, MonikerOptions {
}
interface MonikerParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

/**
 * @since 3.17.0
 */
type TypeHierarchyClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
};
/**
 * Type hierarchy options used during static registration.
 *
 * @since 3.17.0
 */
type TypeHierarchyOptions = WorkDoneProgressOptions;
/**
 * Type hierarchy options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type TypeHierarchyRegistrationOptions = TextDocumentRegistrationOptions & TypeHierarchyOptions & StaticRegistrationOptions;
/**
 * The parameter of a `textDocument/prepareTypeHierarchy` request.
 *
 * @since 3.17.0
 */
type TypeHierarchyPrepareParams = TextDocumentPositionParams & WorkDoneProgressParams;
/**
 * The parameter of a `typeHierarchy/supertypes` request.
 *
 * @since 3.17.0
 */
type TypeHierarchySupertypesParams = WorkDoneProgressParams & PartialResultParams & {
    item: TypeHierarchyItem;
};
/**
 * The parameter of a `typeHierarchy/subtypes` request.
 *
 * @since 3.17.0
 */
type TypeHierarchySubtypesParams = WorkDoneProgressParams & PartialResultParams & {
    item: TypeHierarchyItem;
};

/**
 * Client capabilities specific to inline values.
 *
 * @since 3.17.0
 */
type InlineValueClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration for inline value providers.
     */
    dynamicRegistration?: boolean;
};
/**
 * Client workspace capabilities specific to inline values.
 *
 * @since 3.17.0
 */
type InlineValueWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * inline values currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Inline value options used during static registration.
 *
 * @since 3.17.0
 */
type InlineValueOptions = WorkDoneProgressOptions;
/**
 * Inline value options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type InlineValueRegistrationOptions = InlineValueOptions & TextDocumentRegistrationOptions & StaticRegistrationOptions;
/**
 * A parameter literal used in inline value requests.
 *
 * @since 3.17.0
 */
type InlineValueParams = WorkDoneProgressParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The document range for which inline values should be computed.
     */
    range: Range$1;
    /**
     * Additional information about the context in which inline values were
     * requested.
     */
    context: InlineValueContext;
};

/**
 * Inlay hint client capabilities.
 *
 * @since 3.17.0
 */
type InlayHintClientCapabilities = {
    /**
     * Whether inlay hints support dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Indicates which properties a client can resolve lazily on an inlay
     * hint.
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily.
         */
        properties: string[];
    };
};
/**
 * Client workspace capabilities specific to inlay hints.
 *
 * @since 3.17.0
 */
type InlayHintWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * inlay hints currently shown. It should be used with absolute care and
     * is useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Inlay hint options used during static registration.
 *
 * @since 3.17.0
 */
type InlayHintOptions = WorkDoneProgressOptions & {
    /**
     * The server provides support to resolve additional
     * information for an inlay hint item.
     */
    resolveProvider?: boolean;
};
/**
 * Inlay hint options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type InlayHintRegistrationOptions = InlayHintOptions & TextDocumentRegistrationOptions & StaticRegistrationOptions;
/**
 * A parameter literal used in inlay hint requests.
 *
 * @since 3.17.0
 */
type InlayHintParams = WorkDoneProgressParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The document range for which inlay hints should be computed.
     */
    range: Range$1;
};

/**
 * Client capabilities specific to diagnostic pull requests.
 *
 * @since 3.17.0
 */
type DiagnosticClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the clients supports related documents for document diagnostic pulls.
     */
    relatedDocumentSupport?: boolean;
};
/**
 * Workspace client capabilities specific to diagnostic pull requests.
 *
 * @since 3.17.0
 */
type DiagnosticWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * pulled diagnostics currently shown. It should be used with absolute care and
     * is useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Diagnostic options.
 *
 * @since 3.17.0
 */
type DiagnosticOptions = WorkDoneProgressOptions & {
    /**
     * An optional identifier under which the diagnostics are
     * managed by the client.
     */
    identifier?: string;
    /**
     * Whether the language has inter file dependencies meaning that
     * editing code in one file can result in a different diagnostic
     * set in another file. Inter file dependencies are common for
     * most programming languages and typically uncommon for linters.
     */
    interFileDependencies: boolean;
    /**
     * The server provides support for workspace diagnostics as well.
     */
    workspaceDiagnostics: boolean;
};
/**
 * Diagnostic registration options.
 *
 * @since 3.17.0
 */
type DiagnosticRegistrationOptions = TextDocumentRegistrationOptions & DiagnosticOptions & StaticRegistrationOptions;
/**
 * Cancellation data returned from a diagnostic request.
 *
 * @since 3.17.0
 */
type DiagnosticServerCancellationData = {
    retriggerRequest: boolean;
};
/**
 * @since 3.17.0
 */
declare namespace DiagnosticServerCancellationData {
    function is(value: any): value is DiagnosticServerCancellationData;
}
/**
 * Parameters of the document diagnostic request.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticParams = WorkDoneProgressParams & PartialResultParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The additional identifier  provided during registration.
     */
    identifier?: string;
    /**
     * The result id of a previous response if provided.
     */
    previousResultId?: string;
};
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
declare namespace DocumentDiagnosticReportKind {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    const Full = "full";
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    const Unchanged = "unchanged";
}
type DocumentDiagnosticReportKind = 'full' | 'unchanged';
/**
 * A diagnostic report with a full set of problems.
 *
 * @since 3.17.0
 */
type FullDocumentDiagnosticReport = {
    /**
     * A full document diagnostic report.
     */
    kind: typeof DocumentDiagnosticReportKind.Full;
    /**
     * An optional result id. If provided it will
     * be sent on the next diagnostic request for the
     * same document.
     */
    resultId?: string;
    /**
     * The actual items.
     */
    items: Diagnostic[];
};
/**
 * A full diagnostic report with a set of related documents.
 *
 * @since 3.17.0
 */
type RelatedFullDocumentDiagnosticReport = FullDocumentDiagnosticReport & {
    /**
     * Diagnostics of related documents. This information is useful
     * in programming languages where code in a file A can generate
     * diagnostics in a file B which A depends on. An example of
     * such a language is C/C++ where marco definitions in a file
     * a.cpp and result in errors in a header file b.hpp.
     *
     * @since 3.17.0
     */
    relatedDocuments?: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * A diagnostic report indicating that the last returned
 * report is still accurate.
 *
 * @since 3.17.0
 */
type UnchangedDocumentDiagnosticReport = {
    /**
     * A document diagnostic report indicating
     * no changes to the last result. A server can
     * only return `unchanged` if result ids are
     * provided.
     */
    kind: typeof DocumentDiagnosticReportKind.Unchanged;
    /**
     * A result id which will be sent on the next
     * diagnostic request for the same document.
     */
    resultId: string;
};
/**
 * An unchanged diagnostic report with a set of related documents.
 *
 * @since 3.17.0
 */
type RelatedUnchangedDocumentDiagnosticReport = UnchangedDocumentDiagnosticReport & {
    /**
     * Diagnostics of related documents. This information is useful
     * in programming languages where code in a file A can generate
     * diagnostics in a file B which A depends on. An example of
     * such a language is C/C++ where marco definitions in a file
     * a.cpp and result in errors in a header file b.hpp.
     *
     * @since 3.17.0
     */
    relatedDocuments?: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * The result of a document diagnostic pull request. A report can
 * either be a full report containing all diagnostics for the
 * requested document or an unchanged report indicating that nothing
 * has changed in terms of diagnostics in comparison to the last
 * pull request.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticReport = RelatedFullDocumentDiagnosticReport | RelatedUnchangedDocumentDiagnosticReport;
/**
 * A partial result for a document diagnostic report.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticReportPartialResult = {
    relatedDocuments: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * A previous result id in a workspace pull request.
 *
 * @since 3.17.0
 */
type PreviousResultId = {
    /**
     * The URI for which the client knowns a
     * result id.
     */
    uri: DocumentUri$1;
    /**
     * The value of the previous result id.
     */
    value: string;
};
/**
 * Parameters of the workspace diagnostic request.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticParams = WorkDoneProgressParams & PartialResultParams & {
    /**
     * The additional identifier provided during registration.
     */
    identifier?: string;
    /**
     * The currently known diagnostic reports with their
     * previous result ids.
     */
    previousResultIds: PreviousResultId[];
};
/**
 * A full document diagnostic report for a workspace diagnostic result.
 *
 * @since 3.17.0
 */
type WorkspaceFullDocumentDiagnosticReport = FullDocumentDiagnosticReport & {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * The version number for which the diagnostics are reported.
     * If the document is not marked as open `null` can be provided.
     */
    version: integer | null;
};
/**
 * An unchanged document diagnostic report for a workspace diagnostic result.
 *
 * @since 3.17.0
 */
type WorkspaceUnchangedDocumentDiagnosticReport = UnchangedDocumentDiagnosticReport & {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * The version number for which the diagnostics are reported.
     * If the document is not marked as open `null` can be provided.
     */
    version: integer | null;
};
/**
 * A workspace diagnostic document report.
 *
 * @since 3.17.0
 */
type WorkspaceDocumentDiagnosticReport = WorkspaceFullDocumentDiagnosticReport | WorkspaceUnchangedDocumentDiagnosticReport;
/**
 * A workspace diagnostic report.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticReport = {
    items: WorkspaceDocumentDiagnosticReport[];
};
/**
 * A partial result for a workspace diagnostic report.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticReportPartialResult = {
    items: WorkspaceDocumentDiagnosticReport[];
};

/**
 * Notebook specific client capabilities.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is
     * set to `true` the client supports the new
     * `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports sending execution summary data per cell.
     */
    executionSummarySupport?: boolean;
};
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
declare namespace NotebookCellKind {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    const Markup: 1;
    /**
     * A code-cell is source code.
     */
    const Code: 2;
    function is(value: any): value is NotebookCellKind;
}
type NotebookCellKind = 1 | 2;
type ExecutionSummary = {
    /**
     * A strict monotonically increasing value
     * indicating the execution order of a cell
     * inside a notebook.
     */
    executionOrder: uinteger;
    /**
     * Whether the execution was successful or
     * not if known by the client.
     */
    success?: boolean;
};
declare namespace ExecutionSummary {
    function create(executionOrder: number, success?: boolean): ExecutionSummary;
    function is(value: any): value is ExecutionSummary;
    function equals(one: ExecutionSummary | undefined, other: ExecutionSummary | undefined): boolean;
}
/**
 * A notebook cell.
 *
 * A cell's document URI must be unique across ALL notebook
 * cells and can therefore be used to uniquely identify a
 * notebook cell or the cell's text document.
 *
 * @since 3.17.0
 */
type NotebookCell = {
    /**
     * The cell's kind
     */
    kind: NotebookCellKind;
    /**
     * The URI of the cell's text document
     * content.
     */
    document: DocumentUri$1;
    /**
     * Additional metadata stored with the cell.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * Additional execution summary information
     * if supported by the client.
     */
    executionSummary?: ExecutionSummary;
};
declare namespace NotebookCell {
    function create(kind: NotebookCellKind, document: DocumentUri$1): NotebookCell;
    function is(value: any): value is NotebookCell;
    function diff(one: NotebookCell, two: NotebookCell): Set<keyof NotebookCell>;
}
/**
 * A notebook document.
 *
 * @since 3.17.0
 */
type NotebookDocument = {
    /**
     * The notebook document's uri.
     */
    uri: URI$1;
    /**
     * The type of the notebook.
     */
    notebookType: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     */
    version: integer;
    /**
     * Additional metadata stored with the notebook
     * document.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * The cells of a notebook.
     */
    cells: NotebookCell[];
};
declare namespace NotebookDocument {
    function create(uri: URI$1, notebookType: string, version: integer, cells: NotebookCell[]): NotebookDocument;
    function is(value: any): value is NotebookDocument;
}
/**
 * A literal to identify a notebook document in the client.
 *
 * @since 3.17.0
 */
type NotebookDocumentIdentifier = {
    /**
     * The notebook document's uri.
     */
    uri: URI$1;
};
/**
 * A versioned notebook document identifier.
 *
 * @since 3.17.0
 */
type VersionedNotebookDocumentIdentifier = {
    /**
     * The version number of this notebook document.
     */
    version: integer;
    /**
     * The notebook document's uri.
     */
    uri: URI$1;
};
/**
 * Options specific to a notebook plus its cells
 * to be synced to the server.
 *
 * If a selector provides a notebook document
 * filter but no cell selector all cells of a
 * matching notebook document will be synced.
 *
 * If a selector provides no notebook document
 * filter but only a cell selector all notebook
 * document that contain at least one matching
 * cell will be synced.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncOptions = {
    /**
     * The notebooks to be synced
     */
    notebookSelector: ({
        /**
         * The notebook to be synced If a string
         * value is provided it matches against the
         * notebook type. '*' matches every notebook.
         */
        notebook: string | NotebookDocumentFilter;
        /**
         * The cells of the matching notebook to be synced.
         */
        cells?: {
            language: string;
        }[];
    } | {
        /**
         * The notebook to be synced If a string
         * value is provided it matches against the
         * notebook type. '*' matches every notebook.
         */
        notebook?: string | NotebookDocumentFilter;
        /**
         * The cells of the matching notebook to be synced.
         */
        cells: {
            language: string;
        }[];
    })[];
    /**
     * Whether save notification should be forwarded to
     * the server. Will only be honored if mode === `notebook`.
     */
    save?: boolean;
};
/**
 * Registration options specific to a notebook.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncRegistrationOptions = NotebookDocumentSyncOptions & StaticRegistrationOptions;
/**
 * The params sent in an open notebook document notification.
 *
 * @since 3.17.0
 */
type DidOpenNotebookDocumentParams = {
    /**
     * The notebook document that got opened.
     */
    notebookDocument: NotebookDocument;
    /**
     * The text documents that represent the content
     * of a notebook cell.
     */
    cellTextDocuments: TextDocumentItem[];
};
/**
 * A change describing how to move a `NotebookCell`
 * array from state S to S'.
 *
 * @since 3.17.0
 */
type NotebookCellArrayChange = {
    /**
     * The start oftest of the cell that changed.
     */
    start: uinteger;
    /**
     * The deleted cells
     */
    deleteCount: uinteger;
    /**
     * The new cells, if any
     */
    cells?: NotebookCell[];
};
declare namespace NotebookCellArrayChange {
    function is(value: any): value is NotebookCellArrayChange;
    function create(start: uinteger, deleteCount: uinteger, cells?: NotebookCell[]): NotebookCellArrayChange;
}
/**
 * A change event for a notebook document.
 *
 * @since 3.17.0
 */
type NotebookDocumentChangeEvent$1 = {
    /**
     * The changed meta data if any.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * Changes to cells
     */
    cells?: {
        /**
         * Changes to the cell structure to add or
         * remove cells.
         */
        structure?: {
            /**
             * The change to the cell array.
             */
            array: NotebookCellArrayChange;
            /**
             * Additional opened cell text documents.
             */
            didOpen?: TextDocumentItem[];
            /**
             * Additional closed cell text documents.
             */
            didClose?: TextDocumentIdentifier[];
        };
        /**
         * Changes to notebook cells properties like its
         * kind, execution summary or metadata.
         */
        data?: NotebookCell[];
        /**
         * Changes to the text content of notebook cells.
         */
        textContent?: {
            document: VersionedTextDocumentIdentifier;
            changes: TextDocumentContentChangeEvent[];
        }[];
    };
};
/**
 * The params sent in a change notebook document notification.
 *
 * @since 3.17.0
 */
type DidChangeNotebookDocumentParams = {
    /**
     * The notebook document that did change. The version number points
     * to the version after all provided changes have been applied. If
     * only the text document content of a cell changes the notebook version
     * doesn't necessarily have to change.
     */
    notebookDocument: VersionedNotebookDocumentIdentifier;
    /**
     * The actual changes to the notebook document.
     *
     * The changes describe single state changes to the notebook document.
     * So if there are two changes c1 (at array index 0) and c2 (at array
     * index 1) for a notebook in state S then c1 moves the notebook from
     * S to S' and c2 from S' to S''. So c1 is computed on the state S and
     * c2 is computed on the state S'.
     *
     * To mirror the content of a notebook using change events use the following approach:
     * - start with the same initial content
     * - apply the 'notebookDocument/didChange' notifications in the order you receive them.
     * - apply the `NotebookChangeEvent`s in a single notification in the order
     *   you receive them.
     */
    change: NotebookDocumentChangeEvent$1;
};
/**
 * The params sent in a save notebook document notification.
 *
 * @since 3.17.0
 */
type DidSaveNotebookDocumentParams = {
    /**
     * The notebook document that got saved.
     */
    notebookDocument: NotebookDocumentIdentifier;
};
/**
 * The params sent in a close notebook document notification.
 *
 * @since 3.17.0
 */
type DidCloseNotebookDocumentParams = {
    /**
     * The notebook document that got closed.
     */
    notebookDocument: NotebookDocumentIdentifier;
    /**
     * The text documents that represent the content
     * of a notebook cell that got closed.
     */
    cellTextDocuments: TextDocumentIdentifier[];
};

/**
 * Client capabilities specific to inline completions.
 *
 * @since 3.18.0
 * @proposed
 */
type InlineCompletionClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration for inline completion providers.
     */
    dynamicRegistration?: boolean;
};
/**
 * Inline completion options used during static registration.
 *
 * @since 3.18.0
 * @proposed
 */
type InlineCompletionOptions = WorkDoneProgressOptions;

/**
 * A document filter denotes a document by different properties like
 * the {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of
 * its resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.
 *
 * Glob patterns can have the following syntax:
 * - `*` to match one or more characters in a path segment
 * - `?` to match on one character in a path segment
 * - `**` to match any number of path segments, including none
 * - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
 * - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
 * - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
 *
 * @sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
 * @sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`
 *
 * @since 3.17.0
 */
type TextDocumentFilter = {
    /** A language id, like `typescript`. */
    language: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern?: string;
} | {
    /** A language id, like `typescript`. */
    language?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme: string;
    /** A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern?: string;
} | {
    /** A language id, like `typescript`. */
    language?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern: string;
};
/**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace TextDocumentFilter {
    function is(value: any): value is TextDocumentFilter;
}
/**
 * A notebook document filter denotes a notebook document by
 * different properties. The properties will be match
 * against the notebook's URI (same as with documents)
 *
 * @since 3.17.0
 */
type NotebookDocumentFilter = {
    /** The type of the enclosing notebook. */
    notebookType: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern. */
    pattern?: string;
} | {
    /** The type of the enclosing notebook. */
    notebookType?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.*/
    scheme: string;
    /** A glob pattern. */
    pattern?: string;
} | {
    /** The type of the enclosing notebook. */
    notebookType?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern. */
    pattern: string;
};
/**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace NotebookDocumentFilter {
    function is(value: any): value is NotebookDocumentFilter;
}
/**
 * A notebook cell text document filter denotes a cell text
 * document by different properties.
 *
 * @since 3.17.0
 */
type NotebookCellTextDocumentFilter = {
    /**
     * A filter that matches against the notebook
     * containing the notebook cell. If a string
     * value is provided it matches against the
     * notebook type. '*' matches every notebook.
     */
    notebook: string | NotebookDocumentFilter;
    /**
     * A language id like `python`.
     *
     * Will be matched against the language id of the
     * notebook cell document. '*' matches every language.
     */
    language?: string;
};
/**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace NotebookCellTextDocumentFilter {
    function is(value: any): value is NotebookCellTextDocumentFilter;
}
/**
 * A document filter describes a top level text document or
 * a notebook cell document.
 *
 * @since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.
 */
type DocumentFilter = TextDocumentFilter | NotebookCellTextDocumentFilter;
/**
 * A document selector is the combination of one or many document filters.
 *
 * @sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**∕tsconfig.json' }]`;
 *
 * The use of a string as a document filter is deprecated @since 3.16.0.
 */
type DocumentSelector = (string | DocumentFilter)[];
/**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */
declare namespace DocumentSelector {
    function is(value: any[] | undefined | null): value is DocumentSelector;
}
interface WorkDoneProgressParams {
    /**
     * An optional token that a server can use to report work done progress.
     */
    workDoneToken?: ProgressToken;
}
interface PartialResultParams {
    /**
     * An optional token that a server can use to report partial results (e.g. streaming) to
     * the client.
     */
    partialResultToken?: ProgressToken;
}
/**
 * A parameter literal used in requests to pass a text document and a position inside that
 * document.
 */
interface TextDocumentPositionParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position inside the text document.
     */
    position: Position$1;
}
/**
 * The kind of resource operations supported by the client.
 */
type ResourceOperationKind = 'create' | 'rename' | 'delete';
declare namespace ResourceOperationKind {
    /**
     * Supports creating new files and folders.
     */
    const Create: ResourceOperationKind;
    /**
     * Supports renaming existing files and folders.
     */
    const Rename: ResourceOperationKind;
    /**
     * Supports deleting existing files and folders.
     */
    const Delete: ResourceOperationKind;
}
type FailureHandlingKind = 'abort' | 'transactional' | 'undo' | 'textOnlyTransactional';
declare namespace FailureHandlingKind {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    const Abort: FailureHandlingKind;
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    const Transactional: FailureHandlingKind;
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    const TextOnlyTransactional: FailureHandlingKind;
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    const Undo: FailureHandlingKind;
}
/**
 * Workspace specific client capabilities.
 */
interface WorkspaceClientCapabilities {
    /**
     * The client supports applying batch edits
     * to the workspace by supporting the request
     * 'workspace/applyEdit'
     */
    applyEdit?: boolean;
    /**
     * Capabilities specific to `WorkspaceEdit`s.
     */
    workspaceEdit?: WorkspaceEditClientCapabilities;
    /**
     * Capabilities specific to the `workspace/didChangeConfiguration` notification.
     */
    didChangeConfiguration?: DidChangeConfigurationClientCapabilities;
    /**
     * Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
     */
    didChangeWatchedFiles?: DidChangeWatchedFilesClientCapabilities;
    /**
     * Capabilities specific to the `workspace/symbol` request.
     */
    symbol?: WorkspaceSymbolClientCapabilities;
    /**
     * Capabilities specific to the `workspace/executeCommand` request.
     */
    executeCommand?: ExecuteCommandClientCapabilities;
    /**
     * The client has support for workspace folders.
     *
     * @since 3.6.0
     */
    workspaceFolders?: boolean;
    /**
     * The client supports `workspace/configuration` requests.
     *
     * @since 3.6.0
     */
    configuration?: boolean;
    /**
     * Capabilities specific to the semantic token requests scoped to the
     * workspace.
     *
     * @since 3.16.0.
     */
    semanticTokens?: SemanticTokensWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the code lens requests scoped to the
     * workspace.
     *
     * @since 3.16.0.
     */
    codeLens?: CodeLensWorkspaceClientCapabilities;
    /**
     * The client has support for file notifications/requests for user operations on files.
     *
     * Since 3.16.0
     */
    fileOperations?: FileOperationClientCapabilities;
    /**
     * Capabilities specific to the inline values requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    inlineValue?: InlineValueWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the inlay hint requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    inlayHint?: InlayHintWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the diagnostic requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    diagnostics?: DiagnosticWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the folding range requests scoped to the workspace.
     *
     * @since 3.18.0
     * @proposed
     */
    foldingRange?: FoldingRangeWorkspaceClientCapabilities;
}
/**
 * Text document specific client capabilities.
 */
interface TextDocumentClientCapabilities {
    /**
     * Defines which synchronization capabilities the client supports.
     */
    synchronization?: TextDocumentSyncClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/completion` request.
     */
    completion?: CompletionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/hover` request.
     */
    hover?: HoverClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/signatureHelp` request.
     */
    signatureHelp?: SignatureHelpClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/declaration` request.
     *
     * @since 3.14.0
     */
    declaration?: DeclarationClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/definition` request.
     */
    definition?: DefinitionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/typeDefinition` request.
     *
     * @since 3.6.0
     */
    typeDefinition?: TypeDefinitionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/implementation` request.
     *
     * @since 3.6.0
     */
    implementation?: ImplementationClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/references` request.
     */
    references?: ReferenceClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentHighlight` request.
     */
    documentHighlight?: DocumentHighlightClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentSymbol` request.
     */
    documentSymbol?: DocumentSymbolClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/codeAction` request.
     */
    codeAction?: CodeActionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/codeLens` request.
     */
    codeLens?: CodeLensClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentLink` request.
     */
    documentLink?: DocumentLinkClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentColor` and the
     * `textDocument/colorPresentation` request.
     *
     * @since 3.6.0
     */
    colorProvider?: DocumentColorClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/formatting` request.
     */
    formatting?: DocumentFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/rangeFormatting` request.
     */
    rangeFormatting?: DocumentRangeFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/onTypeFormatting` request.
     */
    onTypeFormatting?: DocumentOnTypeFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/rename` request.
     */
    rename?: RenameClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/foldingRange` request.
     *
     * @since 3.10.0
     */
    foldingRange?: FoldingRangeClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/selectionRange` request.
     *
     * @since 3.15.0
     */
    selectionRange?: SelectionRangeClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/publishDiagnostics` notification.
     */
    publishDiagnostics?: PublishDiagnosticsClientCapabilities;
    /**
     * Capabilities specific to the various call hierarchy requests.
     *
     * @since 3.16.0
     */
    callHierarchy?: CallHierarchyClientCapabilities;
    /**
     * Capabilities specific to the various semantic token request.
     *
     * @since 3.16.0
     */
    semanticTokens?: SemanticTokensClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/linkedEditingRange` request.
     *
     * @since 3.16.0
     */
    linkedEditingRange?: LinkedEditingRangeClientCapabilities;
    /**
     * Client capabilities specific to the `textDocument/moniker` request.
     *
     * @since 3.16.0
     */
    moniker?: MonikerClientCapabilities;
    /**
     * Capabilities specific to the various type hierarchy requests.
     *
     * @since 3.17.0
     */
    typeHierarchy?: TypeHierarchyClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/inlineValue` request.
     *
     * @since 3.17.0
     */
    inlineValue?: InlineValueClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/inlayHint` request.
     *
     * @since 3.17.0
     */
    inlayHint?: InlayHintClientCapabilities;
    /**
     * Capabilities specific to the diagnostic pull model.
     *
     * @since 3.17.0
     */
    diagnostic?: DiagnosticClientCapabilities;
    /**
     * Client capabilities specific to inline completions.
     *
     * @since 3.18.0
     * @proposed
     */
    inlineCompletion?: InlineCompletionClientCapabilities;
}
interface WindowClientCapabilities {
    /**
     * It indicates whether the client supports server initiated
     * progress using the `window/workDoneProgress/create` request.
     *
     * The capability also controls Whether client supports handling
     * of progress notifications. If set servers are allowed to report a
     * `workDoneProgress` property in the request specific server
     * capabilities.
     *
     * @since 3.15.0
     */
    workDoneProgress?: boolean;
    /**
     * Capabilities specific to the showMessage request.
     *
     * @since 3.16.0
     */
    showMessage?: ShowMessageRequestClientCapabilities;
    /**
     * Capabilities specific to the showDocument request.
     *
     * @since 3.16.0
     */
    showDocument?: ShowDocumentClientCapabilities;
}
/**
 * Client capabilities specific to regular expressions.
 *
 * @since 3.16.0
 */
interface RegularExpressionsClientCapabilities {
    /**
     * The engine's name.
     */
    engine: string;
    /**
     * The engine's version.
     */
    version?: string;
}
/**
 * Client capabilities specific to the used markdown parser.
 *
 * @since 3.16.0
 */
interface MarkdownClientCapabilities {
    /**
     * The name of the parser.
     */
    parser: string;
    /**
     * The version of the parser.
     */
    version?: string;
    /**
     * A list of HTML tags that the client allows / supports in
     * Markdown.
     *
     * @since 3.17.0
     */
    allowedTags?: string[];
}
/**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */
declare namespace PositionEncodingKind {
    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */
    const UTF8: PositionEncodingKind;
    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */
    const UTF16: PositionEncodingKind;
    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */
    const UTF32: PositionEncodingKind;
}
/**
 * A type indicating how positions are encoded,
 * specifically what column offsets mean.
 *
 * @since 3.17.0
 */
type PositionEncodingKind = string;
/**
 * General client capabilities.
 *
 * @since 3.16.0
 */
interface GeneralClientCapabilities {
    /**
     * Client capability that signals how the client
     * handles stale requests (e.g. a request
     * for which the client will not process the response
     * anymore since the information is outdated).
     *
     * @since 3.17.0
     */
    staleRequestSupport?: {
        /**
         * The client will actively cancel the request.
         */
        cancel: boolean;
        /**
         * The list of requests for which the client
         * will retry the request if it receives a
         * response with error code `ContentModified`
         */
        retryOnContentModified: string[];
    };
    /**
     * Client capabilities specific to regular expressions.
     *
     * @since 3.16.0
     */
    regularExpressions?: RegularExpressionsClientCapabilities;
    /**
     * Client capabilities specific to the client's markdown parser.
     *
     * @since 3.16.0
     */
    markdown?: MarkdownClientCapabilities;
    /**
     * The position encodings supported by the client. Client and server
     * have to agree on the same position encoding to ensure that offsets
     * (e.g. character position in a line) are interpreted the same on both
     * sides.
     *
     * To keep the protocol backwards compatible the following applies: if
     * the value 'utf-16' is missing from the array of position encodings
     * servers can assume that the client supports UTF-16. UTF-16 is
     * therefore a mandatory encoding.
     *
     * If omitted it defaults to ['utf-16'].
     *
     * Implementation considerations: since the conversion from one encoding
     * into another requires the content of the file / line the conversion
     * is best done where the file is read which is usually on the server
     * side.
     *
     * @since 3.17.0
     */
    positionEncodings?: PositionEncodingKind[];
}
/**
 * Capabilities specific to the notebook document support.
 *
 * @since 3.17.0
 */
interface NotebookDocumentClientCapabilities {
    /**
     * Capabilities specific to notebook document synchronization
     *
     * @since 3.17.0
     */
    synchronization: NotebookDocumentSyncClientCapabilities;
}
/**
 * Defines the capabilities provided by the client.
 */
interface ClientCapabilities$1 {
    /**
     * Workspace specific client capabilities.
     */
    workspace?: WorkspaceClientCapabilities;
    /**
     * Text document specific client capabilities.
     */
    textDocument?: TextDocumentClientCapabilities;
    /**
     * Capabilities specific to the notebook document support.
     *
     * @since 3.17.0
     */
    notebookDocument?: NotebookDocumentClientCapabilities;
    /**
     * Window specific client capabilities.
     */
    window?: WindowClientCapabilities;
    /**
     * General client capabilities.
     *
     * @since 3.16.0
     */
    general?: GeneralClientCapabilities;
    /**
     * Experimental client capabilities.
     */
    experimental?: LSPAny;
}
/**
 * Static registration options to be returned in the initialize
 * request.
 */
interface StaticRegistrationOptions {
    /**
     * The id used to register the request. The id can be used to deregister
     * the request again. See also Registration#id.
     */
    id?: string;
}
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */
declare namespace StaticRegistrationOptions {
    function hasId(value: object): value is {
        id: string;
    };
}
/**
 * General text document registration options.
 */
interface TextDocumentRegistrationOptions {
    /**
     * A document selector to identify the scope of the registration. If set to null
     * the document selector provided on the client side will be used.
     */
    documentSelector: DocumentSelector | null;
}
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */
declare namespace TextDocumentRegistrationOptions {
    function is(value: any): value is TextDocumentRegistrationOptions;
}
/**
 * Save options.
 */
interface SaveOptions {
    /**
     * The client is supposed to include the content on save.
     */
    includeText?: boolean;
}
interface WorkDoneProgressOptions {
    workDoneProgress?: boolean;
}
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */
declare namespace WorkDoneProgressOptions {
    function is(value: any): value is WorkDoneProgressOptions;
    function hasWorkDoneProgress(value: any): value is {
        workDoneProgress: boolean;
    };
}
/**
 * Defines the capabilities provided by a language
 * server.
 */
interface ServerCapabilities$1<T = LSPAny> {
    /**
     * The position encoding the server picked from the encodings offered
     * by the client via the client capability `general.positionEncodings`.
     *
     * If the client didn't provide any position encodings the only valid
     * value that a server can return is 'utf-16'.
     *
     * If omitted it defaults to 'utf-16'.
     *
     * @since 3.17.0
     */
    positionEncoding?: PositionEncodingKind;
    /**
     * Defines how text documents are synced. Is either a detailed structure
     * defining each notification or for backwards compatibility the
     * TextDocumentSyncKind number.
     */
    textDocumentSync?: TextDocumentSyncOptions | TextDocumentSyncKind;
    /**
     * Defines how notebook documents are synced.
     *
     * @since 3.17.0
     */
    notebookDocumentSync?: NotebookDocumentSyncOptions | NotebookDocumentSyncRegistrationOptions;
    /**
     * The server provides completion support.
     */
    completionProvider?: CompletionOptions;
    /**
     * The server provides hover support.
     */
    hoverProvider?: boolean | HoverOptions;
    /**
     * The server provides signature help support.
     */
    signatureHelpProvider?: SignatureHelpOptions;
    /**
     * The server provides Goto Declaration support.
     */
    declarationProvider?: boolean | DeclarationOptions | DeclarationRegistrationOptions;
    /**
     * The server provides goto definition support.
     */
    definitionProvider?: boolean | DefinitionOptions;
    /**
     * The server provides Goto Type Definition support.
     */
    typeDefinitionProvider?: boolean | TypeDefinitionOptions | TypeDefinitionRegistrationOptions;
    /**
     * The server provides Goto Implementation support.
     */
    implementationProvider?: boolean | ImplementationOptions | ImplementationRegistrationOptions;
    /**
     * The server provides find references support.
     */
    referencesProvider?: boolean | ReferenceOptions;
    /**
     * The server provides document highlight support.
     */
    documentHighlightProvider?: boolean | DocumentHighlightOptions;
    /**
     * The server provides document symbol support.
     */
    documentSymbolProvider?: boolean | DocumentSymbolOptions;
    /**
     * The server provides code actions. CodeActionOptions may only be
     * specified if the client states that it supports
     * `codeActionLiteralSupport` in its initial `initialize` request.
     */
    codeActionProvider?: boolean | CodeActionOptions;
    /**
     * The server provides code lens.
     */
    codeLensProvider?: CodeLensOptions;
    /**
     * The server provides document link support.
     */
    documentLinkProvider?: DocumentLinkOptions;
    /**
     * The server provides color provider support.
     */
    colorProvider?: boolean | DocumentColorOptions | DocumentColorRegistrationOptions;
    /**
     * The server provides workspace symbol support.
     */
    workspaceSymbolProvider?: boolean | WorkspaceSymbolOptions;
    /**
     * The server provides document formatting.
     */
    documentFormattingProvider?: boolean | DocumentFormattingOptions;
    /**
     * The server provides document range formatting.
     */
    documentRangeFormattingProvider?: boolean | DocumentRangeFormattingOptions;
    /**
     * The server provides document formatting on typing.
     */
    documentOnTypeFormattingProvider?: DocumentOnTypeFormattingOptions;
    /**
     * The server provides rename support. RenameOptions may only be
     * specified if the client states that it supports
     * `prepareSupport` in its initial `initialize` request.
     */
    renameProvider?: boolean | RenameOptions;
    /**
     * The server provides folding provider support.
     */
    foldingRangeProvider?: boolean | FoldingRangeOptions | FoldingRangeRegistrationOptions;
    /**
     * The server provides selection range support.
     */
    selectionRangeProvider?: boolean | SelectionRangeOptions | SelectionRangeRegistrationOptions;
    /**
     * The server provides execute command support.
     */
    executeCommandProvider?: ExecuteCommandOptions;
    /**
     * The server provides call hierarchy support.
     *
     * @since 3.16.0
     */
    callHierarchyProvider?: boolean | CallHierarchyOptions | CallHierarchyRegistrationOptions;
    /**
     * The server provides linked editing range support.
     *
     * @since 3.16.0
     */
    linkedEditingRangeProvider?: boolean | LinkedEditingRangeOptions | LinkedEditingRangeRegistrationOptions;
    /**
     * The server provides semantic tokens support.
     *
     * @since 3.16.0
     */
    semanticTokensProvider?: SemanticTokensOptions | SemanticTokensRegistrationOptions;
    /**
     * The server provides moniker support.
     *
     * @since 3.16.0
     */
    monikerProvider?: boolean | MonikerOptions | MonikerRegistrationOptions;
    /**
     * The server provides type hierarchy support.
     *
     * @since 3.17.0
     */
    typeHierarchyProvider?: boolean | TypeHierarchyOptions | TypeHierarchyRegistrationOptions;
    /**
     * The server provides inline values.
     *
     * @since 3.17.0
     */
    inlineValueProvider?: boolean | InlineValueOptions | InlineValueRegistrationOptions;
    /**
     * The server provides inlay hints.
     *
     * @since 3.17.0
     */
    inlayHintProvider?: boolean | InlayHintOptions | InlayHintRegistrationOptions;
    /**
     * The server has support for pull model diagnostics.
     *
     * @since 3.17.0
     */
    diagnosticProvider?: DiagnosticOptions | DiagnosticRegistrationOptions;
    /**
     * Inline completion options used during static registration.
     *
     * @since 3.18.0
     * @proposed
     */
    inlineCompletionProvider?: boolean | InlineCompletionOptions;
    /**
     * Workspace specific server capabilities.
     */
    workspace?: {
        /**
         * The server supports workspace folder.
         *
         * @since 3.6.0
         */
        workspaceFolders?: WorkspaceFoldersServerCapabilities;
        /**
        * The server is interested in notifications/requests for operations on files.
        *
        * @since 3.16.0
        */
        fileOperations?: FileOperationOptions;
    };
    /**
     * Experimental server capabilities.
     */
    experimental?: T;
}
/**
 * The initialize parameters
 */
interface _InitializeParams extends WorkDoneProgressParams {
    /**
     * The process Id of the parent process that started
     * the server.
     *
     * Is `null` if the process has not been started by another process.
     * If the parent process is not alive then the server should exit.
     */
    processId: integer | null;
    /**
     * Information about the client
     *
     * @since 3.15.0
     */
    clientInfo?: {
        /**
         * The name of the client as defined by the client.
         */
        name: string;
        /**
         * The client's version as defined by the client.
         */
        version?: string;
    };
    /**
     * The locale the client is currently showing the user interface
     * in. This must not necessarily be the locale of the operating
     * system.
     *
     * Uses IETF language tags as the value's syntax
     * (See https://en.wikipedia.org/wiki/IETF_language_tag)
     *
     * @since 3.16.0
     */
    locale?: string;
    /**
     * The rootPath of the workspace. Is null
     * if no folder is open.
     *
     * @deprecated in favour of rootUri.
     */
    rootPath?: string | null;
    /**
     * The rootUri of the workspace. Is null if no
     * folder is open. If both `rootPath` and `rootUri` are set
     * `rootUri` wins.
     *
     * @deprecated in favour of workspaceFolders.
     */
    rootUri: DocumentUri$1 | null;
    /**
     * The capabilities provided by the client (editor or tool)
     */
    capabilities: ClientCapabilities$1;
    /**
     * User provided initialization options.
     */
    initializationOptions?: LSPAny;
    /**
     * The initial trace setting. If omitted trace is disabled ('off').
     */
    trace?: TraceValues;
}
type InitializeParams = _InitializeParams & WorkspaceFoldersInitializeParams;
/**
 * The result returned from an initialize request.
 */
interface InitializeResult<T = any> {
    /**
     * The capabilities the language server provides.
     */
    capabilities: ServerCapabilities$1<T>;
    /**
     * Information about the server.
     *
     * @since 3.15.0
     */
    serverInfo?: {
        /**
         * The name of the server as defined by the server.
         */
        name: string;
        /**
         * The server's version as defined by the server.
         */
        version?: string;
    };
    /**
     * Custom initialization results.
     */
    [custom: string]: LSPAny | ServerCapabilities$1<T> | undefined; /** undefined is needed since serverInfo is optional */
}
/**
 * The data type of the ResponseError if the
 * initialize request fails.
 */
interface InitializeError {
    /**
     * Indicates whether the client execute the following retry logic:
     * (1) show the message provided by the ResponseError to the user
     * (2) user selects retry or cancel
     * (3) if user selected retry the initialize method is sent again.
     */
    retry: boolean;
}
interface InitializedParams {
}
interface DidChangeConfigurationClientCapabilities {
    /**
     * Did change configuration notification supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
interface DidChangeConfigurationRegistrationOptions {
    section?: string | string[];
}
/**
 * The parameters of a change configuration notification.
 */
interface DidChangeConfigurationParams {
    /**
     * The actual changed settings
     */
    settings: LSPAny;
}
/**
 * Show message request client capabilities
 */
interface ShowMessageRequestClientCapabilities {
    /**
     * Capabilities specific to the `MessageActionItem` type.
     */
    messageActionItem?: {
        /**
         * Whether the client supports additional attributes which
         * are preserved and send back to the server in the
         * request's response.
         */
        additionalPropertiesSupport?: boolean;
    };
}
interface MessageActionItem {
    /**
     * A short title like 'Retry', 'Open Log' etc.
     */
    title: string;
    /**
     * Additional attributes that the client preserves and
     * sends back to the server. This depends on the client
     * capability window.messageActionItem.additionalPropertiesSupport
     */
    [key: string]: string | boolean | integer | object;
}
interface TextDocumentSyncClientCapabilities {
    /**
     * Whether text document synchronization supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports sending will save notifications.
     */
    willSave?: boolean;
    /**
     * The client supports sending a will save request and
     * waits for a response providing text edits which will
     * be applied to the document before it is saved.
     */
    willSaveWaitUntil?: boolean;
    /**
     * The client supports did save notifications.
     */
    didSave?: boolean;
}
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
declare namespace TextDocumentSyncKind {
    /**
     * Documents should not be synced at all.
     */
    const None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    const Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    const Incremental = 2;
}
type TextDocumentSyncKind = 0 | 1 | 2;
interface TextDocumentSyncOptions {
    /**
     * Open and close notifications are sent to the server. If omitted open close notification should not
     * be sent.
     */
    openClose?: boolean;
    /**
     * Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
     * and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
     */
    change?: TextDocumentSyncKind;
    /**
     * If present will save notifications are sent to the server. If omitted the notification should not be
     * sent.
     */
    willSave?: boolean;
    /**
     * If present will save wait until requests are sent to the server. If omitted the request should not be
     * sent.
     */
    willSaveWaitUntil?: boolean;
    /**
     * If present save notifications are sent to the server. If omitted the notification should not be
     * sent.
     */
    save?: boolean | SaveOptions;
}
/**
 * The parameters sent in an open text document notification
 */
interface DidOpenTextDocumentParams {
    /**
     * The document that was opened.
     */
    textDocument: TextDocumentItem;
}
/**
 * An event describing a change to a text document. If only a text is provided
 * it is considered to be the full content of the document.
 */
type TextDocumentContentChangeEvent = {
    /**
     * The range of the document that changed.
     */
    range: Range$1;
    /**
     * The optional length of the range that got replaced.
     *
     * @deprecated use range instead.
     */
    rangeLength?: uinteger;
    /**
     * The new text for the provided range.
     */
    text: string;
} | {
    /**
     * The new text of the whole document.
     */
    text: string;
};
declare namespace TextDocumentContentChangeEvent {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event: TextDocumentContentChangeEvent): event is {
        range: Range$1;
        rangeLength?: uinteger;
        text: string;
    };
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event: TextDocumentContentChangeEvent): event is {
        text: string;
    };
}
/**
 * The change text document notification's parameters.
 */
interface DidChangeTextDocumentParams {
    /**
     * The document that did change. The version number points
     * to the version after all provided content changes have
     * been applied.
     */
    textDocument: VersionedTextDocumentIdentifier;
    /**
     * The actual content changes. The content changes describe single state changes
     * to the document. So if there are two content changes c1 (at array index 0) and
     * c2 (at array index 1) for a document in state S then c1 moves the document from
     * S to S' and c2 from S' to S''. So c1 is computed on the state S and c2 is computed
     * on the state S'.
     *
     * To mirror the content of a document using change events use the following approach:
     * - start with the same initial content
     * - apply the 'textDocument/didChange' notifications in the order you receive them.
     * - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
     *   you receive them.
     */
    contentChanges: TextDocumentContentChangeEvent[];
}
/**
 * The parameters sent in a close text document notification
 */
interface DidCloseTextDocumentParams {
    /**
     * The document that was closed.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * The parameters sent in a save text document notification
 */
interface DidSaveTextDocumentParams {
    /**
     * The document that was saved.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * Optional the content when saved. Depends on the includeText value
     * when the save notification was requested.
     */
    text?: string;
}
/**
 * Represents reasons why a text document is saved.
 */
declare namespace TextDocumentSaveReason {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    const Manual: 1;
    /**
     * Automatic after a delay.
     */
    const AfterDelay: 2;
    /**
     * When the editor lost focus.
     */
    const FocusOut: 3;
}
type TextDocumentSaveReason = 1 | 2 | 3;
/**
 * The parameters sent in a will save text document notification.
 */
interface WillSaveTextDocumentParams {
    /**
     * The document that will be saved.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The 'TextDocumentSaveReason'.
     */
    reason: TextDocumentSaveReason;
}
interface DidChangeWatchedFilesClientCapabilities {
    /**
     * Did change watched files notification supports dynamic registration. Please note
     * that the current protocol doesn't support static configuration for file changes
     * from the server side.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client has support for {@link  RelativePattern relative pattern}
     * or not.
     *
     * @since 3.17.0
     */
    relativePatternSupport?: boolean;
}
/**
 * The watched files change notification's parameters.
 */
interface DidChangeWatchedFilesParams {
    /**
     * The actual file events.
     */
    changes: FileEvent[];
}
/**
 * The file event type
 */
declare namespace FileChangeType {
    /**
     * The file got created.
     */
    const Created = 1;
    /**
     * The file got changed.
     */
    const Changed = 2;
    /**
     * The file got deleted.
     */
    const Deleted = 3;
}
type FileChangeType = 1 | 2 | 3;
/**
 * An event describing a file change.
 */
interface FileEvent {
    /**
     * The file's uri.
     */
    uri: DocumentUri$1;
    /**
     * The change type.
     */
    type: FileChangeType;
}
/**
 * The publish diagnostic client capabilities.
 */
interface PublishDiagnosticsClientCapabilities {
    /**
     * Whether the clients accepts diagnostics with related information.
     */
    relatedInformation?: boolean;
    /**
     * Client supports the tag property to provide meta data about a diagnostic.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.15.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: DiagnosticTag[];
    };
    /**
     * Whether the client interprets the version property of the
     * `textDocument/publishDiagnostics` notification's parameter.
     *
     * @since 3.15.0
     */
    versionSupport?: boolean;
    /**
     * Client supports a codeDescription property
     *
     * @since 3.16.0
     */
    codeDescriptionSupport?: boolean;
    /**
     * Whether code action supports the `data` property which is
     * preserved between a `textDocument/publishDiagnostics` and
     * `textDocument/codeAction` request.
     *
     * @since 3.16.0
     */
    dataSupport?: boolean;
}
/**
 * The publish diagnostic notification's parameters.
 */
interface PublishDiagnosticsParams {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * Optional the version number of the document the diagnostics are published for.
     *
     * @since 3.15.0
     */
    version?: integer;
    /**
     * An array of diagnostic information items.
     */
    diagnostics: Diagnostic[];
}
/**
 * Completion client capabilities
 */
interface CompletionClientCapabilities {
    /**
     * Whether completion supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports the following `CompletionItem` specific
     * capabilities.
     */
    completionItem?: {
        /**
         * Client supports snippets as insert text.
         *
         * A snippet can define tab stops and placeholders with `$1`, `$2`
         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
         * the end of the snippet. Placeholders with equal identifiers are linked,
         * that is typing in one will update others too.
         */
        snippetSupport?: boolean;
        /**
         * Client supports commit characters on a completion item.
         */
        commitCharactersSupport?: boolean;
        /**
         * Client supports the following content formats for the documentation
         * property. The order describes the preferred format of the client.
         */
        documentationFormat?: MarkupKind[];
        /**
         * Client supports the deprecated property on a completion item.
         */
        deprecatedSupport?: boolean;
        /**
         * Client supports the preselect property on a completion item.
         */
        preselectSupport?: boolean;
        /**
         * Client supports the tag property on a completion item. Clients supporting
         * tags have to handle unknown tags gracefully. Clients especially need to
         * preserve unknown tags when sending a completion item back to the server in
         * a resolve call.
         *
         * @since 3.15.0
         */
        tagSupport?: {
            /**
             * The tags supported by the client.
             */
            valueSet: CompletionItemTag[];
        };
        /**
         * Client support insert replace edit to control different behavior if a
         * completion item is inserted in the text or should replace text.
         *
         * @since 3.16.0
         */
        insertReplaceSupport?: boolean;
        /**
         * Indicates which properties a client can resolve lazily on a completion
         * item. Before version 3.16.0 only the predefined properties `documentation`
         * and `details` could be resolved lazily.
         *
         * @since 3.16.0
         */
        resolveSupport?: {
            /**
             * The properties that a client can resolve lazily.
             */
            properties: string[];
        };
        /**
         * The client supports the `insertTextMode` property on
         * a completion item to override the whitespace handling mode
         * as defined by the client (see `insertTextMode`).
         *
         * @since 3.16.0
         */
        insertTextModeSupport?: {
            valueSet: InsertTextMode[];
        };
        /**
         * The client has support for completion item label
         * details (see also `CompletionItemLabelDetails`).
         *
         * @since 3.17.0
         */
        labelDetailsSupport?: boolean;
    };
    completionItemKind?: {
        /**
         * The completion item kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the completion items kinds from `Text` to `Reference` as defined in
         * the initial version of the protocol.
         */
        valueSet?: CompletionItemKind[];
    };
    /**
     * Defines how the client handles whitespace and indentation
     * when accepting a completion item that uses multi line
     * text in either `insertText` or `textEdit`.
     *
     * @since 3.17.0
     */
    insertTextMode?: InsertTextMode;
    /**
     * The client supports to send additional context information for a
     * `textDocument/completion` request.
     */
    contextSupport?: boolean;
    /**
     * The client supports the following `CompletionList` specific
     * capabilities.
     *
     * @since 3.17.0
     */
    completionList?: {
        /**
         * The client supports the following itemDefaults on
         * a completion list.
         *
         * The value lists the supported property names of the
         * `CompletionList.itemDefaults` object. If omitted
         * no properties are supported.
         *
         * @since 3.17.0
         */
        itemDefaults?: string[];
    };
}
/**
 * How a completion was triggered
 */
declare namespace CompletionTriggerKind {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    const Invoked: 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    const TriggerCharacter: 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    const TriggerForIncompleteCompletions: 3;
}
type CompletionTriggerKind = 1 | 2 | 3;
/**
 * Contains additional information about the context in which a completion request is triggered.
 */
interface CompletionContext$1 {
    /**
     * How the completion was triggered.
     */
    triggerKind: CompletionTriggerKind;
    /**
     * The trigger character (a single character) that has trigger code complete.
     * Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
     */
    triggerCharacter?: string;
}
/**
 * Completion parameters
 */
interface CompletionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
    /**
     * The completion context. This is only available it the client specifies
     * to send this using the client capability `textDocument.completion.contextSupport === true`
     */
    context?: CompletionContext$1;
}
/**
 * Completion options.
 */
interface CompletionOptions extends WorkDoneProgressOptions {
    /**
     * Most tools trigger completion request automatically without explicitly requesting
     * it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
     * starts to type an identifier. For example if the user types `c` in a JavaScript file
     * code complete will automatically pop up present `console` besides others as a
     * completion item. Characters that make up identifiers don't need to be listed here.
     *
     * If code complete should automatically be trigger on characters not being valid inside
     * an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
     */
    triggerCharacters?: string[];
    /**
     * The list of all possible characters that commit a completion. This field can be used
     * if clients don't support individual commit characters per completion item. See
     * `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
     *
     * If a server provides both `allCommitCharacters` and commit characters on an individual
     * completion item the ones on the completion item win.
     *
     * @since 3.2.0
     */
    allCommitCharacters?: string[];
    /**
     * The server provides support to resolve additional
     * information for a completion item.
     */
    resolveProvider?: boolean;
    /**
     * The server supports the following `CompletionItem` specific
     * capabilities.
     *
     * @since 3.17.0
     */
    completionItem?: {
        /**
         * The server has support for completion item label
         * details (see also `CompletionItemLabelDetails`) when
         * receiving a completion item in a resolve call.
         *
         * @since 3.17.0
         */
        labelDetailsSupport?: boolean;
    };
}
interface HoverClientCapabilities {
    /**
     * Whether hover supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Client supports the following content formats for the content
     * property. The order describes the preferred format of the client.
     */
    contentFormat?: MarkupKind[];
}
/**
 * Hover options.
 */
interface HoverOptions extends WorkDoneProgressOptions {
}
/**
 * Parameters for a {@link HoverRequest}.
 */
interface HoverParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * Client Capabilities for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpClientCapabilities {
    /**
     * Whether signature help supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports the following `SignatureInformation`
     * specific properties.
     */
    signatureInformation?: {
        /**
         * Client supports the following content formats for the documentation
         * property. The order describes the preferred format of the client.
         */
        documentationFormat?: MarkupKind[];
        /**
         * Client capabilities specific to parameter information.
         */
        parameterInformation?: {
            /**
             * The client supports processing label offsets instead of a
             * simple label string.
             *
             * @since 3.14.0
             */
            labelOffsetSupport?: boolean;
        };
        /**
         * The client supports the `activeParameter` property on `SignatureInformation`
         * literal.
         *
         * @since 3.16.0
         */
        activeParameterSupport?: boolean;
    };
    /**
     * The client supports to send additional context information for a
     * `textDocument/signatureHelp` request. A client that opts into
     * contextSupport will also support the `retriggerCharacters` on
     * `SignatureHelpOptions`.
     *
     * @since 3.15.0
     */
    contextSupport?: boolean;
}
/**
 * Server Capabilities for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpOptions extends WorkDoneProgressOptions {
    /**
     * List of characters that trigger signature help automatically.
     */
    triggerCharacters?: string[];
    /**
     * List of characters that re-trigger signature help.
     *
     * These trigger characters are only active when signature help is already showing. All trigger characters
     * are also counted as re-trigger characters.
     *
     * @since 3.15.0
     */
    retriggerCharacters?: string[];
}
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
declare namespace SignatureHelpTriggerKind {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    const Invoked: 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    const TriggerCharacter: 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    const ContentChange: 3;
}
type SignatureHelpTriggerKind = 1 | 2 | 3;
/**
 * Additional information about the context in which a signature help request was triggered.
 *
 * @since 3.15.0
 */
interface SignatureHelpContext {
    /**
     * Action that caused signature help to be triggered.
     */
    triggerKind: SignatureHelpTriggerKind;
    /**
     * Character that caused signature help to be triggered.
     *
     * This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
     */
    triggerCharacter?: string;
    /**
     * `true` if signature help was already showing when it was triggered.
     *
     * Retriggers occurs when the signature help is already active and can be caused by actions such as
     * typing a trigger character, a cursor move, or document content changes.
     */
    isRetrigger: boolean;
    /**
     * The currently active `SignatureHelp`.
     *
     * The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
     * the user navigating through available signatures.
     */
    activeSignatureHelp?: SignatureHelp;
}
/**
 * Parameters for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpParams extends TextDocumentPositionParams, WorkDoneProgressParams {
    /**
     * The signature help context. This is only available if the client specifies
     * to send this using the client capability `textDocument.signatureHelp.contextSupport === true`
     *
     * @since 3.15.0
     */
    context?: SignatureHelpContext;
}
/**
 * Client Capabilities for a {@link DefinitionRequest}.
 */
interface DefinitionClientCapabilities {
    /**
     * Whether definition supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * @since 3.14.0
     */
    linkSupport?: boolean;
}
/**
 * Server Capabilities for a {@link DefinitionRequest}.
 */
interface DefinitionOptions extends WorkDoneProgressOptions {
}
/**
 * Parameters for a {@link DefinitionRequest}.
 */
interface DefinitionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}
/**
 * Client Capabilities for a {@link ReferencesRequest}.
 */
interface ReferenceClientCapabilities {
    /**
     * Whether references supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * Parameters for a {@link ReferencesRequest}.
 */
interface ReferenceParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
    context: ReferenceContext;
}
/**
 * Reference options.
 */
interface ReferenceOptions extends WorkDoneProgressOptions {
}
/**
 * Client Capabilities for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightClientCapabilities {
    /**
     * Whether document highlight supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * Parameters for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}
/**
 * Provider options for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightOptions extends WorkDoneProgressOptions {
}
/**
 * Client Capabilities for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolClientCapabilities {
    /**
     * Whether document symbol supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Specific capabilities for the `SymbolKind` in the
     * `textDocument/documentSymbol` request.
     */
    symbolKind?: {
        /**
         * The symbol kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the symbol kinds from `File` to `Array` as defined in
         * the initial version of the protocol.
         */
        valueSet?: SymbolKind[];
    };
    /**
     * The client supports hierarchical document symbols.
     */
    hierarchicalDocumentSymbolSupport?: boolean;
    /**
     * The client supports tags on `SymbolInformation`. Tags are supported on
     * `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.16.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: SymbolTag[];
    };
    /**
     * The client supports an additional label presented in the UI when
     * registering a document symbol provider.
     *
     * @since 3.16.0
     */
    labelSupport?: boolean;
}
/**
 * Parameters for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Provider options for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolOptions extends WorkDoneProgressOptions {
    /**
     * A human-readable string that is shown when multiple outlines trees
     * are shown for the same document.
     *
     * @since 3.16.0
     */
    label?: string;
}
/**
 * The Client Capabilities of a {@link CodeActionRequest}.
 */
interface CodeActionClientCapabilities {
    /**
     * Whether code action supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client support code action literals of type `CodeAction` as a valid
     * response of the `textDocument/codeAction` request. If the property is not
     * set the request can only return `Command` literals.
     *
     * @since 3.8.0
     */
    codeActionLiteralSupport?: {
        /**
         * The code action kind is support with the following value
         * set.
         */
        codeActionKind: {
            /**
             * The code action kind values the client supports. When this
             * property exists the client also guarantees that it will
             * handle values outside its set gracefully and falls back
             * to a default value when unknown.
             */
            valueSet: CodeActionKind[];
        };
    };
    /**
     * Whether code action supports the `isPreferred` property.
     *
     * @since 3.15.0
     */
    isPreferredSupport?: boolean;
    /**
     * Whether code action supports the `disabled` property.
     *
     * @since 3.16.0
     */
    disabledSupport?: boolean;
    /**
     * Whether code action supports the `data` property which is
     * preserved between a `textDocument/codeAction` and a
     * `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    dataSupport?: boolean;
    /**
     * Whether the client supports resolving additional code action
     * properties via a separate `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily.
         */
        properties: string[];
    };
    /**
     * Whether the client honors the change annotations in
     * text edits and resource operations returned via the
     * `CodeAction#edit` property by for example presenting
     * the workspace edit in the user interface and asking
     * for confirmation.
     *
     * @since 3.16.0
     */
    honorsChangeAnnotations?: boolean;
}
/**
 * The parameters of a {@link CodeActionRequest}.
 */
interface CodeActionParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document in which the command was invoked.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range for which the command was invoked.
     */
    range: Range$1;
    /**
     * Context carrying additional information.
     */
    context: CodeActionContext;
}
/**
 * Provider options for a {@link CodeActionRequest}.
 */
interface CodeActionOptions extends WorkDoneProgressOptions {
    /**
     * CodeActionKinds that this server may return.
     *
     * The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
     * may list out every specific kind they provide.
     */
    codeActionKinds?: CodeActionKind[];
    /**
     * The server provides support to resolve additional
     * information for a code action.
     *
     * @since 3.16.0
     */
    resolveProvider?: boolean;
}
/**
 * Client capabilities for a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolClientCapabilities {
    /**
     * Symbol request supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
     */
    symbolKind?: {
        /**
         * The symbol kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the symbol kinds from `File` to `Array` as defined in
         * the initial version of the protocol.
         */
        valueSet?: SymbolKind[];
    };
    /**
     * The client supports tags on `SymbolInformation`.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.16.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: SymbolTag[];
    };
    /**
     * The client support partial workspace symbols. The client will send the
     * request `workspaceSymbol/resolve` to the server to resolve additional
     * properties.
     *
     * @since 3.17.0
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily. Usually
         * `location.range`
         */
        properties: string[];
    };
}
/**
 * The parameters of a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * A query string to filter symbols by. Clients may send an empty
     * string here to request all symbols.
     */
    query: string;
}
/**
 * Server capabilities for a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolOptions extends WorkDoneProgressOptions {
    /**
     * The server provides support to resolve additional
     * information for a workspace symbol.
     *
     * @since 3.17.0
     */
    resolveProvider?: boolean;
}
/**
 * The client capabilities  of a {@link CodeLensRequest}.
 */
interface CodeLensClientCapabilities {
    /**
     * Whether code lens supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * @since 3.16.0
 */
interface CodeLensWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * code lenses currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detect a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
}
/**
 * The parameters of a {@link CodeLensRequest}.
 */
interface CodeLensParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document to request code lens for.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Code Lens provider options of a {@link CodeLensRequest}.
 */
interface CodeLensOptions extends WorkDoneProgressOptions {
    /**
     * Code lens has a resolve provider as well.
     */
    resolveProvider?: boolean;
}
/**
 * The client capabilities of a {@link DocumentLinkRequest}.
 */
interface DocumentLinkClientCapabilities {
    /**
     * Whether document link supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client supports the `tooltip` property on `DocumentLink`.
     *
     * @since 3.15.0
     */
    tooltipSupport?: boolean;
}
/**
 * The parameters of a {@link DocumentLinkRequest}.
 */
interface DocumentLinkParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document to provide document links for.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Provider options for a {@link DocumentLinkRequest}.
 */
interface DocumentLinkOptions extends WorkDoneProgressOptions {
    /**
     * Document links have a resolve provider as well.
     */
    resolveProvider?: boolean;
}
/**
 * Client capabilities of a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingClientCapabilities {
    /**
     * Whether formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingParams extends WorkDoneProgressParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The format options.
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingOptions extends WorkDoneProgressOptions {
}
/**
 * Client capabilities of a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingClientCapabilities {
    /**
     * Whether range formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client supports formatting multiple ranges at once.
     *
     * @since 3.18.0
     * @proposed
     */
    rangesSupport?: boolean;
}
/**
 * The parameters of a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingParams extends WorkDoneProgressParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range to format
     */
    range: Range$1;
    /**
     * The format options
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingOptions extends WorkDoneProgressOptions {
    /**
     * Whether the server supports formatting multiple ranges at once.
     *
     * @since 3.18.0
     * @proposed
     */
    rangesSupport?: boolean;
}
/**
 * Client capabilities of a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingClientCapabilities {
    /**
     * Whether on type formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position around which the on type formatting should happen.
     * This is not necessarily the exact position where the character denoted
     * by the property `ch` got typed.
     */
    position: Position$1;
    /**
     * The character that has been typed that triggered the formatting
     * on type request. That is not necessarily the last character that
     * got inserted into the document since the client could auto insert
     * characters as well (e.g. like automatic brace completion).
     */
    ch: string;
    /**
     * The formatting options.
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingOptions {
    /**
     * A character on which formatting should be triggered, like `{`.
     */
    firstTriggerCharacter: string;
    /**
     * More trigger characters.
     */
    moreTriggerCharacter?: string[];
}
declare namespace PrepareSupportDefaultBehavior {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    const Identifier: 1;
}
type PrepareSupportDefaultBehavior = 1;
interface RenameClientCapabilities {
    /**
     * Whether rename supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Client supports testing for validity of rename operations
     * before execution.
     *
     * @since 3.12.0
     */
    prepareSupport?: boolean;
    /**
     * Client supports the default behavior result.
     *
     * The value indicates the default behavior used by the
     * client.
     *
     * @since 3.16.0
     */
    prepareSupportDefaultBehavior?: PrepareSupportDefaultBehavior;
    /**
     * Whether the client honors the change annotations in
     * text edits and resource operations returned via the
     * rename request's workspace edit by for example presenting
     * the workspace edit in the user interface and asking
     * for confirmation.
     *
     * @since 3.16.0
     */
    honorsChangeAnnotations?: boolean;
}
/**
 * The parameters of a {@link RenameRequest}.
 */
interface RenameParams extends WorkDoneProgressParams {
    /**
     * The document to rename.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position at which this request was sent.
     */
    position: Position$1;
    /**
     * The new name of the symbol. If the given name is not valid the
     * request must return a {@link ResponseError} with an
     * appropriate message set.
     */
    newName: string;
}
/**
 * Provider options for a {@link RenameRequest}.
 */
interface RenameOptions extends WorkDoneProgressOptions {
    /**
     * Renames should be checked and tested before being executed.
     *
     * @since version 3.12.0
     */
    prepareProvider?: boolean;
}
interface PrepareRenameParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * The client capabilities of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandClientCapabilities {
    /**
     * Execute command supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandParams extends WorkDoneProgressParams {
    /**
     * The identifier of the actual command handler.
     */
    command: string;
    /**
     * Arguments that the command should be invoked with.
     */
    arguments?: LSPAny[];
}
/**
 * The server capabilities of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandOptions extends WorkDoneProgressOptions {
    /**
     * The commands to be executed on the server
     */
    commands: string[];
}
interface WorkspaceEditClientCapabilities {
    /**
     * The client supports versioned document changes in `WorkspaceEdit`s
     */
    documentChanges?: boolean;
    /**
     * The resource operations the client supports. Clients should at least
     * support 'create', 'rename' and 'delete' files and folders.
     *
     * @since 3.13.0
     */
    resourceOperations?: ResourceOperationKind[];
    /**
     * The failure handling strategy of a client if applying the workspace edit
     * fails.
     *
     * @since 3.13.0
     */
    failureHandling?: FailureHandlingKind;
    /**
     * Whether the client normalizes line endings to the client specific
     * setting.
     * If set to `true` the client will normalize line ending characters
     * in a workspace edit to the client-specified new line
     * character.
     *
     * @since 3.16.0
     */
    normalizesLineEndings?: boolean;
    /**
     * Whether the client in general supports change annotations on text edits,
     * create file, rename file and delete file changes.
     *
     * @since 3.16.0
     */
    changeAnnotationSupport?: {
        /**
         * Whether the client groups edits with equal labels into tree nodes,
         * for instance all edits labelled with "Changes in Strings" would
         * be a tree node.
         */
        groupsOnLabel?: boolean;
    };
}
/**
 * The parameters passed via an apply workspace edit request.
 */
interface ApplyWorkspaceEditParams {
    /**
     * An optional label of the workspace edit. This label is
     * presented in the user interface for example on an undo
     * stack to undo the workspace edit.
     */
    label?: string;
    /**
     * The edits to apply.
     */
    edit: WorkspaceEdit;
}
/**
 * The result returned from the apply workspace edit request.
 *
 * @since 3.17 renamed from ApplyWorkspaceEditResponse
 */
interface ApplyWorkspaceEditResult {
    /**
     * Indicates whether the edit was applied or not.
     */
    applied: boolean;
    /**
     * An optional textual description for why the edit was not applied.
     * This may be used by the server for diagnostic logging or to provide
     * a suitable error for a request that triggered the edit.
     */
    failureReason?: string;
    /**
     * Depending on the client's failure handling strategy `failedChange` might
     * contain the index of the change that failed. This property is only available
     * if the client signals a `failureHandlingStrategy` in its client capabilities.
     */
    failedChange?: uinteger;
}
/**
 * @deprecated Use ApplyWorkspaceEditResult instead.
 */
type ApplyWorkspaceEditResponse = ApplyWorkspaceEditResult;

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ConfigurationProvider {
    /**
     * A promise that resolves when the configuration provider is ready to be used.
     */
    readonly ready: Promise<void>;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialize` request.
     */
    initialize(params: InitializeParams): void;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialized` notification.
     */
    initialized(params: ConfigurationInitializedParams): Promise<void>;
    /**
     * Returns a configuration value stored for the given language.
     *
     * @param language The language id
     * @param configuration Configuration name
     */
    getConfiguration(language: string, configuration: string): Promise<any>;
    /**
     *  Updates the cached configurations using the `change` notification parameters.
     *
     * @param change The parameters of a change configuration notification.
     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`
     */
    updateConfiguration(change: DidChangeConfigurationParams): void;
    /**
     * Get notified after a configuration section has been updated.
     */
    onConfigurationSectionUpdate(callback: ConfigurationSectionUpdateListener): Disposable$1;
}
interface ConfigurationInitializedParams extends InitializedParams {
    register?: (params: DidChangeConfigurationRegistrationOptions) => void;
    fetchConfiguration?: (configuration: ConfigurationItem[]) => Promise<any>;
}
interface ConfigurationSectionUpdate {
    /**
     * The name of the configuration section that has been updated.
     */
    section: string;
    /**
     * The updated configuration section.
     */
    configuration: any;
}
type ConfigurationSectionUpdateListener = (update: ConfigurationSectionUpdate) => void;

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface BuildOptions {
    /**
     * Control the validation phase with this option:
     *  - `true` enables all validation checks and forces revalidating the documents
     *  - `false` or `undefined` disables all validation checks
     *  - An object runs only the necessary validation checks; the `categories` property restricts this to a specific subset
     */
    validation?: boolean | ValidationOptions;
}
/**
 * Shared-service for building and updating `LangiumDocument`s.
 */
interface DocumentBuilder {
    /** The options used for rebuilding documents after an update. */
    updateBuildOptions: BuildOptions;
    /**
     * Execute all necessary build steps for the given documents.
     *
     * @param documents Set of documents to be built.
     * @param options Options for the document builder.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options?: BuildOptions, cancelToken?: CancellationToken): Promise<void>;
    /**
     * This method is called when a document change is detected. It updates the state of all
     * affected documents, including those with references to the changed ones, so they are rebuilt.
     *
     * @param changed URIs of changed or created documents
     * @param deleted URIs of deleted documents
     * @param cancelToken allows to cancel the current operation
     * @throws `OperationCancelled` if cancellation is detected during execution
     */
    update(changed: URI[], deleted: URI[], cancelToken?: CancellationToken): Promise<void>;
    /**
     * Notify the given callback when a document update was triggered, but before any document
     * is rebuilt. Listeners to this event should not perform any long-running task.
     */
    onUpdate(callback: DocumentUpdateListener): Disposable;
    /**
     * Notify the given callback when a set of documents has been built reaching the specified target state.
     */
    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable;
    /**
     * Notify the specified callback when a document has been built reaching the specified target state.
     * Unlike {@link onBuildPhase} the listener is called for every single document.
     *
     * There are two main advantages compared to {@link onBuildPhase}:
     * 1. If the build is cancelled, {@link onDocumentPhase} will still fire for documents that have reached a specific state.
     *    Meanwhile, {@link onBuildPhase} won't fire for that state.
     * 2. The {@link DocumentBuilder} ensures that all {@link DocumentPhaseListener} instances are called for a built document.
     *    Even if the build is cancelled before those listeners were called.
     */
    onDocumentPhase(targetState: DocumentState, callback: DocumentPhaseListener): Disposable;
    /**
     * Wait until the workspace has reached the specified state for all documents.
     *
     * @param state The desired state. The promise won't resolve until all documents have reached this state
     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process
     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached
     */
    waitUntil(state: DocumentState, cancelToken?: CancellationToken): Promise<void>;
    /**
     * Wait until the document specified by the {@link uri} has reached the specified state.
     *
     * @param state The desired state. The promise won't resolve until the document has reached this state.
     * @param uri The specified URI that points to the document. If the URI does not exist, the promise will resolve once the workspace has reached the specified state.
     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process.
     * @return The URI of the document that has reached the desired state, or `undefined` if the document does not exist.
     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached
     */
    waitUntil(state: DocumentState, uri?: URI, cancelToken?: CancellationToken): Promise<URI | undefined>;
}
type DocumentUpdateListener = (changed: URI[], deleted: URI[]) => void | Promise<void>;
type DocumentBuildListener = (built: LangiumDocument[], cancelToken: CancellationToken) => void | Promise<void>;
type DocumentPhaseListener = (built: LangiumDocument, cancelToken: CancellationToken) => void | Promise<void>;

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Utility service to execute mutually exclusive actions.
 */
interface WorkspaceLock {
    /**
     * Performs a single async action, like initializing the workspace or processing document changes.
     * Only one action will be executed at a time.
     *
     * When another action is queued up, the token provided for the action will be cancelled.
     * Assuming the action makes use of this token, the next action only has to wait for the current action to finish cancellation.
     */
    write(action: (token: CancellationToken) => MaybePromise$1<void>): Promise<void>;
    /**
     * Performs a single action, like computing completion results or providing workspace symbols.
     * Read actions will only be executed after all write actions have finished. They will be executed in parallel if possible.
     *
     * If a write action is currently running, the read action will be queued up and executed afterwards.
     * If a new write action is queued up while a read action is waiting, the write action will receive priority and will be handled before the read action.
     *
     * Note that read actions are not allowed to modify anything in the workspace. Please use {@link write} instead.
     */
    read<T>(action: () => MaybePromise$1<T>): Promise<T>;
    /**
     * Cancels the last queued write action. All previous write actions already have been cancelled.
     */
    cancelWrite(): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The workspace manager is responsible for finding source files in the workspace.
 * This service is shared between all languages of a language server.
 */
interface WorkspaceManager {
    /** The options used for the initial workspace build. */
    initialBuildOptions: BuildOptions | undefined;
    /**
     * A promise that resolves when the workspace manager is ready to be used.
     * Use this to ensure that the workspace manager has finished its initialization.
     */
    readonly ready: Promise<void>;
    /**
     * The workspace folders of the current workspace.
     * Available only after the `ready` promise resolves.
     */
    get workspaceFolders(): readonly WorkspaceFolder[] | undefined;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialize` request.
     */
    initialize(params: InitializeParams): void;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialized` notification.
     */
    initialized(params: InitializedParams): Promise<void>;
    /**
     * Does the initial indexing of workspace folders.
     * Collects information about exported and referenced AstNodes in
     * each language file and stores it locally.
     *
     * @param folders The set of workspace folders to be indexed.
     * @param cancelToken A cancellation token that can be used to cancel the operation.
     *
     * @throws OperationCancelled if a cancellation event has been detected
     */
    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken): Promise<void>;
}
declare class DefaultWorkspaceManager implements WorkspaceManager {
    initialBuildOptions: BuildOptions;
    protected readonly serviceRegistry: ServiceRegistry;
    protected readonly langiumDocuments: LangiumDocuments$1;
    protected readonly documentBuilder: DocumentBuilder;
    protected readonly fileSystemProvider: FileSystemProvider;
    protected readonly mutex: WorkspaceLock;
    protected readonly _ready: Deferred<void>;
    protected folders?: WorkspaceFolder[];
    constructor(services: LangiumSharedCoreServices);
    get ready(): Promise<void>;
    get workspaceFolders(): readonly WorkspaceFolder[] | undefined;
    initialize(params: InitializeParams): void;
    initialized(_params: InitializedParams): Promise<void>;
    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken): Promise<void>;
    /**
     * Performs the uninterruptable startup sequence of the workspace manager.
     * This methods loads all documents in the workspace and other documents and returns them.
     */
    protected performStartup(folders: WorkspaceFolder[]): Promise<LangiumDocument[]>;
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    protected loadAdditionalDocuments(_folders: WorkspaceFolder[], _collector: (document: LangiumDocument) => void): Promise<void>;
    /**
     * Determine the root folder of the source documents in the given workspace folder.
     * The default implementation returns the URI of the workspace folder, but you can override
     * this to return a subfolder like `src` instead.
     */
    protected getRootFolder(workspaceFolder: WorkspaceFolder): URI;
    /**
     * Traverse the file system folder identified by the given URI and its subfolders. All
     * contained files that match the file extensions are added to the collector.
     */
    protected traverseFolder(workspaceFolder: WorkspaceFolder, folderPath: URI, fileExtensions: string[], collector: (document: LangiumDocument) => void): Promise<void>;
    /**
     * Determine whether the given folder entry shall be included while indexing the workspace.
     */
    protected includeEntry(_workspaceFolder: WorkspaceFolder, entry: FileSystemNode, fileExtensions: string[]): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The services generated by `langium-cli` for a specific language. These are derived from the
 * grammar definition and the language configuration.
 */
type LangiumGeneratedCoreServices = {
    readonly Grammar: Grammar;
    readonly LanguageMetaData: LanguageMetaData;
    readonly parser: {
        readonly ParserConfig?: IParserConfig;
    };
};
/**
 * Core services for a specific language of which Langium provides default implementations.
 */
type LangiumDefaultCoreServices = {
    readonly parser: {
        readonly AsyncParser: AsyncParser;
        readonly GrammarConfig: GrammarConfig;
        readonly ValueConverter: ValueConverter;
        readonly LangiumParser: LangiumParser;
        readonly ParserErrorMessageProvider: IParserErrorMessageProvider;
        readonly LexerErrorMessageProvider: ILexerErrorMessageProvider;
        readonly CompletionParser: LangiumCompletionParser;
        readonly TokenBuilder: TokenBuilder;
        readonly Lexer: Lexer;
    };
    readonly documentation: {
        readonly CommentProvider: CommentProvider;
        readonly DocumentationProvider: DocumentationProvider;
    };
    readonly references: {
        readonly Linker: Linker;
        readonly NameProvider: NameProvider;
        readonly References: References;
        readonly ScopeProvider: ScopeProvider;
        readonly ScopeComputation: ScopeComputation;
    };
    readonly serializer: {
        readonly Hydrator: Hydrator;
        readonly JsonSerializer: JsonSerializer;
    };
    readonly validation: {
        readonly DocumentValidator: DocumentValidator;
        readonly ValidationRegistry: ValidationRegistry;
    };
    readonly workspace: {
        readonly AstNodeLocator: AstNodeLocator;
        readonly AstNodeDescriptionProvider: AstNodeDescriptionProvider;
        readonly ReferenceDescriptionProvider: ReferenceDescriptionProvider;
    };
    readonly shared: LangiumSharedCoreServices;
};
/**
 * The core set of services available for a language. These are either generated by `langium-cli`
 * or provided as default implementations.
 */
type LangiumCoreServices = LangiumGeneratedCoreServices & LangiumDefaultCoreServices;
/**
 * The services generated by `langium-cli` that are shared between multiple languages. These are
 * derived from the grammar definition.
 */
type LangiumGeneratedSharedCoreServices = {
    readonly AstReflection: AstReflection;
};
/**
 * Core services shared between multiple languages where Langium provides default implementations.
 */
type LangiumDefaultSharedCoreServices = {
    readonly ServiceRegistry: ServiceRegistry;
    readonly workspace: {
        readonly ConfigurationProvider: ConfigurationProvider;
        readonly DocumentBuilder: DocumentBuilder;
        readonly FileSystemProvider: FileSystemProvider;
        readonly IndexManager: IndexManager$1;
        readonly LangiumDocuments: LangiumDocuments$1;
        readonly LangiumDocumentFactory: LangiumDocumentFactory;
        readonly TextDocuments?: TextDocumentProvider;
        readonly WorkspaceLock: WorkspaceLock;
        readonly WorkspaceManager: WorkspaceManager;
    };
};
/**
 * The shared core services are a set of services that are used by every language within a Langium project (excluding LSP services)
 * This is necessary to enable features like cross references across different languages.
 */
type LangiumSharedCoreServices = LangiumDefaultSharedCoreServices & LangiumGeneratedSharedCoreServices;

/**
 * @hidden
 */
type $keywords<T extends string> = {
  [key in T]: key;
};

declare module 'ts-graphviz' {
    namespace GraphAttributeKey {
        interface $values extends $keywords<'likec4_viewId'> {
        }
    }
    namespace ClusterSubgraphAttributeKey {
        interface $values extends $keywords<'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_level' | 'likec4_depth'> {
        }
    }
    namespace NodeAttributeKey {
        interface $values extends $keywords<'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_level'> {
        }
    }
    namespace EdgeAttributeKey {
        interface $values extends $keywords<'likec4_id'> {
        }
    }
    namespace Attribute {
        interface $keys extends $keywords<'likec4_viewId' | 'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_level' | 'likec4_depth'> {
        }
        interface $types {
            likec4_viewId: string;
            likec4_type: 'folder' | 'file' | 'view';
            likec4_path: string;
            likec4_id: string;
            likec4_level: number;
            likec4_depth: number;
        }
    }
}
type DotSource = Tagged<string, 'DotSource'>;

type GvNodeName = Tagged<string, 'GvNodeName'>;
type GvId = Tagged<number, 'GvId'>;
type Point = [x: number, y: number];
interface GraphvizJson {
    name: GvNodeName;
    directed: boolean;
    strict: boolean;
    _draw_: GraphvizJson.Draw[];
    bb: string;
    compound: string;
    fontname: string;
    fontsize: string;
    label: string;
    nodesep: string;
    outputorder: string;
    rankdir: string;
    ranksep: string;
    splines: string;
    xdotversion: string;
    _subgraph_cnt: number;
    objects?: GraphvizJson.GvObject[];
    edges?: GraphvizJson.Edge[];
}
declare namespace GraphvizJson {
    interface Draw {
        op: string;
        grad: string;
        color: string;
        points: Point[];
    }
    interface Draw2 {
        op: string;
        grad: string;
        color: string;
        points: Point[];
    }
    namespace DrawOps {
        type Style = {
            op: 'S';
            style: string;
        };
        type BSpline = {
            op: 'b' | 'B';
            points: Point[];
        };
        type Color = {
            op: 'c';
            grad: string;
            color: string;
        };
        type Polygon = {
            op: 'p' | 'P';
            points: Point[];
        };
    }
    type DrawOp = DrawOps.Style | DrawOps.BSpline | DrawOps.Color | DrawOps.Polygon;
    type LabelDrawOps = {
        op: 'F';
        size: number;
        face: string;
    } | {
        op: 'c';
        color: string;
    } | {
        op: 't';
        fontchar: number;
    } | {
        op: 'T';
        pt: Point;
        align: 'l' | 'r' | 'c';
        width: number;
        text: string;
    };
    type GvObject = GvNodeObject | GvSubgraph;
    interface GvSubgraph {
        bb: string;
        label?: string;
        compound: 'true';
        _ldraw_?: LabelDrawOps[];
        likec4_type?: 'folder' | 'file';
        likec4_path?: string;
        likec4_id?: Fqn;
        likec4_level?: number;
        likec4_depth?: number;
        _gvid: GvId;
        subgraphs?: GvId[];
        nodes?: GvId[];
        edges?: GvId[];
    }
    interface GvNodeObject {
        _draw_: Draw[];
        _ldraw_?: LabelDrawOps[];
        likec4_type?: 'folder' | 'file' | 'view';
        likec4_path?: string;
        likec4_id?: Fqn;
        likec4_level?: number;
        _gvid: GvId;
        height: string;
        pos: string;
        shape: 'rect';
        width: string;
        label?: string;
    }
    interface Draw3 {
        op: string;
        grad: string;
        color: string;
        points: Point[];
    }
    interface Hdraw {
        op: string;
        style: string;
        grad: string;
        color: string;
        points: Point[];
    }
    interface Edge {
        _gvid: GvId;
        tail: GvId;
        head: GvId;
        dir?: 'forward' | 'back' | 'both' | 'none';
        _draw_: DrawOp[];
        _hdraw_?: DrawOp[];
        _tdraw_?: DrawOp[];
        _ldraw_?: LabelDrawOps[];
        _tldraw_?: LabelDrawOps[];
        _hldraw_?: LabelDrawOps[];
        fontname: string;
        fontsize: string;
        likec4_id?: EdgeId;
        label: string;
        lp: string;
        nojustify?: 'true' | 'false';
        pos?: string;
    }
}

interface GraphvizPort {
    unflatten(dot: DotSource): Promise<DotSource>;
    acyclic(dot: DotSource): Promise<DotSource>;
    layoutJson(dot: DotSource): Promise<string>;
    svg(dot: DotSource): Promise<string>;
}
type LayoutResult = {
    dot: DotSource;
    diagram: DiagramView;
};
declare class GraphvizLayouter {
    private graphviz;
    constructor(graphviz: GraphvizPort);
    get port(): GraphvizPort;
    changePort(graphviz: GraphvizPort): void;
    dotToJson(dot: DotSource): Promise<GraphvizJson>;
    layout(view: ComputedView): Promise<LayoutResult>;
    svg(view: ComputedView): Promise<{
        svg: string;
        dot: DotSource;
    }>;
    dot(computedView: ComputedView): Promise<DotSource>;
    layoutOverviewGraph(views: ComputedView[]): Promise<OverviewGraph>;
}

interface WorkDoneProgressReporter {
    begin(title: string, percentage?: number, message?: string, cancellable?: boolean): void;
    report(percentage: number): void;
    report(message: string): void;
    report(percentage: number, message: string): void;
    done(): void;
}
interface WorkDoneProgressServerReporter extends WorkDoneProgressReporter {
    readonly token: CancellationToken;
}
interface WindowProgress {
    attachWorkDoneProgress(token: ProgressToken | undefined): WorkDoneProgressReporter;
    createWorkDoneProgress(): Promise<WorkDoneProgressServerReporter>;
}
interface ResultProgressReporter<R> {
    report(data: R): void;
}

interface Configuration {
    getConfiguration(): Promise<any>;
    getConfiguration(section: string): Promise<any>;
    getConfiguration(item: ConfigurationItem): Promise<any>;
    getConfiguration(items: ConfigurationItem[]): Promise<any[]>;
}

interface WorkspaceFolders {
    getWorkspaceFolders(): Promise<WorkspaceFolder[] | null>;
    onDidChangeWorkspaceFolders: Event<WorkspaceFoldersChangeEvent>;
}

/**
 * Shape of the call hierarchy feature
 *
 * @since 3.16.0
 */
interface CallHierarchy {
    callHierarchy: {
        onPrepare(handler: ServerRequestHandler<CallHierarchyPrepareParams, CallHierarchyItem[] | null, never, void>): Disposable$1;
        onIncomingCalls(handler: ServerRequestHandler<CallHierarchyIncomingCallsParams, CallHierarchyIncomingCall[] | null, CallHierarchyIncomingCall[], void>): Disposable$1;
        onOutgoingCalls(handler: ServerRequestHandler<CallHierarchyOutgoingCallsParams, CallHierarchyOutgoingCall[] | null, CallHierarchyOutgoingCall[], void>): Disposable$1;
    };
}

/**
 * Shape of the semantic token feature
 *
 * @since 3.16.0
 */
interface SemanticTokensFeatureShape {
    semanticTokens: {
        refresh(): void;
        on(handler: ServerRequestHandler<SemanticTokensParams, SemanticTokens, SemanticTokensPartialResult, void>): Disposable$1;
        onDelta(handler: ServerRequestHandler<SemanticTokensDeltaParams, SemanticTokensDelta | SemanticTokens, SemanticTokensDeltaPartialResult | SemanticTokensPartialResult, void>): Disposable$1;
        onRange(handler: ServerRequestHandler<SemanticTokensRangeParams, SemanticTokens, SemanticTokensPartialResult, void>): Disposable$1;
    };
}
declare class SemanticTokensBuilder$1 {
    private _id;
    private _prevLine;
    private _prevChar;
    private _data;
    private _dataLen;
    private _prevData;
    constructor();
    private initialize;
    push(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void;
    get id(): string;
    previousResult(id: string): void;
    build(): SemanticTokens;
    canBuildEdits(): boolean;
    buildEdits(): SemanticTokens | SemanticTokensDelta;
}

interface ShowDocumentFeatureShape {
    showDocument(params: ShowDocumentParams): Promise<ShowDocumentResult>;
}

/**
 * Shape of the file operations feature
 *
 * @since 3.16.0
 */
interface FileOperationsFeatureShape {
    onDidCreateFiles(handler: NotificationHandler<CreateFilesParams>): Disposable$1;
    onDidRenameFiles(handler: NotificationHandler<RenameFilesParams>): Disposable$1;
    onDidDeleteFiles(handler: NotificationHandler<DeleteFilesParams>): Disposable$1;
    onWillCreateFiles(handler: RequestHandler<CreateFilesParams, WorkspaceEdit | null, never>): Disposable$1;
    onWillRenameFiles(handler: RequestHandler<RenameFilesParams, WorkspaceEdit | null, never>): Disposable$1;
    onWillDeleteFiles(handler: RequestHandler<DeleteFilesParams, WorkspaceEdit | null, never>): Disposable$1;
}

/**
 * Shape of the linked editing feature
 *
 * @since 3.16.0
 */
interface LinkedEditingRangeFeatureShape {
    /**
     * Installs a handler for the linked editing range request.
     *
     * @param handler The corresponding handler.
     */
    onLinkedEditingRange(handler: ServerRequestHandler<LinkedEditingRangeParams, LinkedEditingRanges | undefined | null, never, never>): Disposable$1;
}

/**
 * Shape of the type hierarchy feature
 *
 * @since 3.17.0
 */
interface TypeHierarchyFeatureShape {
    typeHierarchy: {
        onPrepare(handler: ServerRequestHandler<TypeHierarchyPrepareParams, TypeHierarchyItem[] | null, never, void>): Disposable$1;
        onSupertypes(handler: ServerRequestHandler<TypeHierarchySupertypesParams, TypeHierarchyItem[] | null, TypeHierarchyItem[], void>): Disposable$1;
        onSubtypes(handler: ServerRequestHandler<TypeHierarchySubtypesParams, TypeHierarchyItem[] | null, TypeHierarchyItem[], void>): Disposable$1;
    };
}

/**
 * Shape of the inline values feature
 *
 * @since 3.17.0
 */
interface InlineValueFeatureShape {
    inlineValue: {
        /**
         * Ask the client to refresh all inline values.
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the inline values request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<InlineValueParams, InlineValue[] | undefined | null, InlineValue[], void>): Disposable$1;
    };
}

/**
 * Shape of the folding range feature
 */
interface FoldingRangeFeatureShape {
    foldingRange: {
        /**
         * Ask the client to refresh all folding ranges
         *
         * @since 3.18.0.
         * @proposed
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the folding range request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<FoldingRangeParams, FoldingRange[] | undefined | null, FoldingRange[], void>): Disposable$1;
    };
}

/**
 * Shape of the inlay hints feature
 *
 * @since 3.17.0
 */
interface InlayHintFeatureShape {
    inlayHint: {
        /**
         * Ask the client to refresh all inlay hints.
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the inlay hints request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<InlayHintParams, InlayHint[] | undefined | null, InlayHint[], void>): Disposable$1;
        /**
         * Installs a handler for the inlay hint resolve request.
         *
         * @param handler The corresponding handler.
         */
        resolve(handler: RequestHandler<InlayHint, InlayHint, void>): Disposable$1;
    };
}

/**
 * Shape of the linked editing feature
 *
 * @since 3.16.0
 */
interface DiagnosticFeatureShape {
    diagnostics: {
        /**
        * Asks the client to refresh all diagnostics provided by this server by
        * pull for the corresponding documents again.
        */
        refresh(): void;
        /**
        * Installs a handler for the document diagnostic request.
        *
        * @param handler The corresponding handler.
        */
        on(handler: ServerRequestHandler<DocumentDiagnosticParams, DocumentDiagnosticReport, DocumentDiagnosticReportPartialResult, DiagnosticServerCancellationData>): Disposable$1;
        /**
         * Installs a handler for the workspace diagnostic request.
         *
         * @param handler The corresponding handler.
         */
        onWorkspace(handler: ServerRequestHandler<WorkspaceDiagnosticParams, WorkspaceDiagnosticReport, WorkspaceDiagnosticReportPartialResult, DiagnosticServerCancellationData>): Disposable$1;
    };
}

/**
 * Event to signal changes to a text document.
 */
interface TextDocumentChangeEvent<T> {
    /**
     * The document that has changed.
     */
    document: T;
}
/**
 * Event to signal that a document will be saved.
 */
interface TextDocumentWillSaveEvent<T> {
    /**
     * The document that will be saved
     */
    document: T;
    /**
     * The reason why save was triggered.
     */
    reason: TextDocumentSaveReason;
}

/**
 * Shape of the notebooks feature
 *
 * @since 3.17.0
 */
interface NotebookSyncFeatureShape {
    synchronization: {
        onDidOpenNotebookDocument(handler: NotificationHandler1<DidOpenNotebookDocumentParams>): Disposable$1;
        onDidChangeNotebookDocument(handler: NotificationHandler1<DidChangeNotebookDocumentParams>): Disposable$1;
        onDidSaveNotebookDocument(handler: NotificationHandler1<DidSaveNotebookDocumentParams>): Disposable$1;
        onDidCloseNotebookDocument(handler: NotificationHandler1<DidCloseNotebookDocumentParams>): Disposable$1;
    };
}
type NotebookDocumentChangeEvent = {
    /**
     * The notebook document that changed.
     */
    notebookDocument: NotebookDocument;
    /**
     * The meta data change if any.
     *
     * Note: old and new should always be an object literal (e.g. LSPObject)
     */
    metadata?: {
        old: LSPObject | undefined;
        new: LSPObject | undefined;
    };
    /**
     * The cell changes if any.
     */
    cells?: {
        /**
         * The cells that got added.
         */
        added: NotebookCell[];
        /**
         * The cells that got removed.
         */
        removed: NotebookCell[];
        /**
         * The cells that changed.
         */
        changed: {
            /**
             * The cell data has changed, excluding its
             * text content which is reported via
             * `textContentChanged`.
             */
            data: {
                old: NotebookCell;
                new: NotebookCell;
            }[];
            /**
             * The text content of a cell has changed.
             * The actual text is available via the `Notebooks`
             * text document manager.
             */
            textContent: NotebookCell[];
        };
    };
};

/**
 * Shape of the moniker feature
 *
 * @since 3.16.0
 */
interface MonikerFeatureShape {
    moniker: {
        on(handler: ServerRequestHandler<MonikerParams, Moniker[] | null, Moniker[], void>): Disposable$1;
    };
}

interface FeatureBase {
    /**
     * Called to initialize the remote with the given
     * client capabilities
     *
     * @param capabilities The client capabilities
     */
    initialize(capabilities: ClientCapabilities$1): void;
    /**
     * Called to fill in the server capabilities this feature implements.
     *
     * @param capabilities The server capabilities to fill.
     */
    fillServerCapabilities(capabilities: ServerCapabilities$1): void;
}
/**
 * The RemoteConsole interface contains all functions to interact with
 * the tools / clients console or log system. Internally it used `window/logMessage`
 * notifications.
 */
interface RemoteConsole extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Show an error message.
     *
     * @param message The message to show.
     */
    error(message: string): void;
    /**
     * Show a warning message.
     *
     * @param message The message to show.
     */
    warn(message: string): void;
    /**
     * Show an information message.
     *
     * @param message The message to show.
     */
    info(message: string): void;
    /**
     * Log a message.
     *
     * @param message The message to log.
     */
    log(message: string): void;
    /**
     * Log a debug message.
     *
     * @param message The message to log.
     *
     * @since 3.18.0
     */
    debug(message: string): void;
}
/**
 * The RemoteWindow interface contains all functions to interact with
 * the visual window of VS Code.
 */
interface _RemoteWindow extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Shows an error message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showErrorMessage(message: string): void;
    showErrorMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
    /**
     * Shows a warning message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showWarningMessage(message: string): void;
    showWarningMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
    /**
     * Shows an information message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showInformationMessage(message: string): void;
    showInformationMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
}
type RemoteWindow = _RemoteWindow & WindowProgress & ShowDocumentFeatureShape;
/**
 * A bulk registration manages n single registration to be able to register
 * for n notifications or requests using one register request.
 */
interface BulkRegistration {
    /**
     * Adds a single registration.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     */
    add<RO>(type: ProtocolNotificationType0<RO>, registerParams: RO): void;
    add<P, RO>(type: ProtocolNotificationType<P, RO>, registerParams: RO): void;
    /**
     * Adds a single registration.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     */
    add<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, registerParams: RO): void;
    add<P, PR, R, E, RO>(type: ProtocolRequestType<P, PR, R, E, RO>, registerParams: RO): void;
    /**
     * Adds a single registration.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     */
    add<RO>(type: RegistrationType<RO>, registerParams: RO): void;
}
declare namespace BulkRegistration {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create(): BulkRegistration;
}
/**
 * A `BulkUnregistration` manages n unregistrations.
 */
interface BulkUnregistration extends Disposable$1 {
    /**
     * Disposes a single registration. It will be removed from the
     * `BulkUnregistration`.
     */
    disposeSingle(arg: string | MessageSignature): boolean;
}
declare namespace BulkUnregistration {
    function create(): BulkUnregistration;
}
/**
 * Interface to register and unregister `listeners` on the client / tools side.
 */
interface RemoteClient extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Registers a listener for the given request.
     *
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<P, RO>(type: ProtocolNotificationType<P, RO>, registerParams?: RO): Promise<Disposable$1>;
    register<RO>(type: ProtocolNotificationType0<RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given request.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<P, RO>(unregisteration: BulkUnregistration, type: ProtocolNotificationType<P, RO>, registerParams?: RO): Promise<Disposable$1>;
    register<RO>(unregisteration: BulkUnregistration, type: ProtocolNotificationType0<RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given request.
     *
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, registerParams?: RO): Promise<Disposable$1>;
    register<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given request.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<P, R, PR, E, RO>(unregisteration: BulkUnregistration, type: ProtocolRequestType<P, R, PR, E, RO>, registerParams?: RO): Promise<Disposable$1>;
    register<R, PR, E, RO>(unregisteration: BulkUnregistration, type: ProtocolRequestType0<R, PR, E, RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given registration type.
     *
     * @param type the registration type.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<RO>(type: RegistrationType<RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a listener for the given registration type.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the registration type.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<RO>(unregisteration: BulkUnregistration, type: RegistrationType<RO>, registerParams?: RO): Promise<Disposable$1>;
    /**
     * Registers a set of listeners.
     * @param registrations the bulk registration
     * @return a `Disposable` to unregister the listeners again.
     */
    register(registrations: BulkRegistration): Promise<BulkUnregistration>;
}
/**
 * Represents the workspace managed by the client.
 */
interface _RemoteWorkspace extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Applies a `WorkspaceEdit` to the workspace
     * @param param the workspace edit params.
     * @return a thenable that resolves to the `ApplyWorkspaceEditResponse`.
     */
    applyEdit(paramOrEdit: ApplyWorkspaceEditParams | WorkspaceEdit): Promise<ApplyWorkspaceEditResponse>;
}
type RemoteWorkspace = _RemoteWorkspace & Configuration & WorkspaceFolders & FileOperationsFeatureShape;
/**
 * Interface to log telemetry events. The events are actually send to the client
 * and the client needs to feed the event into a proper telemetry system.
 */
interface Telemetry extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Log the given data to telemetry.
     *
     * @param data The data to log. Must be a JSON serializable object.
     */
    logEvent(data: any): void;
}
/**
 * Interface to log traces to the client. The events are sent to the client and the
 * client needs to log the trace events.
 */
interface RemoteTracer extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Log the given data to the trace Log
     */
    log(message: string, verbose?: string): void;
}
interface _Languages extends FeatureBase {
    connection: Connection;
    attachWorkDoneProgress(params: WorkDoneProgressParams): WorkDoneProgressReporter;
    attachPartialResultProgress<PR>(type: ProgressType<PR>, params: PartialResultParams): ResultProgressReporter<PR> | undefined;
}
type Languages = _Languages & CallHierarchy & SemanticTokensFeatureShape & LinkedEditingRangeFeatureShape & TypeHierarchyFeatureShape & InlineValueFeatureShape & InlayHintFeatureShape & DiagnosticFeatureShape & MonikerFeatureShape & FoldingRangeFeatureShape;
interface _Notebooks extends FeatureBase {
    connection: Connection;
    attachWorkDoneProgress(params: WorkDoneProgressParams): WorkDoneProgressReporter;
    attachPartialResultProgress<PR>(type: ProgressType<PR>, params: PartialResultParams): ResultProgressReporter<PR> | undefined;
}
type Notebooks = _Notebooks & NotebookSyncFeatureShape;
/**
 * An empty interface for new proposed API.
 */
interface _ {
}
interface ServerRequestHandler<P, R, PR, E> {
    (params: P, token: CancellationToken, workDoneProgress: WorkDoneProgressReporter, resultProgress?: ResultProgressReporter<PR>): HandlerResult<R, E>;
}
/**
 * Interface to describe the shape of the server connection.
 */
interface _Connection<PConsole = _, PTracer = _, PTelemetry = _, PClient = _, PWindow = _, PWorkspace = _, PLanguages = _, PNotebooks = _> {
    /**
     * Start listening on the input stream for messages to process.
     */
    listen(): void;
    /**
     * Installs a request handler described by the given {@link RequestType}.
     *
     * @param type The {@link RequestType} describing the request.
     * @param handler The handler to install
     */
    onRequest<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, handler: RequestHandler0<R, E>): Disposable$1;
    onRequest<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, handler: RequestHandler<P, R, E>): Disposable$1;
    onRequest<R, PR, E, RO>(type: RequestType0<R, E>, handler: RequestHandler0<R, E>): Disposable$1;
    onRequest<P, R, E>(type: RequestType<P, R, E>, handler: RequestHandler<P, R, E>): Disposable$1;
    /**
     * Installs a request handler for the given method.
     *
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onRequest<R, E>(method: string, handler: GenericRequestHandler<R, E>): Disposable$1;
    /**
     * Installs a request handler that is invoked if no specific request handler can be found.
     *
     * @param handler a handler that handles all requests.
     */
    onRequest(handler: StarRequestHandler): Disposable$1;
    /**
     * Send a request to the client.
     *
     * @param type The {@link RequestType} describing the request.
     * @param params The request's parameters.
     */
    sendRequest<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, token?: CancellationToken): Promise<R>;
    sendRequest<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, params: P, token?: CancellationToken): Promise<R>;
    sendRequest<R, E>(type: RequestType0<R, E>, token?: CancellationToken): Promise<R>;
    sendRequest<P, R, E>(type: RequestType<P, R, E>, params: P, token?: CancellationToken): Promise<R>;
    /**
     * Send a request to the client.
     *
     * @param method The method to invoke on the client.
     * @param params The request's parameters.
     */
    sendRequest<R>(method: string, token?: CancellationToken): Promise<R>;
    sendRequest<R>(method: string, params: any, token?: CancellationToken): Promise<R>;
    /**
     * Installs a notification handler described by the given {@link NotificationType}.
     *
     * @param type The {@link NotificationType} describing the notification.
     * @param handler The handler to install.
     */
    onNotification<RO>(type: ProtocolNotificationType0<RO>, handler: NotificationHandler0): Disposable$1;
    onNotification<P, RO>(type: ProtocolNotificationType<P, RO>, handler: NotificationHandler<P>): Disposable$1;
    onNotification(type: NotificationType0, handler: NotificationHandler0): Disposable$1;
    onNotification<P>(type: NotificationType<P>, handler: NotificationHandler<P>): Disposable$1;
    /**
     * Installs a notification handler for the given method.
     *
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onNotification(method: string, handler: GenericNotificationHandler): Disposable$1;
    /**
     * Installs a notification handler that is invoked if no specific notification handler can be found.
     *
     * @param handler a handler that handles all notifications.
     */
    onNotification(handler: StarNotificationHandler): Disposable$1;
    /**
     * Send a notification to the client.
     *
     * @param type The {@link NotificationType} describing the notification.
     * @param params The notification's parameters.
     */
    sendNotification<RO>(type: ProtocolNotificationType0<RO>): Promise<void>;
    sendNotification<P, RO>(type: ProtocolNotificationType<P, RO>, params: P): Promise<void>;
    sendNotification(type: NotificationType0): Promise<void>;
    sendNotification<P>(type: NotificationType<P>, params: P): Promise<void>;
    /**
     * Send a notification to the client.
     *
     * @param method The method to invoke on the client.
     * @param params The notification's parameters.
     */
    sendNotification(method: string, params?: any): Promise<void>;
    /**
     * Installs a progress handler for a given token.
     * @param type the progress type
     * @param token the token
     * @param handler the handler
     */
    onProgress<P>(type: ProgressType<P>, token: string | number, handler: NotificationHandler<P>): Disposable$1;
    /**
     * Sends progress.
     * @param type the progress type
     * @param token the token to use
     * @param value the progress value
     */
    sendProgress<P>(type: ProgressType<P>, token: string | number, value: P): Promise<void>;
    /**
     * Installs a handler for the initialize request.
     *
     * @param handler The initialize handler.
     */
    onInitialize(handler: ServerRequestHandler<InitializeParams, InitializeResult, never, InitializeError>): Disposable$1;
    /**
     * Installs a handler for the initialized notification.
     *
     * @param handler The initialized handler.
     */
    onInitialized(handler: NotificationHandler<InitializedParams>): Disposable$1;
    /**
     * Installs a handler for the shutdown request.
     *
     * @param handler The initialize handler.
     */
    onShutdown(handler: RequestHandler0<void, void>): Disposable$1;
    /**
     * Installs a handler for the exit notification.
     *
     * @param handler The exit handler.
     */
    onExit(handler: NotificationHandler0): Disposable$1;
    /**
     * A property to provide access to console specific features.
     */
    console: RemoteConsole & PConsole;
    /**
     * A property to provide access to tracer specific features.
     */
    tracer: RemoteTracer & PTracer;
    /**
     * A property to provide access to telemetry specific features.
     */
    telemetry: Telemetry & PTelemetry;
    /**
     * A property to provide access to client specific features like registering
     * for requests or notifications.
     */
    client: RemoteClient & PClient;
    /**
     * A property to provide access to windows specific features.
     */
    window: RemoteWindow & PWindow;
    /**
     * A property to provide access to workspace specific features.
     */
    workspace: RemoteWorkspace & PWorkspace;
    /**
     * A property to provide access to language specific features.
     */
    languages: Languages & PLanguages;
    /**
     * A property to provide access to notebook specific features.
     */
    notebooks: Notebooks & PNotebooks;
    /**
     * Installs a handler for the `DidChangeConfiguration` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeConfiguration(handler: NotificationHandler<DidChangeConfigurationParams>): Disposable$1;
    /**
     * Installs a handler for the `DidChangeWatchedFiles` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeWatchedFiles(handler: NotificationHandler<DidChangeWatchedFilesParams>): Disposable$1;
    /**
     * Installs a handler for the `DidOpenTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidOpenTextDocument(handler: NotificationHandler<DidOpenTextDocumentParams>): Disposable$1;
    /**
     * Installs a handler for the `DidChangeTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeTextDocument(handler: NotificationHandler<DidChangeTextDocumentParams>): Disposable$1;
    /**
     * Installs a handler for the `DidCloseTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidCloseTextDocument(handler: NotificationHandler<DidCloseTextDocumentParams>): Disposable$1;
    /**
     * Installs a handler for the `WillSaveTextDocument` notification.
     *
     * Note that this notification is opt-in. The client will not send it unless
     * your server has the `textDocumentSync.willSave` capability or you've
     * dynamically registered for the `textDocument/willSave` method.
     *
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocument(handler: NotificationHandler<WillSaveTextDocumentParams>): Disposable$1;
    /**
     * Installs a handler for the `WillSaveTextDocumentWaitUntil` request.
     *
     * Note that this request is opt-in. The client will not send it unless
     * your server has the `textDocumentSync.willSaveWaitUntil` capability,
     * or you've dynamically registered for the `textDocument/willSaveWaitUntil`
     * method.
     *
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocumentWaitUntil(handler: RequestHandler<WillSaveTextDocumentParams, TextEdit$1[] | undefined | null, void>): Disposable$1;
    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidSaveTextDocument(handler: NotificationHandler<DidSaveTextDocumentParams>): Disposable$1;
    /**
     * Sends diagnostics computed for a given document to VSCode to render them in the
     * user interface.
     *
     * @param params The diagnostic parameters.
     */
    sendDiagnostics(params: PublishDiagnosticsParams): Promise<void>;
    /**
     * Installs a handler for the `Hover` request.
     *
     * @param handler The corresponding handler.
     */
    onHover(handler: ServerRequestHandler<HoverParams, Hover | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the `Completion` request.
     *
     * @param handler The corresponding handler.
     */
    onCompletion(handler: ServerRequestHandler<CompletionParams, CompletionItem[] | CompletionList | undefined | null, CompletionItem[], void>): Disposable$1;
    /**
     * Installs a handler for the `CompletionResolve` request.
     *
     * @param handler The corresponding handler.
     */
    onCompletionResolve(handler: RequestHandler<CompletionItem, CompletionItem, void>): Disposable$1;
    /**
     * Installs a handler for the `SignatureHelp` request.
     *
     * @param handler The corresponding handler.
     */
    onSignatureHelp(handler: ServerRequestHandler<SignatureHelpParams, SignatureHelp | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the `Declaration` request.
     *
     * @param handler The corresponding handler.
     */
    onDeclaration(handler: ServerRequestHandler<DeclarationParams, Declaration | DeclarationLink[] | undefined | null, Location[] | DeclarationLink[], void>): Disposable$1;
    /**
     * Installs a handler for the `Definition` request.
     *
     * @param handler The corresponding handler.
     */
    onDefinition(handler: ServerRequestHandler<DefinitionParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$1;
    /**
     * Installs a handler for the `Type Definition` request.
     *
     * @param handler The corresponding handler.
     */
    onTypeDefinition(handler: ServerRequestHandler<TypeDefinitionParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$1;
    /**
     * Installs a handler for the `Implementation` request.
     *
     * @param handler The corresponding handler.
     */
    onImplementation(handler: ServerRequestHandler<ImplementationParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$1;
    /**
     * Installs a handler for the `References` request.
     *
     * @param handler The corresponding handler.
     */
    onReferences(handler: ServerRequestHandler<ReferenceParams, Location[] | undefined | null, Location[], void>): Disposable$1;
    /**
     * Installs a handler for the `DocumentHighlight` request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentHighlight(handler: ServerRequestHandler<DocumentHighlightParams, DocumentHighlight[] | undefined | null, DocumentHighlight[], void>): Disposable$1;
    /**
     * Installs a handler for the `DocumentSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentSymbol(handler: ServerRequestHandler<DocumentSymbolParams, SymbolInformation[] | DocumentSymbol[] | undefined | null, SymbolInformation[] | DocumentSymbol[], void>): Disposable$1;
    /**
     * Installs a handler for the `WorkspaceSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onWorkspaceSymbol(handler: ServerRequestHandler<WorkspaceSymbolParams, SymbolInformation[] | WorkspaceSymbol[] | undefined | null, SymbolInformation[], void>): Disposable$1;
    /**
     * Installs a handler for the `WorkspaceSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onWorkspaceSymbolResolve(handler: RequestHandler<WorkspaceSymbol, WorkspaceSymbol, void>): Disposable$1;
    /**
     * Installs a handler for the `CodeAction` request.
     *
     * @param handler The corresponding handler.
     */
    onCodeAction(handler: ServerRequestHandler<CodeActionParams, (Command | CodeAction)[] | undefined | null, (Command | CodeAction)[], void>): Disposable$1;
    /**
     * Installs a handler for the `CodeAction` resolve request.
     *
     * @param handler The corresponding handler.
     */
    onCodeActionResolve(handler: RequestHandler<CodeAction, CodeAction, void>): Disposable$1;
    /**
     * Compute a list of {@link CodeLens lenses}. This call should return as fast as possible and if
     * computing the commands is expensive implementers should only return code lens objects with the
     * range set and handle the resolve request.
     *
     * @param handler The corresponding handler.
     */
    onCodeLens(handler: ServerRequestHandler<CodeLensParams, CodeLens[] | undefined | null, CodeLens[], void>): Disposable$1;
    /**
     * This function will be called for each visible code lens, usually when scrolling and after
     * the onCodeLens has been called.
     *
     * @param handler The corresponding handler.
     */
    onCodeLensResolve(handler: RequestHandler<CodeLens, CodeLens, void>): Disposable$1;
    /**
     * Installs a handler for the document formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentFormatting(handler: ServerRequestHandler<DocumentFormattingParams, TextEdit$1[] | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the document range formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentRangeFormatting(handler: ServerRequestHandler<DocumentRangeFormattingParams, TextEdit$1[] | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the document on type formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentOnTypeFormatting(handler: RequestHandler<DocumentOnTypeFormattingParams, TextEdit$1[] | undefined | null, void>): Disposable$1;
    /**
     * Installs a handler for the rename request.
     *
     * @param handler The corresponding handler.
     */
    onRenameRequest(handler: ServerRequestHandler<RenameParams, WorkspaceEdit | undefined | null, never, void>): Disposable$1;
    /**
     * Installs a handler for the prepare rename request.
     *
     * @param handler The corresponding handler.
     */
    onPrepareRename(handler: RequestHandler<PrepareRenameParams, Range$1 | {
        range: Range$1;
        placeholder: string;
    } | {
        defaultBehavior: boolean;
    } | undefined | null, void>): Disposable$1;
    /**
     * Installs a handler for the document links request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentLinks(handler: ServerRequestHandler<DocumentLinkParams, DocumentLink[] | undefined | null, DocumentLink[], void>): Disposable$1;
    /**
     * Installs a handler for the document links resolve request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentLinkResolve(handler: RequestHandler<DocumentLink, DocumentLink | undefined | null, void>): Disposable$1;
    /**
     * Installs a handler for the document color request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentColor(handler: ServerRequestHandler<DocumentColorParams, ColorInformation[] | undefined | null, ColorInformation[], void>): Disposable$1;
    /**
     * Installs a handler for the document color request.
     *
     * @param handler The corresponding handler.
     */
    onColorPresentation(handler: ServerRequestHandler<ColorPresentationParams, ColorPresentation[] | undefined | null, ColorPresentation[], void>): Disposable$1;
    /**
     * Installs a handler for the folding ranges request.
     *
     * @param handler The corresponding handler.
     */
    onFoldingRanges(handler: ServerRequestHandler<FoldingRangeParams, FoldingRange[] | undefined | null, FoldingRange[], void>): Disposable$1;
    /**
     * Installs a handler for the selection ranges request.
     *
     * @param handler The corresponding handler.
     */
    onSelectionRanges(handler: ServerRequestHandler<SelectionRangeParams, SelectionRange[] | undefined | null, SelectionRange[], void>): Disposable$1;
    /**
     * Installs a handler for the execute command request.
     *
     * @param handler The corresponding handler.
     */
    onExecuteCommand(handler: ServerRequestHandler<ExecuteCommandParams, any | undefined | null, never, void>): Disposable$1;
    /**
     * Disposes the connection
     */
    dispose(): void;
}
interface Connection extends _Connection {
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling call hierarchy requests.
 */
interface CallHierarchyProvider {
    prepareCallHierarchy(document: LangiumDocument, params: CallHierarchyPrepareParams, cancelToken?: CancellationToken): MaybePromise$1<CallHierarchyItem[] | undefined>;
    incomingCalls(params: CallHierarchyIncomingCallsParams, cancelToken?: CancellationToken): MaybePromise$1<CallHierarchyIncomingCall[] | undefined>;
    outgoingCalls(params: CallHierarchyOutgoingCallsParams, cancelToken?: CancellationToken): MaybePromise$1<CallHierarchyOutgoingCall[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface CodeActionProvider {
    /**
     * Handle a code action request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getCodeActions(document: LangiumDocument, params: CodeActionParams, cancelToken?: CancellationToken): MaybePromise$1<Array<Command | CodeAction> | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface CodeLensProvider {
    provideCodeLens(document: LangiumDocument, params: CodeLensParams, cancelToken?: CancellationToken): MaybePromise$1<CodeLens[] | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to declaration requests
 */
interface DeclarationProvider {
    /**
     * Handle a go to declaration request.
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDeclaration(document: LangiumDocument, params: DeclarationParams, cancelToken?: CancellationToken): MaybePromise$1<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to definition requests.
 */
interface DefinitionProvider {
    /**
     * Handle a go to definition request.
     *
     * @param document The document in which the request was triggered.
     * @param params The parameters of the request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A list of location links to the definition(s) of the symbol at the given position.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDefinition(document: LangiumDocument, params: DefinitionParams, cancelToken?: CancellationToken): MaybePromise$1<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document highlight requests.
 */
interface DocumentHighlightProvider {
    /**
     * Handle a document highlight request.
     *
     * @param document The document in which the request was received.
     * @param params The parameters of the document highlight request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns The document highlights or `undefined` if no highlights are available.
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDocumentHighlight(document: LangiumDocument, params: DocumentHighlightParams, cancelToken?: CancellationToken): MaybePromise$1<DocumentHighlight[] | undefined>;
}
declare class DefaultDocumentHighlightProvider implements DocumentHighlightProvider {
    protected readonly references: References;
    protected readonly nameProvider: NameProvider;
    protected readonly grammarConfig: GrammarConfig;
    constructor(services: LangiumServices);
    getDocumentHighlight(document: LangiumDocument, params: DocumentHighlightParams, _cancelToken?: CancellationToken): MaybePromise$1<DocumentHighlight[] | undefined>;
    /**
    * Override this method to determine the highlight kind of the given reference.
    */
    protected createDocumentHighlight(reference: ReferenceDescription): DocumentHighlight;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document link requests.
 */
interface DocumentLinkProvider {
    /**
     * Handle a document links request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDocumentLinks(document: LangiumDocument, params: DocumentLinkParams, cancelToken?: CancellationToken): MaybePromise$1<DocumentLink[]>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * This service consolidates the logic for gathering LSP kind information based on AST nodes or their descriptions.
 */
interface NodeKindProvider$1 {
    /**
     * Returns a `SymbolKind` as used by `WorkspaceSymbolProvider` or `DocumentSymbolProvider`.
     * @param node AST node or node description.
     * @returns The corresponding symbol kind.
     */
    getSymbolKind(node: AstNode | AstNodeDescription): SymbolKind;
    /**
     * Returns a `CompletionItemKind` as used by the `CompletionProvider`.
     * @param node AST node or node description.
     * @returns The corresponding completion item kind.
     */
    getCompletionItemKind(node: AstNode | AstNodeDescription): CompletionItemKind;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document symbols requests.
 */
interface DocumentSymbolProvider {
    /**
     * Handle a document symbols request.
     *
     * @param document The document in the workspace.
     * @param params The parameters of the request.
     * @param cancelToken A cancellation token that migh be used to cancel the request.
     * @returns The symbols for the given document.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getSymbols(document: LangiumDocument, params: DocumentSymbolParams, cancelToken?: CancellationToken): MaybePromise$1<DocumentSymbol[]>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling text document changes and watching relevant files.
 */
interface DocumentUpdateHandler {
    /**
     * A document open event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didOpenDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A content change event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didChangeContent?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A document save event (initiated) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    willSaveDocument?(event: TextDocumentWillSaveEvent<TextDocument>): void;
    /**
     * A document save event (initiated) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     * @returns An array of text edits which will be applied to the document before it is saved.
     */
    willSaveDocumentWaitUntil?(event: TextDocumentWillSaveEvent<TextDocument>): MaybePromise$1<TextEdit$1[]>;
    /**
     * A document save event (completed) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didSaveDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A document close event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didCloseDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * The client detected changes to files and folders watched by the language client.
     * @param params The files/folders change event.
     */
    didChangeWatchedFiles?(params: DidChangeWatchedFilesParams): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ExecuteCommandHandler {
    get commands(): string[];
    executeCommand(name: string, args: any[], cancelToken?: CancellationToken): Promise<unknown>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling file changes such as file creation, deletion and renaming.
 * The interface methods are optional, so they are only registered if they are implemented.
 */
interface FileOperationHandler {
    /**
     * These options are reported to the client as part of the ServerCapabilities.
     */
    readonly fileOperationOptions: FileOperationOptions;
    /**
     * Files were created from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didCreateFiles?(params: CreateFilesParams): void;
    /**
     * Files were renamed from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didRenameFiles?(params: RenameFilesParams): void;
    /**
     * Files were deleted from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didDeleteFiles?(params: DeleteFilesParams): void;
    /**
     * Called before files are actually created as long as the creation is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are created.
     */
    willCreateFiles?(params: CreateFilesParams): MaybePromise$1<WorkspaceEdit | null>;
    /**
     * Called before files are actually renamed as long as the rename is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are renamed.
     */
    willRenameFiles?(params: RenameFilesParams): MaybePromise$1<WorkspaceEdit | null>;
    /**
     * Called before files are actually deleted as long as the deletion is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are deleted.
     */
    willDeleteFiles?(params: DeleteFilesParams): MaybePromise$1<WorkspaceEdit | null>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling folding range requests.
 */
interface FoldingRangeProvider {
    /**
     * Handle a folding range request.
     *
     * @param document The document to compute folding ranges for
     * @param params The folding range parameters
     * @param cancelToken A cancellation token that can be used to cancel the request
     * @returns The computed folding ranges
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getFoldingRanges(document: LangiumDocument, params: FoldingRangeParams, cancelToken?: CancellationToken): MaybePromise$1<FoldingRange[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language specific service for handling formatting related LSP requests.
 */
interface Formatter {
    /**
     * Handles full document formatting.
     */
    formatDocument(document: LangiumDocument, params: DocumentFormattingParams, cancelToken?: CancellationToken): MaybePromise$1<TextEdit$1[]>;
    /**
     * Handles partial document formatting. Only parts of the document within the `params.range` property are formatted.
     */
    formatDocumentRange(document: LangiumDocument, params: DocumentRangeFormattingParams, cancelToken?: CancellationToken): MaybePromise$1<TextEdit$1[]>;
    /**
     * Handles document formatting while typing. Only formats the current line.
     */
    formatDocumentOnType(document: LangiumDocument, params: DocumentOnTypeFormattingParams, cancelToken?: CancellationToken): MaybePromise$1<TextEdit$1[]>;
    /**
     * Options that determine when the `formatDocumentOnType` method should be invoked by the language client.
     * When `undefined` is returned, document format on type will be disabled.
     */
    get formatOnTypeOptions(): DocumentOnTypeFormattingOptions | undefined;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * This service implements a [fuzzy matching](https://en.wikipedia.org/wiki/Approximate_string_matching) method.
 */
interface FuzzyMatcher {
    /**
     * Performs [fuzzy matching](https://en.wikipedia.org/wiki/Approximate_string_matching).
     *
     * Fuzzy matching improves search/completion user experience by allowing to omit characters.
     * For example, a query such as `FuMa` matches the text `FuzzyMatcher`.
     *
     * @param query The user input search query.
     * @param text The text that should be matched against the query.
     * @returns Whether the query matches the text.
     */
    match(query: string, text: string): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling hover requests.
 */
interface HoverProvider {
    /**
     * Handle a hover request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getHoverContent(document: LangiumDocument, params: HoverParams, cancelToken?: CancellationToken): MaybePromise$1<Hover | undefined>;
}
declare abstract class AstNodeHoverProvider implements HoverProvider {
    protected readonly references: References;
    protected readonly grammarConfig: GrammarConfig;
    constructor(services: LangiumServices);
    getHoverContent(document: LangiumDocument, params: HoverParams): MaybePromise$1<Hover | undefined>;
    protected abstract getAstNodeHoverContent(node: AstNode): MaybePromise$1<Hover | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to implementation requests.
 */
interface ImplementationProvider {
    /**
     * Handles a go to implementation request.
     */
    getImplementation(document: LangiumDocument, params: ImplementationParams, cancelToken?: CancellationToken): MaybePromise$1<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provider for the inlay hint LSP type.
 */
interface InlayHintProvider {
    /**
     * Handle the `textDocument.inlayHint` language server request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getInlayHints(document: LangiumDocument, params: InlayHintParams, cancelToken?: CancellationToken): MaybePromise$1<InlayHint[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface LanguageServer {
    initialize(params: InitializeParams): Promise<InitializeResult>;
    initialized(params: InitializedParams): void;
    onInitialize(callback: (params: InitializeParams) => void): Disposable$1;
    onInitialized(callback: (params: InitializedParams) => void): Disposable$1;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling find references requests.
 */
interface ReferencesProvider {
    /**
     * Handle a find references request.
     *
     * @param document The document in which to search for references.
     * @param params The parameters of the find references request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns The locations of the references.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    findReferences(document: LangiumDocument, params: ReferenceParams, cancelToken?: CancellationToken): MaybePromise$1<Location[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling rename requests and prepare rename requests.
 */
interface RenameProvider {
    /**
     * Handle a rename request.
     *
     * @param document The document in which the rename request was triggered.
     * @param params The rename parameters.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A workspace edit that describes the changes to be applied to the workspace.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    rename(document: LangiumDocument, params: RenameParams, cancelToken?: CancellationToken): MaybePromise$1<WorkspaceEdit | undefined>;
    /**
     * Handle a prepare rename request.
     *
     * @param document The document in which the prepare rename request was triggered.
     * @param params The prepare rename parameters.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A range that describes the range of the symbol to be renamed.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    prepareRename(document: LangiumDocument, params: TextDocumentPositionParams, cancelToken?: CancellationToken): MaybePromise$1<Range$1 | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface SemanticTokenProvider {
    semanticHighlight(document: LangiumDocument, params: SemanticTokensParams, cancelToken?: CancellationToken): MaybePromise$1<SemanticTokens>;
    semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken?: CancellationToken): MaybePromise$1<SemanticTokens>;
    semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken?: CancellationToken): MaybePromise$1<SemanticTokens | SemanticTokensDelta>;
    readonly tokenTypes: Record<string, number>;
    readonly tokenModifiers: Record<string, number>;
    readonly semanticTokensOptions: SemanticTokensOptions;
}
type SemanticTokenAcceptorOptions<N extends AstNode = AstNode> = ({
    line: number;
    char: number;
    length: number;
} | {
    node: N;
    property: Properties<N>;
    index?: number;
} | {
    node: N;
    keyword: string;
    index?: number;
} | {
    cst: CstNode;
} | {
    range: Range$1;
}) & {
    type: string;
    modifier?: string | string[];
};
interface SemanticTokenPropertyOptions<T extends AstNode> {
    node: T;
    property: Properties<T>;
    index?: number;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenKeywordOptions {
    node: AstNode;
    keyword: string;
    index?: number;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenNodeOptions {
    node: CstNode;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenRangeOptions {
    range: Range$1;
    type: string;
    modifier?: string | string[];
}
declare class SemanticTokensBuilder extends SemanticTokensBuilder$1 {
    private _tokens;
    push(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void;
    build(): SemanticTokens;
    buildEdits(): SemanticTokens | SemanticTokensDelta;
    /**
     * Flushes the cached delta token values
     */
    flush(): void;
    private applyTokens;
    private compareTokens;
}
type SemanticTokenAcceptor = <N extends AstNode = AstNode>(options: SemanticTokenAcceptorOptions<N>) => void;
/**
 * A basic super class for providing semantic token data.
 * Users of Langium should extend this class to create their own `SemanticTokenProvider`.
 *
 * The entry method for generating semantic tokens based on an `AstNode` is the `highlightElement` method.
 */
declare abstract class AbstractSemanticTokenProvider implements SemanticTokenProvider {
    /**
     * Store a token builder for each open document.
     */
    protected tokensBuilders: Map<string, SemanticTokensBuilder>;
    protected currentDocument?: LangiumDocument;
    protected currentTokensBuilder?: SemanticTokensBuilder;
    protected currentRange?: Range$1;
    protected clientCapabilities?: SemanticTokensClientCapabilities;
    constructor(services: LangiumServices);
    initialize(clientCapabilities?: SemanticTokensClientCapabilities): void;
    get tokenTypes(): Record<string, number>;
    get tokenModifiers(): Record<string, number>;
    get semanticTokensOptions(): SemanticTokensOptions;
    semanticHighlight(document: LangiumDocument, _params: SemanticTokensParams, cancelToken?: CancellationToken): Promise<SemanticTokens>;
    semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken?: CancellationToken): Promise<SemanticTokens>;
    semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken?: CancellationToken): Promise<SemanticTokens | SemanticTokensDelta>;
    protected createAcceptor(): SemanticTokenAcceptor;
    protected getDocumentTokensBuilder(document: LangiumDocument): SemanticTokensBuilder;
    protected computeHighlighting(document: LangiumDocument, acceptor: SemanticTokenAcceptor, cancelToken: CancellationToken): Promise<void>;
    /**
     * @return `'prune'` to skip the children of this element, nothing otherwise.
     */
    protected abstract highlightElement(node: AstNode, acceptor: SemanticTokenAcceptor): void | undefined | 'prune';
    protected highlightToken(options: SemanticTokenRangeOptions): void;
    protected highlightProperty<N extends AstNode>(options: SemanticTokenPropertyOptions<N>): void;
    protected highlightKeyword(options: SemanticTokenKeywordOptions): void;
    protected highlightNode(options: SemanticTokenNodeOptions): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling signature help requests.
 */
interface SignatureHelpProvider {
    /**
     * Handles a signature help request
     */
    provideSignatureHelp(document: LangiumDocument, params: SignatureHelpParams, cancelToken?: CancellationToken): MaybePromise$1<SignatureHelp | undefined>;
    /**
     * Options that determine the server capabilities for a signature help request. It contains the list of triggering characters.
     */
    get signatureHelpOptions(): SignatureHelpOptions;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling type hierarchy requests.
 */
interface TypeHierarchyProvider {
    prepareTypeHierarchy(document: LangiumDocument, params: TypeHierarchyPrepareParams, cancelToken?: CancellationToken): MaybePromise$1<TypeHierarchyItem[] | undefined>;
    supertypes(params: TypeHierarchySupertypesParams, cancelToken?: CancellationToken): MaybePromise$1<TypeHierarchyItem[] | undefined>;
    subtypes(params: TypeHierarchySubtypesParams, cancelToken?: CancellationToken): MaybePromise$1<TypeHierarchyItem[] | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to type requests.
 */
interface TypeDefinitionProvider {
    /**
     * Handles a go to type definition request.
     */
    getTypeDefinition(document: LangiumDocument, params: TypeDefinitionParams, cancelToken?: CancellationToken): MaybePromise$1<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling workspace symbols requests.
 */
interface WorkspaceSymbolProvider$1 {
    /**
     * Handle a workspace symbols request.
     *
     * @param params workspaces symbols request parameters
     * @param cancelToken a cancellation token tha can be used to cancel the request
     * @returns a list of workspace symbols
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getSymbols(params: WorkspaceSymbolParams, cancelToken?: CancellationToken): MaybePromise$1<WorkspaceSymbol[]>;
    /**
     * Handle a resolve request for a workspace symbol.
     *
     * @param symbol the workspace symbol to resolve
     * @param cancelToken a cancellation token tha can be used to cancel the request
     * @returns the resolved workspace symbol
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    resolveSymbol?(symbol: WorkspaceSymbol, cancelToken?: CancellationToken): MaybePromise$1<WorkspaceSymbol>;
}
declare class DefaultWorkspaceSymbolProvider implements WorkspaceSymbolProvider$1 {
    protected readonly indexManager: IndexManager$1;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    protected readonly fuzzyMatcher: FuzzyMatcher;
    constructor(services: LangiumSharedServices);
    getSymbols(params: WorkspaceSymbolParams, cancelToken?: CancellationToken): Promise<WorkspaceSymbol[]>;
    protected getWorkspaceSymbol(astDescription: AstNodeDescription): WorkspaceSymbol | undefined;
}

/******************************************************************************
 * Copyright 2024 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type TextDocumentConnection = Pick<Connection, 'onDidOpenTextDocument' | 'onDidChangeTextDocument' | 'onDidCloseTextDocument' | 'onWillSaveTextDocument' | 'onWillSaveTextDocumentWaitUntil' | 'onDidSaveTextDocument'>;
/**
 * A manager service that keeps track of all currently opened text documents.
 *
 * Designed to be compatible with the `TextDocuments` class in the `vscode-languageserver` package.
 */
interface TextDocuments<T extends {
    uri: string;
}> {
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    readonly onDidOpen: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    readonly onDidChangeContent: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    readonly onWillSave: Event<TextDocumentWillSaveEvent<T>>;
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler: RequestHandler<TextDocumentWillSaveEvent<T>, TextEdit$1[], void>): void;
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    readonly onDidSave: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    readonly onDidClose: Event<TextDocumentChangeEvent<T>>;
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not managed by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri: string | URI): T | undefined;
    /**
     * Sets the text document managed by this instance.
     * @param document The text document to add.
     * @returns `true` if the document didn't exist yet, `false` if it was already present.
     */
    set(document: T): boolean;
    /**
     * Deletes a text document managed by this instance.
     */
    delete(uri: string | URI | T): void;
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all(): T[];
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys(): string[];
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
     *
     * Use the corresponding events on the TextDocuments instance instead.
     *
     * @param connection The connection to listen on.
     */
    listen(connection: TextDocumentConnection): Disposable$1;
}
interface NotebookDocuments<T extends {
    uri: string;
}> {
    get cellTextDocuments(): TextDocuments<T>;
    getCellTextDocument(cell: NotebookCell): T | undefined;
    getNotebookDocument(uri: string | URI): NotebookDocument | undefined;
    getNotebookCell(uri: string | URI): NotebookCell | undefined;
    findNotebookDocumentForCell(cell: string | URI | NotebookCell): NotebookDocument | undefined;
    get onDidOpen(): Event<NotebookDocument>;
    get onDidSave(): Event<NotebookDocument>;
    get onDidChange(): Event<NotebookDocumentChangeEvent>;
    get onDidClose(): Event<NotebookDocument>;
    /**
     * Listens for `low level` notification on the given connection to
     * update the notebook documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
     *  and `onDidCloseNotebookDocument`.
     *
     * @param connection The connection to listen on.
     */
    listen(connection: Connection): Disposable$1;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Combined Core + LSP services of Langium (total services)
 */
type LangiumServices = LangiumCoreServices & LangiumLSPServices;
/**
 * Combined Core + LSP shared services of Langium (total services)
 */
type LangiumSharedServices = LangiumSharedCoreServices & LangiumSharedLSPServices;
/**
 * LSP services for a specific language of which Langium provides default implementations.
 */
type LangiumLSPServices = {
    readonly lsp: {
        readonly CompletionProvider?: CompletionProvider;
        readonly DocumentHighlightProvider?: DocumentHighlightProvider;
        readonly DocumentSymbolProvider?: DocumentSymbolProvider;
        readonly HoverProvider?: HoverProvider;
        readonly FoldingRangeProvider?: FoldingRangeProvider;
        readonly DefinitionProvider?: DefinitionProvider;
        readonly TypeProvider?: TypeDefinitionProvider;
        readonly ImplementationProvider?: ImplementationProvider;
        readonly ReferencesProvider?: ReferencesProvider;
        readonly CodeActionProvider?: CodeActionProvider;
        readonly SemanticTokenProvider?: SemanticTokenProvider;
        readonly RenameProvider?: RenameProvider;
        readonly Formatter?: Formatter;
        readonly SignatureHelp?: SignatureHelpProvider;
        readonly CallHierarchyProvider?: CallHierarchyProvider;
        readonly TypeHierarchyProvider?: TypeHierarchyProvider;
        readonly DeclarationProvider?: DeclarationProvider;
        readonly InlayHintProvider?: InlayHintProvider;
        readonly CodeLensProvider?: CodeLensProvider;
        readonly DocumentLinkProvider?: DocumentLinkProvider;
    };
    readonly shared: LangiumSharedServices;
};
/**
 * LSP services shared between multiple languages of which Langium provides default implementations.
 */
type LangiumSharedLSPServices = {
    readonly lsp: {
        readonly Connection?: Connection;
        readonly DocumentUpdateHandler: DocumentUpdateHandler;
        readonly ExecuteCommandHandler?: ExecuteCommandHandler;
        readonly FileOperationHandler?: FileOperationHandler;
        readonly FuzzyMatcher: FuzzyMatcher;
        readonly LanguageServer: LanguageServer;
        readonly NodeKindProvider: NodeKindProvider$1;
        readonly WorkspaceSymbolProvider?: WorkspaceSymbolProvider$1;
    };
    readonly workspace: {
        readonly TextDocuments: TextDocuments<TextDocument>;
        readonly NotebookDocuments: NotebookDocuments<TextDocument>;
    };
};

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface NextFeature<T extends AbstractElement = AbstractElement> {
    /**
     * A feature that could appear during completion.
     */
    feature: T;
    /**
     * The type that carries this `feature`. Only set if we encounter a new type.
     */
    type?: string;
    /**
     * The container property for the new `type`
     */
    property?: string;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type CompletionAcceptor = (context: CompletionContext, value: CompletionValueItem) => void;
type CompletionValueItem = ({
    label?: string;
} | {
    node: AstNode;
} | {
    nodeDescription: AstNodeDescription;
}) & Partial<CompletionItem>;
interface CompletionContext {
    node?: AstNode;
    document: LangiumDocument;
    textDocument: TextDocument;
    features: NextFeature[];
    /**
     * Index at the start of the token related to this context.
     * If the context performs completion for a token that doesn't exist yet, it is equal to the `offset`.
     */
    tokenOffset: number;
    /**
     * Index at the end of the token related to this context, even if it is behind the cursor position.
     * Points at the first character after the last token.
     * If the context performs completion for a token that doesn't exist yet, it is equal to the `offset`.
     */
    tokenEndOffset: number;
    /**
     * Index of the requested completed position.
     */
    offset: number;
    position: Position$1;
}
interface CompletionProviderOptions$1 {
    /**
     * Most tools trigger completion request automatically without explicitly requesting
     * it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
     * starts to type an identifier. For example if the user types `c` in a JavaScript file
     * code complete will automatically pop up present `console` besides others as a
     * completion item. Characters that make up identifiers don't need to be listed here.
     *
     * If code complete should automatically be trigger on characters not being valid inside
     * an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
     */
    triggerCharacters?: string[];
    /**
     * The list of all possible characters that commit a completion. This field can be used
     * if clients don't support individual commit characters per completion item.
     *
     * If a server provides both `allCommitCharacters` and commit characters on an individual
     * completion item the ones on the completion item win.
     */
    allCommitCharacters?: string[];
}
interface CompletionBacktrackingInformation {
    previousTokenStart?: number;
    previousTokenEnd?: number;
    nextTokenStart: number;
    nextTokenEnd: number;
}
/**
 * Language-specific service for handling completion requests.
 */
interface CompletionProvider {
    /**
     * Handle a completion request.
     *
     * @param document - the document for which the completion request was triggered
     * @param params - the completion parameters
     * @param cancelToken - a token that can be used to cancel the request
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getCompletion(document: LangiumDocument, params: CompletionParams, cancelToken?: CancellationToken): MaybePromise$1<CompletionList | undefined>;
    /**
     * Contains the completion options for this completion provider.
     *
     * If multiple languages return different options, they are merged before being sent to the language client.
     */
    readonly completionOptions?: CompletionProviderOptions$1;
}
declare class DefaultCompletionProvider implements CompletionProvider {
    protected readonly completionParser: LangiumCompletionParser;
    protected readonly documentationProvider: DocumentationProvider;
    protected readonly scopeProvider: ScopeProvider;
    protected readonly grammar: Grammar;
    protected readonly nameProvider: NameProvider;
    protected readonly lexer: Lexer;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    protected readonly fuzzyMatcher: FuzzyMatcher;
    protected readonly grammarConfig: GrammarConfig;
    protected readonly astReflection: AstReflection;
    readonly completionOptions?: CompletionProviderOptions$1;
    constructor(services: LangiumServices);
    getCompletion(document: LangiumDocument, params: CompletionParams, _cancelToken?: CancellationToken): Promise<CompletionList | undefined>;
    /**
     * The completion algorithm could yield the same reference/keyword multiple times.
     *
     * This methods deduplicates these items afterwards before returning to the client.
     * Unique items are identified as a combination of `kind`, `label` and `detail`.
     */
    protected deduplicateItems(items: CompletionItem[]): CompletionItem[];
    protected findFeaturesAt(document: TextDocument, offset: number): NextFeature[];
    protected buildContexts(document: LangiumDocument, position: Position$1): IterableIterator<CompletionContext>;
    protected performNextTokenCompletion(document: LangiumDocument, text: string, _offset: number, _end: number): boolean;
    protected findDataTypeRuleStart(cst: CstNode, offset: number): [number, number] | undefined;
    /**
     * Indicates whether the completion should continue to process the next completion context.
     *
     * The default implementation continues the completion only if there are currently no proposed completion items.
     */
    protected continueCompletion(items: CompletionItem[]): boolean;
    /**
     * This method returns two sets of token offset information.
     *
     * The `nextToken*` offsets are related to the token at the cursor position.
     * If there is none, both offsets are simply set to `offset`.
     *
     * The `previousToken*` offsets are related to the last token before the current token at the cursor position.
     * They are `undefined`, if there is no token before the cursor position.
     */
    protected backtrackToAnyToken(text: string, offset: number): CompletionBacktrackingInformation;
    protected completionFor(context: CompletionContext, next: NextFeature, acceptor: CompletionAcceptor): MaybePromise$1<void>;
    protected completionForCrossReference(context: CompletionContext, next: NextFeature<CrossReference>, acceptor: CompletionAcceptor): MaybePromise$1<void>;
    /**
     * Override this method to change how the stream of candidates is determined for a reference.
     * This way completion-specific modifications and refinements can be added to the proposals computation
     *  beyond the rules being implemented in the scope provider, e.g. filtering.
     *
     * @param refInfo Information about the reference for which the candidates are requested.
     * @param _context Information about the completion request including document, cursor position, token under cursor, etc.
     * @returns A stream of all elements being valid for the given reference.
     */
    protected getReferenceCandidates(refInfo: ReferenceInfo, _context: CompletionContext): Stream<AstNodeDescription>;
    /**
     * Override this method to change how reference completion items are created.
     *
     * To change the `kind` of a completion item, override the `NodeKindProvider` service instead.
     * To change the `documentation`, override the `DocumentationProvider` service instead.
     *
     * @param nodeDescription The description of a reference candidate
     * @returns A partial completion item
     */
    protected createReferenceCompletionItem(nodeDescription: AstNodeDescription): CompletionValueItem;
    protected getReferenceDocumentation(nodeDescription: AstNodeDescription): MarkupContent | string | undefined;
    protected completionForKeyword(context: CompletionContext, keyword: Keyword, acceptor: CompletionAcceptor): MaybePromise$1<void>;
    protected getKeywordCompletionItemKind(_keyword: Keyword): CompletionItemKind;
    protected filterKeyword(context: CompletionContext, keyword: Keyword): boolean;
    protected fillCompletionItem(context: CompletionContext, item: CompletionValueItem): CompletionItem | undefined;
    protected buildCompletionTextEdit(context: CompletionContext, label: string, newText: string): TextEdit$1 | undefined;
}

declare class LikeC4DocumentationProvider implements DocumentationProvider {
    private parser;
    private locator;
    constructor(services: LikeC4Services);
    getDocumentation(node: AstNode): string | undefined;
}

/**
 * Fallback type.
 */
type Fallback<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>>> = MaybeReadonly<InferOutput<TSchema>> | ((dataset?: OutputDataset<InferOutput<TSchema>, InferIssue<TSchema>>, config?: Config<InferIssue<TSchema>>) => MaybeReadonly<InferOutput<TSchema>>);
/**
 * Schema with fallback type.
 */
type SchemaWithFallback<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TFallback extends Fallback<TSchema>> = TSchema & {
    /**
     * The fallback value.
     */
    readonly fallback: TFallback;
};

/**
 * Fallback async type.
 */
type FallbackAsync<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>> = MaybeReadonly<InferOutput<TSchema>> | ((dataset?: OutputDataset<InferOutput<TSchema>, InferIssue<TSchema>>, config?: Config<InferIssue<TSchema>>) => MaybePromise<MaybeReadonly<InferOutput<TSchema>>>);
/**
 * Schema with fallback async type.
 */
type SchemaWithFallbackAsync<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TFallback extends FallbackAsync<TSchema>> = Omit<TSchema, 'async' | '~standard' | '~run'> & {
    /**
     * The fallback value.
     */
    readonly fallback: TFallback;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * The Standard Schema properties.
     *
     * @internal
     */
    readonly '~standard': StandardProps<InferInput<TSchema>, InferOutput<TSchema>>;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<InferOutput<TSchema>, InferIssue<TSchema>>>;
};

/**
 * Schema with pipe type.
 */
type SchemaWithPipe<TPipe extends readonly [
    BaseSchema<unknown, unknown, BaseIssue<unknown>>,
    ...PipeItem<any, unknown, BaseIssue<unknown>>[]
]> = Omit<FirstTupleItem<TPipe>, '~standard' | '~run' | '~types'> & {
    /**
     * The pipe items.
     */
    readonly pipe: TPipe;
    /**
     * The Standard Schema properties.
     *
     * @internal
     */
    readonly '~standard': StandardProps<InferInput<FirstTupleItem<TPipe>>, InferOutput<LastTupleItem<TPipe>>>;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => OutputDataset<InferOutput<LastTupleItem<TPipe>>, InferIssue<TPipe[number]>>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: InferInput<FirstTupleItem<TPipe>>;
        readonly output: InferOutput<LastTupleItem<TPipe>>;
        readonly issue: InferIssue<TPipe[number]>;
    } | undefined;
};

/**
 * Schema with pipe async type.
 */
type SchemaWithPipeAsync<TPipe extends readonly [
    (BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>),
    ...(PipeItem<any, unknown, BaseIssue<unknown>> | PipeItemAsync<any, unknown, BaseIssue<unknown>>)[]
]> = Omit<FirstTupleItem<TPipe>, 'async' | '~standard' | '~run' | '~types'> & {
    /**
     * The pipe items.
     */
    readonly pipe: TPipe;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * The Standard Schema properties.
     *
     * @internal
     */
    readonly '~standard': StandardProps<InferInput<FirstTupleItem<TPipe>>, InferOutput<LastTupleItem<TPipe>>>;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<InferOutput<LastTupleItem<TPipe>>, InferIssue<TPipe[number]>>>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: InferInput<FirstTupleItem<TPipe>>;
        readonly output: InferOutput<LastTupleItem<TPipe>>;
        readonly issue: InferIssue<TPipe[number]>;
    } | undefined;
};

/**
 * Base metadata interface.
 */
interface BaseMetadata<TInput> {
    /**
     * The object kind.
     */
    readonly kind: 'metadata';
    /**
     * The metadata type.
     */
    readonly type: string;
    /**
     * The metadata reference.
     */
    readonly reference: (...args: any[]) => BaseMetadata<any>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: TInput;
        readonly output: TInput;
        readonly issue: never;
    } | undefined;
}

/**
 * Unknown dataset interface.
 */
interface UnknownDataset {
    /**
     * Whether is's typed.
     */
    typed?: false;
    /**
     * The dataset value.
     */
    value: unknown;
    /**
     * The dataset issues.
     */
    issues?: undefined;
}
/**
 * Success dataset interface.
 */
interface SuccessDataset<TValue> {
    /**
     * Whether is's typed.
     */
    typed: true;
    /**
     * The dataset value.
     */
    value: TValue;
    /**
     * The dataset issues.
     */
    issues?: undefined;
}
/**
 * Partial dataset interface.
 */
interface PartialDataset<TValue, TIssue extends BaseIssue<unknown>> {
    /**
     * Whether is's typed.
     */
    typed: true;
    /**
     * The dataset value.
     */
    value: TValue;
    /**
     * The dataset issues.
     */
    issues: [TIssue, ...TIssue[]];
}
/**
 * Failure dataset interface.
 */
interface FailureDataset<TIssue extends BaseIssue<unknown>> {
    /**
     * Whether is's typed.
     */
    typed: false;
    /**
     * The dataset value.
     */
    value: unknown;
    /**
     * The dataset issues.
     */
    issues: [TIssue, ...TIssue[]];
}
/**
 * Output dataset type.
 */
type OutputDataset<TValue, TIssue extends BaseIssue<unknown>> = SuccessDataset<TValue> | PartialDataset<TValue, TIssue> | FailureDataset<TIssue>;

/**
 * The Standard Schema properties interface.
 */
interface StandardProps<TInput, TOutput> {
    /**
     * The version number of the standard.
     */
    readonly version: 1;
    /**
     * The vendor name of the schema library.
     */
    readonly vendor: 'valibot';
    /**
     * Validates unknown input values.
     */
    readonly validate: (value: unknown) => StandardResult<TOutput> | Promise<StandardResult<TOutput>>;
    /**
     * Inferred types associated with the schema.
     */
    readonly types?: StandardTypes<TInput, TOutput> | undefined;
}
/**
 * The result interface of the validate function.
 */
type StandardResult<TOutput> = StandardSuccessResult<TOutput> | StandardFailureResult;
/**
 * The result interface if validation succeeds.
 */
interface StandardSuccessResult<TOutput> {
    /**
     * The typed output value.
     */
    readonly value: TOutput;
    /**
     * The non-existent issues.
     */
    readonly issues?: undefined;
}
/**
 * The result interface if validation fails.
 */
interface StandardFailureResult {
    /**
     * The issues of failed validation.
     */
    readonly issues: readonly StandardIssue[];
}
/**
 * The issue interface of the failure output.
 */
interface StandardIssue {
    /**
     * The error message of the issue.
     */
    readonly message: string;
    /**
     * The path of the issue, if any.
     */
    readonly path?: readonly (PropertyKey | StandardPathItem)[] | undefined;
}
/**
 * The path item interface of the issue.
 */
interface StandardPathItem {
    /**
     * The key of the path item.
     */
    readonly key: PropertyKey;
}
/**
 * The Standard Schema types interface.
 */
interface StandardTypes<TInput, TOutput> {
    /**
     * The input type of the schema.
     */
    readonly input: TInput;
    /**
     * The output type of the schema.
     */
    readonly output: TOutput;
}

/**
 * Base schema interface.
 */
interface BaseSchema<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'schema';
    /**
     * The schema type.
     */
    readonly type: string;
    /**
     * The schema reference.
     */
    readonly reference: (...args: any[]) => BaseSchema<unknown, unknown, BaseIssue<unknown>>;
    /**
     * The expected property.
     */
    readonly expects: string;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * The Standard Schema properties.
     *
     * @internal
     */
    readonly '~standard': StandardProps<TInput, TOutput>;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => OutputDataset<TOutput, TIssue>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    } | undefined;
}
/**
 * Base schema async interface.
 */
interface BaseSchemaAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseSchema<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'> {
    /**
     * The schema reference.
     */
    readonly reference: (...args: any[]) => BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<TOutput, TIssue>>;
}

/**
 * Base transformation interface.
 */
interface BaseTransformation<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'transformation';
    /**
     * The transformation type.
     */
    readonly type: string;
    /**
     * The transformation reference.
     */
    readonly reference: (...args: any[]) => BaseTransformation<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * Transforms known input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: SuccessDataset<TInput>, config: Config<BaseIssue<unknown>>) => OutputDataset<TOutput, BaseIssue<unknown> | TIssue>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    } | undefined;
}
/**
 * Base transformation async interface.
 */
interface BaseTransformationAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseTransformation<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'> {
    /**
     * The transformation reference.
     */
    readonly reference: (...args: any[]) => BaseTransformation<any, any, BaseIssue<unknown>> | BaseTransformationAsync<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Transforms known input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: SuccessDataset<TInput>, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<TOutput, BaseIssue<unknown> | TIssue>>;
}

/**
 * Base validation interface.
 */
interface BaseValidation<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'validation';
    /**
     * The validation type.
     */
    readonly type: string;
    /**
     * The validation reference.
     */
    readonly reference: (...args: any[]) => BaseValidation<any, any, BaseIssue<unknown>>;
    /**
     * The expected property.
     */
    readonly expects: string | null;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * Validates known input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: OutputDataset<TInput, BaseIssue<unknown>>, config: Config<BaseIssue<unknown>>) => OutputDataset<TOutput, BaseIssue<unknown> | TIssue>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    } | undefined;
}
/**
 * Base validation async interface.
 */
interface BaseValidationAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseValidation<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'> {
    /**
     * The validation reference.
     */
    readonly reference: (...args: any[]) => BaseValidation<any, any, BaseIssue<unknown>> | BaseValidationAsync<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Validates known input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: OutputDataset<TInput, BaseIssue<unknown>>, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<TOutput, BaseIssue<unknown> | TIssue>>;
}

/**
 * Infer input type.
 */
type InferInput<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['~types']>['input'];
/**
 * Infer output type.
 */
type InferOutput<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['~types']>['output'];
/**
 * Infer issue type.
 */
type InferIssue<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['~types']>['issue'];
/**
 * Constructs a type that is maybe readonly.
 */
type MaybeReadonly<TValue> = TValue | Readonly<TValue>;
/**
 * Constructs a type that is maybe a promise.
 */
type MaybePromise<TValue> = TValue | Promise<TValue>;
/**
 * Prettifies a type for better readability.
 *
 * Hint: This type has no effect and is only used so that TypeScript displays
 * the final type in the preview instead of the utility types used.
 */
type Prettify<TObject> = {
    [TKey in keyof TObject]: TObject[TKey];
} & {};
/**
 * Marks specific keys as optional.
 */
type MarkOptional<TObject, TKeys extends keyof TObject> = Partial<TObject> & Required<Omit<TObject, TKeys>>;
/**
 * Extracts first tuple item.
 *
 */
type FirstTupleItem<TTuple extends readonly [unknown, ...unknown[]]> = TTuple[0];
/**
 * Extracts last tuple item.
 *
 */
type LastTupleItem<TTuple extends readonly [unknown, ...unknown[]]> = TTuple[TTuple extends readonly [unknown, ...infer TRest] ? TRest['length'] : never];

/**
 * Error message type.
 */
type ErrorMessage<TIssue extends BaseIssue<unknown>> = ((issue: TIssue) => string) | string;
/**
 * Default type.
 */
type Default<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TInput extends null | undefined> = MaybeReadonly<InferInput<TWrapped> | TInput> | ((dataset?: UnknownDataset, config?: Config<InferIssue<TWrapped>>) => MaybeReadonly<InferInput<TWrapped> | TInput>) | undefined;
/**
 * Default async type.
 */
type DefaultAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TInput extends null | undefined> = MaybeReadonly<InferInput<TWrapped> | TInput> | ((dataset?: UnknownDataset, config?: Config<InferIssue<TWrapped>>) => MaybePromise<MaybeReadonly<InferInput<TWrapped> | TInput>>) | undefined;
/**
 * Default value type.
 */
type DefaultValue<TDefault extends Default<BaseSchema<unknown, unknown, BaseIssue<unknown>>, null | undefined> | DefaultAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, null | undefined>> = TDefault extends DefaultAsync<infer TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, infer TInput> ? TDefault extends (dataset?: UnknownDataset, config?: Config<InferIssue<TWrapped>>) => MaybePromise<InferInput<TWrapped> | TInput> ? Awaited<ReturnType<TDefault>> : TDefault : never;

/**
 * Optional entry schema type.
 */
type OptionalEntrySchema = ExactOptionalSchema<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | NullishSchema<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalSchema<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown>;
/**
 * Optional entry schema async type.
 */
type OptionalEntrySchemaAsync = ExactOptionalSchemaAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown> | NullishSchemaAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalSchemaAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown>;
/**
 * Object entries interface.
 */
interface ObjectEntries {
    [key: string]: BaseSchema<unknown, unknown, BaseIssue<unknown>> | SchemaWithFallback<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalEntrySchema;
}
/**
 * Object entries async interface.
 */
interface ObjectEntriesAsync {
    [key: string]: BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | SchemaWithFallback<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | SchemaWithFallbackAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalEntrySchema | OptionalEntrySchemaAsync;
}
/**
 * Infer entries input type.
 */
type InferEntriesInput<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    -readonly [TKey in keyof TEntries]: InferInput<TEntries[TKey]>;
};
/**
 * Infer entries output type.
 */
type InferEntriesOutput<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    -readonly [TKey in keyof TEntries]: InferOutput<TEntries[TKey]>;
};
/**
 * Optional input keys type.
 */
type OptionalInputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends OptionalEntrySchema | OptionalEntrySchemaAsync ? TKey : never;
}[keyof TEntries];
/**
 * Optional output keys type.
 */
type OptionalOutputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends OptionalEntrySchema | OptionalEntrySchemaAsync ? undefined extends TEntries[TKey]['default'] ? TKey : never : never;
}[keyof TEntries];
/**
 * Input with question marks type.
 */
type InputWithQuestionMarks<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends InferEntriesInput<TEntries>> = MarkOptional<TObject, OptionalInputKeys<TEntries>>;
/**
 * Output with question marks type.
 */
type OutputWithQuestionMarks<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends InferEntriesOutput<TEntries>> = MarkOptional<TObject, OptionalOutputKeys<TEntries>>;
/**
 * Readonly output keys type.
 */
type ReadonlyOutputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends SchemaWithPipe<infer TPipe> | SchemaWithPipeAsync<infer TPipe> ? ReadonlyAction<any> extends TPipe[number] ? TKey : never : never;
}[keyof TEntries];
/**
 * Output with readonly type.
 */
type OutputWithReadonly<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends OutputWithQuestionMarks<TEntries, InferEntriesOutput<TEntries>>> = Readonly<TObject> & Pick<TObject, Exclude<keyof TObject, ReadonlyOutputKeys<TEntries>>>;
/**
 * Infer object input type.
 */
type InferObjectInput<TEntries extends ObjectEntries | ObjectEntriesAsync> = Prettify<InputWithQuestionMarks<TEntries, InferEntriesInput<TEntries>>>;
/**
 * Infer object output type.
 */
type InferObjectOutput<TEntries extends ObjectEntries | ObjectEntriesAsync> = Prettify<OutputWithReadonly<TEntries, OutputWithQuestionMarks<TEntries, InferEntriesOutput<TEntries>>>>;
/**
 * Infer object issue type.
 */
type InferObjectIssue<TEntries extends ObjectEntries | ObjectEntriesAsync> = InferIssue<TEntries[keyof TEntries]>;

/**
 * Array path item interface.
 */
interface ArrayPathItem {
    /**
     * The path item type.
     */
    readonly type: 'array';
    /**
     * The path item origin.
     */
    readonly origin: 'value';
    /**
     * The path item input.
     */
    readonly input: MaybeReadonly<unknown[]>;
    /**
     * The path item key.
     */
    readonly key: number;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Map path item interface.
 */
interface MapPathItem {
    /**
     * The path item type.
     */
    readonly type: 'map';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: Map<unknown, unknown>;
    /**
     * The path item key.
     */
    readonly key: unknown;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Object path item interface.
 */
interface ObjectPathItem {
    /**
     * The path item type.
     */
    readonly type: 'object';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: Record<string, unknown>;
    /**
     * The path item key.
     */
    readonly key: string;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Set path item interface.
 */
interface SetPathItem {
    /**
     * The path item type.
     */
    readonly type: 'set';
    /**
     * The path item origin.
     */
    readonly origin: 'value';
    /**
     * The path item input.
     */
    readonly input: Set<unknown>;
    /**
     * The path item key.
     */
    readonly key: null;
    /**
     * The path item key.
     */
    readonly value: unknown;
}
/**
 * Unknown path item interface.
 */
interface UnknownPathItem {
    /**
     * The path item type.
     */
    readonly type: 'unknown';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: unknown;
    /**
     * The path item key.
     */
    readonly key: unknown;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Issue path item type.
 */
type IssuePathItem = ArrayPathItem | MapPathItem | ObjectPathItem | SetPathItem | UnknownPathItem;
/**
 * Base issue interface.
 */
interface BaseIssue<TInput> extends Config<BaseIssue<TInput>> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema' | 'validation' | 'transformation';
    /**
     * The issue type.
     */
    readonly type: string;
    /**
     * The raw input data.
     */
    readonly input: TInput;
    /**
     * The expected property.
     */
    readonly expected: string | null;
    /**
     * The received property.
     */
    readonly received: string;
    /**
     * The error message.
     */
    readonly message: string;
    /**
     * The input requirement.
     */
    readonly requirement?: unknown | undefined;
    /**
     * The issue path.
     */
    readonly path?: [IssuePathItem, ...IssuePathItem[]] | undefined;
    /**
     * The sub issues.
     */
    readonly issues?: [BaseIssue<TInput>, ...BaseIssue<TInput>[]] | undefined;
}

/**
 * Config interface.
 */
interface Config<TIssue extends BaseIssue<unknown>> {
    /**
     * The selected language.
     */
    readonly lang?: string | undefined;
    /**
     * The error message.
     */
    readonly message?: ErrorMessage<TIssue> | undefined;
    /**
     * Whether it should be aborted early.
     */
    readonly abortEarly?: boolean | undefined;
    /**
     * Whether a pipe should be aborted early.
     */
    readonly abortPipeEarly?: boolean | undefined;
}

/**
 * Pipe action type.
 */
type PipeAction<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseValidation<TInput, TOutput, TIssue> | BaseTransformation<TInput, TOutput, TIssue> | BaseMetadata<TInput>;
/**
 * Pipe action async type.
 */
type PipeActionAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseValidationAsync<TInput, TOutput, TIssue> | BaseTransformationAsync<TInput, TOutput, TIssue>;
/**
 * Pipe item type.
 */
type PipeItem<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseSchema<TInput, TOutput, TIssue> | PipeAction<TInput, TOutput, TIssue>;
/**
 * Pipe item async type.
 */
type PipeItemAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseSchemaAsync<TInput, TOutput, TIssue> | PipeActionAsync<TInput, TOutput, TIssue>;

/**
 * Array issue interface.
 */
interface ArrayIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'array';
    /**
     * The expected property.
     */
    readonly expected: 'Array';
}

/**
 * Array schema interface.
 */
interface ArraySchema<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TMessage extends ErrorMessage<ArrayIssue> | undefined> extends BaseSchema<InferInput<TItem>[], InferOutput<TItem>[], ArrayIssue | InferIssue<TItem>> {
    /**
     * The schema type.
     */
    readonly type: 'array';
    /**
     * The schema reference.
     */
    readonly reference: typeof array;
    /**
     * The expected property.
     */
    readonly expects: 'Array';
    /**
     * The array item schema.
     */
    readonly item: TItem;
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates an array schema.
 *
 * @param item The item schema.
 *
 * @returns An array schema.
 */
declare function array<const TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(item: TItem): ArraySchema<TItem, undefined>;
/**
 * Creates an array schema.
 *
 * @param item The item schema.
 * @param message The error message.
 *
 * @returns An array schema.
 */
declare function array<const TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TMessage extends ErrorMessage<ArrayIssue> | undefined>(item: TItem, message: TMessage): ArraySchema<TItem, TMessage>;

/**
 * Exact optional schema interface.
 */
interface ExactOptionalSchema<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TDefault extends Default<TWrapped, never>> extends BaseSchema<InferInput<TWrapped>, InferOutput<TWrapped>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'exact_optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof exactOptional;
    /**
     * The expected property.
     */
    readonly expects: TWrapped['expects'];
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an exact optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An exact optional schema.
 */
declare function exactOptional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): ExactOptionalSchema<TWrapped, undefined>;
/**
 * Creates an exact optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An exact optional schema.
 */
declare function exactOptional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TDefault extends Default<TWrapped, never>>(wrapped: TWrapped, default_: TDefault): ExactOptionalSchema<TWrapped, TDefault>;

/**
 * Exact optional schema async interface.
 */
interface ExactOptionalSchemaAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, never>> extends BaseSchemaAsync<InferInput<TWrapped>, InferOutput<TWrapped>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'exact_optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof exactOptional | typeof exactOptionalAsync;
    /**
     * The expected property.
     */
    readonly expects: TWrapped['expects'];
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an exact optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An exact optional schema.
 */
declare function exactOptionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): ExactOptionalSchemaAsync<TWrapped, undefined>;
/**
 * Creates an exact optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An exact optional schema.
 */
declare function exactOptionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, const TDefault extends DefaultAsync<TWrapped, never>>(wrapped: TWrapped, default_: TDefault): ExactOptionalSchemaAsync<TWrapped, TDefault>;

/**
 * Infer nullish output type.
 */
type InferNullishOutput<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, null | undefined>> = undefined extends TDefault ? InferOutput<TWrapped> | null | undefined : InferOutput<TWrapped> | Extract<DefaultValue<TDefault>, null | undefined>;

/**
 * Nullish schema interface.
 */
interface NullishSchema<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TDefault extends Default<TWrapped, null | undefined>> extends BaseSchema<InferInput<TWrapped> | null | undefined, InferNullishOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'nullish';
    /**
     * The schema reference.
     */
    readonly reference: typeof nullish;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | null | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A nullish schema.
 */
declare function nullish<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): NullishSchema<TWrapped, undefined>;
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A nullish schema.
 */
declare function nullish<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TDefault extends Default<TWrapped, null | undefined>>(wrapped: TWrapped, default_: TDefault): NullishSchema<TWrapped, TDefault>;

/**
 * Nullish schema async interface.
 */
interface NullishSchemaAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, null | undefined>> extends BaseSchemaAsync<InferInput<TWrapped> | null | undefined, InferNullishOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'nullish';
    /**
     * The schema reference.
     */
    readonly reference: typeof nullish | typeof nullishAsync;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | null | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A nullish schema.
 */
declare function nullishAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): NullishSchemaAsync<TWrapped, undefined>;
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A nullish schema.
 */
declare function nullishAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, const TDefault extends DefaultAsync<TWrapped, null | undefined>>(wrapped: TWrapped, default_: TDefault): NullishSchemaAsync<TWrapped, TDefault>;

/**
 * Object issue interface.
 */
interface ObjectIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'object';
    /**
     * The expected property.
     */
    readonly expected: 'Object' | `"${string}"`;
}

/**
 * Object schema interface.
 */
interface ObjectSchema<TEntries extends ObjectEntries, TMessage extends ErrorMessage<ObjectIssue> | undefined> extends BaseSchema<InferObjectInput<TEntries>, InferObjectOutput<TEntries>, ObjectIssue | InferObjectIssue<TEntries>> {
    /**
     * The schema type.
     */
    readonly type: 'object';
    /**
     * The schema reference.
     */
    readonly reference: typeof object;
    /**
     * The expected property.
     */
    readonly expects: 'Object';
    /**
     * The entries schema.
     */
    readonly entries: TEntries;
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates an object schema.
 *
 * Hint: This schema removes unknown entries. The output will only include the
 * entries you specify. To include unknown entries, use `looseObject`. To
 * return an issue for unknown entries, use `strictObject`. To include and
 * validate unknown entries, use `objectWithRest`.
 *
 * @param entries The entries schema.
 *
 * @returns An object schema.
 */
declare function object<const TEntries extends ObjectEntries>(entries: TEntries): ObjectSchema<TEntries, undefined>;
/**
 * Creates an object schema.
 *
 * Hint: This schema removes unknown entries. The output will only include the
 * entries you specify. To include unknown entries, use `looseObject`. To
 * return an issue for unknown entries, use `strictObject`. To include and
 * validate unknown entries, use `objectWithRest`.
 *
 * @param entries The entries schema.
 * @param message The error message.
 *
 * @returns An object schema.
 */
declare function object<const TEntries extends ObjectEntries, const TMessage extends ErrorMessage<ObjectIssue> | undefined>(entries: TEntries, message: TMessage): ObjectSchema<TEntries, TMessage>;

/**
 * Infer optional output type.
 */
type InferOptionalOutput<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, undefined>> = undefined extends TDefault ? InferOutput<TWrapped> | undefined : InferOutput<TWrapped> | Extract<DefaultValue<TDefault>, undefined>;

/**
 * Optional schema interface.
 */
interface OptionalSchema<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TDefault extends Default<TWrapped, undefined>> extends BaseSchema<InferInput<TWrapped> | undefined, InferOptionalOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof optional;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An optional schema.
 */
declare function optional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): OptionalSchema<TWrapped, undefined>;
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An optional schema.
 */
declare function optional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TDefault extends Default<TWrapped, undefined>>(wrapped: TWrapped, default_: TDefault): OptionalSchema<TWrapped, TDefault>;

/**
 * Optional schema async interface.
 */
interface OptionalSchemaAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, undefined>> extends BaseSchemaAsync<InferInput<TWrapped> | undefined, InferOptionalOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof optional | typeof optionalAsync;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An optional schema.
 */
declare function optionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): OptionalSchemaAsync<TWrapped, undefined>;
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An optional schema.
 */
declare function optionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, const TDefault extends DefaultAsync<TWrapped, undefined>>(wrapped: TWrapped, default_: TDefault): OptionalSchemaAsync<TWrapped, TDefault>;

/**
 * String issue interface.
 */
interface StringIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'string';
    /**
     * The expected property.
     */
    readonly expected: 'string';
}
/**
 * String schema interface.
 */
interface StringSchema<TMessage extends ErrorMessage<StringIssue> | undefined> extends BaseSchema<string, string, StringIssue> {
    /**
     * The schema type.
     */
    readonly type: 'string';
    /**
     * The schema reference.
     */
    readonly reference: typeof string;
    /**
     * The expected property.
     */
    readonly expects: 'string';
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates a string schema.
 *
 * @returns A string schema.
 */
declare function string(): StringSchema<undefined>;
/**
 * Creates a string schema.
 *
 * @param message The error message.
 *
 * @returns A string schema.
 */
declare function string<const TMessage extends ErrorMessage<StringIssue> | undefined>(message: TMessage): StringSchema<TMessage>;
/**
 * Length input type.
 */
type LengthInput = string | ArrayLike<unknown>;

/**
 * Description action interface.
 */
interface DescriptionAction<TInput, TDescription extends string> extends BaseMetadata<TInput> {
    /**
     * The action type.
     */
    readonly type: 'description';
    /**
     * The action reference.
     */
    readonly reference: typeof description;
    /**
     * The description text.
     */
    readonly description: TDescription;
}
/**
 * Creates a description metadata action.
 *
 * @param description_ The description text.
 *
 * @returns A description action.
 */
declare function description<TInput, TDescription extends string>(description_: TDescription): DescriptionAction<TInput, TDescription>;

/**
 * Non empty issue interface.
 */
interface NonEmptyIssue<TInput extends LengthInput> extends BaseIssue<TInput> {
    /**
     * The issue kind.
     */
    readonly kind: 'validation';
    /**
     * The issue type.
     */
    readonly type: 'non_empty';
    /**
     * The expected input.
     */
    readonly expected: '!0';
    /**
     * The received input.
     */
    readonly received: '0';
}
/**
 * Non empty action interface.
 */
interface NonEmptyAction<TInput extends LengthInput, TMessage extends ErrorMessage<NonEmptyIssue<TInput>> | undefined> extends BaseValidation<TInput, TInput, NonEmptyIssue<TInput>> {
    /**
     * The action type.
     */
    readonly type: 'non_empty';
    /**
     * The action reference.
     */
    readonly reference: typeof nonEmpty;
    /**
     * The expected property.
     */
    readonly expects: '!0';
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates a non-empty validation action.
 *
 * @returns A non-empty action.
 */
declare function nonEmpty<TInput extends LengthInput>(): NonEmptyAction<TInput, undefined>;
/**
 * Creates a non-empty validation action.
 *
 * @param message The error message.
 *
 * @returns A non-empty action.
 */
declare function nonEmpty<TInput extends LengthInput, const TMessage extends ErrorMessage<NonEmptyIssue<TInput>> | undefined>(message: TMessage): NonEmptyAction<TInput, TMessage>;

/**
 * Readonly output type.
 */
type ReadonlyOutput<TInput> = TInput extends Map<infer TKey, infer TValue> ? ReadonlyMap<TKey, TValue> : TInput extends Set<infer TValue> ? ReadonlySet<TValue> : Readonly<TInput>;
/**
 * Readonly action interface.
 */
interface ReadonlyAction<TInput> extends BaseTransformation<TInput, ReadonlyOutput<TInput>, never> {
    /**
     * The action type.
     */
    readonly type: 'readonly';
    /**
     * The action reference.
     */
    readonly reference: typeof readonly;
}
/**
 * Creates a readonly transformation action.
 *
 * @returns A readonly action.
 */
declare function readonly<TInput>(): ReadonlyAction<TInput>;

declare const ProjectConfig: ObjectSchema<{
    readonly name: SchemaWithPipe<readonly [SchemaWithPipe<readonly [StringSchema<undefined>, NonEmptyAction<string, undefined>]>, DescriptionAction<string, "Project name, must be unique in the workspace">]>;
    readonly contactPerson: OptionalSchema<SchemaWithPipe<readonly [SchemaWithPipe<readonly [StringSchema<undefined>, NonEmptyAction<string, undefined>]>, DescriptionAction<string, "A person who has been involved in creating or maintaining this project">]>, undefined>;
    readonly exclude: OptionalSchema<SchemaWithPipe<readonly [ArraySchema<StringSchema<undefined>, undefined>, DescriptionAction<string[], "List of file patterns to exclude from the project, default is [\"**/node_modules/**/*\"]">]>, undefined>;
}, undefined>;
type ProjectConfig = InferOutput<typeof ProjectConfig>;

/******************************************************************************
 * This file was generated by langium-cli 3.4.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

type ArrowType = 'crow' | 'diamond' | 'dot' | 'none' | 'normal' | 'odiamond' | 'odot' | 'onormal' | 'open' | 'vee';
type Boolean = boolean;
type BorderStyleValue = 'none' | LineOptions;
type CustomColorId = 'element' | 'model' | ArrowType | ElementShape | LineOptions | string;
type CustomColorValue = string;
type DeploymentElement = DeployedInstance | DeploymentNode;
declare const DeploymentElement = "DeploymentElement";
type DeploymentNodeOrElementKind = DeploymentNodeKind | ElementKind;
declare const DeploymentNodeOrElementKind = "DeploymentNodeOrElementKind";
type DeploymentViewRule = DeploymentViewRulePredicate | DeploymentViewRuleStyle | ViewRuleAutoLayout;
declare const DeploymentViewRule = "DeploymentViewRule";
type DynamicViewRule = DynamicViewGlobalPredicateRef | DynamicViewIncludePredicate | ViewRuleAutoLayout | ViewRuleStyleOrGlobalRef;
declare const DynamicViewRule = "DynamicViewRule";
type ElementProperty = ElementStringProperty | ElementStyleProperty | IconProperty | LinkProperty | MetadataProperty;
declare const ElementProperty = "ElementProperty";
type ElementShape = 'browser' | 'cylinder' | 'mobile' | 'person' | 'queue' | 'rectangle' | 'storage';
type ExpressionV2 = FqnExprOrWith | RelationExprOrWith;
declare const ExpressionV2 = "ExpressionV2";
type ExtendElementProperty = LinkProperty | MetadataProperty;
declare const ExtendElementProperty = "ExtendElementProperty";
type FqnExpr = ElementKindExpression | ElementTagExpression | FqnRefExpr | WildcardExpression;
declare const FqnExpr = "FqnExpr";
type FqnExprOrWhere = FqnExpr | FqnExprWhere;
declare const FqnExprOrWhere = "FqnExprOrWhere";
type FqnExprOrWith = FqnExprOrWhere | FqnExprWith;
declare const FqnExprOrWith = "FqnExprOrWith";
type FqnReferenceable = Element | ExtendDeployment | ExtendElement | Referenceable;
declare const FqnReferenceable = "FqnReferenceable";
type IconId = string;
type Id = 'deployment' | 'element' | 'group' | 'instance' | 'model' | 'node' | ArrowType | ElementShape | LineOptions | Participant | SizeValue | ThemeColor | string;
type LikeC4View = DeploymentView | DynamicView | ElementView;
declare const LikeC4View = "LikeC4View";
type LineOptions = 'dashed' | 'dotted' | 'solid';
type MetadataProperty = MetadataBody;
declare const MetadataProperty = "MetadataProperty";
type ModelReferenceable = Element | Imported;
declare const ModelReferenceable = "ModelReferenceable";
type Participant = 'source' | 'target';
type Referenceable = DeployedInstance | DeploymentNode | Element | Imported;
declare const Referenceable = "Referenceable";
type RelationExpr = DirectedRelationExpr | InOutRelationExpr | IncomingRelationExpr | OutgoingRelationExpr;
declare const RelationExpr = "RelationExpr";
type RelationExprOrWhere = RelationExpr | RelationExprWhere;
declare const RelationExprOrWhere = "RelationExprOrWhere";
type RelationExprOrWith = RelationExprOrWhere | RelationExprWith;
declare const RelationExprOrWith = "RelationExprOrWith";
type RelationProperty = LinkProperty | MetadataProperty | RelationNavigateToProperty | RelationStringProperty | RelationStyleProperty;
declare const RelationProperty = "RelationProperty";
type RelationshipStyleProperty = ArrowProperty | ColorProperty | LineProperty;
declare const RelationshipStyleProperty = "RelationshipStyleProperty";
type SizeProperty = PaddingSizeProperty | ShapeSizeProperty | TextSizeProperty;
declare const SizeProperty = "SizeProperty";
type SizeValue = 'large' | 'lg' | 'md' | 'medium' | 'sm' | 'small' | 'xl' | 'xlarge' | 'xs' | 'xsmall';
type StringProperty = ElementStringProperty | MetadataAttribute | NotationProperty | NotesProperty | RelationStringProperty | SpecificationElementStringProperty | SpecificationRelationshipStringProperty | ViewStringProperty;
declare const StringProperty = "StringProperty";
type StyleProperty = BorderProperty | ColorProperty | IconProperty | MultipleProperty | OpacityProperty | PaddingSizeProperty | ShapeProperty | ShapeSizeProperty | TextSizeProperty;
declare const StyleProperty = "StyleProperty";
type ThemeColor = 'amber' | 'blue' | 'gray' | 'green' | 'indigo' | 'muted' | 'primary' | 'red' | 'secondary' | 'sky' | 'slate';
type Uri = string;
type ViewLayoutDirection = 'BottomTop' | 'LeftRight' | 'RightLeft' | 'TopBottom';
type ViewProperty = LinkProperty | ViewStringProperty;
declare const ViewProperty = "ViewProperty";
type ViewRule = ViewRuleAutoLayout | ViewRuleGlobalPredicateRef | ViewRuleGroup | ViewRulePredicate | ViewRuleStyleOrGlobalRef;
declare const ViewRule = "ViewRule";
type ViewRuleStyleOrGlobalRef = ViewRuleGlobalStyle | ViewRuleStyle;
declare const ViewRuleStyleOrGlobalRef = "ViewRuleStyleOrGlobalRef";
type WhereElement = WhereElementKind | WhereElementTag;
declare const WhereElement = "WhereElement";
type WhereElementExpression = WhereBinaryExpression | WhereElement | WhereElementNegation;
declare const WhereElementExpression = "WhereElementExpression";
type WhereExpression = WhereElementExpression | WhereRelationExpression;
declare const WhereExpression = "WhereExpression";
type WhereKindEqual = WhereElementKind | WhereRelationKind | WhereRelationParticipantKind;
declare const WhereKindEqual = "WhereKindEqual";
type WhereRelation = WhereRelationKind | WhereRelationParticipantKind | WhereRelationParticipantTag | WhereRelationTag;
declare const WhereRelation = "WhereRelation";
type WhereRelationExpression = WhereBinaryExpression | WhereRelation | WhereRelationNegation;
declare const WhereRelationExpression = "WhereRelationExpression";
type WhereTagEqual = WhereElementTag | WhereRelationParticipantTag | WhereRelationTag;
declare const WhereTagEqual = "WhereTagEqual";
interface ArrowProperty extends AstNode {
    readonly $container: CustomRelationProperties | RelationStyleProperty | SpecificationRelationshipKind;
    readonly $type: 'ArrowProperty';
    key: 'head' | 'tail';
    value: ArrowType;
}
declare const ArrowProperty = "ArrowProperty";
interface BorderProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'BorderProperty';
    key: 'border';
    value: BorderStyleValue;
}
declare const BorderProperty = "BorderProperty";
interface ColorProperty extends AstNode {
    readonly $container: CustomElementProperties | CustomRelationProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | RelationStyleProperty | SpecificationRelationshipKind | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'ColorProperty';
    customColor?: Reference<CustomColor>;
    key: 'color';
    themeColor?: ThemeColor;
}
declare const ColorProperty = "ColorProperty";
interface CustomColor extends AstNode {
    readonly $container: SpecificationColor;
    readonly $type: 'CustomColor';
    name: CustomColorId;
}
declare const CustomColor = "CustomColor";
interface CustomElementProperties extends AstNode {
    readonly $container: FqnExprWith;
    readonly $type: 'CustomElementProperties';
    props: Array<ElementStringProperty | NavigateToProperty | NotationProperty | StyleProperty>;
}
declare const CustomElementProperties = "CustomElementProperties";
interface CustomRelationProperties extends AstNode {
    readonly $container: DynamicViewStep | RelationExprWith;
    readonly $type: 'CustomRelationProperties';
    props: Array<NotationProperty | NotesProperty | RelationNavigateToProperty | RelationStringProperty | RelationshipStyleProperty>;
}
declare const CustomRelationProperties = "CustomRelationProperties";
interface DeployedInstance extends AstNode {
    readonly $container: DeploymentNodeBody | ExtendDeploymentBody;
    readonly $type: 'DeployedInstance';
    body?: DeployedInstanceBody;
    name?: Id;
    target: ElementRef;
    title?: string;
}
declare const DeployedInstance = "DeployedInstance";
interface DeployedInstanceBody extends AstNode {
    readonly $container: DeployedInstance;
    readonly $type: 'DeployedInstanceBody';
    elements: Array<DeploymentRelation>;
    props: Array<ElementProperty>;
    tags?: Tags;
}
declare const DeployedInstanceBody = "DeployedInstanceBody";
interface DeploymentNode extends AstNode {
    readonly $container: DeploymentNodeBody | ExtendDeploymentBody | ModelDeployments;
    readonly $type: 'DeploymentNode';
    body?: DeploymentNodeBody;
    kind: Reference<DeploymentNodeKind>;
    name: Id;
    title?: string;
}
declare const DeploymentNode = "DeploymentNode";
interface DeploymentNodeBody extends AstNode {
    readonly $container: DeploymentNode;
    readonly $type: 'DeploymentNodeBody';
    elements: Array<DeployedInstance | DeploymentNode | DeploymentRelation>;
    props: Array<ElementProperty>;
    tags?: Tags;
}
declare const DeploymentNodeBody = "DeploymentNodeBody";
interface DeploymentNodeKind extends AstNode {
    readonly $container: SpecificationDeploymentNodeKind;
    readonly $type: 'DeploymentNodeKind';
    name: Id;
}
declare const DeploymentNodeKind = "DeploymentNodeKind";
interface DeploymentRelation extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | ExtendDeploymentBody | ModelDeployments;
    readonly $type: 'DeploymentRelation';
    body?: DeploymentRelationBody;
    kind?: Reference<RelationshipKind>;
    source?: FqnRef;
    tags?: Tags;
    target: FqnRef;
    technology?: string;
    title?: string;
}
declare const DeploymentRelation = "DeploymentRelation";
interface DeploymentRelationBody extends AstNode {
    readonly $container: DeploymentRelation;
    readonly $type: 'DeploymentRelationBody';
    props: Array<RelationProperty>;
    tags?: Tags;
}
declare const DeploymentRelationBody = "DeploymentRelationBody";
interface DeploymentView extends AstNode {
    readonly $container: ModelViews;
    readonly $type: 'DeploymentView';
    body?: DeploymentViewBody;
    name: Id;
}
declare const DeploymentView = "DeploymentView";
interface DeploymentViewBody extends AstNode {
    readonly $container: DeploymentView;
    readonly $type: 'DeploymentViewBody';
    props: Array<ViewProperty>;
    rules: Array<DeploymentViewRule>;
    tags?: Tags;
}
declare const DeploymentViewBody = "DeploymentViewBody";
interface DeploymentViewRulePredicate extends AstNode {
    readonly $container: DeploymentViewBody;
    readonly $type: 'DeploymentViewRulePredicate';
    expr: Expressions;
    isInclude: boolean;
}
declare const DeploymentViewRulePredicate = "DeploymentViewRulePredicate";
interface DeploymentViewRuleStyle extends AstNode {
    readonly $container: DeploymentViewBody;
    readonly $type: 'DeploymentViewRuleStyle';
    props: Array<NotationProperty | StyleProperty>;
    targets: FqnExpressions;
}
declare const DeploymentViewRuleStyle = "DeploymentViewRuleStyle";
interface DirectedRelationExpr extends AstNode {
    readonly $container: Expressions | RelationExprWhere | RelationExprWith;
    readonly $type: 'DirectedRelationExpr';
    source: OutgoingRelationExpr;
    target: FqnExpr;
}
declare const DirectedRelationExpr = "DirectedRelationExpr";
interface DynamicView extends AstNode {
    readonly $container: ModelViews;
    readonly $type: 'DynamicView';
    body?: DynamicViewBody;
    name: Id;
}
declare const DynamicView = "DynamicView";
interface DynamicViewBody extends AstNode {
    readonly $container: DynamicView;
    readonly $type: 'DynamicViewBody';
    props: Array<ViewProperty>;
    rules: Array<DynamicViewRule>;
    steps: Array<DynamicViewParallelSteps | DynamicViewStep>;
    tags?: Tags;
}
declare const DynamicViewBody = "DynamicViewBody";
interface DynamicViewGlobalPredicateRef extends AstNode {
    readonly $container: DynamicViewBody;
    readonly $type: 'DynamicViewGlobalPredicateRef';
    predicate: Reference<GlobalDynamicPredicateGroup>;
}
declare const DynamicViewGlobalPredicateRef = "DynamicViewGlobalPredicateRef";
interface DynamicViewIncludePredicate extends AstNode {
    readonly $container: DynamicViewBody | GlobalDynamicPredicateGroup;
    readonly $type: 'DynamicViewIncludePredicate';
    exprs: Expressions;
}
declare const DynamicViewIncludePredicate = "DynamicViewIncludePredicate";
interface DynamicViewParallelSteps extends AstNode {
    readonly $container: DynamicViewBody;
    readonly $type: 'DynamicViewParallelSteps';
    steps: Array<DynamicViewStep>;
}
declare const DynamicViewParallelSteps = "DynamicViewParallelSteps";
interface DynamicViewRef extends AstNode {
    readonly $container: RelationNavigateToProperty;
    readonly $type: 'DynamicViewRef';
    view: Reference<DynamicView>;
}
declare const DynamicViewRef = "DynamicViewRef";
interface DynamicViewStep extends AstNode {
    readonly $container: DynamicViewBody | DynamicViewParallelSteps;
    readonly $type: 'DynamicViewStep';
    custom?: CustomRelationProperties;
    isBackward: boolean;
    kind?: Reference<RelationshipKind>;
    source: ElementRef;
    target: ElementRef;
    title?: string;
}
declare const DynamicViewStep = "DynamicViewStep";
interface Element extends AstNode {
    readonly $container: ElementBody | ExtendElementBody | Model;
    readonly $type: 'Element';
    body?: ElementBody;
    kind: Reference<ElementKind>;
    name: Id;
    props: Array<string>;
}
declare const Element = "Element";
interface ElementBody extends AstNode {
    readonly $container: Element;
    readonly $type: 'ElementBody';
    elements: Array<Element | Relation>;
    props: Array<ElementProperty>;
    tags?: Tags;
}
declare const ElementBody = "ElementBody";
interface ElementKind extends AstNode {
    readonly $container: SpecificationElementKind;
    readonly $type: 'ElementKind';
    name: Id;
}
declare const ElementKind = "ElementKind";
interface ElementKindExpression extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | FqnExprWhere | FqnExprWith | FqnExpressions | IncomingRelationExpr | OutgoingRelationExpr;
    readonly $type: 'ElementKindExpression';
    isEqual: boolean;
    kind?: Reference<ElementKind>;
}
declare const ElementKindExpression = "ElementKindExpression";
interface ElementRef extends AstNode {
    readonly $container: DeployedInstance | DynamicViewStep | ElementView;
    readonly $type: 'ElementRef';
    modelElement: FqnRef;
}
declare const ElementRef = "ElementRef";
interface ElementStringProperty extends AstNode {
    readonly $container: CustomElementProperties | DeployedInstanceBody | DeploymentNodeBody | ElementBody;
    readonly $type: 'ElementStringProperty';
    key: 'description' | 'technology' | 'title';
    value: string;
}
declare const ElementStringProperty = "ElementStringProperty";
interface ElementStyleProperty extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | ElementBody | SpecificationDeploymentNodeKind | SpecificationElementKind;
    readonly $type: 'ElementStyleProperty';
    key: 'style';
    props: Array<StyleProperty>;
}
declare const ElementStyleProperty = "ElementStyleProperty";
interface ElementTagExpression extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | FqnExprWhere | FqnExprWith | FqnExpressions | IncomingRelationExpr | OutgoingRelationExpr;
    readonly $type: 'ElementTagExpression';
    isEqual: boolean;
    tag?: Reference<Tag>;
}
declare const ElementTagExpression = "ElementTagExpression";
interface ElementView extends AstNode {
    readonly $container: ModelViews;
    readonly $type: 'ElementView';
    body?: ElementViewBody;
    extends?: ElementViewRef;
    name?: Id;
    viewOf?: ElementRef;
}
declare const ElementView = "ElementView";
interface ElementViewBody extends AstNode {
    readonly $container: ElementView;
    readonly $type: 'ElementViewBody';
    props: Array<ViewProperty>;
    rules: Array<ViewRule>;
    tags?: Tags;
}
declare const ElementViewBody = "ElementViewBody";
interface ElementViewRef extends AstNode {
    readonly $container: ElementView;
    readonly $type: 'ElementViewRef';
    view: Reference<ElementView>;
}
declare const ElementViewRef = "ElementViewRef";
interface Expressions extends AstNode {
    readonly $container: DeploymentViewRulePredicate | DynamicViewIncludePredicate | Expressions | ViewRulePredicate;
    readonly $type: 'Expressions';
    prev?: Expressions;
    value: ExpressionV2;
}
declare const Expressions = "Expressions";
interface ExtendDeployment extends AstNode {
    readonly $container: ModelDeployments;
    readonly $type: 'ExtendDeployment';
    body: ExtendDeploymentBody;
    deploymentNode: StrictFqnRef;
}
declare const ExtendDeployment = "ExtendDeployment";
interface ExtendDeploymentBody extends AstNode {
    readonly $container: ExtendDeployment;
    readonly $type: 'ExtendDeploymentBody';
    elements: Array<DeployedInstance | DeploymentNode | DeploymentRelation>;
    props: Array<ExtendElementProperty>;
    tags?: Tags;
}
declare const ExtendDeploymentBody = "ExtendDeploymentBody";
interface ExtendElement extends AstNode {
    readonly $container: Model;
    readonly $type: 'ExtendElement';
    body: ExtendElementBody;
    element: StrictFqnElementRef;
}
declare const ExtendElement = "ExtendElement";
interface ExtendElementBody extends AstNode {
    readonly $container: ExtendElement;
    readonly $type: 'ExtendElementBody';
    elements: Array<Element | Relation>;
    props: Array<ExtendElementProperty>;
    tags?: Tags;
}
declare const ExtendElementBody = "ExtendElementBody";
interface FqnExpressions extends AstNode {
    readonly $container: DeploymentViewRuleStyle | FqnExpressions | GlobalStyle | ViewRuleStyle;
    readonly $type: 'FqnExpressions';
    prev?: FqnExpressions;
    value: FqnExpr;
}
declare const FqnExpressions = "FqnExpressions";
interface FqnExprWhere extends AstNode {
    readonly $container: Expressions | FqnExprWith;
    readonly $type: 'FqnExprWhere';
    subject: FqnExpr;
    where?: WhereElementExpression;
}
declare const FqnExprWhere = "FqnExprWhere";
interface FqnExprWith extends AstNode {
    readonly $container: Expressions;
    readonly $type: 'FqnExprWith';
    custom?: CustomElementProperties;
    subject: FqnExprOrWhere;
}
declare const FqnExprWith = "FqnExprWith";
interface FqnRef extends AstNode {
    readonly $container: DeploymentRelation | ElementRef | FqnRef | FqnRefExpr | Relation;
    readonly $type: 'FqnRef';
    parent?: FqnRef;
    value: Reference<Referenceable>;
}
declare const FqnRef = "FqnRef";
interface FqnRefExpr extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | FqnExprWhere | FqnExprWith | FqnExpressions | IncomingRelationExpr | OutgoingRelationExpr;
    readonly $type: 'FqnRefExpr';
    ref: FqnRef;
    selector?: string;
}
declare const FqnRefExpr = "FqnRefExpr";
interface GlobalDynamicPredicateGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalDynamicPredicateGroup';
    name: string;
    predicates: Array<DynamicViewIncludePredicate>;
}
declare const GlobalDynamicPredicateGroup = "GlobalDynamicPredicateGroup";
interface GlobalPredicateGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalPredicateGroup';
    name: string;
    predicates: Array<ViewRulePredicate>;
}
declare const GlobalPredicateGroup = "GlobalPredicateGroup";
interface Globals extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'Globals';
    name: 'global';
    predicates: Array<GlobalDynamicPredicateGroup | GlobalPredicateGroup>;
    styles: Array<GlobalStyle | GlobalStyleGroup>;
}
declare const Globals = "Globals";
interface GlobalStyle extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalStyle';
    id: GlobalStyleId;
    props: Array<NotationProperty | StyleProperty>;
    targets: FqnExpressions;
}
declare const GlobalStyle = "GlobalStyle";
interface GlobalStyleGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalStyleGroup';
    id: GlobalStyleId;
    styles: Array<ViewRuleStyle>;
}
declare const GlobalStyleGroup = "GlobalStyleGroup";
interface GlobalStyleId extends AstNode {
    readonly $container: GlobalStyle | GlobalStyleGroup;
    readonly $type: 'GlobalStyleId';
    name: string;
}
declare const GlobalStyleId = "GlobalStyleId";
interface IconProperty extends AstNode {
    readonly $container: CustomElementProperties | DeployedInstanceBody | DeploymentNodeBody | DeploymentViewRuleStyle | ElementBody | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'IconProperty';
    key: 'icon';
    libicon?: Reference<LibIcon>;
    value?: 'none' | Uri;
}
declare const IconProperty = "IconProperty";
interface Imported extends AstNode {
    readonly $container: Imported | ImportsFromPoject;
    readonly $type: 'Imported';
    imported: Reference<Element>;
    prev?: Imported;
}
declare const Imported = "Imported";
interface ImportsFromPoject extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'ImportsFromPoject';
    imports: Imported;
    project: string;
}
declare const ImportsFromPoject = "ImportsFromPoject";
interface IncomingRelationExpr extends AstNode {
    readonly $container: Expressions | InOutRelationExpr | RelationExprWhere | RelationExprWith;
    readonly $type: 'IncomingRelationExpr';
    to: FqnExpr;
}
declare const IncomingRelationExpr = "IncomingRelationExpr";
interface InOutRelationExpr extends AstNode {
    readonly $container: Expressions | RelationExprWhere | RelationExprWith;
    readonly $type: 'InOutRelationExpr';
    inout: IncomingRelationExpr;
}
declare const InOutRelationExpr = "InOutRelationExpr";
interface LibIcon extends AstNode {
    readonly $container: LikeC4Lib;
    readonly $type: 'LibIcon';
    name: IconId;
}
declare const LibIcon = "LibIcon";
interface LikeC4Grammar extends AstNode {
    readonly $type: 'LikeC4Grammar';
    deployments: Array<ModelDeployments>;
    globals: Array<Globals>;
    imports: Array<ImportsFromPoject>;
    likec4lib: Array<LikeC4Lib>;
    models: Array<Model>;
    specifications: Array<SpecificationRule>;
    views: Array<ModelViews>;
}
declare const LikeC4Grammar = "LikeC4Grammar";
interface LikeC4Lib extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'LikeC4Lib';
    icons: Array<LibIcon>;
}
declare const LikeC4Lib = "LikeC4Lib";
interface LineProperty extends AstNode {
    readonly $container: CustomRelationProperties | RelationStyleProperty | SpecificationRelationshipKind;
    readonly $type: 'LineProperty';
    key: 'line';
    value: LineOptions;
}
declare const LineProperty = "LineProperty";
interface LinkProperty extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | DeploymentRelationBody | DeploymentViewBody | DynamicViewBody | ElementBody | ElementViewBody | ExtendDeploymentBody | ExtendElementBody | RelationBody;
    readonly $type: 'LinkProperty';
    key: 'link';
    title?: string;
    value: Uri;
}
declare const LinkProperty = "LinkProperty";
interface MetadataAttribute extends AstNode {
    readonly $container: MetadataBody;
    readonly $type: 'MetadataAttribute';
    key: string;
    value: string;
}
declare const MetadataAttribute = "MetadataAttribute";
interface MetadataBody extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | DeploymentRelationBody | ElementBody | ExtendDeploymentBody | ExtendElementBody | RelationBody;
    readonly $type: 'MetadataBody';
    props: Array<MetadataAttribute>;
}
declare const MetadataBody = "MetadataBody";
interface Model extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'Model';
    elements: Array<Element | ExtendElement | Relation>;
    name: 'model';
}
declare const Model = "Model";
interface ModelDeployments extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'ModelDeployments';
    elements: Array<DeploymentNode | DeploymentRelation | ExtendDeployment>;
    name: 'deployment';
}
declare const ModelDeployments = "ModelDeployments";
interface ModelViews extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'ModelViews';
    name: 'views';
    styles: Array<ViewRuleStyleOrGlobalRef>;
    views: Array<LikeC4View>;
}
declare const ModelViews = "ModelViews";
interface MultipleProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'MultipleProperty';
    key: 'multiple';
    value: Boolean;
}
declare const MultipleProperty = "MultipleProperty";
interface NavigateToProperty extends AstNode {
    readonly $container: CustomElementProperties;
    readonly $type: 'NavigateToProperty';
    key: 'navigateTo';
    value: ViewRef;
}
declare const NavigateToProperty = "NavigateToProperty";
interface NotationProperty extends AstNode {
    readonly $container: CustomElementProperties | CustomRelationProperties | DeploymentViewRuleStyle | GlobalStyle | ViewRuleStyle;
    readonly $type: 'NotationProperty';
    key: 'notation';
    value: string;
}
declare const NotationProperty = "NotationProperty";
interface NotesProperty extends AstNode {
    readonly $container: CustomRelationProperties;
    readonly $type: 'NotesProperty';
    key: 'notes';
    value: string;
}
declare const NotesProperty = "NotesProperty";
interface OpacityProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'OpacityProperty';
    key: 'opacity';
    value: string;
}
declare const OpacityProperty = "OpacityProperty";
interface OutgoingRelationExpr extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | RelationExprWhere | RelationExprWith;
    readonly $type: 'OutgoingRelationExpr';
    from: FqnExpr;
    isBidirectional: boolean;
    kind?: Reference<RelationshipKind>;
}
declare const OutgoingRelationExpr = "OutgoingRelationExpr";
interface PaddingSizeProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'PaddingSizeProperty';
    key: 'padding';
    value: SizeValue;
}
declare const PaddingSizeProperty = "PaddingSizeProperty";
interface Relation extends AstNode {
    readonly $container: ElementBody | ExtendElementBody | Model;
    readonly $type: 'Relation';
    body?: RelationBody;
    kind?: Reference<RelationshipKind>;
    source?: FqnRef;
    tags?: Tags;
    target: FqnRef;
    technology?: string;
    title?: string;
}
declare const Relation = "Relation";
interface RelationBody extends AstNode {
    readonly $container: Relation;
    readonly $type: 'RelationBody';
    props: Array<RelationProperty>;
    tags?: Tags;
}
declare const RelationBody = "RelationBody";
interface RelationExprWhere extends AstNode {
    readonly $container: Expressions | RelationExprWith;
    readonly $type: 'RelationExprWhere';
    subject: RelationExpr;
    where?: WhereRelationExpression;
}
declare const RelationExprWhere = "RelationExprWhere";
interface RelationExprWith extends AstNode {
    readonly $container: Expressions;
    readonly $type: 'RelationExprWith';
    custom?: CustomRelationProperties;
    subject: RelationExprOrWhere;
}
declare const RelationExprWith = "RelationExprWith";
interface RelationNavigateToProperty extends AstNode {
    readonly $container: CustomRelationProperties | DeploymentRelationBody | RelationBody;
    readonly $type: 'RelationNavigateToProperty';
    key: 'navigateTo';
    value: DynamicViewRef;
}
declare const RelationNavigateToProperty = "RelationNavigateToProperty";
interface RelationshipKind extends AstNode {
    readonly $container: SpecificationRelationshipKind;
    readonly $type: 'RelationshipKind';
    name: Id;
}
declare const RelationshipKind = "RelationshipKind";
interface RelationStringProperty extends AstNode {
    readonly $container: CustomRelationProperties | DeploymentRelationBody | RelationBody;
    readonly $type: 'RelationStringProperty';
    key: 'description' | 'technology' | 'title';
    value: string;
}
declare const RelationStringProperty = "RelationStringProperty";
interface RelationStyleProperty extends AstNode {
    readonly $container: DeploymentRelationBody | RelationBody;
    readonly $type: 'RelationStyleProperty';
    key: 'style';
    props: Array<RelationshipStyleProperty>;
}
declare const RelationStyleProperty = "RelationStyleProperty";
interface ShapeProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'ShapeProperty';
    key: 'shape';
    value: ElementShape;
}
declare const ShapeProperty = "ShapeProperty";
interface ShapeSizeProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'ShapeSizeProperty';
    key: 'size';
    value: SizeValue;
}
declare const ShapeSizeProperty = "ShapeSizeProperty";
interface SpecificationColor extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationColor';
    color: CustomColorValue;
    name: CustomColor;
}
declare const SpecificationColor = "SpecificationColor";
interface SpecificationDeploymentNodeKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationDeploymentNodeKind';
    kind: DeploymentNodeKind;
    props: Array<ElementStyleProperty | SpecificationElementStringProperty>;
}
declare const SpecificationDeploymentNodeKind = "SpecificationDeploymentNodeKind";
interface SpecificationElementKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationElementKind';
    kind: ElementKind;
    props: Array<ElementStyleProperty | SpecificationElementStringProperty>;
}
declare const SpecificationElementKind = "SpecificationElementKind";
interface SpecificationElementStringProperty extends AstNode {
    readonly $container: SpecificationDeploymentNodeKind | SpecificationElementKind;
    readonly $type: 'SpecificationElementStringProperty';
    key: 'notation' | 'technology';
    value: string;
}
declare const SpecificationElementStringProperty = "SpecificationElementStringProperty";
interface SpecificationRelationshipKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationRelationshipKind';
    kind: RelationshipKind;
    props: Array<RelationshipStyleProperty | SpecificationRelationshipStringProperty>;
}
declare const SpecificationRelationshipKind = "SpecificationRelationshipKind";
interface SpecificationRelationshipStringProperty extends AstNode {
    readonly $container: SpecificationRelationshipKind;
    readonly $type: 'SpecificationRelationshipStringProperty';
    key: 'notation' | 'technology';
    value: string;
}
declare const SpecificationRelationshipStringProperty = "SpecificationRelationshipStringProperty";
interface SpecificationRule extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'SpecificationRule';
    colors: Array<SpecificationColor>;
    deploymentNodes: Array<SpecificationDeploymentNodeKind>;
    elements: Array<SpecificationElementKind>;
    name: 'specification';
    relationships: Array<SpecificationRelationshipKind>;
    tags: Array<SpecificationTag>;
}
declare const SpecificationRule = "SpecificationRule";
interface SpecificationTag extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationTag';
    tag: Tag;
}
declare const SpecificationTag = "SpecificationTag";
interface StrictFqnElementRef extends AstNode {
    readonly $container: ExtendElement | StrictFqnElementRef;
    readonly $type: 'StrictFqnElementRef';
    el: Reference<Element>;
    parent?: StrictFqnElementRef;
}
declare const StrictFqnElementRef = "StrictFqnElementRef";
interface StrictFqnRef extends AstNode {
    readonly $container: ExtendDeployment | StrictFqnRef;
    readonly $type: 'StrictFqnRef';
    parent?: StrictFqnRef;
    value: Reference<Referenceable>;
}
declare const StrictFqnRef = "StrictFqnRef";
interface Tag extends AstNode {
    readonly $container: SpecificationTag;
    readonly $type: 'Tag';
    name: Id;
}
declare const Tag = "Tag";
interface Tags extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | DeploymentRelation | DeploymentRelationBody | DeploymentViewBody | DynamicViewBody | ElementBody | ElementViewBody | ExtendDeploymentBody | ExtendElementBody | Relation | RelationBody | Tags;
    readonly $type: 'Tags';
    prev?: Tags;
    values: Array<Reference<Tag>>;
}
declare const Tags = "Tags";
interface TextSizeProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'TextSizeProperty';
    key: 'textSize';
    value: SizeValue;
}
declare const TextSizeProperty = "TextSizeProperty";
interface ViewRef extends AstNode {
    readonly $container: NavigateToProperty;
    readonly $type: 'ViewRef';
    view: Reference<LikeC4View>;
}
declare const ViewRef = "ViewRef";
interface ViewRuleAutoLayout extends AstNode {
    readonly $container: DeploymentViewBody | DynamicViewBody | ElementViewBody;
    readonly $type: 'ViewRuleAutoLayout';
    direction: ViewLayoutDirection;
    nodeSep?: number;
    rankSep?: number;
}
declare const ViewRuleAutoLayout = "ViewRuleAutoLayout";
interface ViewRuleGlobalPredicateRef extends AstNode {
    readonly $container: ElementViewBody;
    readonly $type: 'ViewRuleGlobalPredicateRef';
    predicate: Reference<GlobalPredicateGroup>;
}
declare const ViewRuleGlobalPredicateRef = "ViewRuleGlobalPredicateRef";
interface ViewRuleGlobalStyle extends AstNode {
    readonly $container: DynamicViewBody | ElementViewBody | ModelViews;
    readonly $type: 'ViewRuleGlobalStyle';
    style: Reference<GlobalStyleId>;
}
declare const ViewRuleGlobalStyle = "ViewRuleGlobalStyle";
interface ViewRuleGroup extends AstNode {
    readonly $container: ElementViewBody | ViewRuleGroup;
    readonly $type: 'ViewRuleGroup';
    groupRules: Array<ViewRuleGroup | ViewRulePredicate>;
    props: Array<BorderProperty | ColorProperty | OpacityProperty>;
    title?: string;
}
declare const ViewRuleGroup = "ViewRuleGroup";
interface ViewRulePredicate extends AstNode {
    readonly $container: ElementViewBody | GlobalPredicateGroup | ViewRuleGroup;
    readonly $type: 'ViewRulePredicate';
    exprs: Expressions;
    isInclude: boolean;
}
declare const ViewRulePredicate = "ViewRulePredicate";
interface ViewRuleStyle extends AstNode {
    readonly $container: DynamicViewBody | ElementViewBody | GlobalStyleGroup | ModelViews;
    readonly $type: 'ViewRuleStyle';
    props: Array<NotationProperty | StyleProperty>;
    targets: FqnExpressions;
}
declare const ViewRuleStyle = "ViewRuleStyle";
interface ViewStringProperty extends AstNode {
    readonly $container: DeploymentViewBody | DynamicViewBody | ElementViewBody;
    readonly $type: 'ViewStringProperty';
    key: 'description' | 'title';
    value: string;
}
declare const ViewStringProperty = "ViewStringProperty";
interface WhereBinaryExpression extends AstNode {
    readonly $container: FqnExprWhere | RelationExprWhere | WhereBinaryExpression | WhereElementNegation | WhereRelationNegation;
    readonly $type: 'WhereBinaryExpression';
    left: WhereElementExpression | WhereRelationExpression;
    operator: 'and' | 'or';
    right: WhereElementExpression | WhereRelationExpression;
}
declare const WhereBinaryExpression = "WhereBinaryExpression";
interface WhereElementKind extends AstNode {
    readonly $container: FqnExprWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementKind';
    not: boolean;
    operator: 'is' | string;
    value?: Reference<DeploymentNodeOrElementKind>;
}
declare const WhereElementKind = "WhereElementKind";
interface WhereElementNegation extends AstNode {
    readonly $container: FqnExprWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementNegation';
    value: WhereElementExpression;
}
declare const WhereElementNegation = "WhereElementNegation";
interface WhereElementTag extends AstNode {
    readonly $container: FqnExprWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementTag';
    not: boolean;
    operator: 'is' | string;
    value?: Reference<Tag>;
}
declare const WhereElementTag = "WhereElementTag";
interface WhereRelationKind extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationKind';
    not: boolean;
    operator: 'is' | string;
    value?: Reference<RelationshipKind>;
}
declare const WhereRelationKind = "WhereRelationKind";
interface WhereRelationNegation extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationNegation';
    value: WhereRelationExpression;
}
declare const WhereRelationNegation = "WhereRelationNegation";
interface WhereRelationParticipantKind extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationParticipantKind';
    not: boolean;
    operator: 'is' | string;
    participant: Participant;
    value?: Reference<DeploymentNodeOrElementKind>;
}
declare const WhereRelationParticipantKind = "WhereRelationParticipantKind";
interface WhereRelationParticipantTag extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationParticipantTag';
    not: boolean;
    operator: 'is' | string;
    participant: Participant;
    value?: Reference<Tag>;
}
declare const WhereRelationParticipantTag = "WhereRelationParticipantTag";
interface WhereRelationTag extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationTag';
    not: boolean;
    operator: 'is' | string;
    value?: Reference<Tag>;
}
declare const WhereRelationTag = "WhereRelationTag";
interface WildcardExpression extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | FqnExprWhere | FqnExprWith | FqnExpressions | IncomingRelationExpr | OutgoingRelationExpr;
    readonly $type: 'WildcardExpression';
    isWildcard: boolean;
}
declare const WildcardExpression = "WildcardExpression";
type LikeC4AstType = {
    ArrowProperty: ArrowProperty;
    BorderProperty: BorderProperty;
    ColorProperty: ColorProperty;
    CustomColor: CustomColor;
    CustomElementProperties: CustomElementProperties;
    CustomRelationProperties: CustomRelationProperties;
    DeployedInstance: DeployedInstance;
    DeployedInstanceBody: DeployedInstanceBody;
    DeploymentElement: DeploymentElement;
    DeploymentNode: DeploymentNode;
    DeploymentNodeBody: DeploymentNodeBody;
    DeploymentNodeKind: DeploymentNodeKind;
    DeploymentNodeOrElementKind: DeploymentNodeOrElementKind;
    DeploymentRelation: DeploymentRelation;
    DeploymentRelationBody: DeploymentRelationBody;
    DeploymentView: DeploymentView;
    DeploymentViewBody: DeploymentViewBody;
    DeploymentViewRule: DeploymentViewRule;
    DeploymentViewRulePredicate: DeploymentViewRulePredicate;
    DeploymentViewRuleStyle: DeploymentViewRuleStyle;
    DirectedRelationExpr: DirectedRelationExpr;
    DynamicView: DynamicView;
    DynamicViewBody: DynamicViewBody;
    DynamicViewGlobalPredicateRef: DynamicViewGlobalPredicateRef;
    DynamicViewIncludePredicate: DynamicViewIncludePredicate;
    DynamicViewParallelSteps: DynamicViewParallelSteps;
    DynamicViewRef: DynamicViewRef;
    DynamicViewRule: DynamicViewRule;
    DynamicViewStep: DynamicViewStep;
    Element: Element;
    ElementBody: ElementBody;
    ElementKind: ElementKind;
    ElementKindExpression: ElementKindExpression;
    ElementProperty: ElementProperty;
    ElementRef: ElementRef;
    ElementStringProperty: ElementStringProperty;
    ElementStyleProperty: ElementStyleProperty;
    ElementTagExpression: ElementTagExpression;
    ElementView: ElementView;
    ElementViewBody: ElementViewBody;
    ElementViewRef: ElementViewRef;
    ExpressionV2: ExpressionV2;
    Expressions: Expressions;
    ExtendDeployment: ExtendDeployment;
    ExtendDeploymentBody: ExtendDeploymentBody;
    ExtendElement: ExtendElement;
    ExtendElementBody: ExtendElementBody;
    ExtendElementProperty: ExtendElementProperty;
    FqnExpr: FqnExpr;
    FqnExprOrWhere: FqnExprOrWhere;
    FqnExprOrWith: FqnExprOrWith;
    FqnExprWhere: FqnExprWhere;
    FqnExprWith: FqnExprWith;
    FqnExpressions: FqnExpressions;
    FqnRef: FqnRef;
    FqnRefExpr: FqnRefExpr;
    FqnReferenceable: FqnReferenceable;
    GlobalDynamicPredicateGroup: GlobalDynamicPredicateGroup;
    GlobalPredicateGroup: GlobalPredicateGroup;
    GlobalStyle: GlobalStyle;
    GlobalStyleGroup: GlobalStyleGroup;
    GlobalStyleId: GlobalStyleId;
    Globals: Globals;
    IconProperty: IconProperty;
    Imported: Imported;
    ImportsFromPoject: ImportsFromPoject;
    InOutRelationExpr: InOutRelationExpr;
    IncomingRelationExpr: IncomingRelationExpr;
    LibIcon: LibIcon;
    LikeC4Grammar: LikeC4Grammar;
    LikeC4Lib: LikeC4Lib;
    LikeC4View: LikeC4View;
    LineProperty: LineProperty;
    LinkProperty: LinkProperty;
    MetadataAttribute: MetadataAttribute;
    MetadataBody: MetadataBody;
    MetadataProperty: MetadataProperty;
    Model: Model;
    ModelDeployments: ModelDeployments;
    ModelReferenceable: ModelReferenceable;
    ModelViews: ModelViews;
    MultipleProperty: MultipleProperty;
    NavigateToProperty: NavigateToProperty;
    NotationProperty: NotationProperty;
    NotesProperty: NotesProperty;
    OpacityProperty: OpacityProperty;
    OutgoingRelationExpr: OutgoingRelationExpr;
    PaddingSizeProperty: PaddingSizeProperty;
    Referenceable: Referenceable;
    Relation: Relation;
    RelationBody: RelationBody;
    RelationExpr: RelationExpr;
    RelationExprOrWhere: RelationExprOrWhere;
    RelationExprOrWith: RelationExprOrWith;
    RelationExprWhere: RelationExprWhere;
    RelationExprWith: RelationExprWith;
    RelationNavigateToProperty: RelationNavigateToProperty;
    RelationProperty: RelationProperty;
    RelationStringProperty: RelationStringProperty;
    RelationStyleProperty: RelationStyleProperty;
    RelationshipKind: RelationshipKind;
    RelationshipStyleProperty: RelationshipStyleProperty;
    ShapeProperty: ShapeProperty;
    ShapeSizeProperty: ShapeSizeProperty;
    SizeProperty: SizeProperty;
    SpecificationColor: SpecificationColor;
    SpecificationDeploymentNodeKind: SpecificationDeploymentNodeKind;
    SpecificationElementKind: SpecificationElementKind;
    SpecificationElementStringProperty: SpecificationElementStringProperty;
    SpecificationRelationshipKind: SpecificationRelationshipKind;
    SpecificationRelationshipStringProperty: SpecificationRelationshipStringProperty;
    SpecificationRule: SpecificationRule;
    SpecificationTag: SpecificationTag;
    StrictFqnElementRef: StrictFqnElementRef;
    StrictFqnRef: StrictFqnRef;
    StringProperty: StringProperty;
    StyleProperty: StyleProperty;
    Tag: Tag;
    Tags: Tags;
    TextSizeProperty: TextSizeProperty;
    ViewProperty: ViewProperty;
    ViewRef: ViewRef;
    ViewRule: ViewRule;
    ViewRuleAutoLayout: ViewRuleAutoLayout;
    ViewRuleGlobalPredicateRef: ViewRuleGlobalPredicateRef;
    ViewRuleGlobalStyle: ViewRuleGlobalStyle;
    ViewRuleGroup: ViewRuleGroup;
    ViewRulePredicate: ViewRulePredicate;
    ViewRuleStyle: ViewRuleStyle;
    ViewRuleStyleOrGlobalRef: ViewRuleStyleOrGlobalRef;
    ViewStringProperty: ViewStringProperty;
    WhereBinaryExpression: WhereBinaryExpression;
    WhereElement: WhereElement;
    WhereElementExpression: WhereElementExpression;
    WhereElementKind: WhereElementKind;
    WhereElementNegation: WhereElementNegation;
    WhereElementTag: WhereElementTag;
    WhereExpression: WhereExpression;
    WhereKindEqual: WhereKindEqual;
    WhereRelation: WhereRelation;
    WhereRelationExpression: WhereRelationExpression;
    WhereRelationKind: WhereRelationKind;
    WhereRelationNegation: WhereRelationNegation;
    WhereRelationParticipantKind: WhereRelationParticipantKind;
    WhereRelationParticipantTag: WhereRelationParticipantTag;
    WhereRelationTag: WhereRelationTag;
    WhereTagEqual: WhereTagEqual;
    WildcardExpression: WildcardExpression;
};

type Guard<N extends AstNode> = (n: AstNode) => n is N;
type Guarded<G> = G extends Guard<infer N> ? N : never;
declare const isValidatableAstNode: (n: AstNode) => n is DeployedInstance | DeploymentNode | DeploymentViewRulePredicate | DeploymentViewRuleStyle | ViewRuleAutoLayout | DynamicViewGlobalPredicateRef | DynamicViewIncludePredicate | ViewRuleGlobalStyle | ViewRuleStyle | ElementStringProperty | ElementStyleProperty | IconProperty | LinkProperty | MetadataBody | ElementKindExpression | ElementTagExpression | FqnRefExpr | WildcardExpression | FqnExprWhere | FqnExprWith | DirectedRelationExpr | InOutRelationExpr | IncomingRelationExpr | OutgoingRelationExpr | RelationExprWhere | RelationExprWith | Element | ExtendDeployment | ExtendElement | Imported | DeploymentView | DynamicView | ElementView | RelationStringProperty | ArrowProperty | ColorProperty | LineProperty | PaddingSizeProperty | ShapeSizeProperty | TextSizeProperty | MetadataAttribute | NotationProperty | NotesProperty | SpecificationElementStringProperty | SpecificationRelationshipStringProperty | ViewStringProperty | BorderProperty | MultipleProperty | OpacityProperty | ShapeProperty | ViewRuleGlobalPredicateRef | ViewRuleGroup | ViewRulePredicate | SpecificationRelationshipKind | GlobalStyle | SpecificationColor | NavigateToProperty | DynamicViewStep | ElementRef | DeploymentRelation | Tags | SpecificationDeploymentNodeKind | DynamicViewParallelSteps | GlobalDynamicPredicateGroup | Relation | SpecificationElementKind | Globals | GlobalPredicateGroup | GlobalStyleGroup | ImportsFromPoject | SpecificationRule | SpecificationTag;
type ValidatableAstNode = Guarded<typeof isValidatableAstNode>;
declare function checksFromDiagnostics(doc: LikeC4LangiumDocument): {
    isValid: (n: ValidatableAstNode) => boolean;
    invalidNodes: WeakSet<object>;
};
type ChecksFromDiagnostics = ReturnType<typeof checksFromDiagnostics>;
type IsValidFn = ChecksFromDiagnostics['isValid'];

declare module 'langium' {
    interface LangiumDocument {
        likec4ProjectId?: c4.ProjectId;
    }
    interface AstNodeDescription {
        likec4ProjectId?: c4.ProjectId;
    }
}
declare const idattr: unique symbol;
declare module './generated/ast' {
    interface Element {
        [idattr]?: c4.Fqn | undefined;
    }
    interface ElementView {
        [idattr]?: c4.ViewId | undefined;
    }
    interface DynamicView {
        [idattr]?: c4.ViewId | undefined;
    }
    interface DeploymentView {
        [idattr]?: c4.ViewId | undefined;
    }
    interface DeploymentNode {
        [idattr]?: c4.Fqn | undefined;
    }
    interface DeployedInstance {
        [idattr]?: c4.Fqn | undefined;
    }
}
type ParsedElementStyle = {
    shape?: c4.ElementShape;
    icon?: c4.IconUrl;
    color?: c4.Color;
    border?: c4.BorderStyle;
    opacity?: number;
    multiple?: boolean;
    size?: c4.ShapeSize;
    padding?: c4.SpacingSize;
    textSize?: c4.TextSize;
};
interface ParsedAstSpecification {
    tags: Set<c4.Tag>;
    elements: Record<c4.ElementKind, {
        technology?: string;
        notation?: string;
        style: ParsedElementStyle;
    }>;
    relationships: Record<c4.RelationshipKind, {
        technology?: string;
        notation?: string;
        color?: c4.Color;
        line?: c4.RelationshipLineType;
        head?: c4.RelationshipArrowType;
        tail?: c4.RelationshipArrowType;
    }>;
    colors: Record<c4.CustomColor, {
        color: c4.HexColorLiteral;
    }>;
    deployments: Record<c4.DeploymentNodeKind, c4.DeploymentNodeKindSpecification>;
}
interface ParsedAstElement {
    id: c4.Fqn;
    astPath: string;
    kind: c4.ElementKind;
    title: string;
    description?: string;
    technology?: string;
    tags?: c4.NonEmptyArray<c4.Tag>;
    links?: c4.NonEmptyArray<c4.Link>;
    style: ParsedElementStyle;
    metadata?: {
        [key: string]: string;
    };
}
interface ParsedAstExtend {
    id: c4.Fqn;
    astPath: string;
    tags?: c4.NonEmptyArray<c4.Tag>;
    links?: c4.NonEmptyArray<c4.Link>;
    metadata?: {
        [key: string]: string;
    };
}
interface ParsedAstRelation {
    id: c4.RelationId;
    astPath: string;
    source: c4.FqnRef.ModelRef | c4.FqnRef.ImportRef;
    target: c4.FqnRef.ModelRef | c4.FqnRef.ImportRef;
    kind?: c4.RelationshipKind;
    tags?: c4.NonEmptyArray<c4.Tag>;
    title: string;
    description?: string;
    technology?: string;
    color?: c4.Color;
    line?: c4.RelationshipLineType;
    head?: c4.RelationshipArrowType;
    tail?: c4.RelationshipArrowType;
    links?: c4.NonEmptyArray<c4.Link>;
    navigateTo?: c4.ViewId;
    metadata?: {
        [key: string]: string;
    };
}
type ParsedAstDeployment = Simplify<MergeExclusive<ParsedAstDeployment.Node, ParsedAstDeployment.Instance>>;
declare namespace ParsedAstDeployment {
    type Node = c4.DeploymentNode;
    type Instance = Omit<c4.DeployedInstance, 'element'> & {
        readonly element: c4.FqnRef.ModelRef | c4.FqnRef.ImportRef;
    };
}
type ParsedAstDeploymentRelation = c4.DeploymentRelation & {
    astPath: string;
};
type ParsedAstGlobals = Writable<c4.ModelGlobals>;
interface ParsedAstElementView {
    __: 'element';
    id: c4.ViewId;
    viewOf?: c4.Fqn;
    extends?: c4.ViewId;
    astPath: string;
    title: string | null;
    description: string | null;
    tags: c4.NonEmptyArray<c4.Tag> | null;
    links: c4.NonEmptyArray<c4.Link> | null;
    rules: c4.ViewRule[];
    manualLayout?: c4.ViewManualLayout;
}
interface ParsedAstDynamicView {
    __: 'dynamic';
    id: c4.ViewId;
    astPath: string;
    title: string | null;
    description: string | null;
    tags: c4.NonEmptyArray<c4.Tag> | null;
    links: c4.NonEmptyArray<c4.Link> | null;
    steps: c4.DynamicViewStepOrParallel[];
    rules: Array<c4.DynamicViewRule>;
    manualLayout?: c4.ViewManualLayout;
}
interface ParsedAstDeploymentView {
    __: 'deployment';
    id: c4.ViewId;
    astPath: string;
    title: string | null;
    description: string | null;
    tags: c4.NonEmptyArray<c4.Tag> | null;
    links: c4.NonEmptyArray<c4.Link> | null;
    rules: Array<c4.DeploymentViewRule>;
}
type ParsedAstView = ParsedAstElementView | ParsedAstDynamicView | ParsedAstDeploymentView;
interface AstNodeDescriptionWithFqn extends AstNodeDescription {
    likec4ProjectId: c4.ProjectId;
    id: c4.Fqn;
}
type LikeC4AstNode = ValueOf<ConditionalPick<LikeC4AstType, AstNode>>;
type LikeC4DocumentDiagnostic = Diagnostic & DiagnosticInfo<LikeC4AstNode>;
interface LikeC4DocumentProps {
    diagnostics?: Array<LikeC4DocumentDiagnostic>;
    c4Specification?: ParsedAstSpecification;
    c4Elements?: ParsedAstElement[];
    c4ExtendElements?: ParsedAstExtend[];
    c4ExtendDeployments?: ParsedAstExtend[];
    c4Relations?: ParsedAstRelation[];
    c4Globals?: ParsedAstGlobals;
    c4Views?: ParsedAstView[];
    c4Deployments?: ParsedAstDeployment[];
    c4DeploymentRelations?: ParsedAstDeploymentRelation[];
    c4Imports?: MultiMap$1<c4.ProjectId, c4.Fqn, Set<c4.Fqn>>;
}
type LikeC4GrammarDocument = Omit<LangiumDocument<LikeC4Grammar>, 'diagnostics'>;
interface LikeC4LangiumDocument extends LikeC4GrammarDocument, LikeC4DocumentProps {
    likec4ProjectId: c4.ProjectId;
}
interface ParsedLikeC4LangiumDocument extends LikeC4GrammarDocument, Required<LikeC4DocumentProps> {
    likec4ProjectId: c4.ProjectId;
}

declare class LikeC4NameProvider extends DefaultNameProvider {
    protected services: LikeC4Services;
    constructor(services: LikeC4Services);
    getNameStrict(node: AstNode): string;
    getName(node: AstNode): string | undefined;
    getNameNode(node: AstNode): CstNode | undefined;
}

type ElementsContainer = Model | ElementBody | ExtendElementBody;
type DeploymentsContainer = ModelDeployments | DeploymentNodeBody | ExtendDeploymentBody | DeployedInstanceBody;
declare class LikeC4ScopeComputation extends DefaultScopeComputation {
    constructor(services: LikeC4Services);
    computeExports(document: LikeC4LangiumDocument, _cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
    private exportViews;
    private exportGlobals;
    private exportModel;
    private exportLibrary;
    private exportSpecification;
    private exportDeployments;
    computeLocalScopes(document: LikeC4LangiumDocument, _cancelToken?: CancellationToken): Promise<PrecomputedScopes>;
    protected processContainer(container: ElementsContainer, scopes: PrecomputedScopes, document: LikeC4LangiumDocument): AstNodeDescription[];
    protected processDeployments(container: DeploymentsContainer, scopes: PrecomputedScopes, document: LikeC4LangiumDocument): AstNodeDescription[];
}

declare class IndexManager extends DefaultIndexManager {
    protected services: LikeC4SharedServices;
    constructor(services: LikeC4SharedServices);
    updateContent(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;
    projectElements(projectId: ProjectId, nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;
}

declare class LangiumDocuments extends DefaultLangiumDocuments {
    protected services: LikeC4SharedServices;
    constructor(services: LikeC4SharedServices);
    /**
     * Returns all user documents, excluding built-in documents.
     */
    get allExcludingBuiltin(): Stream<LikeC4LangiumDocument>;
    projectDocuments(projectId: ProjectId): Stream<LikeC4LangiumDocument>;
    groupedByProject(): Record<ProjectId, NonEmptyArray<LikeC4LangiumDocument>>;
}

interface Project {
    id: ProjectId;
    config: ProjectConfig;
    folder: string;
    exclude?: picomatch.Matcher;
}
declare class ProjectsManager {
    protected services: LikeC4SharedServices;
    /**
     * The global project ID used for all documents
     * that are not part of a specific project.
     */
    static readonly DefaultProjectId: ProjectId;
    static readonly ConfigFileNames: string[];
    /**
     * The mapping between project config files and project IDs.
     */
    private projectIdToFolder;
    /**
     * Registered projects.
     * Sorted descending by the number of segments in the folder path.
     * This ensures that the most specific project is used for a document.
     */
    private _projects;
    private defaultGlobalProject;
    constructor(services: LikeC4SharedServices);
    /**
     * Returns:
     *  - the default project ID if there are no projects.
     *  - the ID of the only project
     *  - undefined if there are multiple projects.
     */
    get defaultProjectId(): ProjectId | undefined;
    get all(): NonEmptyReadonlyArray<ProjectId>;
    getProject(arg: ProjectId | LangiumDocument): {
        id: ProjectId;
        folder: URI;
        config: Readonly<ProjectConfig>;
    };
    ensureProjectId(projectId?: ProjectId | undefined): ProjectId;
    hasMultipleProjects(): boolean;
    checkIfExcluded(documentUri: URI): boolean;
    isConfigFile(entry: FileSystemNode): boolean;
    /**
     * Checks if the provided file system entry is a valid project config file.
     *
     * @param entry The file system entry to check
     * @returns {boolean} Returns true if the entry is a valid config file, false otherwise.
     */
    loadConfigFile(entry: FileSystemNode): Promise<Project | undefined>;
    registerProject(configFile: URI): Promise<Project>;
    registerProject(opts: {
        config: ProjectConfig;
        folderUri: URI | string;
    }): Promise<Project>;
    belongsTo(document: LangiumDocument | URI | string): ProjectId;
    protected findProjectForDocument(documentUri: string): Omit<Project, 'folder'>;
    private _mappingsToProject;
    protected get mappingsToProject(): WorkspaceCache<string, Omit<Project, 'folder'>>;
}

declare class LikeC4WorkspaceManager extends DefaultWorkspaceManager {
    private services;
    private documentFactory;
    constructor(services: LikeC4SharedServices);
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    protected loadAdditionalDocuments(folders: WorkspaceFolder[], collector: (document: LangiumDocument) => void): Promise<void>;
    /**
     * Determine whether the given folder entry shall be included while indexing the workspace.
     */
    protected includeEntry(_workspaceFolder: WorkspaceFolder, entry: FileSystemNode, fileExtensions: string[]): boolean;
    workspace(): any;
    get workspaceUri(): URI;
    get workspaceURL(): URL;
}

declare class LikeC4ScopeProvider extends DefaultScopeProvider {
    protected deploymentsIndex: DeploymentsIndex;
    protected fqnIndex: FqnIndex;
    protected readonly indexManager: IndexManager;
    constructor(services: LikeC4Services);
    getScope(context: ReferenceInfo): Scope;
    protected genUniqueDescedants(of: () => Element | DeploymentNode | undefined): Generator<Stream<AstNodeDescriptionWithFqn>, void, any>;
    protected genScopeExtendElement({ element }: ExtendElement): Generator<AstNodeDescription>;
    protected genScopeElementView({ viewOf, extends: ext }: ElementView): Generator<AstNodeDescription>;
    protected getScopeForStrictFqnRef(projectId: ProjectId, container: StrictFqnRef, context: ReferenceInfo): any;
    protected genScopeExtendDeployment({ deploymentNode }: ExtendDeployment): Generator<AstNodeDescription>;
    protected streamForFqnRef(projectId: ProjectId, container: FqnRef, context: ReferenceInfo): Stream<AstNodeDescription>;
    protected genScopeForParentlessFqnRef(projectId: ProjectId, container: FqnRef, context: ReferenceInfo): Generator<AstNodeDescription>;
    /**
     * Computes the scope for a given reference context.
     *
     * @param context - The reference information containing the context for which the scope is being computed.
     * @param referenceType - The type of reference being resolved. Defaults to the reference type derived from the context.
     * @returns A scope containing the relevant AST node descriptions for the given reference context.
     *
     * This method first checks if there are precomputed scopes available in the document. If not, it falls back to the global scope.
     * It then iterates through the container hierarchy, collecting relevant scopes based on the reference type and container type.
     * Finally, it combines the collected scopes with the global scope to produce the final scope.
     */
    protected computeScope(projectId: ProjectId, context: ReferenceInfo, referenceType?: any): Generator<AstNodeDescription>;
    /**
     * Create a global scope filtered for the given reference type.
     */
    protected getProjectScope(projectId: ProjectId, referenceType: string, context: ReferenceInfo): Scope;
    /**
     * Create a global scope filtered for the given reference type.
     */
    protected getGlobalScope(referenceType: string, context: ReferenceInfo): Scope;
}

declare abstract class ADisposable implements Disposable {
    protected toDispose: Disposable[];
    protected isDisposed: boolean;
    onDispose(...disposable: Disposable[]): void;
    dispose(): void;
    protected throwIfDisposed(): void;
}

declare class FqnIndex<AstNd = Element> extends ADisposable {
    protected services: LikeC4Services;
    private cachePrefix;
    protected projects: ProjectsManager;
    protected langiumDocuments: LangiumDocuments;
    protected documentCache: DefaultWeakMap<LikeC4LangiumDocument, DocumentFqnIndex>;
    protected workspaceCache: WorkspaceCache<string, AstNodeDescriptionWithFqn[]>;
    constructor(services: LikeC4Services, cachePrefix?: string);
    private documents;
    get(document: LikeC4LangiumDocument): DocumentFqnIndex;
    resolve(reference: Referenceable): Fqn$1;
    getFqn(el: AstNd): Fqn$1;
    byFqn(projectId: ProjectId$1, fqn: Fqn$1): Stream<AstNodeDescriptionWithFqn>;
    rootElements(projectId: ProjectId$1): Stream<AstNodeDescriptionWithFqn>;
    directChildrenOf(projectId: ProjectId$1, parent: Fqn$1): Stream<AstNodeDescriptionWithFqn>;
    /**
     * Returns descedant elements with unique names in the scope
     */
    uniqueDescedants(projectId: ProjectId$1, parent: Fqn$1): Stream<AstNodeDescriptionWithFqn>;
    protected createDocumentIndex(document: LikeC4LangiumDocument): DocumentFqnIndex;
}
declare class DocumentFqnIndex {
    private _rootElements;
    /**
     * direct children of elements
     */
    private _children;
    /**
     * All descendants of an element (unique by name)
     */
    private _descendants;
    /**
     * All elements by FQN
     */
    private _byfqn;
    readonly projectId: ProjectId$1;
    static readonly EMPTY: DocumentFqnIndex;
    constructor(_rootElements: Array<AstNodeDescriptionWithFqn>, 
    /**
     * direct children of elements
     */
    _children: MultiMap$2<Fqn$1, AstNodeDescriptionWithFqn>, 
    /**
     * All descendants of an element (unique by name)
     */
    _descendants: MultiMap$2<Fqn$1, AstNodeDescriptionWithFqn>, 
    /**
     * All elements by FQN
     */
    _byfqn: MultiMap$2<Fqn$1, AstNodeDescriptionWithFqn>, projectId: ProjectId$1);
    rootElements(): readonly AstNodeDescriptionWithFqn[];
    byFqn(fqn: Fqn$1): readonly AstNodeDescriptionWithFqn[];
    children(parent: Fqn$1): readonly AstNodeDescriptionWithFqn[];
    descendants(nodeName: Fqn$1): readonly AstNodeDescriptionWithFqn[];
}

declare class DeploymentsIndex extends FqnIndex<DeploymentElement> {
    protected services: LikeC4Services;
    protected Names: LikeC4NameProvider;
    constructor(services: LikeC4Services);
    protected createDocumentIndex(document: LikeC4LangiumDocument): DocumentFqnIndex;
}

type ModelParsedListener = (docs: URI[]) => void;
interface LikeC4ModelBuilder {
    parseModel(projectId?: c4.ProjectId | undefined, cancelToken?: CancellationToken): Promise<c4.ParsedLikeC4ModelData | null>;
    unsafeSyncBuildModel(projectId: c4.ProjectId): LikeC4Model.Computed;
    buildLikeC4Model(projectId?: c4.ProjectId | undefined, cancelToken?: CancellationToken): Promise<LikeC4Model.Computed>;
    computeView(viewId: ViewId, projectId?: c4.ProjectId | undefined, cancelToken?: CancellationToken): Promise<c4.ComputedView | null>;
    onModelParsed(callback: ModelParsedListener): Disposable;
}

declare class LikeC4ModelLocator {
    private services;
    private fqnIndex;
    private deploymentsIndex;
    private langiumDocuments;
    private parser;
    private projects;
    constructor(services: LikeC4Services);
    private documents;
    getParsedElement(...args: [Element] | [c4.Fqn] | [c4.Fqn, c4.ProjectId]): ParsedAstElement | null;
    locateElement(fqn: c4.Fqn, projectId?: c4.ProjectId | undefined): Location | null;
    locateDeploymentElement(fqn: c4.Fqn, projectId?: c4.ProjectId | undefined): Location | null;
    locateRelation(relationId: c4.RelationId, projectId?: c4.ProjectId): Location | null;
    locateViewAst(viewId: c4.ViewId, projectId?: c4.ProjectId | undefined): null | {
        doc: ParsedLikeC4LangiumDocument;
        view: ParsedAstView;
        viewAst: LikeC4View;
    };
    locateView(viewId: c4.ViewId, projectId?: c4.ProjectId): Location | null;
}

declare class BaseParser {
    readonly services: LikeC4Services;
    readonly doc: ParsedLikeC4LangiumDocument;
    isValid: IsValidFn;
    constructor(services: LikeC4Services, doc: ParsedLikeC4LangiumDocument);
    get project(): {
        id: c4.ProjectId;
        folder: URI;
        config: Readonly<ProjectConfig>;
    };
    resolveFqn(node: FqnReferenceable): c4.Fqn;
    getAstNodePath(node: AstNode): any;
    getMetadata(metadataAstNode: MetadataProperty | undefined): {
        [key: string]: string;
    } | undefined;
    convertTags<E extends {
        tags?: Tags;
    }>(withTags?: E): any;
    parseTags<E extends {
        tags?: Tags;
    }>(withTags?: E): c4.NonEmptyArray<c4.Tag> | null;
    convertLinks(source?: LinkProperty['$container']): c4.Link[] | undefined;
    parseLinks(source?: LinkProperty['$container']): c4.Link[] | undefined;
    parseIconProperty(prop: IconProperty | undefined): c4.IconUrl | undefined;
    parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
    parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
}

declare const DocumentParserFromMixins: {
    new (...args: any[]): {
        parseGlobals(): void;
        parseAndStoreGlobalPredicateGroupOrDynamic(astRule: GlobalPredicateGroup | GlobalDynamicPredicateGroup, id: ProjectId, c4Globals: ParsedAstGlobals): void;
        parseGlobalPredicateGroup(astRule: GlobalPredicateGroup): ProjectId[];
        parseGlobalDynamicPredicateGroup(astRule: GlobalDynamicPredicateGroup): ProjectId[];
        parseGlobalStyleOrGroup(astRule: GlobalStyle | GlobalStyleGroup): ProjectId[];
        parseViews(): void;
        parseElementView(astNode: ElementView, additionalStyles: ProjectId[]): ParsedAstElementView;
        parseViewRule(astRule: ViewRule): ProjectId;
        parseViewRulePredicate(astNode: ViewRulePredicate): ProjectId;
        parseViewRuleGlobalPredicateRef(astRule: ViewRuleGlobalPredicateRef | DynamicViewGlobalPredicateRef): ProjectId;
        parseViewRuleStyleOrGlobalRef(astRule: ViewRuleStyleOrGlobalRef): ProjectId;
        parseViewRuleGroup(astNode: ViewRuleGroup): ProjectId;
        parseViewRuleStyle(astRule: ViewRuleStyle | GlobalStyle): ProjectId;
        parseRuleStyle(styleProperties: StyleProperty[], elementExpressionsIterator: FqnExpressions, notationProperty?: NotationProperty): ProjectId;
        parseViewRuleGlobalStyle(astRule: ViewRuleGlobalStyle): ProjectId;
        parseDynamicElementView(astNode: DynamicView, additionalStyles: ProjectId[]): ParsedAstDynamicView;
        parseDynamicViewRule(astRule: DynamicViewRule): ProjectId;
        parseDynamicViewIncludePredicate(astRule: DynamicViewIncludePredicate): ProjectId;
        parseDynamicParallelSteps(node: DynamicViewParallelSteps): ProjectId;
        parseDynamicStep(node: DynamicViewStep): ProjectId;
        parsePredicate(astNode: ExpressionV2): ProjectId;
        parseElementPredicate(astNode: FqnExprOrWith): ProjectId;
        parseElementPredicateOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseElementExpression(astNode: FqnExpr): ProjectId;
        parseElementPredicateWhere(astNode: FqnExprWhere): ProjectId;
        parseElementPredicateWith(astNode: FqnExprWith): ProjectId;
        parseRelationPredicate(astNode: RelationExprOrWith): ProjectId;
        parseRelationPredicateOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationPredicateWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationPredicateWith(astNode: RelationExprWith): ProjectId;
        parseRelationExpression(astNode: RelationExpr): ProjectId;
        parseFqnRef(astNode: FqnRef): ProjectId;
        parseExpressionV2(astNode: ExpressionV2): ProjectId;
        parseFqnExprOrWith(astNode: FqnExprOrWith): ProjectId;
        parseFqnExprWith(astNode: FqnExprWith): ProjectId;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseFqnExprWhere(astNode: FqnExprWhere): ProjectId;
        parseFqnExpr(astNode: FqnExpr): ProjectId;
        parseFqnRefExpr(astNode: FqnRefExpr): ProjectId;
        parseFqnExpressions(astNode: FqnExpressions): ProjectId[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): ProjectId;
        parseRelationExprWith(astNode: RelationExprWith): ProjectId;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationExprWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationExpr(astNode: RelationExpr): ProjectId;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseDeploymentView(astNode: DeploymentView): ParsedAstDeploymentView;
        parseDeploymentViewRule(astRule: DeploymentViewRule): ProjectId;
        parseDeploymentViewRulePredicate(astRule: DeploymentViewRulePredicate): ProjectId;
        parseDeploymentViewRuleStyle(astRule: DeploymentViewRuleStyle): ProjectId;
        parseDeployment(): void;
        parseDeploymentNode(astNode: DeploymentNode): ParsedAstDeployment.Node;
        parseDeployedInstance(astNode: DeployedInstance): ParsedAstDeployment.Instance;
        parseExtendDeployment(astNode: ExtendDeployment): ParsedAstExtend | null;
        _resolveDeploymentRelationSource(node: DeploymentRelation): ProjectId;
        parseDeploymentRelation(astNode: DeploymentRelation): ParsedAstDeploymentRelation;
    };
} & {
    new (...args: any[]): {
        parseViews(): void;
        parseElementView(astNode: ElementView, additionalStyles: ProjectId[]): ParsedAstElementView;
        parseViewRule(astRule: ViewRule): ProjectId;
        parseViewRulePredicate(astNode: ViewRulePredicate): ProjectId;
        parseViewRuleGlobalPredicateRef(astRule: ViewRuleGlobalPredicateRef | DynamicViewGlobalPredicateRef): ProjectId;
        parseViewRuleStyleOrGlobalRef(astRule: ViewRuleStyleOrGlobalRef): ProjectId;
        parseViewRuleGroup(astNode: ViewRuleGroup): ProjectId;
        parseViewRuleStyle(astRule: ViewRuleStyle | GlobalStyle): ProjectId;
        parseRuleStyle(styleProperties: StyleProperty[], elementExpressionsIterator: FqnExpressions, notationProperty?: NotationProperty): ProjectId;
        parseViewRuleGlobalStyle(astRule: ViewRuleGlobalStyle): ProjectId;
        parseDynamicElementView(astNode: DynamicView, additionalStyles: ProjectId[]): ParsedAstDynamicView;
        parseDynamicViewRule(astRule: DynamicViewRule): ProjectId;
        parseDynamicViewIncludePredicate(astRule: DynamicViewIncludePredicate): ProjectId;
        parseDynamicParallelSteps(node: DynamicViewParallelSteps): ProjectId;
        parseDynamicStep(node: DynamicViewStep): ProjectId;
        parsePredicate(astNode: ExpressionV2): ProjectId;
        parseElementPredicate(astNode: FqnExprOrWith): ProjectId;
        parseElementPredicateOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseElementExpression(astNode: FqnExpr): ProjectId;
        parseElementPredicateWhere(astNode: FqnExprWhere): ProjectId;
        parseElementPredicateWith(astNode: FqnExprWith): ProjectId;
        parseRelationPredicate(astNode: RelationExprOrWith): ProjectId;
        parseRelationPredicateOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationPredicateWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationPredicateWith(astNode: RelationExprWith): ProjectId;
        parseRelationExpression(astNode: RelationExpr): ProjectId;
        parseFqnRef(astNode: FqnRef): ProjectId;
        parseExpressionV2(astNode: ExpressionV2): ProjectId;
        parseFqnExprOrWith(astNode: FqnExprOrWith): ProjectId;
        parseFqnExprWith(astNode: FqnExprWith): ProjectId;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseFqnExprWhere(astNode: FqnExprWhere): ProjectId;
        parseFqnExpr(astNode: FqnExpr): ProjectId;
        parseFqnRefExpr(astNode: FqnRefExpr): ProjectId;
        parseFqnExpressions(astNode: FqnExpressions): ProjectId[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): ProjectId;
        parseRelationExprWith(astNode: RelationExprWith): ProjectId;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationExprWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationExpr(astNode: RelationExpr): ProjectId;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseDeploymentView(astNode: DeploymentView): ParsedAstDeploymentView;
        parseDeploymentViewRule(astRule: DeploymentViewRule): ProjectId;
        parseDeploymentViewRulePredicate(astRule: DeploymentViewRulePredicate): ProjectId;
        parseDeploymentViewRuleStyle(astRule: DeploymentViewRuleStyle): ProjectId;
        parseDeployment(): void;
        parseDeploymentNode(astNode: DeploymentNode): ParsedAstDeployment.Node;
        parseDeployedInstance(astNode: DeployedInstance): ParsedAstDeployment.Instance;
        parseExtendDeployment(astNode: ExtendDeployment): ParsedAstExtend | null;
        _resolveDeploymentRelationSource(node: DeploymentRelation): ProjectId;
        parseDeploymentRelation(astNode: DeploymentRelation): ParsedAstDeploymentRelation;
    };
} & {
    new (...args: any[]): {
        parseSpecification(): void;
        parseSpecificationDeploymentNodeKind({ kind, props }: SpecificationDeploymentNodeKind): {};
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
    };
} & {
    new (...args: any[]): {
        parsePredicate(astNode: ExpressionV2): ProjectId;
        parseElementPredicate(astNode: FqnExprOrWith): ProjectId;
        parseElementPredicateOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseElementExpression(astNode: FqnExpr): ProjectId;
        parseElementPredicateWhere(astNode: FqnExprWhere): ProjectId;
        parseElementPredicateWith(astNode: FqnExprWith): ProjectId;
        parseRelationPredicate(astNode: RelationExprOrWith): ProjectId;
        parseRelationPredicateOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationPredicateWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationPredicateWith(astNode: RelationExprWith): ProjectId;
        parseRelationExpression(astNode: RelationExpr): ProjectId;
        parseFqnRef(astNode: FqnRef): ProjectId;
        parseExpressionV2(astNode: ExpressionV2): ProjectId;
        parseFqnExprOrWith(astNode: FqnExprOrWith): ProjectId;
        parseFqnExprWith(astNode: FqnExprWith): ProjectId;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseFqnExprWhere(astNode: FqnExprWhere): ProjectId;
        parseFqnExpr(astNode: FqnExpr): ProjectId;
        parseFqnRefExpr(astNode: FqnRefExpr): ProjectId;
        parseFqnExpressions(astNode: FqnExpressions): ProjectId[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): ProjectId;
        parseRelationExprWith(astNode: RelationExprWith): ProjectId;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationExprWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationExpr(astNode: RelationExpr): ProjectId;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
    };
} & {
    new (...args: any[]): {
        parseDeploymentView(astNode: DeploymentView): ParsedAstDeploymentView;
        parseDeploymentViewRule(astRule: DeploymentViewRule): ProjectId;
        parseDeploymentViewRulePredicate(astRule: DeploymentViewRulePredicate): ProjectId;
        parseDeploymentViewRuleStyle(astRule: DeploymentViewRuleStyle): ProjectId;
        parseFqnRef(astNode: FqnRef): ProjectId;
        parseExpressionV2(astNode: ExpressionV2): ProjectId;
        parseFqnExprOrWith(astNode: FqnExprOrWith): ProjectId;
        parseFqnExprWith(astNode: FqnExprWith): ProjectId;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseFqnExprWhere(astNode: FqnExprWhere): ProjectId;
        parseFqnExpr(astNode: FqnExpr): ProjectId;
        parseFqnRefExpr(astNode: FqnRefExpr): ProjectId;
        parseFqnExpressions(astNode: FqnExpressions): ProjectId[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): ProjectId;
        parseRelationExprWith(astNode: RelationExprWith): ProjectId;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationExprWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationExpr(astNode: RelationExpr): ProjectId;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseDeployment(): void;
        parseDeploymentNode(astNode: DeploymentNode): ParsedAstDeployment.Node;
        parseDeployedInstance(astNode: DeployedInstance): ParsedAstDeployment.Instance;
        parseExtendDeployment(astNode: ExtendDeployment): ParsedAstExtend | null;
        _resolveDeploymentRelationSource(node: DeploymentRelation): ProjectId;
        parseDeploymentRelation(astNode: DeploymentRelation): ParsedAstDeploymentRelation;
    };
} & {
    new (...args: any[]): {
        parseDeployment(): void;
        parseDeploymentNode(astNode: DeploymentNode): ParsedAstDeployment.Node;
        parseDeployedInstance(astNode: DeployedInstance): ParsedAstDeployment.Instance;
        parseExtendDeployment(astNode: ExtendDeployment): ParsedAstExtend | null;
        _resolveDeploymentRelationSource(node: DeploymentRelation): ProjectId;
        parseDeploymentRelation(astNode: DeploymentRelation): ParsedAstDeploymentRelation;
        parseFqnRef(astNode: FqnRef): ProjectId;
        parseExpressionV2(astNode: ExpressionV2): ProjectId;
        parseFqnExprOrWith(astNode: FqnExprOrWith): ProjectId;
        parseFqnExprWith(astNode: FqnExprWith): ProjectId;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseFqnExprWhere(astNode: FqnExprWhere): ProjectId;
        parseFqnExpr(astNode: FqnExpr): ProjectId;
        parseFqnRefExpr(astNode: FqnRefExpr): ProjectId;
        parseFqnExpressions(astNode: FqnExpressions): ProjectId[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): ProjectId;
        parseRelationExprWith(astNode: RelationExprWith): ProjectId;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationExprWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationExpr(astNode: RelationExpr): ProjectId;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
    };
} & {
    new (...args: any[]): {
        parseModel(): void;
        parseElement(astNode: Element): ParsedAstElement;
        parseExtendElement(astNode: ExtendElement): ParsedAstExtend | null;
        _resolveRelationSource(node: Relation): ProjectId | ProjectId;
        parseRelation(astNode: Relation): ParsedAstRelation;
        parseFqnRef(astNode: FqnRef): ProjectId;
        parseExpressionV2(astNode: ExpressionV2): ProjectId;
        parseFqnExprOrWith(astNode: FqnExprOrWith): ProjectId;
        parseFqnExprWith(astNode: FqnExprWith): ProjectId;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseFqnExprWhere(astNode: FqnExprWhere): ProjectId;
        parseFqnExpr(astNode: FqnExpr): ProjectId;
        parseFqnRefExpr(astNode: FqnRefExpr): ProjectId;
        parseFqnExpressions(astNode: FqnExpressions): ProjectId[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): ProjectId;
        parseRelationExprWith(astNode: RelationExprWith): ProjectId;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationExprWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationExpr(astNode: RelationExpr): ProjectId;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
    };
} & {
    new (...args: any[]): {
        parseImports(): void;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
    };
} & {
    new (...args: any[]): {
        parseFqnRef(astNode: FqnRef): ProjectId;
        parseExpressionV2(astNode: ExpressionV2): ProjectId;
        parseFqnExprOrWith(astNode: FqnExprOrWith): ProjectId;
        parseFqnExprWith(astNode: FqnExprWith): ProjectId;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): ProjectId;
        parseFqnExprWhere(astNode: FqnExprWhere): ProjectId;
        parseFqnExpr(astNode: FqnExpr): ProjectId;
        parseFqnRefExpr(astNode: FqnRefExpr): ProjectId;
        parseFqnExpressions(astNode: FqnExpressions): ProjectId[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): ProjectId;
        parseRelationExprWith(astNode: RelationExprWith): ProjectId;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): ProjectId;
        parseRelationExprWhere(astNode: RelationExprWhere): ProjectId;
        parseRelationExpr(astNode: RelationExpr): ProjectId;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        readonly project: {
            id: ProjectId;
            folder: ProjectId;
            config: Readonly<ProjectConfig>;
        };
        resolveFqn(node: FqnReferenceable): ProjectId;
        getAstNodePath(node: ProjectId): any;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string;
        } | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): any;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): ProjectId<ProjectId> | null;
        convertLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): ProjectId[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): ProjectId | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
    };
} & typeof BaseParser;
declare class DocumentParser extends DocumentParserFromMixins {
}
declare class LikeC4ModelParser {
    private services;
    protected cachedParsers: any;
    constructor(services: LikeC4Services);
    documents(projectId: ProjectId): Stream<ParsedLikeC4LangiumDocument>;
    parse(doc: LangiumDocument): ParsedLikeC4LangiumDocument;
    forDocument(doc: LangiumDocument): DocumentParser;
    private createParser;
}

/**
 * Request to locate an element, relation, deployment or view.
 * If LSP has multiple projects, the projectId is required.
 */
declare namespace Locate {
    type Params = {
        element: Fqn;
        projectId?: string | undefined;
        property?: string;
    } | {
        projectId?: string | undefined;
        relation: RelationId;
    } | {
        deployment: Fqn;
        projectId?: string | undefined;
        property?: string;
    } | {
        view: ViewId;
        projectId?: string | undefined;
    };
    type Res = Location | null;
    const Req: RequestType<Params, Res, void>;
    type Req = typeof Req;
}
/**
 * Request to change the view
 * If LSP has multiple projects, the projectId is required.
 */
declare namespace ChangeView {
    type Params = {
        viewId: ViewId;
        change: ViewChange;
        projectId?: string | undefined;
    };
    type Res = Location | null;
    const Req: RequestType<Params, Res, void>;
    type Req = typeof Req;
}

type GraphvizOut = {
    dot: string;
    diagram: DiagramView;
};
type GraphvizSvgOut = {
    id: ViewId;
    dot: string;
    svg: string;
};
interface LikeC4Views {
    readonly layouter: GraphvizLayouter;
    computedViews(projectId?: ProjectId | undefined, cancelToken?: CancellationToken): Promise<ComputedView[]>;
    layoutAllViews(projectId?: ProjectId | undefined, cancelToken?: CancellationToken): Promise<Array<Readonly<GraphvizOut>>>;
    layoutView(viewId: ViewId, projectId?: ProjectId | undefined, cancelToken?: CancellationToken): Promise<GraphvizOut | null>;
    diagrams(projectId?: ProjectId | undefined, cancelToken?: CancellationToken): Promise<Array<DiagramView>>;
    viewsAsGraphvizOut(projectId?: ProjectId | undefined, cancelToken?: CancellationToken): Promise<Array<GraphvizSvgOut>>;
    overviewGraph(): Promise<OverviewGraph>;
}

interface LikeC4LanguageServices {
    readonly views: LikeC4Views;
    readonly builder: LikeC4ModelBuilder;
    readonly workspaceUri: URI;
    readonly projectsManager: ProjectsManager;
    projects(): NonEmptyArray<{
        id: ProjectId;
        folder: URI;
        config: ProjectConfig;
        documents: NonEmptyArray<URI> | null;
    }>;
    diagrams(): Promise<DiagramView[]>;
    computedModel(project?: ProjectId | undefined): Promise<LikeC4Model.Computed>;
    layoutedModel(project?: ProjectId | undefined): Promise<LikeC4Model.Layouted>;
    getErrors(): Array<{
        message: string;
        line: number;
        range: Range$1;
        sourceFsPath: string;
    }>;
    notifyUpdate(update: {
        changed?: string;
        removed?: string;
    }): Promise<boolean>;
    locate(params: Locate.Params): Locate.Res;
}

declare class LikeC4CodeLensProvider implements CodeLensProvider {
    private services;
    constructor(services: LikeC4Services);
    provideCodeLens(doc: LangiumDocument, _params: CodeLensParams, cancelToken?: CancellationToken): Promise<CodeLens[] | undefined>;
}

declare class LikeC4CompletionProvider extends DefaultCompletionProvider {
    protected services: LikeC4Services;
    constructor(services: LikeC4Services);
    readonly completionOptions: CompletionProviderOptions;
    protected completionForKeyword(context: CompletionContext, keyword: Keyword, acceptor: CompletionAcceptor): MaybePromise$1<void>;
}

declare class LikeC4DocumentHighlightProvider extends DefaultDocumentHighlightProvider {
    /**
     * Override this method to determine the highlight kind of the given reference.
     */
    protected createDocumentHighlight(reference: ReferenceDescription): DocumentHighlight;
}

declare class LikeC4DocumentLinkProvider implements DocumentLinkProvider {
    private services;
    constructor(services: LikeC4Services);
    getDocumentLinks(doc: LangiumDocument, _params: DocumentLinkParams, cancelToken?: CancellationToken): Promise<DocumentLink[]>;
    resolveLink(doc: LangiumDocument, link: string): string;
    relativeLink(doc: LangiumDocument, link: string): string | null;
}

declare class LikeC4DocumentSymbolProvider implements DocumentSymbolProvider {
    private services;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    protected readonly nameProvider: LikeC4NameProvider;
    protected readonly parser: LikeC4ModelParser;
    protected readonly locator: LikeC4ModelLocator;
    constructor(services: LikeC4Services);
    getSymbols(doc: LangiumDocument, _params: DocumentSymbolParams, cancelToken?: CancellationToken): Promise<DocumentSymbol[]>;
    protected getLikec4LibSymbol(astLib: LikeC4Lib): DocumentSymbol[];
    protected getSpecSymbol(astSpec: SpecificationRule): DocumentSymbol[];
    protected getModelSymbol(astModel: Model): DocumentSymbol[];
    protected getDeploymentModelSymbol(astModel: ModelDeployments): DocumentSymbol[];
    protected getElementsSymbol(el: Element | Relation | ExtendElement): DocumentSymbol[];
    protected getExtendElementSymbol(astElement: ExtendElement): DocumentSymbol[];
    protected getElementSymbol(astElement: Element): DocumentSymbol[];
    protected getModelViewsSymbol(astViews: ModelViews): DocumentSymbol[];
    protected getKindSymbol(astKind: SpecificationElementKind | SpecificationRelationshipKind): DocumentSymbol | null;
    protected getTagSymbol(astTag: SpecificationTag): DocumentSymbol | null;
    protected getLibIconSymbol(astTag: LibIcon): DocumentSymbol | null;
    protected getViewSymbol(astView: LikeC4View): DocumentSymbol[];
    protected getDeploymentElementSymbol(el: DeploymentElement | DeploymentRelation | ExtendDeployment): DocumentSymbol[];
    protected getDeploymentNodeSymbol(astElement: DeploymentNode): DocumentSymbol[];
    protected getDeployedInstanceSymbol(astElement: DeployedInstance): DocumentSymbol[];
    protected symbolKind(node: AstNode): SymbolKind;
}

declare class LikeC4HoverProvider extends AstNodeHoverProvider {
    private parser;
    private locator;
    constructor(services: LikeC4Services);
    protected getAstNodeHoverContent(node: AstNode): MaybePromise$1<Hover | undefined>;
}

declare class LikeC4SemanticTokenProvider extends AbstractSemanticTokenProvider {
    protected highlightElement(node: AstNode, acceptor: SemanticTokenAcceptor): void | undefined | 'prune';
    private highlightNameAndKind;
    private highlightView;
}

type Primitive$1 = string | number | symbol | bigint | boolean | null | undefined;

declare namespace util {
    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;
    export type isAny<T> = 0 extends 1 & T ? true : false;
    export const assertEqual: <A, B>(val: AssertEqual<A, B>) => AssertEqual<A, B>;
    export function assertIs<T>(_arg: T): void;
    export function assertNever(_x: never): never;
    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
    export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;
    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };
    export const getValidEnumValues: (obj: any) => any[];
    export const objectValues: (obj: any) => any[];
    export const objectKeys: ObjectConstructor["keys"];
    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;
    export type identity<T> = objectUtil.identity<T>;
    export type flatten<T> = objectUtil.flatten<T>;
    export type noUndefined<T> = T extends undefined ? never : T;
    export const isInteger: NumberConstructor["isInteger"];
    export function joinValues<T extends any[]>(array: T, separator?: string): string;
    export const jsonStringifyReplacer: (_: string, value: any) => any;
    export {  };
}
declare namespace objectUtil {
    export type MergeShapes<U, V> = keyof U & keyof V extends never ? U & V : {
        [k in Exclude<keyof U, keyof V>]: U[k];
    } & V;
    type optionalKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? k : never;
    }[keyof T];
    type requiredKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? never : k;
    }[keyof T];
    export type addQuestionMarks<T extends object, _O = any> = {
        [K in requiredKeys<T>]: T[K];
    } & {
        [K in optionalKeys<T>]?: T[K];
    } & {
        [k in keyof T]?: unknown;
    };
    export type identity<T> = T;
    export type flatten<T> = identity<{
        [k in keyof T]: T[k];
    }>;
    export type noNeverKeys<T> = {
        [k in keyof T]: [T[k]] extends [never] ? never : k;
    }[keyof T];
    export type noNever<T> = identity<{
        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
    }>;
    export const mergeShapes: <U, T>(first: U, second: T) => T & U;
    export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never ? A & B : {
        [K in keyof A as K extends keyof B ? never : K]: A[K];
    } & {
        [K in keyof B]: B[K];
    };
    export {  };
}
declare const ZodParsedType: {
    string: "string";
    number: "number";
    bigint: "bigint";
    boolean: "boolean";
    symbol: "symbol";
    undefined: "undefined";
    object: "object";
    function: "function";
    map: "map";
    nan: "nan";
    integer: "integer";
    float: "float";
    date: "date";
    null: "null";
    array: "array";
    unknown: "unknown";
    promise: "promise";
    void: "void";
    never: "never";
    set: "set";
};
type ZodParsedType = keyof typeof ZodParsedType;

type allKeys<T> = T extends any ? keyof T : never;
type typeToFlattenedError<T, U = string> = {
    formErrors: U[];
    fieldErrors: {
        [P in allKeys<T>]?: U[];
    };
};
declare const ZodIssueCode: {
    invalid_type: "invalid_type";
    invalid_literal: "invalid_literal";
    custom: "custom";
    invalid_union: "invalid_union";
    invalid_union_discriminator: "invalid_union_discriminator";
    invalid_enum_value: "invalid_enum_value";
    unrecognized_keys: "unrecognized_keys";
    invalid_arguments: "invalid_arguments";
    invalid_return_type: "invalid_return_type";
    invalid_date: "invalid_date";
    invalid_string: "invalid_string";
    too_small: "too_small";
    too_big: "too_big";
    invalid_intersection_types: "invalid_intersection_types";
    not_multiple_of: "not_multiple_of";
    not_finite: "not_finite";
};
type ZodIssueCode = keyof typeof ZodIssueCode;
type ZodIssueBase = {
    path: (string | number)[];
    message?: string;
};
interface ZodInvalidTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_type;
    expected: ZodParsedType;
    received: ZodParsedType;
}
interface ZodInvalidLiteralIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_literal;
    expected: unknown;
    received: unknown;
}
interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.unrecognized_keys;
    keys: string[];
}
interface ZodInvalidUnionIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union;
    unionErrors: ZodError[];
}
interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union_discriminator;
    options: Primitive$1[];
}
interface ZodInvalidEnumValueIssue extends ZodIssueBase {
    received: string | number;
    code: typeof ZodIssueCode.invalid_enum_value;
    options: (string | number)[];
}
interface ZodInvalidArgumentsIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_arguments;
    argumentsError: ZodError;
}
interface ZodInvalidReturnTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_return_type;
    returnTypeError: ZodError;
}
interface ZodInvalidDateIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_date;
}
type StringValidation = "email" | "url" | "emoji" | "uuid" | "nanoid" | "regex" | "cuid" | "cuid2" | "ulid" | "datetime" | "date" | "time" | "duration" | "ip" | "cidr" | "base64" | "jwt" | "base64url" | {
    includes: string;
    position?: number;
} | {
    startsWith: string;
} | {
    endsWith: string;
};
interface ZodInvalidStringIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_string;
    validation: StringValidation;
}
interface ZodTooSmallIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_small;
    minimum: number | bigint;
    inclusive: boolean;
    exact?: boolean;
    type: "array" | "string" | "number" | "set" | "date" | "bigint";
}
interface ZodTooBigIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_big;
    maximum: number | bigint;
    inclusive: boolean;
    exact?: boolean;
    type: "array" | "string" | "number" | "set" | "date" | "bigint";
}
interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_intersection_types;
}
interface ZodNotMultipleOfIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_multiple_of;
    multipleOf: number | bigint;
}
interface ZodNotFiniteIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_finite;
}
interface ZodCustomIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params?: {
        [k: string]: any;
    };
}
type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;
type ZodIssue = ZodIssueOptionalMessage & {
    fatal?: boolean;
    message: string;
};
type recursiveZodFormattedError<T> = T extends [any, ...any[]] ? {
    [K in keyof T]?: ZodFormattedError<T[K]>;
} : T extends any[] ? {
    [k: number]: ZodFormattedError<T[number]>;
} : T extends object ? {
    [K in keyof T]?: ZodFormattedError<T[K]>;
} : unknown;
type ZodFormattedError<T, U = string> = {
    _errors: U[];
} & recursiveZodFormattedError<NonNullable<T>>;
declare class ZodError<T = any> extends Error {
    issues: ZodIssue[];
    get errors(): ZodIssue[];
    constructor(issues: ZodIssue[]);
    format(): ZodFormattedError<T>;
    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;
    static create: (issues: ZodIssue[]) => ZodError<any>;
    static assert(value: unknown): asserts value is ZodError;
    toString(): string;
    get message(): string;
    get isEmpty(): boolean;
    addIssue: (sub: ZodIssue) => void;
    addIssues: (subs?: ZodIssue[]) => void;
    flatten(): typeToFlattenedError<T>;
    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;
    get formErrors(): typeToFlattenedError<T, string>;
}
type stripPath<T extends object> = T extends any ? util.OmitKeys<T, "path"> : never;
type IssueData = stripPath<ZodIssueOptionalMessage> & {
    path?: (string | number)[];
    fatal?: boolean;
};
type ErrorMapCtx = {
    defaultError: string;
    data: any;
};
type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {
    message: string;
};

type ParseParams = {
    path: (string | number)[];
    errorMap: ZodErrorMap;
    async: boolean;
};
type ParsePathComponent = string | number;
type ParsePath = ParsePathComponent[];
interface ParseContext {
    readonly common: {
        readonly issues: ZodIssue[];
        readonly contextualErrorMap?: ZodErrorMap;
        readonly async: boolean;
    };
    readonly path: ParsePath;
    readonly schemaErrorMap?: ZodErrorMap;
    readonly parent: ParseContext | null;
    readonly data: any;
    readonly parsedType: ZodParsedType;
}
type ParseInput = {
    data: any;
    path: (string | number)[];
    parent: ParseContext;
};
declare class ParseStatus {
    value: "aborted" | "dirty" | "valid";
    dirty(): void;
    abort(): void;
    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;
    static mergeObjectAsync(status: ParseStatus, pairs: {
        key: ParseReturnType<any>;
        value: ParseReturnType<any>;
    }[]): Promise<SyncParseReturnType<any>>;
    static mergeObjectSync(status: ParseStatus, pairs: {
        key: SyncParseReturnType<any>;
        value: SyncParseReturnType<any>;
        alwaysSet?: boolean;
    }[]): SyncParseReturnType;
}
type INVALID = {
    status: "aborted";
};
declare const INVALID: INVALID;
type DIRTY<T> = {
    status: "dirty";
    value: T;
};
declare const DIRTY: <T>(value: T) => DIRTY<T>;
type OK<T> = {
    status: "valid";
    value: T;
};
declare const OK: <T>(value: T) => OK<T>;
type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;

declare namespace enumUtil {
    type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (k: infer Intersection) => void ? Intersection : never;
    type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;
    type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
    type CastToStringTuple<T> = T extends [string, ...string[]] ? T : never;
    export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;
    export {  };
}

declare namespace errorUtil {
    type ErrMessage = string | {
        message?: string;
    };
    const errToObj: (message?: ErrMessage) => {
        message?: string | undefined;
    };
    const toString: (message?: ErrMessage) => string | undefined;
}

declare namespace partialUtil {
    type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<ZodRawShape> ? ZodObject<{
        [k in keyof T["shape"]]: ZodOptional<DeepPartial<T["shape"][k]>>;
    }, T["_def"]["unknownKeys"], T["_def"]["catchall"]> : T extends ZodArray<infer Type, infer Card> ? ZodArray<DeepPartial<Type>, Card> : T extends ZodOptional<infer Type> ? ZodOptional<DeepPartial<Type>> : T extends ZodNullable<infer Type> ? ZodNullable<DeepPartial<Type>> : T extends ZodTuple<infer Items> ? {
        [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;
    } extends infer PI ? PI extends ZodTupleItems ? ZodTuple<PI> : never : never : T;
}

/**
 * The Standard Schema interface.
 */
type StandardSchemaV1<Input = unknown, Output = Input> = {
    /**
     * The Standard Schema properties.
     */
    readonly "~standard": StandardSchemaV1.Props<Input, Output>;
};
declare namespace StandardSchemaV1 {
    /**
     * The Standard Schema properties interface.
     */
    export interface Props<Input = unknown, Output = Input> {
        /**
         * The version number of the standard.
         */
        readonly version: 1;
        /**
         * The vendor name of the schema library.
         */
        readonly vendor: string;
        /**
         * Validates unknown input values.
         */
        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;
        /**
         * Inferred types associated with the schema.
         */
        readonly types?: Types<Input, Output> | undefined;
    }
    /**
     * The result interface of the validate function.
     */
    export type Result<Output> = SuccessResult<Output> | FailureResult;
    /**
     * The result interface if validation succeeds.
     */
    export interface SuccessResult<Output> {
        /**
         * The typed output value.
         */
        readonly value: Output;
        /**
         * The non-existent issues.
         */
        readonly issues?: undefined;
    }
    /**
     * The result interface if validation fails.
     */
    export interface FailureResult {
        /**
         * The issues of failed validation.
         */
        readonly issues: ReadonlyArray<Issue>;
    }
    /**
     * The issue interface of the failure output.
     */
    export interface Issue {
        /**
         * The error message of the issue.
         */
        readonly message: string;
        /**
         * The path of the issue, if any.
         */
        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;
    }
    /**
     * The path segment interface of the issue.
     */
    export interface PathSegment {
        /**
         * The key representing a path segment.
         */
        readonly key: PropertyKey;
    }
    /**
     * The Standard Schema types interface.
     */
    export interface Types<Input = unknown, Output = Input> {
        /**
         * The input type of the schema.
         */
        readonly input: Input;
        /**
         * The output type of the schema.
         */
        readonly output: Output;
    }
    /**
     * Infers the input type of a Standard Schema.
     */
    export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema["~standard"]["types"]>["input"];
    /**
     * Infers the output type of a Standard Schema.
     */
    export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema["~standard"]["types"]>["output"];
    export {  };
}

interface RefinementCtx {
    addIssue: (arg: IssueData) => void;
    path: (string | number)[];
}
type ZodRawShape = {
    [k: string]: ZodTypeAny;
};
type ZodTypeAny = ZodType<any, any, any>;
type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
type input<T extends ZodType<any, any, any>> = T["_input"];
type output<T extends ZodType<any, any, any>> = T["_output"];

type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
interface ZodTypeDef {
    errorMap?: ZodErrorMap;
    description?: string;
}
type RawCreateParams = {
    errorMap?: ZodErrorMap;
    invalid_type_error?: string;
    required_error?: string;
    message?: string;
    description?: string;
} | undefined;
type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
    error?: never;
};
type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
    data?: never;
};
type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;
declare abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
    readonly _type: Output;
    readonly _output: Output;
    readonly _input: Input;
    readonly _def: Def;
    get description(): string | undefined;
    "~standard": StandardSchemaV1.Props<Input, Output>;
    abstract _parse(input: ParseInput): ParseReturnType<Output>;
    _getType(input: ParseInput): string;
    _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext;
    _processInputParams(input: ParseInput): {
        status: ParseStatus;
        ctx: ParseContext;
    };
    _parseSync(input: ParseInput): SyncParseReturnType<Output>;
    _parseAsync(input: ParseInput): AsyncParseReturnType<Output>;
    parse(data: unknown, params?: Partial<ParseParams>): Output;
    safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;
    "~validate"(data: unknown): StandardSchemaV1.Result<Output> | Promise<StandardSchemaV1.Result<Output>>;
    parseAsync(data: unknown, params?: Partial<ParseParams>): Promise<Output>;
    safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;
    /** Alias of safeParseAsync */
    spa: (data: unknown, params?: Partial<ParseParams>) => Promise<SafeParseReturnType<Input, Output>>;
    refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;
    refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;
    refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, RefinedOutput, Input>;
    refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, Output, Input>;
    _refinement(refinement: RefinementEffect<Output>["refinement"]): ZodEffects<this, Output, Input>;
    superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>): ZodEffects<this, Output, Input>;
    constructor(def: Def);
    optional(): ZodOptional<this>;
    nullable(): ZodNullable<this>;
    nullish(): ZodOptional<ZodNullable<this>>;
    array(): ZodArray<this>;
    promise(): ZodPromise<this>;
    or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]>;
    and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T>;
    transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;
    default(def: util.noUndefined<Input>): ZodDefault<this>;
    default(def: () => util.noUndefined<Input>): ZodDefault<this>;
    brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;
    catch(def: Output): ZodCatch<this>;
    catch(def: (ctx: {
        error: ZodError;
        input: Input;
    }) => Output): ZodCatch<this>;
    describe(description: string): this;
    pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;
    readonly(): ZodReadonly<this>;
    isOptional(): boolean;
    isNullable(): boolean;
}
type IpVersion = "v4" | "v6";
type ZodStringCheck = {
    kind: "min";
    value: number;
    message?: string;
} | {
    kind: "max";
    value: number;
    message?: string;
} | {
    kind: "length";
    value: number;
    message?: string;
} | {
    kind: "email";
    message?: string;
} | {
    kind: "url";
    message?: string;
} | {
    kind: "emoji";
    message?: string;
} | {
    kind: "uuid";
    message?: string;
} | {
    kind: "nanoid";
    message?: string;
} | {
    kind: "cuid";
    message?: string;
} | {
    kind: "includes";
    value: string;
    position?: number;
    message?: string;
} | {
    kind: "cuid2";
    message?: string;
} | {
    kind: "ulid";
    message?: string;
} | {
    kind: "startsWith";
    value: string;
    message?: string;
} | {
    kind: "endsWith";
    value: string;
    message?: string;
} | {
    kind: "regex";
    regex: RegExp;
    message?: string;
} | {
    kind: "trim";
    message?: string;
} | {
    kind: "toLowerCase";
    message?: string;
} | {
    kind: "toUpperCase";
    message?: string;
} | {
    kind: "jwt";
    alg?: string;
    message?: string;
} | {
    kind: "datetime";
    offset: boolean;
    local: boolean;
    precision: number | null;
    message?: string;
} | {
    kind: "date";
    message?: string;
} | {
    kind: "time";
    precision: number | null;
    message?: string;
} | {
    kind: "duration";
    message?: string;
} | {
    kind: "ip";
    version?: IpVersion;
    message?: string;
} | {
    kind: "cidr";
    version?: IpVersion;
    message?: string;
} | {
    kind: "base64";
    message?: string;
} | {
    kind: "base64url";
    message?: string;
};
interface ZodStringDef extends ZodTypeDef {
    checks: ZodStringCheck[];
    typeName: ZodFirstPartyTypeKind.ZodString;
    coerce: boolean;
}
declare class ZodString extends ZodType<string, ZodStringDef, string> {
    _parse(input: ParseInput): ParseReturnType<string>;
    protected _regex(regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage): ZodEffects<this, string, string>;
    _addCheck(check: ZodStringCheck): ZodString;
    email(message?: errorUtil.ErrMessage): ZodString;
    url(message?: errorUtil.ErrMessage): ZodString;
    emoji(message?: errorUtil.ErrMessage): ZodString;
    uuid(message?: errorUtil.ErrMessage): ZodString;
    nanoid(message?: errorUtil.ErrMessage): ZodString;
    cuid(message?: errorUtil.ErrMessage): ZodString;
    cuid2(message?: errorUtil.ErrMessage): ZodString;
    ulid(message?: errorUtil.ErrMessage): ZodString;
    base64(message?: errorUtil.ErrMessage): ZodString;
    base64url(message?: errorUtil.ErrMessage): ZodString;
    jwt(options?: {
        alg?: string;
        message?: string;
    }): ZodString;
    ip(options?: string | {
        version?: IpVersion;
        message?: string;
    }): ZodString;
    cidr(options?: string | {
        version?: IpVersion;
        message?: string;
    }): ZodString;
    datetime(options?: string | {
        message?: string | undefined;
        precision?: number | null;
        offset?: boolean;
        local?: boolean;
    }): ZodString;
    date(message?: string): ZodString;
    time(options?: string | {
        message?: string | undefined;
        precision?: number | null;
    }): ZodString;
    duration(message?: errorUtil.ErrMessage): ZodString;
    regex(regex: RegExp, message?: errorUtil.ErrMessage): ZodString;
    includes(value: string, options?: {
        message?: string;
        position?: number;
    }): ZodString;
    startsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
    endsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
    min(minLength: number, message?: errorUtil.ErrMessage): ZodString;
    max(maxLength: number, message?: errorUtil.ErrMessage): ZodString;
    length(len: number, message?: errorUtil.ErrMessage): ZodString;
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message?: errorUtil.ErrMessage): ZodString;
    trim(): ZodString;
    toLowerCase(): ZodString;
    toUpperCase(): ZodString;
    get isDatetime(): boolean;
    get isDate(): boolean;
    get isTime(): boolean;
    get isDuration(): boolean;
    get isEmail(): boolean;
    get isURL(): boolean;
    get isEmoji(): boolean;
    get isUUID(): boolean;
    get isNANOID(): boolean;
    get isCUID(): boolean;
    get isCUID2(): boolean;
    get isULID(): boolean;
    get isIP(): boolean;
    get isCIDR(): boolean;
    get isBase64(): boolean;
    get isBase64url(): boolean;
    get minLength(): number | null;
    get maxLength(): number | null;
    static create: (params?: RawCreateParams & {
        coerce?: true;
    }) => ZodString;
}
type ZodNumberCheck = {
    kind: "min";
    value: number;
    inclusive: boolean;
    message?: string;
} | {
    kind: "max";
    value: number;
    inclusive: boolean;
    message?: string;
} | {
    kind: "int";
    message?: string;
} | {
    kind: "multipleOf";
    value: number;
    message?: string;
} | {
    kind: "finite";
    message?: string;
};
interface ZodNumberDef extends ZodTypeDef {
    checks: ZodNumberCheck[];
    typeName: ZodFirstPartyTypeKind.ZodNumber;
    coerce: boolean;
}
declare class ZodNumber extends ZodType<number, ZodNumberDef, number> {
    _parse(input: ParseInput): ParseReturnType<number>;
    static create: (params?: RawCreateParams & {
        coerce?: boolean;
    }) => ZodNumber;
    gte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    min: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    gt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    lte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    max: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    lt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    protected setLimit(kind: "min" | "max", value: number, inclusive: boolean, message?: string): ZodNumber;
    _addCheck(check: ZodNumberCheck): ZodNumber;
    int(message?: errorUtil.ErrMessage): ZodNumber;
    positive(message?: errorUtil.ErrMessage): ZodNumber;
    negative(message?: errorUtil.ErrMessage): ZodNumber;
    nonpositive(message?: errorUtil.ErrMessage): ZodNumber;
    nonnegative(message?: errorUtil.ErrMessage): ZodNumber;
    multipleOf(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    step: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    finite(message?: errorUtil.ErrMessage): ZodNumber;
    safe(message?: errorUtil.ErrMessage): ZodNumber;
    get minValue(): number | null;
    get maxValue(): number | null;
    get isInt(): boolean;
    get isFinite(): boolean;
}
interface ZodBooleanDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodBoolean;
    coerce: boolean;
}
declare class ZodBoolean extends ZodType<boolean, ZodBooleanDef, boolean> {
    _parse(input: ParseInput): ParseReturnType<boolean>;
    static create: (params?: RawCreateParams & {
        coerce?: boolean;
    }) => ZodBoolean;
}
interface ZodUnknownDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodUnknown;
}
declare class ZodUnknown extends ZodType<unknown, ZodUnknownDef, unknown> {
    _unknown: true;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: (params?: RawCreateParams) => ZodUnknown;
}
interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodArray;
    exactLength: {
        value: number;
        message?: string;
    } | null;
    minLength: {
        value: number;
        message?: string;
    } | null;
    maxLength: {
        value: number;
        message?: string;
    } | null;
}
type ArrayCardinality = "many" | "atleastone";
type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> = Cardinality extends "atleastone" ? [T["_output"], ...T["_output"][]] : T["_output"][];
declare class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> extends ZodType<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends "atleastone" ? [T["_input"], ...T["_input"][]] : T["_input"][]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get element(): T;
    min(minLength: number, message?: errorUtil.ErrMessage): this;
    max(maxLength: number, message?: errorUtil.ErrMessage): this;
    length(len: number, message?: errorUtil.ErrMessage): this;
    nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone">;
    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodArray<T_1, "many">;
}
type UnknownKeysParam = "passthrough" | "strict" | "strip";
interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodObject;
    shape: () => T;
    catchall: Catchall;
    unknownKeys: UnknownKeys;
}
type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>> & CatchallOutput<Catchall> & PassthroughType<UnknownKeys>;
type baseObjectOutputType<Shape extends ZodRawShape> = {
    [k in keyof Shape]: Shape[k]["_output"];
};
type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<baseObjectInputType<Shape>> & CatchallInput<Catchall> & PassthroughType<UnknownKeys>;
type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_input"];
}>;
type CatchallOutput<T extends ZodType> = ZodType extends T ? unknown : {
    [k: string]: T["_output"];
};
type CatchallInput<T extends ZodType> = ZodType extends T ? unknown : {
    [k: string]: T["_input"];
};
type PassthroughType<T extends UnknownKeysParam> = T extends "passthrough" ? {
    [k: string]: unknown;
} : unknown;
type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T extends ZodNullable<infer U> ? ZodNullable<deoptional<U>> : T;
declare class ZodObject<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall, UnknownKeys>, Input = objectInputType<T, Catchall, UnknownKeys>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
    private _cached;
    _getCached(): {
        shape: T;
        keys: string[];
    };
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get shape(): T;
    strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall>;
    strip(): ZodObject<T, "strip", Catchall>;
    passthrough(): ZodObject<T, "passthrough", Catchall>;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    nonstrict: () => ZodObject<T, "passthrough", Catchall>;
    extend<Augmentation extends ZodRawShape>(augmentation: Augmentation): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;
    /**
     * @deprecated Use `.extend` instead
     *  */
    augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge<Incoming extends AnyZodObject, Augmentation extends Incoming["shape"]>(merging: Incoming): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming["_def"]["unknownKeys"], Incoming["_def"]["catchall"]>;
    setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject<T & {
        [k in Key]: Schema;
    }, UnknownKeys, Catchall>;
    catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index>;
    pick<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;
    omit<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall>;
    /**
     * @deprecated
     */
    deepPartial(): partialUtil.DeepPartial<this>;
    partial(): ZodObject<{
        [k in keyof T]: ZodOptional<T[k]>;
    }, UnknownKeys, Catchall>;
    partial<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
    required(): ZodObject<{
        [k in keyof T]: deoptional<T[k]>;
    }, UnknownKeys, Catchall>;
    required<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
    keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>>;
    static create: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strip", ZodTypeAny, objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any> extends infer T_2 ? { [k in keyof T_2]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k]; } : never, baseObjectInputType<T_1> extends infer T_3 ? { [k_1 in keyof T_3]: baseObjectInputType<T_1>[k_1]; } : never>;
    static strictCreate: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strict", ZodTypeAny, objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any> extends infer T_2 ? { [k in keyof T_2]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k]; } : never, baseObjectInputType<T_1> extends infer T_3 ? { [k_1 in keyof T_3]: baseObjectInputType<T_1>[k_1]; } : never>;
    static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1, params?: RawCreateParams) => ZodObject<T_1, "strip", ZodTypeAny, objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any> extends infer T_2 ? { [k in keyof T_2]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k]; } : never, baseObjectInputType<T_1> extends infer T_3 ? { [k_1 in keyof T_3]: baseObjectInputType<T_1>[k_1]; } : never>;
}
type AnyZodObject = ZodObject<any, any, any>;
type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[
    ZodTypeAny,
    ZodTypeAny,
    ...ZodTypeAny[]
]>> extends ZodTypeDef {
    options: T;
    typeName: ZodFirstPartyTypeKind.ZodUnion;
}
declare class ZodUnion<T extends ZodUnionOptions> extends ZodType<T[number]["_output"], ZodUnionDef<T>, T[number]["_input"]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get options(): T;
    static create: <T_1 extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T_1, params?: RawCreateParams) => ZodUnion<T_1>;
}
type ZodDiscriminatedUnionOption<Discriminator extends string> = ZodObject<{
    [key in Discriminator]: ZodTypeAny;
} & ZodRawShape, UnknownKeysParam, ZodTypeAny>;
interface ZodDiscriminatedUnionDef<Discriminator extends string, Options extends readonly ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[]> extends ZodTypeDef {
    discriminator: Discriminator;
    options: Options;
    optionsMap: Map<Primitive$1, ZodDiscriminatedUnionOption<any>>;
    typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
}
declare class ZodDiscriminatedUnion<Discriminator extends string, Options extends readonly ZodDiscriminatedUnionOption<Discriminator>[]> extends ZodType<output<Options[number]>, ZodDiscriminatedUnionDef<Discriminator, Options>, input<Options[number]>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get discriminator(): Discriminator;
    get options(): Options;
    get optionsMap(): Map<Primitive$1, ZodDiscriminatedUnionOption<any>>;
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create<Discriminator extends string, Types extends readonly [
        ZodDiscriminatedUnionOption<Discriminator>,
        ...ZodDiscriminatedUnionOption<Discriminator>[]
    ]>(discriminator: Discriminator, options: Types, params?: RawCreateParams): ZodDiscriminatedUnion<Discriminator, Types>;
}
interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    left: T;
    right: U;
    typeName: ZodFirstPartyTypeKind.ZodIntersection;
}
declare class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<T["_output"] & U["_output"], ZodIntersectionDef<T, U>, T["_input"] & U["_input"]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <T_1 extends ZodTypeAny, U_1 extends ZodTypeAny>(left: T_1, right: U_1, params?: RawCreateParams) => ZodIntersection<T_1, U_1>;
}
type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
type AssertArray<T> = T extends any[] ? T : never;
type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k]["_output"] : never;
}>;
type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest["_output"][]] : OutputTypeOfTuple<T>;
type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k]["_input"] : never;
}>;
type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest["_input"][]] : InputTypeOfTuple<T>;
interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {
    items: T;
    rest: Rest;
    typeName: ZodFirstPartyTypeKind.ZodTuple;
}
declare class ZodTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]], Rest extends ZodTypeAny | null = null> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get items(): T;
    rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest>;
    static create: <T_1 extends [] | [ZodTypeAny, ...ZodTypeAny[]]>(schemas: T_1, params?: RawCreateParams) => ZodTuple<T_1, null>;
}
interface ZodLiteralDef<T = any> extends ZodTypeDef {
    value: T;
    typeName: ZodFirstPartyTypeKind.ZodLiteral;
}
declare class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>, T> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get value(): T;
    static create: <T_1 extends Primitive$1>(value: T_1, params?: RawCreateParams) => ZodLiteral<T_1>;
}
type EnumValues<T extends string = string> = readonly [T, ...T[]];
type Values<T extends EnumValues> = {
    [k in T[number]]: k;
};
interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {
    values: T;
    typeName: ZodFirstPartyTypeKind.ZodEnum;
}
type Writeable<T> = {
    -readonly [P in keyof T]: T[P];
};
type FilterEnum<Values, ToExclude> = Values extends [] ? [] : Values extends [infer Head, ...infer Rest] ? Head extends ToExclude ? FilterEnum<Rest, ToExclude> : [Head, ...FilterEnum<Rest, ToExclude>] : never;
type typecast<A, T> = A extends T ? A : never;
declare function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;
declare function createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum<T>;
declare class ZodEnum<T extends [string, ...string[]]> extends ZodType<T[number], ZodEnumDef<T>, T[number]> {
    #private;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get options(): T;
    get enum(): Values<T>;
    get Values(): Values<T>;
    get Enum(): Values<T>;
    extract<ToExtract extends readonly [T[number], ...T[number][]]>(values: ToExtract, newDef?: RawCreateParams): ZodEnum<Writeable<ToExtract>>;
    exclude<ToExclude extends readonly [T[number], ...T[number][]]>(values: ToExclude, newDef?: RawCreateParams): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>>;
    static create: typeof createZodEnum;
}
interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodPromise;
}
declare class ZodPromise<T extends ZodTypeAny> extends ZodType<Promise<T["_output"]>, ZodPromiseDef<T>, Promise<T["_input"]>> {
    unwrap(): T;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodPromise<T_1>;
}
type RefinementEffect<T> = {
    type: "refinement";
    refinement: (arg: T, ctx: RefinementCtx) => any;
};
type TransformEffect<T> = {
    type: "transform";
    transform: (arg: T, ctx: RefinementCtx) => any;
};
type PreprocessEffect<T> = {
    type: "preprocess";
    transform: (arg: T, ctx: RefinementCtx) => any;
};
type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;
interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    schema: T;
    typeName: ZodFirstPartyTypeKind.ZodEffects;
    effect: Effect<any>;
}
declare class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<Output, ZodEffectsDef<T>, Input> {
    innerType(): T;
    sourceType(): T;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <I extends ZodTypeAny>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"]>;
    static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
}

interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodOptional;
}
declare class ZodOptional<T extends ZodTypeAny> extends ZodType<T["_output"] | undefined, ZodOptionalDef<T>, T["_input"] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    unwrap(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodOptional<T_1>;
}
interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodNullable;
}
declare class ZodNullable<T extends ZodTypeAny> extends ZodType<T["_output"] | null, ZodNullableDef<T>, T["_input"] | null> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    unwrap(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodNullable<T_1>;
}
interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    defaultValue: () => util.noUndefined<T["_input"]>;
    typeName: ZodFirstPartyTypeKind.ZodDefault;
}
declare class ZodDefault<T extends ZodTypeAny> extends ZodType<util.noUndefined<T["_output"]>, ZodDefaultDef<T>, T["_input"] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    removeDefault(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params: {
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        message?: string | undefined;
        description?: string | undefined;
    } & {
        default: T_1["_input"] | (() => util.noUndefined<T_1["_input"]>);
    }) => ZodDefault<T_1>;
}
interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    catchValue: (ctx: {
        error: ZodError;
        input: unknown;
    }) => T["_input"];
    typeName: ZodFirstPartyTypeKind.ZodCatch;
}
declare class ZodCatch<T extends ZodTypeAny> extends ZodType<T["_output"], ZodCatchDef<T>, unknown> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    removeCatch(): T;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params: {
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        message?: string | undefined;
        description?: string | undefined;
    } & {
        catch: T_1["_output"] | (() => T_1["_output"]);
    }) => ZodCatch<T_1>;
}
interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodBranded;
}
declare const BRAND: unique symbol;
type BRAND<T extends string | number | symbol> = {
    [BRAND]: {
        [k in T]: true;
    };
};
declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T["_output"] & BRAND<B>, ZodBrandedDef<T>, T["_input"]> {
    _parse(input: ParseInput): ParseReturnType<any>;
    unwrap(): T;
}
interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {
    in: A;
    out: B;
    typeName: ZodFirstPartyTypeKind.ZodPipeline;
}
declare class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<B["_output"], ZodPipelineDef<A, B>, A["_input"]> {
    _parse(input: ParseInput): ParseReturnType<any>;
    static create<A extends ZodTypeAny, B extends ZodTypeAny>(a: A, b: B): ZodPipeline<A, B>;
}
type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {
    readonly [Symbol.toStringTag]: string;
} | Date | Error | Generator | Promise<unknown> | RegExp;
type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [infer Head, ...infer Tail] ? readonly [Head, ...Tail] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;
interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodReadonly;
}
declare class ZodReadonly<T extends ZodTypeAny> extends ZodType<MakeReadonly<T["_output"]>, ZodReadonlyDef<T>, MakeReadonly<T["_input"]>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodReadonly<T_1>;
    unwrap(): T;
}
declare enum ZodFirstPartyTypeKind {
    ZodString = "ZodString",
    ZodNumber = "ZodNumber",
    ZodNaN = "ZodNaN",
    ZodBigInt = "ZodBigInt",
    ZodBoolean = "ZodBoolean",
    ZodDate = "ZodDate",
    ZodSymbol = "ZodSymbol",
    ZodUndefined = "ZodUndefined",
    ZodNull = "ZodNull",
    ZodAny = "ZodAny",
    ZodUnknown = "ZodUnknown",
    ZodNever = "ZodNever",
    ZodVoid = "ZodVoid",
    ZodArray = "ZodArray",
    ZodObject = "ZodObject",
    ZodUnion = "ZodUnion",
    ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    ZodIntersection = "ZodIntersection",
    ZodTuple = "ZodTuple",
    ZodRecord = "ZodRecord",
    ZodMap = "ZodMap",
    ZodSet = "ZodSet",
    ZodFunction = "ZodFunction",
    ZodLazy = "ZodLazy",
    ZodLiteral = "ZodLiteral",
    ZodEnum = "ZodEnum",
    ZodEffects = "ZodEffects",
    ZodNativeEnum = "ZodNativeEnum",
    ZodOptional = "ZodOptional",
    ZodNullable = "ZodNullable",
    ZodDefault = "ZodDefault",
    ZodCatch = "ZodCatch",
    ZodPromise = "ZodPromise",
    ZodBranded = "ZodBranded",
    ZodPipeline = "ZodPipeline",
    ZodReadonly = "ZodReadonly"
}

declare const RequestSchema: ZodObject<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, "strip", ZodTypeAny, {
    method: string;
    params?: objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: string;
    params?: objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>;
declare const NotificationSchema: ZodObject<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, "strip", ZodTypeAny, {
    method: string;
    params?: objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: string;
    params?: objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>;
declare const ResultSchema: ZodObject<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, "passthrough", ZodTypeAny, objectOutputType<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, ZodTypeAny, "passthrough">, objectInputType<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, ZodTypeAny, "passthrough">>;
/**
 * A uniquely identifying ID for a request in JSON-RPC.
 */
declare const RequestIdSchema: ZodUnion<[ZodString, ZodNumber]>;
declare const JSONRPCMessageSchema: ZodUnion<[ZodObject<objectUtil.extendShape<{
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodUnion<[ZodString, ZodNumber]>;
}, {
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}>, "strict", ZodTypeAny, {
    method: string;
    jsonrpc: "2.0";
    id: string | number;
    params?: objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: string;
    jsonrpc: "2.0";
    id: string | number;
    params?: objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>, ZodObject<objectUtil.extendShape<{
    jsonrpc: ZodLiteral<"2.0">;
}, {
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}>, "strict", ZodTypeAny, {
    method: string;
    jsonrpc: "2.0";
    params?: objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: string;
    jsonrpc: "2.0";
    params?: objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>, ZodObject<{
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodUnion<[ZodString, ZodNumber]>;
    result: ZodObject<{
        /**
         * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>;
}, "strict", ZodTypeAny, {
    jsonrpc: "2.0";
    id: string | number;
    result: {
        _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
}, {
    jsonrpc: "2.0";
    id: string | number;
    result: {
        _meta?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
}>, ZodObject<{
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodUnion<[ZodString, ZodNumber]>;
    error: ZodObject<{
        /**
         * The error type that occurred.
         */
        code: ZodNumber;
        /**
         * A short description of the error. The message SHOULD be limited to a concise single sentence.
         */
        message: ZodString;
        /**
         * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
         */
        data: ZodOptional<ZodUnknown>;
    }, "strip", ZodTypeAny, {
        code: number;
        message: string;
        data?: unknown;
    }, {
        code: number;
        message: string;
        data?: unknown;
    }>;
}, "strict", ZodTypeAny, {
    jsonrpc: "2.0";
    id: string | number;
    error: {
        code: number;
        message: string;
        data?: unknown;
    };
}, {
    jsonrpc: "2.0";
    id: string | number;
    error: {
        code: number;
        message: string;
        data?: unknown;
    };
}>]>;
/**
 * Describes the name and version of an MCP implementation.
 */
declare const ImplementationSchema: ZodObject<{
    name: ZodString;
    version: ZodString;
}, "passthrough", ZodTypeAny, objectOutputType<{
    name: ZodString;
    version: ZodString;
}, ZodTypeAny, "passthrough">, objectInputType<{
    name: ZodString;
    version: ZodString;
}, ZodTypeAny, "passthrough">>;
/**
 * Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
 */
declare const ClientCapabilitiesSchema: ZodObject<{
    /**
     * Experimental, non-standard capabilities that the client supports.
     */
    experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the client supports sampling from an LLM.
     */
    sampling: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the client supports listing roots.
     */
    roots: ZodOptional<ZodObject<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
}, "passthrough", ZodTypeAny, objectOutputType<{
    /**
     * Experimental, non-standard capabilities that the client supports.
     */
    experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the client supports sampling from an LLM.
     */
    sampling: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the client supports listing roots.
     */
    roots: ZodOptional<ZodObject<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
}, ZodTypeAny, "passthrough">, objectInputType<{
    /**
     * Experimental, non-standard capabilities that the client supports.
     */
    experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the client supports sampling from an LLM.
     */
    sampling: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the client supports listing roots.
     */
    roots: ZodOptional<ZodObject<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
}, ZodTypeAny, "passthrough">>;
/**
 * Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
 */
declare const ServerCapabilitiesSchema: ZodObject<{
    /**
     * Experimental, non-standard capabilities that the server supports.
     */
    experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server supports sending log messages to the client.
     */
    logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server supports sending completions to the client.
     */
    completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any prompt templates.
     */
    prompts: ZodOptional<ZodObject<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any resources to read.
     */
    resources: ZodOptional<ZodObject<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any tools to call.
     */
    tools: ZodOptional<ZodObject<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
}, "passthrough", ZodTypeAny, objectOutputType<{
    /**
     * Experimental, non-standard capabilities that the server supports.
     */
    experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server supports sending log messages to the client.
     */
    logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server supports sending completions to the client.
     */
    completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any prompt templates.
     */
    prompts: ZodOptional<ZodObject<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any resources to read.
     */
    resources: ZodOptional<ZodObject<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any tools to call.
     */
    tools: ZodOptional<ZodObject<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
}, ZodTypeAny, "passthrough">, objectInputType<{
    /**
     * Experimental, non-standard capabilities that the server supports.
     */
    experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server supports sending log messages to the client.
     */
    logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server supports sending completions to the client.
     */
    completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any prompt templates.
     */
    prompts: ZodOptional<ZodObject<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any resources to read.
     */
    resources: ZodOptional<ZodObject<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: ZodOptional<ZodBoolean>;
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
    /**
     * Present if the server offers any tools to call.
     */
    tools: ZodOptional<ZodObject<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>>;
}, ZodTypeAny, "passthrough">>;
declare const ProgressSchema: ZodObject<{
    /**
     * The progress thus far. This should increase every time progress is made, even if the total is unknown.
     */
    progress: ZodNumber;
    /**
     * Total number of items to process (or total progress required), if known.
     */
    total: ZodOptional<ZodNumber>;
}, "passthrough", ZodTypeAny, objectOutputType<{
    /**
     * The progress thus far. This should increase every time progress is made, even if the total is unknown.
     */
    progress: ZodNumber;
    /**
     * Total number of items to process (or total progress required), if known.
     */
    total: ZodOptional<ZodNumber>;
}, ZodTypeAny, "passthrough">, objectInputType<{
    /**
     * The progress thus far. This should increase every time progress is made, even if the total is unknown.
     */
    progress: ZodNumber;
    /**
     * Total number of items to process (or total progress required), if known.
     */
    total: ZodOptional<ZodNumber>;
}, ZodTypeAny, "passthrough">>;
/**
 * A known resource that the server is capable of reading.
 */
declare const ResourceSchema: ZodObject<{
    /**
     * The URI of this resource.
     */
    uri: ZodString;
    /**
     * A human-readable name for this resource.
     *
     * This can be used by clients to populate UI elements.
     */
    name: ZodString;
    /**
     * A description of what this resource represents.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: ZodOptional<ZodString>;
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: ZodOptional<ZodString>;
}, "passthrough", ZodTypeAny, objectOutputType<{
    /**
     * The URI of this resource.
     */
    uri: ZodString;
    /**
     * A human-readable name for this resource.
     *
     * This can be used by clients to populate UI elements.
     */
    name: ZodString;
    /**
     * A description of what this resource represents.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: ZodOptional<ZodString>;
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: ZodOptional<ZodString>;
}, ZodTypeAny, "passthrough">, objectInputType<{
    /**
     * The URI of this resource.
     */
    uri: ZodString;
    /**
     * A human-readable name for this resource.
     *
     * This can be used by clients to populate UI elements.
     */
    name: ZodString;
    /**
     * A description of what this resource represents.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: ZodOptional<ZodString>;
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: ZodOptional<ZodString>;
}, ZodTypeAny, "passthrough">>;
/**
 * The server's response to a resources/list request from the client.
 */
declare const ListResourcesResultSchema: ZodObject<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resources: ZodArray<ZodObject<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resources: ZodArray<ZodObject<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resources: ZodArray<ZodObject<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">>;
/**
 * The server's response to a resources/read request from the client.
 */
declare const ReadResourceResultSchema: ZodObject<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    contents: ZodArray<ZodUnion<[ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">>]>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    contents: ZodArray<ZodUnion<[ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">>]>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    contents: ZodArray<ZodUnion<[ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">>]>, "many">;
}>, ZodTypeAny, "passthrough">>;
/**
 * A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.
 */
declare const ResourceUpdatedNotificationSchema: ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/resources/updated">;
    params: ZodObject<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */
        uri: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */
        uri: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */
        uri: ZodString;
    }>, ZodTypeAny, "passthrough">>;
}>, "strip", ZodTypeAny, {
    params: {
        uri: string;
        _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/resources/updated";
}, {
    params: {
        uri: string;
        _meta?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/resources/updated";
}>;
/**
 * The server's response to a prompts/get request from the client.
 */
declare const GetPromptResultSchema: ZodObject<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An optional description for the prompt.
     */
    description: ZodOptional<ZodString>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An optional description for the prompt.
     */
    description: ZodOptional<ZodString>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An optional description for the prompt.
     */
    description: ZodOptional<ZodString>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">>;
/**
 * The server's response to a tool call.
 */
declare const CallToolResultSchema: ZodObject<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    content: ZodArray<ZodUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>]>, "many">;
    isError: ZodOptional<ZodDefault<ZodBoolean>>;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    content: ZodArray<ZodUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>]>, "many">;
    isError: ZodOptional<ZodDefault<ZodBoolean>>;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    content: ZodArray<ZodUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>]>, "many">;
    isError: ZodOptional<ZodDefault<ZodBoolean>>;
}>, ZodTypeAny, "passthrough">>;
/**
 * Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.
 */
declare const LoggingMessageNotificationSchema: ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/message">;
    params: ZodObject<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The severity of this log message.
         */
        level: ZodEnum<["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]>;
        /**
         * An optional name of the logger issuing this message.
         */
        logger: ZodOptional<ZodString>;
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */
        data: ZodUnknown;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The severity of this log message.
         */
        level: ZodEnum<["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]>;
        /**
         * An optional name of the logger issuing this message.
         */
        logger: ZodOptional<ZodString>;
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */
        data: ZodUnknown;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The severity of this log message.
         */
        level: ZodEnum<["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]>;
        /**
         * An optional name of the logger issuing this message.
         */
        logger: ZodOptional<ZodString>;
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */
        data: ZodUnknown;
    }>, ZodTypeAny, "passthrough">>;
}>, "strip", ZodTypeAny, {
    params: {
        level: "error" | "debug" | "info" | "notice" | "warning" | "critical" | "alert" | "emergency";
        _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
        data?: unknown;
        logger?: string | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/message";
}, {
    params: {
        level: "error" | "debug" | "info" | "notice" | "warning" | "critical" | "alert" | "emergency";
        _meta?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
        data?: unknown;
        logger?: string | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/message";
}>;
/**
 * A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.
 */
declare const CreateMessageRequestSchema: ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"sampling/createMessage">;
    params: ZodObject<objectUtil.extendShape<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, {
        messages: ZodArray<ZodObject<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>, "many">;
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */
        systemPrompt: ZodOptional<ZodString>;
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */
        includeContext: ZodOptional<ZodEnum<["none", "thisServer", "allServers"]>>;
        temperature: ZodOptional<ZodNumber>;
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */
        maxTokens: ZodNumber;
        stopSequences: ZodOptional<ZodArray<ZodString, "many">>;
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */
        metadata: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * The server's preferences for which model to select.
         */
        modelPreferences: ZodOptional<ZodObject<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">>>;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, {
        messages: ZodArray<ZodObject<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>, "many">;
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */
        systemPrompt: ZodOptional<ZodString>;
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */
        includeContext: ZodOptional<ZodEnum<["none", "thisServer", "allServers"]>>;
        temperature: ZodOptional<ZodNumber>;
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */
        maxTokens: ZodNumber;
        stopSequences: ZodOptional<ZodArray<ZodString, "many">>;
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */
        metadata: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * The server's preferences for which model to select.
         */
        modelPreferences: ZodOptional<ZodObject<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">>>;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, {
        messages: ZodArray<ZodObject<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>, "many">;
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */
        systemPrompt: ZodOptional<ZodString>;
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */
        includeContext: ZodOptional<ZodEnum<["none", "thisServer", "allServers"]>>;
        temperature: ZodOptional<ZodNumber>;
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */
        maxTokens: ZodNumber;
        stopSequences: ZodOptional<ZodArray<ZodString, "many">>;
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */
        metadata: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * The server's preferences for which model to select.
         */
        modelPreferences: ZodOptional<ZodObject<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">>>;
    }>, ZodTypeAny, "passthrough">>;
}>, "strip", ZodTypeAny, {
    params: {
        messages: objectOutputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">[];
        maxTokens: number;
        _meta?: objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough"> | undefined;
        systemPrompt?: string | undefined;
        includeContext?: "none" | "thisServer" | "allServers" | undefined;
        temperature?: number | undefined;
        stopSequences?: string[] | undefined;
        metadata?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
        modelPreferences?: objectOutputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "sampling/createMessage";
}, {
    params: {
        messages: objectInputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">[];
        maxTokens: number;
        _meta?: objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough"> | undefined;
        systemPrompt?: string | undefined;
        includeContext?: "none" | "thisServer" | "allServers" | undefined;
        temperature?: number | undefined;
        stopSequences?: string[] | undefined;
        metadata?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
        modelPreferences?: objectInputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "sampling/createMessage";
}>;
/**
 * Sent from the server to request a list of root URIs from the client.
 */
declare const ListRootsRequestSchema: ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"roots/list">;
}>, "strip", ZodTypeAny, {
    method: "roots/list";
    params?: objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: "roots/list";
    params?: objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>;
declare const ServerRequestSchema: ZodUnion<[ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"ping">;
}>, "strip", ZodTypeAny, {
    method: "ping";
    params?: objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: "ping";
    params?: objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>, ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"sampling/createMessage">;
    params: ZodObject<objectUtil.extendShape<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, {
        messages: ZodArray<ZodObject<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>, "many">;
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */
        systemPrompt: ZodOptional<ZodString>;
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */
        includeContext: ZodOptional<ZodEnum<["none", "thisServer", "allServers"]>>;
        temperature: ZodOptional<ZodNumber>;
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */
        maxTokens: ZodNumber;
        stopSequences: ZodOptional<ZodArray<ZodString, "many">>;
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */
        metadata: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * The server's preferences for which model to select.
         */
        modelPreferences: ZodOptional<ZodObject<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">>>;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, {
        messages: ZodArray<ZodObject<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>, "many">;
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */
        systemPrompt: ZodOptional<ZodString>;
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */
        includeContext: ZodOptional<ZodEnum<["none", "thisServer", "allServers"]>>;
        temperature: ZodOptional<ZodNumber>;
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */
        maxTokens: ZodNumber;
        stopSequences: ZodOptional<ZodArray<ZodString, "many">>;
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */
        metadata: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * The server's preferences for which model to select.
         */
        modelPreferences: ZodOptional<ZodObject<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">>>;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, {
        messages: ZodArray<ZodObject<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>, "many">;
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */
        systemPrompt: ZodOptional<ZodString>;
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */
        includeContext: ZodOptional<ZodEnum<["none", "thisServer", "allServers"]>>;
        temperature: ZodOptional<ZodNumber>;
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */
        maxTokens: ZodNumber;
        stopSequences: ZodOptional<ZodArray<ZodString, "many">>;
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */
        metadata: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * The server's preferences for which model to select.
         */
        modelPreferences: ZodOptional<ZodObject<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough">>>;
    }>, ZodTypeAny, "passthrough">>;
}>, "strip", ZodTypeAny, {
    params: {
        messages: objectOutputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">[];
        maxTokens: number;
        _meta?: objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough"> | undefined;
        systemPrompt?: string | undefined;
        includeContext?: "none" | "thisServer" | "allServers" | undefined;
        temperature?: number | undefined;
        stopSequences?: string[] | undefined;
        metadata?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
        modelPreferences?: objectOutputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "sampling/createMessage";
}, {
    params: {
        messages: objectInputType<{
            role: ZodEnum<["user", "assistant"]>;
            content: ZodUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"text">;
                /**
                 * The text content of the message.
                 */
                text: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"image">;
                /**
                 * The base64-encoded image data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the image. Different providers may support different image types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>, ZodObject<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                type: ZodLiteral<"audio">;
                /**
                 * The base64-encoded audio data.
                 */
                data: ZodString;
                /**
                 * The MIME type of the audio. Different providers may support different audio types.
                 */
                mimeType: ZodString;
            }, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">[];
        maxTokens: number;
        _meta?: objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough"> | undefined;
        systemPrompt?: string | undefined;
        includeContext?: "none" | "thisServer" | "allServers" | undefined;
        temperature?: number | undefined;
        stopSequences?: string[] | undefined;
        metadata?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
        modelPreferences?: objectInputType<{
            /**
             * Optional hints to use for model selection.
             */
            hints: ZodOptional<ZodArray<ZodObject<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, "passthrough", ZodTypeAny, objectOutputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">, objectInputType<{
                /**
                 * A hint for a model name.
                 */
                name: ZodOptional<ZodString>;
            }, ZodTypeAny, "passthrough">>, "many">>;
            /**
             * How much to prioritize cost when selecting a model.
             */
            costPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize sampling speed (latency) when selecting a model.
             */
            speedPriority: ZodOptional<ZodNumber>;
            /**
             * How much to prioritize intelligence and capabilities when selecting a model.
             */
            intelligencePriority: ZodOptional<ZodNumber>;
        }, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "sampling/createMessage";
}>, ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"roots/list">;
}>, "strip", ZodTypeAny, {
    method: "roots/list";
    params?: objectOutputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: "roots/list";
    params?: objectInputType<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<[ZodString, ZodNumber]>>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>]>;
declare const ServerNotificationSchema: ZodUnion<[ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/cancelled">;
    params: ZodObject<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The ID of the request to cancel.
         *
         * This MUST correspond to the ID of a request previously issued in the same direction.
         */
        requestId: ZodUnion<[ZodString, ZodNumber]>;
        /**
         * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
         */
        reason: ZodOptional<ZodString>;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The ID of the request to cancel.
         *
         * This MUST correspond to the ID of a request previously issued in the same direction.
         */
        requestId: ZodUnion<[ZodString, ZodNumber]>;
        /**
         * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
         */
        reason: ZodOptional<ZodString>;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The ID of the request to cancel.
         *
         * This MUST correspond to the ID of a request previously issued in the same direction.
         */
        requestId: ZodUnion<[ZodString, ZodNumber]>;
        /**
         * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
         */
        reason: ZodOptional<ZodString>;
    }>, ZodTypeAny, "passthrough">>;
}>, "strip", ZodTypeAny, {
    params: {
        requestId: string | number;
        _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
        reason?: string | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/cancelled";
}, {
    params: {
        requestId: string | number;
        _meta?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
        reason?: string | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/cancelled";
}>, ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/progress">;
    params: ZodObject<objectUtil.extendShape<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The progress thus far. This should increase every time progress is made, even if the total is unknown.
         */
        progress: ZodNumber;
        /**
         * Total number of items to process (or total progress required), if known.
         */
        total: ZodOptional<ZodNumber>;
    }>, {
        /**
         * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
         */
        progressToken: ZodUnion<[ZodString, ZodNumber]>;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The progress thus far. This should increase every time progress is made, even if the total is unknown.
         */
        progress: ZodNumber;
        /**
         * Total number of items to process (or total progress required), if known.
         */
        total: ZodOptional<ZodNumber>;
    }>, {
        /**
         * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
         */
        progressToken: ZodUnion<[ZodString, ZodNumber]>;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The progress thus far. This should increase every time progress is made, even if the total is unknown.
         */
        progress: ZodNumber;
        /**
         * Total number of items to process (or total progress required), if known.
         */
        total: ZodOptional<ZodNumber>;
    }>, {
        /**
         * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
         */
        progressToken: ZodUnion<[ZodString, ZodNumber]>;
    }>, ZodTypeAny, "passthrough">>;
}>, "strip", ZodTypeAny, {
    params: {
        progressToken: string | number;
        progress: number;
        _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
        total?: number | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/progress";
}, {
    params: {
        progressToken: string | number;
        progress: number;
        _meta?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
        total?: number | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/progress";
}>, ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/message">;
    params: ZodObject<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The severity of this log message.
         */
        level: ZodEnum<["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]>;
        /**
         * An optional name of the logger issuing this message.
         */
        logger: ZodOptional<ZodString>;
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */
        data: ZodUnknown;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The severity of this log message.
         */
        level: ZodEnum<["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]>;
        /**
         * An optional name of the logger issuing this message.
         */
        logger: ZodOptional<ZodString>;
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */
        data: ZodUnknown;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The severity of this log message.
         */
        level: ZodEnum<["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]>;
        /**
         * An optional name of the logger issuing this message.
         */
        logger: ZodOptional<ZodString>;
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */
        data: ZodUnknown;
    }>, ZodTypeAny, "passthrough">>;
}>, "strip", ZodTypeAny, {
    params: {
        level: "error" | "debug" | "info" | "notice" | "warning" | "critical" | "alert" | "emergency";
        _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
        data?: unknown;
        logger?: string | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/message";
}, {
    params: {
        level: "error" | "debug" | "info" | "notice" | "warning" | "critical" | "alert" | "emergency";
        _meta?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
        data?: unknown;
        logger?: string | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/message";
}>, ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/resources/updated">;
    params: ZodObject<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */
        uri: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */
        uri: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */
        uri: ZodString;
    }>, ZodTypeAny, "passthrough">>;
}>, "strip", ZodTypeAny, {
    params: {
        uri: string;
        _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/resources/updated";
}, {
    params: {
        uri: string;
        _meta?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
    } & {
        [k: string]: unknown;
    };
    method: "notifications/resources/updated";
}>, ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/resources/list_changed">;
}>, "strip", ZodTypeAny, {
    method: "notifications/resources/list_changed";
    params?: objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: "notifications/resources/list_changed";
    params?: objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>, ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/tools/list_changed">;
}>, "strip", ZodTypeAny, {
    method: "notifications/tools/list_changed";
    params?: objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: "notifications/tools/list_changed";
    params?: objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>, ZodObject<objectUtil.extendShape<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>>;
}, {
    method: ZodLiteral<"notifications/prompts/list_changed">;
}>, "strip", ZodTypeAny, {
    method: "notifications/prompts/list_changed";
    params?: objectOutputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}, {
    method: "notifications/prompts/list_changed";
    params?: objectInputType<{
        /**
         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
         */
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough"> | undefined;
}>]>;
declare const ServerResultSchema: ZodUnion<[ZodObject<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, "strict", ZodTypeAny, {
    _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
}, {
    _meta?: objectInputType<{}, ZodTypeAny, "passthrough"> | undefined;
}>, ZodObject<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
     */
    protocolVersion: ZodString;
    capabilities: ZodObject<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>;
    serverInfo: ZodObject<{
        name: ZodString;
        version: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        name: ZodString;
        version: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        name: ZodString;
        version: ZodString;
    }, ZodTypeAny, "passthrough">>;
    /**
     * Instructions describing how to use the server and its features.
     *
     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
     */
    instructions: ZodOptional<ZodString>;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
     */
    protocolVersion: ZodString;
    capabilities: ZodObject<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>;
    serverInfo: ZodObject<{
        name: ZodString;
        version: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        name: ZodString;
        version: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        name: ZodString;
        version: ZodString;
    }, ZodTypeAny, "passthrough">>;
    /**
     * Instructions describing how to use the server and its features.
     *
     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
     */
    instructions: ZodOptional<ZodString>;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
     */
    protocolVersion: ZodString;
    capabilities: ZodObject<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * Experimental, non-standard capabilities that the server supports.
         */
        experimental: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending log messages to the client.
         */
        logging: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server supports sending completions to the client.
         */
        completions: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any prompt templates.
         */
        prompts: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the prompt list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any resources to read.
         */
        resources: ZodOptional<ZodObject<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports clients subscribing to resource updates.
             */
            subscribe: ZodOptional<ZodBoolean>;
            /**
             * Whether this server supports issuing notifications for changes to the resource list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
        /**
         * Present if the server offers any tools to call.
         */
        tools: ZodOptional<ZodObject<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * Whether this server supports issuing notifications for changes to the tool list.
             */
            listChanged: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>>;
    }, ZodTypeAny, "passthrough">>;
    serverInfo: ZodObject<{
        name: ZodString;
        version: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        name: ZodString;
        version: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        name: ZodString;
        version: ZodString;
    }, ZodTypeAny, "passthrough">>;
    /**
     * Instructions describing how to use the server and its features.
     *
     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
     */
    instructions: ZodOptional<ZodString>;
}>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    completion: ZodObject<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    completion: ZodObject<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    completion: ZodObject<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString, "many">;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, ZodTypeAny, "passthrough">>;
}>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An optional description for the prompt.
     */
    description: ZodOptional<ZodString>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An optional description for the prompt.
     */
    description: ZodOptional<ZodString>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An optional description for the prompt.
     */
    description: ZodOptional<ZodString>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        role: ZodEnum<["user", "assistant"]>;
        content: ZodUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            /**
             * The text content of the message.
             */
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            /**
             * The base64-encoded image data.
             */
            data: ZodString;
            /**
             * The MIME type of the image. Different providers may support different image types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            /**
             * The base64-encoded audio data.
             */
            data: ZodString;
            /**
             * The MIME type of the audio. Different providers may support different audio types.
             */
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
                 */
                text: ZodString;
            }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
                /**
                 * The URI of this resource.
                 */
                uri: ZodString;
                /**
                 * The MIME type of this resource, if known.
                 */
                mimeType: ZodOptional<ZodString>;
            }, {
                /**
                 * A base64-encoded string representing the binary data of the item.
                 */
                blob: ZodString;
            }>, ZodTypeAny, "passthrough">>]>;
        }, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    prompts: ZodArray<ZodObject<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    prompts: ZodArray<ZodObject<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    prompts: ZodArray<ZodObject<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The name of the prompt or prompt template.
         */
        name: ZodString;
        /**
         * An optional description of what this prompt provides
         */
        description: ZodOptional<ZodString>;
        /**
         * A list of arguments to use for templating the prompt.
         */
        arguments: ZodOptional<ZodArray<ZodObject<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            /**
             * The name of the argument.
             */
            name: ZodString;
            /**
             * A human-readable description of the argument.
             */
            description: ZodOptional<ZodString>;
            /**
             * Whether this argument must be provided.
             */
            required: ZodOptional<ZodBoolean>;
        }, ZodTypeAny, "passthrough">>, "many">>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resources: ZodArray<ZodObject<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resources: ZodArray<ZodObject<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resources: ZodArray<ZodObject<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * A human-readable name for this resource.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this resource represents.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resourceTemplates: ZodArray<ZodObject<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resourceTemplates: ZodArray<ZodObject<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    resourceTemplates: ZodArray<ZodObject<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * A URI template (according to RFC 6570) that can be used to construct resource URIs.
         */
        uriTemplate: ZodString;
        /**
         * A human-readable name for the type of resource this template refers to.
         *
         * This can be used by clients to populate UI elements.
         */
        name: ZodString;
        /**
         * A description of what this template is for.
         *
         * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
         */
        description: ZodOptional<ZodString>;
        /**
         * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
         */
        mimeType: ZodOptional<ZodString>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    contents: ZodArray<ZodUnion<[ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">>]>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    contents: ZodArray<ZodUnion<[ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">>]>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    contents: ZodArray<ZodUnion<[ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
         */
        text: ZodString;
    }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
        /**
         * The URI of this resource.
         */
        uri: ZodString;
        /**
         * The MIME type of this resource, if known.
         */
        mimeType: ZodOptional<ZodString>;
    }, {
        /**
         * A base64-encoded string representing the binary data of the item.
         */
        blob: ZodString;
    }>, ZodTypeAny, "passthrough">>]>, "many">;
}>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    content: ZodArray<ZodUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>]>, "many">;
    isError: ZodOptional<ZodDefault<ZodBoolean>>;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    content: ZodArray<ZodUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>]>, "many">;
    isError: ZodOptional<ZodDefault<ZodBoolean>>;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    content: ZodArray<ZodUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"text">;
        /**
         * The text content of the message.
         */
        text: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"image">;
        /**
         * The base64-encoded image data.
         */
        data: ZodString;
        /**
         * The MIME type of the image. Different providers may support different image types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"audio">;
        /**
         * The base64-encoded audio data.
         */
        data: ZodString;
        /**
         * The MIME type of the audio. Different providers may support different audio types.
         */
        mimeType: ZodString;
    }, ZodTypeAny, "passthrough">>, ZodObject<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<[ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
             */
            text: ZodString;
        }>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<{
            /**
             * The URI of this resource.
             */
            uri: ZodString;
            /**
             * The MIME type of this resource, if known.
             */
            mimeType: ZodOptional<ZodString>;
        }, {
            /**
             * A base64-encoded string representing the binary data of the item.
             */
            blob: ZodString;
        }>, ZodTypeAny, "passthrough">>]>;
    }, ZodTypeAny, "passthrough">>]>, "many">;
    isError: ZodOptional<ZodDefault<ZodBoolean>>;
}>, ZodTypeAny, "passthrough">>, ZodObject<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    tools: ZodArray<ZodObject<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, "passthrough", ZodTypeAny, objectOutputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    tools: ZodArray<ZodObject<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">, objectInputType<objectUtil.extendShape<objectUtil.extendShape<{
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
}, {
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: ZodOptional<ZodString>;
}>, {
    tools: ZodArray<ZodObject<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, "passthrough", ZodTypeAny, objectOutputType<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, ZodTypeAny, "passthrough">, objectInputType<{
        /**
         * The name of the tool.
         */
        name: ZodString;
        /**
         * A human-readable description of the tool.
         */
        description: ZodOptional<ZodString>;
        /**
         * A JSON Schema object defining the expected parameters for the tool.
         */
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
        }, ZodTypeAny, "passthrough">>;
    }, ZodTypeAny, "passthrough">>, "many">;
}>, ZodTypeAny, "passthrough">>]>;
type Primitive = string | number | boolean | bigint | null | undefined;
type Flatten<T> = T extends Primitive ? T : T extends Array<infer U> ? Array<Flatten<U>> : T extends Set<infer U> ? Set<Flatten<U>> : T extends Map<infer K, infer V> ? Map<Flatten<K>, Flatten<V>> : T extends object ? {
    [K in keyof T]: Flatten<T[K]>;
} : T;
type Infer<Schema extends ZodTypeAny> = Flatten<TypeOf<Schema>>;
type Request = Infer<typeof RequestSchema>;
type Notification = Infer<typeof NotificationSchema>;
type Result = Infer<typeof ResultSchema>;
type RequestId = Infer<typeof RequestIdSchema>;
type JSONRPCMessage = Infer<typeof JSONRPCMessageSchema>;
type Implementation = Infer<typeof ImplementationSchema>;
type ClientCapabilities = Infer<typeof ClientCapabilitiesSchema>;
type ServerCapabilities = Infer<typeof ServerCapabilitiesSchema>;
type Progress = Infer<typeof ProgressSchema>;
type Resource = Infer<typeof ResourceSchema>;
type ListResourcesResult = Infer<typeof ListResourcesResultSchema>;
type ReadResourceResult = Infer<typeof ReadResourceResultSchema>;
type ResourceUpdatedNotification = Infer<typeof ResourceUpdatedNotificationSchema>;
type GetPromptResult = Infer<typeof GetPromptResultSchema>;
type CallToolResult = Infer<typeof CallToolResultSchema>;
type LoggingMessageNotification = Infer<typeof LoggingMessageNotificationSchema>;
type CreateMessageRequest = Infer<typeof CreateMessageRequestSchema>;
type ListRootsRequest = Infer<typeof ListRootsRequestSchema>;
type ServerRequest = Infer<typeof ServerRequestSchema>;
type ServerNotification = Infer<typeof ServerNotificationSchema>;
type ServerResult = Infer<typeof ServerResultSchema>;

/**
 * Information about a validated access token, provided to request handlers.
 */
interface AuthInfo {
    /**
     * The access token.
     */
    token: string;
    /**
     * The client ID associated with this token.
     */
    clientId: string;
    /**
     * Scopes associated with this token.
     */
    scopes: string[];
    /**
     * When the token expires (in seconds since epoch).
     */
    expiresAt?: number;
    /**
     * Additional data associated with the token.
     * This field should be used for any additional data that needs to be attached to the auth info.
    */
    extra?: Record<string, unknown>;
}

/**
 * Options for sending a JSON-RPC message.
 */
type TransportSendOptions = {
    /**
     * If present, `relatedRequestId` is used to indicate to the transport which incoming request to associate this outgoing message with.
     */
    relatedRequestId?: RequestId;
    /**
     * The resumption token used to continue long-running requests that were interrupted.
     *
     * This allows clients to reconnect and continue from where they left off, if supported by the transport.
     */
    resumptionToken?: string;
    /**
     * A callback that is invoked when the resumption token changes, if supported by the transport.
     *
     * This allows clients to persist the latest token for potential reconnection.
     */
    onresumptiontoken?: (token: string) => void;
};
/**
 * Describes the minimal contract for a MCP transport that a client or server can communicate over.
 */
interface Transport {
    /**
     * Starts processing messages on the transport, including any connection steps that might need to be taken.
     *
     * This method should only be called after callbacks are installed, or else messages may be lost.
     *
     * NOTE: This method should not be called explicitly when using Client, Server, or Protocol classes, as they will implicitly call start().
     */
    start(): Promise<void>;
    /**
     * Sends a JSON-RPC message (request or response).
     *
     * If present, `relatedRequestId` is used to indicate to the transport which incoming request to associate this outgoing message with.
     */
    send(message: JSONRPCMessage, options?: TransportSendOptions): Promise<void>;
    /**
     * Closes the connection.
     */
    close(): Promise<void>;
    /**
     * Callback for when the connection is closed for any reason.
     *
     * This should be invoked when close() is called as well.
     */
    onclose?: () => void;
    /**
     * Callback for when an error occurs.
     *
     * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.
     */
    onerror?: (error: Error) => void;
    /**
     * Callback for when a message (request or response) is received over the connection.
     *
     * Includes the authInfo if the transport is authenticated.
     *
     */
    onmessage?: (message: JSONRPCMessage, extra?: {
        authInfo?: AuthInfo;
    }) => void;
    /**
     * The session ID generated for this connection.
     */
    sessionId?: string;
}

/**
 * Callback for progress notifications.
 */
type ProgressCallback = (progress: Progress) => void;
/**
 * Additional initialization options.
 */
type ProtocolOptions = {
    /**
     * Whether to restrict emitted requests to only those that the remote side has indicated that they can handle, through their advertised capabilities.
     *
     * Note that this DOES NOT affect checking of _local_ side capabilities, as it is considered a logic error to mis-specify those.
     *
     * Currently this defaults to false, for backwards compatibility with SDK versions that did not advertise capabilities correctly. In future, this will default to true.
     */
    enforceStrictCapabilities?: boolean;
};
/**
 * Options that can be given per request.
 */
type RequestOptions = {
    /**
     * If set, requests progress notifications from the remote end (if supported). When progress notifications are received, this callback will be invoked.
     */
    onprogress?: ProgressCallback;
    /**
     * Can be used to cancel an in-flight request. This will cause an AbortError to be raised from request().
     */
    signal?: AbortSignal;
    /**
     * A timeout (in milliseconds) for this request. If exceeded, an McpError with code `RequestTimeout` will be raised from request().
     *
     * If not specified, `DEFAULT_REQUEST_TIMEOUT_MSEC` will be used as the timeout.
     */
    timeout?: number;
    /**
     * If true, receiving a progress notification will reset the request timeout.
     * This is useful for long-running operations that send periodic progress updates.
     * Default: false
     */
    resetTimeoutOnProgress?: boolean;
    /**
     * Maximum total time (in milliseconds) to wait for a response.
     * If exceeded, an McpError with code `RequestTimeout` will be raised, regardless of progress notifications.
     * If not specified, there is no maximum total timeout.
     */
    maxTotalTimeout?: number;
} & TransportSendOptions;
/**
 * Options that can be given per notification.
 */
type NotificationOptions = {
    /**
     * May be used to indicate to the transport which incoming request to associate this outgoing notification with.
     */
    relatedRequestId?: RequestId;
};
/**
 * Extra data given to request handlers.
 */
type RequestHandlerExtra<SendRequestT extends Request, SendNotificationT extends Notification> = {
    /**
     * An abort signal used to communicate if the request was cancelled from the sender's side.
     */
    signal: AbortSignal;
    /**
     * Information about a validated access token, provided to request handlers.
     */
    authInfo?: AuthInfo;
    /**
     * The session ID from the transport, if available.
     */
    sessionId?: string;
    /**
     * Sends a notification that relates to the current request being handled.
     *
     * This is used by certain transports to correctly associate related messages.
     */
    sendNotification: (notification: SendNotificationT) => Promise<void>;
    /**
     * Sends a request that relates to the current request being handled.
     *
     * This is used by certain transports to correctly associate related messages.
     */
    sendRequest: <U extends ZodType<object>>(request: SendRequestT, resultSchema: U, options?: RequestOptions) => Promise<TypeOf<U>>;
};
/**
 * Implements MCP protocol framing on top of a pluggable transport, including
 * features like request/response linking, notifications, and progress.
 */
declare abstract class Protocol<SendRequestT extends Request, SendNotificationT extends Notification, SendResultT extends Result> {
    private _options?;
    private _transport?;
    private _requestMessageId;
    private _requestHandlers;
    private _requestHandlerAbortControllers;
    private _notificationHandlers;
    private _responseHandlers;
    private _progressHandlers;
    private _timeoutInfo;
    /**
     * Callback for when the connection is closed for any reason.
     *
     * This is invoked when close() is called as well.
     */
    onclose?: () => void;
    /**
     * Callback for when an error occurs.
     *
     * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.
     */
    onerror?: (error: Error) => void;
    /**
     * A handler to invoke for any request types that do not have their own handler installed.
     */
    fallbackRequestHandler?: (request: Request) => Promise<SendResultT>;
    /**
     * A handler to invoke for any notification types that do not have their own handler installed.
     */
    fallbackNotificationHandler?: (notification: Notification) => Promise<void>;
    constructor(_options?: ProtocolOptions | undefined);
    private _setupTimeout;
    private _resetTimeout;
    private _cleanupTimeout;
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */
    connect(transport: Transport): Promise<void>;
    private _onclose;
    private _onerror;
    private _onnotification;
    private _onrequest;
    private _onprogress;
    private _onresponse;
    get transport(): Transport | undefined;
    /**
     * Closes the connection.
     */
    close(): Promise<void>;
    /**
     * A method to check if a capability is supported by the remote side, for the given method to be called.
     *
     * This should be implemented by subclasses.
     */
    protected abstract assertCapabilityForMethod(method: SendRequestT["method"]): void;
    /**
     * A method to check if a notification is supported by the local side, for the given method to be sent.
     *
     * This should be implemented by subclasses.
     */
    protected abstract assertNotificationCapability(method: SendNotificationT["method"]): void;
    /**
     * A method to check if a request handler is supported by the local side, for the given method to be handled.
     *
     * This should be implemented by subclasses.
     */
    protected abstract assertRequestHandlerCapability(method: string): void;
    /**
     * Sends a request and wait for a response.
     *
     * Do not use this method to emit notifications! Use notification() instead.
     */
    request<T extends ZodType<object>>(request: SendRequestT, resultSchema: T, options?: RequestOptions): Promise<TypeOf<T>>;
    /**
     * Emits a notification, which is a one-way message that does not expect a response.
     */
    notification(notification: SendNotificationT, options?: NotificationOptions): Promise<void>;
    /**
     * Registers a handler to invoke when this protocol object receives a request with the given method.
     *
     * Note that this will replace any previous request handler for the same method.
     */
    setRequestHandler<T extends ZodObject<{
        method: ZodLiteral<string>;
    }>>(requestSchema: T, handler: (request: TypeOf<T>, extra: RequestHandlerExtra<SendRequestT, SendNotificationT>) => SendResultT | Promise<SendResultT>): void;
    /**
     * Removes the request handler for the given method.
     */
    removeRequestHandler(method: string): void;
    /**
     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
     */
    assertCanSetRequestHandler(method: string): void;
    /**
     * Registers a handler to invoke when this protocol object receives a notification with the given method.
     *
     * Note that this will replace any previous notification handler for the same method.
     */
    setNotificationHandler<T extends ZodObject<{
        method: ZodLiteral<string>;
    }>>(notificationSchema: T, handler: (notification: TypeOf<T>) => void | Promise<void>): void;
    /**
     * Removes the notification handler for the given method.
     */
    removeNotificationHandler(method: string): void;
}

type ServerOptions = ProtocolOptions & {
    /**
     * Capabilities to advertise as being supported by this server.
     */
    capabilities?: ServerCapabilities;
    /**
     * Optional instructions describing how to use the server and its features.
     */
    instructions?: string;
};
/**
 * An MCP server on top of a pluggable transport.
 *
 * This server will automatically respond to the initialization flow as initiated from the client.
 *
 * To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
 *
 * ```typescript
 * // Custom schemas
 * const CustomRequestSchema = RequestSchema.extend({...})
 * const CustomNotificationSchema = NotificationSchema.extend({...})
 * const CustomResultSchema = ResultSchema.extend({...})
 *
 * // Type aliases
 * type CustomRequest = z.infer<typeof CustomRequestSchema>
 * type CustomNotification = z.infer<typeof CustomNotificationSchema>
 * type CustomResult = z.infer<typeof CustomResultSchema>
 *
 * // Create typed server
 * const server = new Server<CustomRequest, CustomNotification, CustomResult>({
 *   name: "CustomServer",
 *   version: "1.0.0"
 * })
 * ```
 */
declare class Server<RequestT extends Request = Request, NotificationT extends Notification = Notification, ResultT extends Result = Result> extends Protocol<ServerRequest | RequestT, ServerNotification | NotificationT, ServerResult | ResultT> {
    private _serverInfo;
    private _clientCapabilities?;
    private _clientVersion?;
    private _capabilities;
    private _instructions?;
    /**
     * Callback for when initialization has fully completed (i.e., the client has sent an `initialized` notification).
     */
    oninitialized?: () => void;
    /**
     * Initializes this server with the given name and version information.
     */
    constructor(_serverInfo: Implementation, options?: ServerOptions);
    /**
     * Registers new capabilities. This can only be called before connecting to a transport.
     *
     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
     */
    registerCapabilities(capabilities: ServerCapabilities): void;
    protected assertCapabilityForMethod(method: RequestT["method"]): void;
    protected assertNotificationCapability(method: (ServerNotification | NotificationT)["method"]): void;
    protected assertRequestHandlerCapability(method: string): void;
    private _oninitialize;
    /**
     * After initialization has completed, this will be populated with the client's reported capabilities.
     */
    getClientCapabilities(): ClientCapabilities | undefined;
    /**
     * After initialization has completed, this will be populated with information about the client's name and version.
     */
    getClientVersion(): Implementation | undefined;
    private getCapabilities;
    ping(): Promise<{
        _meta?: objectOutputType<{}, ZodTypeAny, "passthrough"> | undefined;
    }>;
    createMessage(params: CreateMessageRequest["params"], options?: RequestOptions): Promise<objectOutputType<objectUtil.extendShape<{
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        model: ZodString;
        stopReason: ZodOptional<ZodUnion<[ZodEnum<["endTurn", "stopSequence", "maxTokens"]>, ZodString]>>;
        role: ZodEnum<["user", "assistant"]>;
        content: ZodDiscriminatedUnion<"type", [ZodObject<{
            type: ZodLiteral<"text">;
            text: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"text">;
            text: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"text">;
            text: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>, ZodObject<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
        }, ZodTypeAny, "passthrough">>]>;
    }>, ZodTypeAny, "passthrough">>;
    listRoots(params?: ListRootsRequest["params"], options?: RequestOptions): Promise<objectOutputType<objectUtil.extendShape<{
        _meta: ZodOptional<ZodObject<{}, "passthrough", ZodTypeAny, objectOutputType<{}, ZodTypeAny, "passthrough">, objectInputType<{}, ZodTypeAny, "passthrough">>>;
    }, {
        roots: ZodArray<ZodObject<{
            uri: ZodString;
            name: ZodOptional<ZodString>;
        }, "passthrough", ZodTypeAny, objectOutputType<{
            uri: ZodString;
            name: ZodOptional<ZodString>;
        }, ZodTypeAny, "passthrough">, objectInputType<{
            uri: ZodString;
            name: ZodOptional<ZodString>;
        }, ZodTypeAny, "passthrough">>, "many">;
    }>, ZodTypeAny, "passthrough">>;
    sendLoggingMessage(params: LoggingMessageNotification["params"]): Promise<void>;
    sendResourceUpdated(params: ResourceUpdatedNotification["params"]): Promise<void>;
    sendResourceListChanged(): Promise<void>;
    sendToolListChanged(): Promise<void>;
    sendPromptListChanged(): Promise<void>;
}

type Variables = Record<string, string | string[]>;
declare class UriTemplate {
    /**
     * Returns true if the given string contains any URI template expressions.
     * A template expression is a sequence of characters enclosed in curly braces,
     * like {foo} or {?bar}.
     */
    static isTemplate(str: string): boolean;
    private static validateLength;
    private readonly template;
    private readonly parts;
    get variableNames(): string[];
    constructor(template: string);
    toString(): string;
    private parse;
    private getOperator;
    private getNames;
    private encodeValue;
    private expandPart;
    expand(variables: Variables): string;
    private escapeRegExp;
    private partToRegExp;
    match(uri: string): Variables | null;
}

/**
 * High-level MCP server that provides a simpler API for working with resources, tools, and prompts.
 * For advanced usage (like sending notifications or setting custom request handlers), use the underlying
 * Server instance available via the `server` property.
 */
declare class McpServer {
    /**
     * The underlying Server instance, useful for advanced operations like sending notifications.
     */
    readonly server: Server;
    private _registeredResources;
    private _registeredResourceTemplates;
    private _registeredTools;
    private _registeredPrompts;
    constructor(serverInfo: Implementation, options?: ServerOptions);
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The `server` object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */
    connect(transport: Transport): Promise<void>;
    /**
     * Closes the connection.
     */
    close(): Promise<void>;
    private _toolHandlersInitialized;
    private setToolRequestHandlers;
    private _completionHandlerInitialized;
    private setCompletionRequestHandler;
    private handlePromptCompletion;
    private handleResourceCompletion;
    private _resourceHandlersInitialized;
    private setResourceRequestHandlers;
    private _promptHandlersInitialized;
    private setPromptRequestHandlers;
    /**
     * Registers a resource `name` at a fixed URI, which will use the given callback to respond to read requests.
     */
    resource(name: string, uri: string, readCallback: ReadResourceCallback): RegisteredResource;
    /**
     * Registers a resource `name` at a fixed URI with metadata, which will use the given callback to respond to read requests.
     */
    resource(name: string, uri: string, metadata: ResourceMetadata, readCallback: ReadResourceCallback): RegisteredResource;
    /**
     * Registers a resource `name` with a template pattern, which will use the given callback to respond to read requests.
     */
    resource(name: string, template: ResourceTemplate, readCallback: ReadResourceTemplateCallback): RegisteredResourceTemplate;
    /**
     * Registers a resource `name` with a template pattern and metadata, which will use the given callback to respond to read requests.
     */
    resource(name: string, template: ResourceTemplate, metadata: ResourceMetadata, readCallback: ReadResourceTemplateCallback): RegisteredResourceTemplate;
    /**
     * Registers a zero-argument tool `name`, which will run the given function when the client calls it.
     */
    tool(name: string, cb: ToolCallback): RegisteredTool;
    /**
     * Registers a zero-argument tool `name` (with a description) which will run the given function when the client calls it.
     */
    tool(name: string, description: string, cb: ToolCallback): RegisteredTool;
    /**
     * Registers a tool `name` accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.
     */
    tool<Args extends ZodRawShape>(name: string, paramsSchema: Args, cb: ToolCallback<Args>): RegisteredTool;
    /**
     * Registers a tool `name` (with a description) accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.
     */
    tool<Args extends ZodRawShape>(name: string, description: string, paramsSchema: Args, cb: ToolCallback<Args>): RegisteredTool;
    /**
     * Registers a zero-argument prompt `name`, which will run the given function when the client calls it.
     */
    prompt(name: string, cb: PromptCallback): RegisteredPrompt;
    /**
     * Registers a zero-argument prompt `name` (with a description) which will run the given function when the client calls it.
     */
    prompt(name: string, description: string, cb: PromptCallback): RegisteredPrompt;
    /**
     * Registers a prompt `name` accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.
     */
    prompt<Args extends PromptArgsRawShape>(name: string, argsSchema: Args, cb: PromptCallback<Args>): RegisteredPrompt;
    /**
     * Registers a prompt `name` (with a description) accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.
     */
    prompt<Args extends PromptArgsRawShape>(name: string, description: string, argsSchema: Args, cb: PromptCallback<Args>): RegisteredPrompt;
    /**
     * Checks if the server is connected to a transport.
     * @returns True if the server is connected
     */
    isConnected(): boolean;
    /**
     * Sends a resource list changed event to the client, if connected.
     */
    sendResourceListChanged(): void;
    /**
     * Sends a tool list changed event to the client, if connected.
     */
    sendToolListChanged(): void;
    /**
     * Sends a prompt list changed event to the client, if connected.
     */
    sendPromptListChanged(): void;
}
/**
 * A callback to complete one variable within a resource template's URI template.
 */
type CompleteResourceTemplateCallback = (value: string) => string[] | Promise<string[]>;
/**
 * A resource template combines a URI pattern with optional functionality to enumerate
 * all resources matching that pattern.
 */
declare class ResourceTemplate {
    private _callbacks;
    private _uriTemplate;
    constructor(uriTemplate: string | UriTemplate, _callbacks: {
        /**
         * A callback to list all resources matching this template. This is required to specified, even if `undefined`, to avoid accidentally forgetting resource listing.
         */
        list: ListResourcesCallback | undefined;
        /**
         * An optional callback to autocomplete variables within the URI template. Useful for clients and users to discover possible values.
         */
        complete?: {
            [variable: string]: CompleteResourceTemplateCallback;
        };
    });
    /**
     * Gets the URI template pattern.
     */
    get uriTemplate(): UriTemplate;
    /**
     * Gets the list callback, if one was provided.
     */
    get listCallback(): ListResourcesCallback | undefined;
    /**
     * Gets the callback for completing a specific URI template variable, if one was provided.
     */
    completeCallback(variable: string): CompleteResourceTemplateCallback | undefined;
}
/**
 * Callback for a tool handler registered with Server.tool().
 *
 * Parameters will include tool arguments, if applicable, as well as other request handler context.
 */
type ToolCallback<Args extends undefined | ZodRawShape = undefined> = Args extends ZodRawShape ? (args: objectOutputType<Args, ZodTypeAny>, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => CallToolResult | Promise<CallToolResult> : (extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => CallToolResult | Promise<CallToolResult>;
type RegisteredTool = {
    description?: string;
    inputSchema?: AnyZodObject;
    callback: ToolCallback<undefined | ZodRawShape>;
    enabled: boolean;
    enable(): void;
    disable(): void;
    update<Args extends ZodRawShape>(updates: {
        name?: string | null;
        description?: string;
        paramsSchema?: Args;
        callback?: ToolCallback<Args>;
        enabled?: boolean;
    }): void;
    remove(): void;
};
/**
 * Additional, optional information for annotating a resource.
 */
type ResourceMetadata = Omit<Resource, "uri" | "name">;
/**
 * Callback to list all resources matching a given template.
 */
type ListResourcesCallback = (extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => ListResourcesResult | Promise<ListResourcesResult>;
/**
 * Callback to read a resource at a given URI.
 */
type ReadResourceCallback = (uri: URL, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => ReadResourceResult | Promise<ReadResourceResult>;
type RegisteredResource = {
    name: string;
    metadata?: ResourceMetadata;
    readCallback: ReadResourceCallback;
    enabled: boolean;
    enable(): void;
    disable(): void;
    update(updates: {
        name?: string;
        uri?: string | null;
        metadata?: ResourceMetadata;
        callback?: ReadResourceCallback;
        enabled?: boolean;
    }): void;
    remove(): void;
};
/**
 * Callback to read a resource at a given URI, following a filled-in URI template.
 */
type ReadResourceTemplateCallback = (uri: URL, variables: Variables, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => ReadResourceResult | Promise<ReadResourceResult>;
type RegisteredResourceTemplate = {
    resourceTemplate: ResourceTemplate;
    metadata?: ResourceMetadata;
    readCallback: ReadResourceTemplateCallback;
    enabled: boolean;
    enable(): void;
    disable(): void;
    update(updates: {
        name?: string | null;
        template?: ResourceTemplate;
        metadata?: ResourceMetadata;
        callback?: ReadResourceTemplateCallback;
        enabled?: boolean;
    }): void;
    remove(): void;
};
type PromptArgsRawShape = {
    [k: string]: ZodType<string, ZodTypeDef, string> | ZodOptional<ZodType<string, ZodTypeDef, string>>;
};
type PromptCallback<Args extends undefined | PromptArgsRawShape = undefined> = Args extends PromptArgsRawShape ? (args: objectOutputType<Args, ZodTypeAny>, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => GetPromptResult | Promise<GetPromptResult> : (extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => GetPromptResult | Promise<GetPromptResult>;
type RegisteredPrompt = {
    description?: string;
    argsSchema?: ZodObject<PromptArgsRawShape>;
    callback: PromptCallback<undefined | PromptArgsRawShape>;
    enabled: boolean;
    enable(): void;
    disable(): void;
    update<Args extends PromptArgsRawShape>(updates: {
        name?: string | null;
        description?: string;
        argsSchema?: Args;
        callback?: PromptCallback<Args>;
        enabled?: boolean;
    }): void;
    remove(): void;
};

interface LikeC4MCPServer {
    start(port: number): Promise<void>;
    stop(): Promise<void>;
}
declare class LikeC4MCPServerFactory {
    private services;
    constructor(services: LikeC4Services);
    create(options?: ServerOptions): McpServer;
}

declare namespace LikeC4MCPTools {
    const instructions = "This server provides access to LikeC4 model.\n\nKey capabilities:\n- List all available LikeC4 projects in the workspace\n- Search for LikeC4 project and return its summary, that includes specifications, all elements and views\n- Search for LikeC4 element by title\n- Read details about LikeC4 element by id\n- Read details about LikeC4 view by id\n\n";
    const listProjects: {
        name: string;
        description: string;
    };
    const readProjectSummary: {
        name: string;
        description: string;
        paramsSchema: {
            project: ZodOptional<ZodString>;
        };
    };
    const searchElement: {
        name: string;
        description: string;
        paramsSchema: {
            search: ZodString;
        };
    };
    const readElement: {
        name: string;
        description: string;
        paramsSchema: {
            id: ZodString;
            project: ZodOptional<ZodString>;
        };
    };
    const readView: {
        name: string;
        description: string;
        paramsSchema: {
            id: ZodString;
            project: ZodOptional<ZodString>;
        };
    };
}
interface LikeC4MCPTools {
    listProjects(): Promise<string>;
    /**
     * Searches for LikeC4 project and returns its summary, specifications, elements and views
     *
     * @param project Project name (optional, will use default project if not specified)
     */
    readProjectSummary(project?: string): Promise<string>;
    /**
     * Searches for LikeC4 elements that have the search string in their names
     * Can be used to resolve projects for further requests (like read-element or read-project-summary)
     *
     * @param params.search non-empty string
     */
    searchElement(params: {
        search: string;
    }): Promise<string>;
    /**
     * Read details about LikeC4 element.
     *
     * @param params.id Element id (FQN)
     * @param params.project Project name (optional, will use default project if not specified)
     */
    readElement(params: {
        id: string;
        project?: string | undefined;
    }): Promise<string>;
    /**
     * Read details about LikeC4 view.
     *
     * @param params.id View id (FQN)
     * @param params.project Project name (optional, will use default project if not specified)
     */
    readView(params: {
        id: string;
        project?: string | undefined;
    }): Promise<string>;
}

declare class LikeC4ModelChanges {
    private services;
    private locator;
    constructor(services: LikeC4Services);
    applyChange(changeView: ChangeView.Params): Promise<Location | null>;
    protected convertToTextEdit({ viewId, projectId, change }: ChangeView.Params): {
        doc: ParsedLikeC4LangiumDocument;
        modifiedRange: Range$1;
        edits: TextEdit$1[];
    };
}

declare class Rpc extends ADisposable {
    private services;
    constructor(services: LikeC4Services);
    init(): void;
}

declare class NodeKindProvider implements NodeKindProvider$1 {
    private services;
    constructor(services: LangiumSharedServices);
    /**
     * Returns a `SymbolKind` as used by `WorkspaceSymbolProvider` or `DocumentSymbolProvider`.
     */
    getSymbolKind(node: AstNode | AstNodeDescription): SymbolKind;
    /**
     * Returns a `CompletionItemKind` as used by the `CompletionProvider`.
     */
    getCompletionItemKind(node: AstNode | AstNodeDescription): CompletionItemKind;
}

declare class WorkspaceSymbolProvider extends DefaultWorkspaceSymbolProvider {
}

interface LikeC4AddedSharedServices {
    lsp: {
        NodeKindProvider: NodeKindProvider;
        WorkspaceSymbolProvider: WorkspaceSymbolProvider;
    };
    workspace: {
        ProjectsManager: ProjectsManager;
        IndexManager: IndexManager;
        LangiumDocuments: LangiumDocuments;
        WorkspaceManager: LikeC4WorkspaceManager;
    };
}
type LikeC4SharedServices = LangiumSharedServices & LikeC4AddedSharedServices;
/**
 * Declaration of custom services - add your own service classes here.
 */
interface LikeC4AddedServices {
    documentation: {
        DocumentationProvider: LikeC4DocumentationProvider;
    };
    ValidatedWorkspaceCache: WorkspaceCache<string, any>;
    Rpc: Rpc;
    mcp: {
        Tools: LikeC4MCPTools;
        Server: LikeC4MCPServer;
        ServerFactory: LikeC4MCPServerFactory;
    };
    likec4: {
        LanguageServices: LikeC4LanguageServices;
        Views: LikeC4Views;
        Layouter: GraphvizLayouter;
        DeploymentsIndex: DeploymentsIndex;
        FqnIndex: FqnIndex;
        ModelParser: LikeC4ModelParser;
        ModelBuilder: LikeC4ModelBuilder;
        ModelLocator: LikeC4ModelLocator;
        ModelChanges: LikeC4ModelChanges;
    };
    lsp: {
        CompletionProvider: LikeC4CompletionProvider;
        DocumentHighlightProvider: LikeC4DocumentHighlightProvider;
        DocumentSymbolProvider: LikeC4DocumentSymbolProvider;
        SemanticTokenProvider: LikeC4SemanticTokenProvider;
        HoverProvider: LikeC4HoverProvider;
        CodeLensProvider: LikeC4CodeLensProvider;
        DocumentLinkProvider: LikeC4DocumentLinkProvider;
    };
    references: {
        NameProvider: LikeC4NameProvider;
        ScopeComputation: LikeC4ScopeComputation;
        ScopeProvider: LikeC4ScopeProvider;
    };
    shared?: LikeC4SharedServices;
}
type LikeC4Services = LangiumServices & LikeC4AddedServices;

export { GraphvizLayouter as G, type LikeC4LanguageServices as L, Range$1 as R, WorkspaceFolder as W, type LikeC4Services as a, type LikeC4Views as b };
