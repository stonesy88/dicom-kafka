import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import * as React from "react";
import React__default, { useState, Fragment, createContext, useContext, useRef, useEffect, useMemo, useCallback, useLayoutEffect as useLayoutEffect$1, useId as useId$2, forwardRef, cloneElement, Children, createElement, useInsertionEffect as useInsertionEffect$1, isValidElement, Component, memo as memo$2, useSyncExternalStore, createRef, useDeferredValue, StrictMode } from "react";
import { createRoot } from "react-dom/client";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { createPortal, flushSync } from "react-dom";
import { ComponentName, useHashHistory, withOverviewGraph, isDevelopment, krokiD2SvgUrl, basepath } from "./const.js";
import { projects, isSingleProject } from "likec4:projects";
import { createLikeC4Model } from "likec4/model";
import { invariant as invariant$2, hasAtLeast, nonexhaustive, isStepEdgeId, extractStep, DefaultShapeSize, DefaultTextSize, DefaultPaddingSize, compareNatural, DiagramNode, nameFromFqn, nonNullable, defaultTheme, ElementShapes, toArray, ifind, DefaultMap, ancestorsFqn, isScopedElementView, isDeploymentView, Queue, ElementKind, delay as delay$1, isAncestor, sortParentsFirst, ifilter, whereOperatorAsPredicate, getBBoxCenter, getParallelStepsPrefix, ComputedView, isDescendantOf } from "@likec4/core";
import { computeRelationshipsView, treeFromElements as treeFromElements$1 } from "@likec4/core/compute-view/relationships";
import { modelConnection } from "@likec4/core/model";
import { ifind as ifind$1, DefaultMap as DefaultMap$1 } from "@likec4/core/utils";
import { ProjectIcons } from "likec4:icons";
import { loadModel } from "likec4:model";
import { loadMmdSources } from "likec4:mmd";
import { projectId } from "likec4:single-project";
import { loadDotSources } from "likec4:dot";
import { loadD2Sources } from "likec4:d2";
var __assign = function() {
  return __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && (t2[p2] = s2[p2]);
    }
    return t2;
  }, __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
  if (s2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++)
      e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
  return t2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++)
    (ar || !(i2 in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i2)), ar[i2] = from[i2]);
  return to.concat(ar || Array.prototype.slice.call(from));
}
var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef$1(ref, value) {
  return typeof ref == "function" ? ref(value) : ref && (ref.current = value), ref;
}
function useCallbackRef$1(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          last2 !== value && (ref.value = value, ref.callback(value, last2));
        }
      }
    };
  })[0];
  return ref.callback = callback, ref.facade;
}
var useIsomorphicLayoutEffect$3 = typeof window < "u" ? React.useLayoutEffect : React.useEffect, currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs$1(refs, defaultValue) {
  var callbackRef = useCallbackRef$1(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef$1(ref, newValue);
    });
  });
  return useIsomorphicLayoutEffect$3(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue), nextRefs_1 = new Set(refs), current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        nextRefs_1.has(ref) || assignRef$1(ref, null);
      }), nextRefs_1.forEach(function(ref) {
        prevRefs_1.has(ref) || assignRef$1(ref, current_1);
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]), callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  middleware === void 0 && (middleware = ItoI);
  var buffer = [], assigned = !1, medium = {
    read: function() {
      if (assigned)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return buffer.length ? buffer[buffer.length - 1] : defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      return buffer.push(item), function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      for (assigned = !0; buffer.length; ) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = !0;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb), pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [], cbs2.forEach(cb);
      }, cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle(), buffer = {
        push: function(x2) {
          pendingQueue.push(x2), cycle();
        },
        filter: function(filter2) {
          return pendingQueue = pendingQueue.filter(filter2), buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  options === void 0 && (options = {});
  var medium = innerCreateMedium(null);
  return medium.options = __assign({ async: !0, ssr: !1 }, options), medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var Target = sideCar.read();
  if (!Target)
    throw new Error("Sidecar medium not found");
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(medium, exported) {
  return medium.useMedium(exported), SideCar$1;
}
var effectCar = createSidecarMedium(), nothing = function() {
}, RemoveScroll$1 = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null), _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1], forwardProps = props.forwardProps, children2 = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container2 = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), SideCar2 = sideCar, containerRef = useMergeRefs$1([ref, parentRef]), containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children2), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children2)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var currentNonce, getNonce = function() {
  if (currentNonce)
    return currentNonce;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  return nonce && tag.setAttribute("nonce", nonce), tag;
}
function injectStyles(tag, css2) {
  tag.styleSheet ? tag.styleSheet.cssText = css2 : tag.appendChild(document.createTextNode(css2));
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0, stylesheet = null;
  return {
    add: function(style2) {
      counter == 0 && (stylesheet = makeStyleTag()) && (injectStyles(stylesheet, style2), insertStyleTag(stylesheet)), counter++;
    },
    remove: function() {
      counter--, !counter && stylesheet && (stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet), stylesheet = null);
    }
  };
}, styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      return sheet.add(styles), function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
}, styleSingleton = function() {
  var useStyle2 = styleHookSingleton(), Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    return useStyle2(styles, dynamic), null;
  };
  return Sheet;
}, zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
}, getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body), left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"], top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"], right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
}, getGapWidth = function(gapMode) {
  if (gapMode === void 0 && (gapMode = "margin"), typeof window > "u")
    return zeroGap;
  var offsets = getOffset(gapMode), documentWidth = document.documentElement.clientWidth, windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
}, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  return gapMode === void 0 && (gapMode = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
}, getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
}, useLockAttribute = function() {
  React.useEffect(function() {
    return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
      var newCounter = getCurrentUseCounter() - 1;
      newCounter <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, newCounter.toString());
    };
  }, []);
}, RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, noImportant ? "" : "!important") });
}, passiveSupported = !1;
if (typeof window < "u")
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        return passiveSupported = !0, !0;
      }
    });
    window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
  } catch {
    passiveSupported = !1;
  }
var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
}, elementCanBeScrolled = function(node2, overflow) {
  if (!(node2 instanceof Element))
    return !1;
  var styles = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node2) && styles[overflow] === "visible")
  );
}, elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
}, elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
}, locationCouldBeScrolled = function(axis, node2) {
  var ownerDocument = node2.ownerDocument, current = node2;
  do {
    typeof ShadowRoot < "u" && current instanceof ShadowRoot && (current = current.host);
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight)
        return !0;
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return !1;
}, getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
}, getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
}, elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
}, getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
}, getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
}, handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction), delta = directionFactor * sourceDelta, target = event.target, targetInLock = endTarget.contains(target), shouldCancelScroll = !1, isDeltaPositive = delta > 0, availableScroll = 0, availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2], elementScroll = scroll_1 - capacity - directionFactor * position;
    (position || elementScroll) && elementCouldBeScrolled(axis, target) && (availableScroll += elementScroll, availableScrollTop += position), target instanceof ShadowRoot ? target = target.host : target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  return (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll) || !isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) && (shouldCancelScroll = !0), shouldCancelScroll;
}, getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
}, getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
}, extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
}, deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
}, generateStyle = function(id2) {
  return `
  .block-interactivity-`.concat(id2, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id2, ` {pointer-events: all;}
`);
}, idCounter = 0, lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]), touchStartRef = React.useRef([0, 0]), activeAxis = React.useRef(), id2 = React.useState(idCounter++)[0], Style2 = React.useState(styleSingleton)[0], lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]), React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), !0).filter(Boolean);
      return allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(id2)), allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey)
      return !lastProps.current.allowPinchZoom;
    var touch = getTouchXY(event), touchStart = touchStartRef.current, deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0], deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1], currentAxis, target = event.target, moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range")
      return !1;
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection)
      return !0;
    if (canBeScrolledInMainDirection ? currentAxis = moveDirection : (currentAxis = moveDirection === "v" ? "h" : "v", canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)), !canBeScrolledInMainDirection)
      return !1;
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY) && (activeAxis.current = currentAxis), !currentAxis)
      return !0;
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, !0);
  }, []), shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Style2)) {
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event), sourceEvent2 = shouldPreventQueue.current.filter(function(e2) {
        return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
      })[0];
      if (sourceEvent2 && sourceEvent2.should) {
        event.cancelable && event.preventDefault();
        return;
      }
      if (!sourceEvent2) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
          return node2.contains(event.target);
        }), shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        shouldStop && event.cancelable && event.preventDefault();
      }
    }
  }, []), shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event), setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []), scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event), activeAxis.current = void 0;
  }, []), scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []), scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    return lockStack.push(Style2), props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    }), document.addEventListener("wheel", shouldPrevent, nonPassive), document.addEventListener("touchmove", shouldPrevent, nonPassive), document.addEventListener("touchstart", scrollTouchStart, nonPassive), function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      }), document.removeEventListener("wheel", shouldPrevent, nonPassive), document.removeEventListener("touchmove", shouldPrevent, nonPassive), document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node2) {
  for (var shadowParent = null; node2 !== null; )
    node2 instanceof ShadowRoot && (shadowParent = node2.host, node2 = node2.host), node2 = node2.parentNode;
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll$1, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll$1.classNames;
const RemoveScroll = ReactRemoveScroll;
function keys$1(object) {
  return Object.keys(object);
}
function isObject$1(item) {
  return item && typeof item == "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
  const result = { ...target }, _source = source;
  return isObject$1(target) && isObject$1(source) && Object.keys(source).forEach((key2) => {
    isObject$1(_source[key2]) && key2 in target ? result[key2] = deepMerge(result[key2], _source[key2]) : result[key2] = _source[key2];
  }), result;
}
function camelToKebabCase(value) {
  return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}
function getTransformedScaledValue(value) {
  return typeof value != "string" || !value.includes("var(--mantine-scale)") ? value : value.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function px$1(value) {
  const transformedValue = getTransformedScaledValue(value);
  return typeof transformedValue == "number" ? transformedValue : typeof transformedValue == "string" ? transformedValue.includes("calc") || transformedValue.includes("var") ? transformedValue : transformedValue.includes("px") ? Number(transformedValue.replace("px", "")) : transformedValue.includes("rem") ? Number(transformedValue.replace("rem", "")) * 16 : transformedValue.includes("em") ? Number(transformedValue.replace("em", "")) * 16 : Number(transformedValue) : NaN;
}
function scaleRem(remValue) {
  return remValue === "0rem" ? "0rem" : `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = !1 } = {}) {
  function converter(value) {
    if (value === 0 || value === "0")
      return `0${units}`;
    if (typeof value == "number") {
      const val = `${value / 16}${units}`;
      return shouldScale ? scaleRem(val) : val;
    }
    if (typeof value == "string") {
      if (value === "" || value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba("))
        return value;
      if (value.includes(","))
        return value.split(",").map((val) => converter(val)).join(",");
      if (value.includes(" "))
        return value.split(" ").map((val) => converter(val)).join(" ");
      if (value.includes(units))
        return shouldScale ? scaleRem(value) : value;
      const replaced = value.replace("px", "");
      if (!Number.isNaN(Number(replaced))) {
        const val = `${Number(replaced) / 16}${units}`;
        return shouldScale ? scaleRem(val) : val;
      }
    }
    return value;
  }
  return converter;
}
const rem = createConverter("rem", { shouldScale: !0 }), em = createConverter("em");
function filterProps$1(props) {
  return Object.keys(props).reduce((acc, key2) => (props[key2] !== void 0 && (acc[key2] = props[key2]), acc), {});
}
function isNumberLike(value) {
  if (typeof value == "number")
    return !0;
  if (typeof value == "string") {
    if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "")
      return !0;
    const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    return value.trim().split(/\s+/).every((val) => cssUnitsRegex.test(val));
  }
  return !1;
}
function isElement$1(value) {
  return Array.isArray(value) || value === null ? !1 : typeof value == "object" ? value.type !== Fragment : !1;
}
function createSafeContext(errorMessage) {
  const Context = createContext(null);
  return [({ children: children2, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children: children2 }), () => {
    const ctx = useContext(Context);
    if (ctx === null)
      throw new Error(errorMessage);
    return ctx;
  }];
}
function createOptionalContext(initialValue = null) {
  const Context = createContext(initialValue);
  return [({ children: children2, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children: children2 }), () => useContext(Context)];
}
function getSafeId(uid, errorMessage) {
  return (value) => {
    if (typeof value != "string" || value.trim().length === 0)
      throw new Error(errorMessage);
    return `${uid}-${value}`;
  };
}
function findElementAncestor(element, selector3) {
  let _element = element;
  for (; (_element = _element.parentElement) && !_element.matches(selector3); )
    ;
  return _element;
}
function getPreviousIndex$1(current, elements, loop) {
  for (let i2 = current - 1; i2 >= 0; i2 -= 1)
    if (!elements[i2].disabled)
      return i2;
  if (loop) {
    for (let i2 = elements.length - 1; i2 > -1; i2 -= 1)
      if (!elements[i2].disabled)
        return i2;
  }
  return current;
}
function getNextIndex$1(current, elements, loop) {
  for (let i2 = current + 1; i2 < elements.length; i2 += 1)
    if (!elements[i2].disabled)
      return i2;
  if (loop) {
    for (let i2 = 0; i2 < elements.length; i2 += 1)
      if (!elements[i2].disabled)
        return i2;
  }
  return current;
}
function onSameLevel(target, sibling, parentSelector) {
  return findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector);
}
function createScopedKeydownHandler({
  parentSelector,
  siblingSelector,
  onKeyDown,
  loop = !0,
  activateOnFocus = !1,
  dir = "rtl",
  orientation
}) {
  return (event) => {
    onKeyDown?.(event);
    const elements = Array.from(
      findElementAncestor(event.currentTarget, parentSelector)?.querySelectorAll(
        siblingSelector
      ) || []
    ).filter((node2) => onSameLevel(event.currentTarget, node2, parentSelector)), current = elements.findIndex((el) => event.currentTarget === el), _nextIndex = getNextIndex$1(current, elements, loop), _previousIndex = getPreviousIndex$1(current, elements, loop), nextIndex = dir === "rtl" ? _previousIndex : _nextIndex, previousIndex = dir === "rtl" ? _nextIndex : _previousIndex;
    switch (event.key) {
      case "ArrowRight": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[nextIndex].focus(), activateOnFocus && elements[nextIndex].click());
        break;
      }
      case "ArrowLeft": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[previousIndex].focus(), activateOnFocus && elements[previousIndex].click());
        break;
      }
      case "ArrowUp": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_previousIndex].focus(), activateOnFocus && elements[_previousIndex].click());
        break;
      }
      case "ArrowDown": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_nextIndex].focus(), activateOnFocus && elements[_nextIndex].click());
        break;
      }
      case "Home": {
        event.stopPropagation(), event.preventDefault(), !elements[0].disabled && elements[0].focus();
        break;
      }
      case "End": {
        event.stopPropagation(), event.preventDefault();
        const last2 = elements.length - 1;
        !elements[last2].disabled && elements[last2].focus();
        break;
      }
    }
  };
}
const elevations = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function getDefaultZIndex(level2) {
  return elevations[level2];
}
const noop$5 = () => {
};
function closeOnEscape(callback, options = { active: !0 }) {
  return typeof callback != "function" || !options.active ? options.onKeyDown || noop$5 : (event) => {
    event.key === "Escape" && (callback(event), options.onTrigger?.());
  };
}
function getSize(size2, prefix2 = "size", convertToRem = !0) {
  if (size2 !== void 0)
    return isNumberLike(size2) ? convertToRem ? rem(size2) : size2 : `var(--${prefix2}-${size2})`;
}
function getSpacing(size2) {
  return getSize(size2, "mantine-spacing");
}
function getRadius$1(size2) {
  return size2 === void 0 ? "var(--mantine-radius-default)" : getSize(size2, "mantine-radius");
}
function getFontSize(size2) {
  return getSize(size2, "mantine-font-size");
}
function getLineHeight(size2) {
  return getSize(size2, "mantine-line-height", !1);
}
function getShadow(size2) {
  if (size2)
    return getSize(size2, "mantine-shadow", !1);
}
function createEventHandler(parentEventHandler, eventHandler) {
  return (event) => {
    parentEventHandler?.(event), eventHandler?.(event);
  };
}
function getBreakpointValue$1(breakpoint, breakpoints) {
  return breakpoint in breakpoints ? px$1(breakpoints[breakpoint]) : px$1(breakpoint);
}
function getSortedBreakpoints(values2, breakpoints) {
  const convertedBreakpoints = values2.map((breakpoint) => ({
    value: breakpoint,
    px: getBreakpointValue$1(breakpoint, breakpoints)
  }));
  return convertedBreakpoints.sort((a2, b2) => a2.px - b2.px), convertedBreakpoints;
}
function getBaseValue$1(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getContextItemIndex(elementSelector, parentSelector, node2) {
  return node2 ? Array.from(
    findElementAncestor(node2, parentSelector)?.querySelectorAll(elementSelector) || []
  ).findIndex((element) => element === node2) : null;
}
function useHovered() {
  const [hovered, setHovered] = useState(-1);
  return [hovered, { setHovered, resetHovered: () => setHovered(-1) }];
}
function clamp$4(value, min2, max2) {
  return min2 === void 0 && max2 === void 0 ? value : min2 !== void 0 && max2 === void 0 ? Math.max(value, min2) : Math.min(min2 === void 0 && max2 !== void 0 ? value : Math.max(value, min2), max2);
}
function randomId(prefix2 = "mantine-") {
  return `${prefix2}${Math.random().toString(36).slice(2, 11)}`;
}
function shallowEqual$1(a2, b2) {
  if (a2 === b2)
    return !0;
  if (!(a2 instanceof Object) || !(b2 instanceof Object))
    return !1;
  const keys2 = Object.keys(a2), { length } = keys2;
  if (length !== Object.keys(b2).length)
    return !1;
  for (let i2 = 0; i2 < length; i2 += 1) {
    const key2 = keys2[i2];
    if (!(key2 in b2) || a2[key2] !== b2[key2])
      return !1;
  }
  return !0;
}
function useCallbackRef(callback) {
  const callbackRef = useRef(callback);
  return useEffect(() => {
    callbackRef.current = callback;
  }), useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
const noop$4 = () => {
};
function useDebouncedCallback$1(callback, options) {
  const delay2 = typeof options == "number" ? options : options.delay, flushOnUnmount = typeof options == "number" ? !1 : options.flushOnUnmount, handleCallback = useCallbackRef(callback), debounceTimerRef = useRef(0), lastCallback = Object.assign(
    useCallback(
      (...args) => {
        window.clearTimeout(debounceTimerRef.current);
        const flush = () => {
          debounceTimerRef.current !== 0 && (debounceTimerRef.current = 0, handleCallback(...args));
        };
        lastCallback.flush = flush, debounceTimerRef.current = window.setTimeout(flush, delay2);
      },
      [handleCallback, delay2]
    ),
    { flush: noop$4 }
  );
  return useEffect(
    () => () => {
      window.clearTimeout(debounceTimerRef.current), flushOnUnmount && lastCallback.flush();
    },
    [lastCallback, flushOnUnmount]
  ), lastCallback;
}
const DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(handler, events, nodes) {
  const ref = useRef(null);
  return useEffect(() => {
    const listener = (event) => {
      const { target } = event ?? {};
      if (Array.isArray(nodes)) {
        const shouldIgnore = target?.hasAttribute("data-ignore-outside-clicks") || !document.body.contains(target) && target.tagName !== "HTML";
        nodes.every((node2) => !!node2 && !event.composedPath().includes(node2)) && !shouldIgnore && handler();
      } else ref.current && !ref.current.contains(target) && handler();
    };
    return (events || DEFAULT_EVENTS).forEach((fn) => document.addEventListener(fn, listener)), () => {
      (events || DEFAULT_EVENTS).forEach((fn) => document.removeEventListener(fn, listener));
    };
  }, [ref, handler, nodes]), ref;
}
function useClipboard({ timeout: timeout2 = 2e3 } = {}) {
  const [error, setError] = useState(null), [copied, setCopied] = useState(!1), [copyTimeout, setCopyTimeout] = useState(null), handleCopyResult = (value) => {
    window.clearTimeout(copyTimeout), setCopyTimeout(window.setTimeout(() => setCopied(!1), timeout2)), setCopied(value);
  };
  return { copy: (valueToCopy) => {
    "clipboard" in navigator ? navigator.clipboard.writeText(valueToCopy).then(() => handleCopyResult(!0)).catch((err) => setError(err)) : setError(new Error("useClipboard: navigator.clipboard is not supported"));
  }, reset: () => {
    setCopied(!1), setError(null), window.clearTimeout(copyTimeout);
  }, error, copied };
}
function attachMediaListener(query, callback) {
  try {
    return query.addEventListener("change", callback), () => query.removeEventListener("change", callback);
  } catch {
    return query.addListener(callback), () => query.removeListener(callback);
  }
}
function getInitialValue(query, initialValue) {
  return typeof window < "u" && "matchMedia" in window ? window.matchMedia(query).matches : !1;
}
function useMediaQuery(query, initialValue, { getInitialValueInEffect } = {
  getInitialValueInEffect: !0
}) {
  const [matches, setMatches] = useState(
    getInitialValueInEffect ? initialValue : getInitialValue(query)
  ), queryRef = useRef(null);
  return useEffect(() => {
    if ("matchMedia" in window)
      return queryRef.current = window.matchMedia(query), setMatches(queryRef.current.matches), attachMediaListener(queryRef.current, (event) => setMatches(event.matches));
  }, [query]), matches;
}
function useColorScheme(initialValue, options) {
  return useMediaQuery("(prefers-color-scheme: dark)", initialValue === "dark", options) ? "dark" : "light";
}
function useDebouncedValue(value, wait, options = { leading: !1 }) {
  const [_value, setValue] = useState(value), mountedRef = useRef(!1), timeoutRef = useRef(null), cooldownRef = useRef(!1), cancel = () => window.clearTimeout(timeoutRef.current);
  return useEffect(() => {
    mountedRef.current && (!cooldownRef.current && options.leading ? (cooldownRef.current = !0, setValue(value)) : (cancel(), timeoutRef.current = window.setTimeout(() => {
      cooldownRef.current = !1, setValue(value);
    }, wait)));
  }, [value, options.leading, wait]), useEffect(() => (mountedRef.current = !0, cancel), []), [_value, cancel];
}
const useIsomorphicEffect = typeof document < "u" ? useLayoutEffect$1 : useEffect;
function useDocumentTitle(title2) {
  useIsomorphicEffect(() => {
    typeof title2 == "string" && title2.trim().length > 0 && (document.title = title2.trim());
  }, [title2]);
}
function useDidUpdate(fn, dependencies) {
  const mounted = useRef(!1);
  useEffect(
    () => () => {
      mounted.current = !1;
    },
    []
  ), useEffect(() => {
    if (mounted.current)
      return fn();
    mounted.current = !0;
  }, dependencies);
}
function useFocusReturn({ opened, shouldReturnFocus = !0 }) {
  const lastActiveElement = useRef(null), returnFocus = () => {
    lastActiveElement.current && "focus" in lastActiveElement.current && typeof lastActiveElement.current.focus == "function" && lastActiveElement.current?.focus({ preventScroll: !0 });
  };
  return useDidUpdate(() => {
    let timeout2 = -1;
    const clearFocusTimeout = (event) => {
      event.key === "Tab" && window.clearTimeout(timeout2);
    };
    return document.addEventListener("keydown", clearFocusTimeout), opened ? lastActiveElement.current = document.activeElement : shouldReturnFocus && (timeout2 = window.setTimeout(returnFocus, 10)), () => {
      window.clearTimeout(timeout2), document.removeEventListener("keydown", clearFocusTimeout);
    };
  }, [opened, shouldReturnFocus]), returnFocus;
}
const TABBABLE_NODES = /input|select|textarea|button|object/, FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
  return element.style.display === "none";
}
function visible(element) {
  if (element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden")
    return !1;
  let parentElement = element;
  for (; parentElement && !(parentElement === document.body || parentElement.nodeType === 11); ) {
    if (hidden(parentElement))
      return !1;
    parentElement = parentElement.parentNode;
  }
  return !0;
}
function getElementTabIndex(element) {
  let tabIndex = element.getAttribute("tabindex");
  return tabIndex === null && (tabIndex = void 0), parseInt(tabIndex, 10);
}
function focusable$1(element) {
  const nodeName = element.nodeName.toLowerCase(), isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));
  return /* @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition */ (TABBABLE_NODES.test(nodeName) && !element.disabled || element instanceof HTMLAnchorElement && element.href || isTabIndexNotNaN) && visible(element);
}
function tabbable(element) {
  const tabIndex = getElementTabIndex(element);
  return (Number.isNaN(tabIndex) || tabIndex >= 0) && focusable$1(element);
}
function findTabbableDescendants(element) {
  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}
function scopeTab(node2, event) {
  const tabbable2 = findTabbableDescendants(node2);
  if (!tabbable2.length) {
    event.preventDefault();
    return;
  }
  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1], root2 = node2.getRootNode();
  let leavingFinalTabbable = finalTabbable === root2.activeElement || node2 === root2.activeElement;
  const activeElement2 = root2.activeElement;
  if (activeElement2.tagName === "INPUT" && activeElement2.getAttribute("type") === "radio" && (leavingFinalTabbable = tabbable2.filter(
    (element) => element.getAttribute("type") === "radio" && element.getAttribute("name") === activeElement2.getAttribute("name")
  ).includes(finalTabbable)), !leavingFinalTabbable)
    return;
  event.preventDefault();
  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];
  target && target.focus();
}
function useFocusTrap(active = !0) {
  const ref = useRef(null), focusNode = (node2) => {
    let focusElement = node2.querySelector("[data-autofocus]");
    if (!focusElement) {
      const children2 = Array.from(node2.querySelectorAll(FOCUS_SELECTOR));
      focusElement = children2.find(tabbable) || children2.find(focusable$1) || null, !focusElement && focusable$1(node2) && (focusElement = node2);
    }
    focusElement && focusElement.focus({ preventScroll: !0 });
  }, setRef = useCallback(
    (node2) => {
      active && node2 !== null && ref.current !== node2 && (node2 ? (setTimeout(() => {
        node2.getRootNode() && focusNode(node2);
      }), ref.current = node2) : ref.current = null);
    },
    [active]
  );
  return useEffect(() => {
    if (!active)
      return;
    ref.current && setTimeout(() => focusNode(ref.current));
    const handleKeyDown = (event) => {
      event.key === "Tab" && ref.current && scopeTab(ref.current, event);
    };
    return document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown);
  }, [active]), setRef;
}
const __useId = React__default.useId || (() => {
});
function useReactId$1() {
  const id2 = __useId();
  return id2 ? `mantine-${id2.replace(/:/g, "")}` : "";
}
function useId$1(staticId) {
  const reactId = useReactId$1(), [uuid, setUuid] = useState(reactId);
  return useIsomorphicEffect(() => {
    setUuid(randomId());
  }, []), typeof staticId == "string" ? staticId : typeof window > "u" ? reactId : uuid;
}
function useWindowEvent(type, listener, options) {
  useEffect(() => (window.addEventListener(type, listener, options), () => window.removeEventListener(type, listener, options)), [type, listener]);
}
function serializeJSON(value, hookName = "use-local-storage") {
  try {
    return JSON.stringify(value);
  } catch {
    throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);
  }
}
function deserializeJSON(value) {
  try {
    return value && JSON.parse(value);
  } catch {
    return value;
  }
}
function createStorageHandler(type) {
  return { getItem: (key2) => {
    try {
      return window[type].getItem(key2);
    } catch {
      return console.warn("use-local-storage: Failed to get value from storage, localStorage is blocked"), null;
    }
  }, setItem: (key2, value) => {
    try {
      window[type].setItem(key2, value);
    } catch {
      console.warn("use-local-storage: Failed to set value to storage, localStorage is blocked");
    }
  }, removeItem: (key2) => {
    try {
      window[type].removeItem(key2);
    } catch {
      console.warn(
        "use-local-storage: Failed to remove value from storage, localStorage is blocked"
      );
    }
  } };
}
function createStorage(type, hookName) {
  const eventName = type === "localStorage" ? "mantine-local-storage" : "mantine-session-storage", { getItem, setItem, removeItem: removeItem2 } = createStorageHandler(type);
  return function({
    key: key2,
    defaultValue,
    getInitialValueInEffect = !0,
    sync = !0,
    deserialize = deserializeJSON,
    serialize = (value) => serializeJSON(value, hookName)
  }) {
    const readStorageValue = useCallback(
      (skipStorage) => {
        let storageBlockedOrSkipped;
        try {
          storageBlockedOrSkipped = typeof window > "u" || !(type in window) || window[type] === null || !!skipStorage;
        } catch {
          storageBlockedOrSkipped = !0;
        }
        if (storageBlockedOrSkipped)
          return defaultValue;
        const storageValue = getItem(key2);
        return storageValue !== null ? deserialize(storageValue) : defaultValue;
      },
      [key2, defaultValue]
    ), [value, setValue] = useState(readStorageValue(getInitialValueInEffect)), setStorageValue = useCallback(
      (val) => {
        val instanceof Function ? setValue((current) => {
          const result = val(current);
          return setItem(key2, serialize(result)), window.dispatchEvent(
            new CustomEvent(eventName, { detail: { key: key2, value: val(current) } })
          ), result;
        }) : (setItem(key2, serialize(val)), window.dispatchEvent(new CustomEvent(eventName, { detail: { key: key2, value: val } })), setValue(val));
      },
      [key2]
    ), removeStorageValue = useCallback(() => {
      removeItem2(key2), window.dispatchEvent(new CustomEvent(eventName, { detail: { key: key2, value: defaultValue } }));
    }, []);
    return useWindowEvent("storage", (event) => {
      sync && event.storageArea === window[type] && event.key === key2 && setValue(deserialize(event.newValue ?? void 0));
    }), useWindowEvent(eventName, (event) => {
      sync && event.detail.key === key2 && setValue(event.detail.value);
    }), useEffect(() => {
      defaultValue !== void 0 && value === void 0 && setStorageValue(defaultValue);
    }, [defaultValue, value, setStorageValue]), useEffect(() => {
      const val = readStorageValue();
      val !== void 0 && setStorageValue(val);
    }, [key2]), [value === void 0 ? defaultValue : value, setStorageValue, removeStorageValue];
  };
}
function useLocalStorage(props) {
  return createStorage("localStorage", "use-local-storage")(props);
}
function useSessionStorage(props) {
  return createStorage("sessionStorage", "use-session-storage")(props);
}
function assignRef(ref, value) {
  if (typeof ref == "function")
    return ref(value);
  typeof ref == "object" && ref !== null && "current" in ref && (ref.current = value);
}
function mergeRefs(...refs) {
  const cleanupMap = /* @__PURE__ */ new Map();
  return (node2) => {
    if (refs.forEach((ref) => {
      const cleanup = assignRef(ref, node2);
      cleanup && cleanupMap.set(ref, cleanup);
    }), cleanupMap.size > 0)
      return () => {
        refs.forEach((ref) => {
          const cleanup = cleanupMap.get(ref);
          cleanup ? cleanup() : assignRef(ref, null);
        }), cleanupMap.clear();
      };
  };
}
function useMergedRef(...refs) {
  return useCallback(mergeRefs(...refs), refs);
}
function clampUseMovePosition(position) {
  return {
    x: clamp$4(position.x, 0, 1),
    y: clamp$4(position.y, 0, 1)
  };
}
function useMove(onChange, handlers, dir = "ltr") {
  const ref = useRef(null), mounted = useRef(!1), isSliding = useRef(!1), frame2 = useRef(0), [active, setActive] = useState(!1);
  return useEffect(() => {
    mounted.current = !0;
  }, []), useEffect(() => {
    const node2 = ref.current, onScrub = ({ x: x2, y: y2 }) => {
      cancelAnimationFrame(frame2.current), frame2.current = requestAnimationFrame(() => {
        if (mounted.current && node2) {
          node2.style.userSelect = "none";
          const rect = node2.getBoundingClientRect();
          if (rect.width && rect.height) {
            const _x = clamp$4((x2 - rect.left) / rect.width, 0, 1);
            onChange({
              x: dir === "ltr" ? _x : 1 - _x,
              y: clamp$4((y2 - rect.top) / rect.height, 0, 1)
            });
          }
        }
      });
    }, bindEvents = () => {
      document.addEventListener("mousemove", onMouseMove), document.addEventListener("mouseup", stopScrubbing), document.addEventListener("touchmove", onTouchMove), document.addEventListener("touchend", stopScrubbing);
    }, unbindEvents = () => {
      document.removeEventListener("mousemove", onMouseMove), document.removeEventListener("mouseup", stopScrubbing), document.removeEventListener("touchmove", onTouchMove), document.removeEventListener("touchend", stopScrubbing);
    }, startScrubbing = () => {
      !isSliding.current && mounted.current && (isSliding.current = !0, typeof handlers?.onScrubStart == "function" && handlers.onScrubStart(), setActive(!0), bindEvents());
    }, stopScrubbing = () => {
      isSliding.current && mounted.current && (isSliding.current = !1, setActive(!1), unbindEvents(), setTimeout(() => {
        typeof handlers?.onScrubEnd == "function" && handlers.onScrubEnd();
      }, 0));
    }, onMouseDown = (event) => {
      startScrubbing(), event.preventDefault(), onMouseMove(event);
    }, onMouseMove = (event) => onScrub({ x: event.clientX, y: event.clientY }), onTouchStart = (event) => {
      event.cancelable && event.preventDefault(), startScrubbing(), onTouchMove(event);
    }, onTouchMove = (event) => {
      event.cancelable && event.preventDefault(), onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });
    };
    return node2?.addEventListener("mousedown", onMouseDown), node2?.addEventListener("touchstart", onTouchStart, { passive: !1 }), () => {
      node2 && (node2.removeEventListener("mousedown", onMouseDown), node2.removeEventListener("touchstart", onTouchStart));
    };
  }, [dir, onChange]), { ref, active };
}
function useUncontrolled({
  value,
  defaultValue,
  finalValue,
  onChange = () => {
  }
}) {
  const [uncontrolledValue, setUncontrolledValue] = useState(
    defaultValue !== void 0 ? defaultValue : finalValue
  ), handleUncontrolledChange = (val, ...payload) => {
    setUncontrolledValue(val), onChange?.(val, ...payload);
  };
  return value !== void 0 ? [value, onChange, !0] : [uncontrolledValue, handleUncontrolledChange, !1];
}
function useReducedMotion$1(initialValue, options) {
  return useMediaQuery("(prefers-reduced-motion: reduce)", initialValue, options);
}
const defaultState = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
function useResizeObserver$2(options) {
  const frameID = useRef(0), ref = useRef(null), [rect, setRect] = useState(defaultState), observer = useMemo(
    () => typeof window < "u" ? new ResizeObserver((entries) => {
      const entry = entries[0];
      entry && (cancelAnimationFrame(frameID.current), frameID.current = requestAnimationFrame(() => {
        ref.current && setRect(entry.contentRect);
      }));
    }) : null,
    []
  );
  return useEffect(() => (ref.current && observer?.observe(ref.current, options), () => {
    observer?.disconnect(), frameID.current && cancelAnimationFrame(frameID.current);
  }), [ref.current]), [ref, rect];
}
function useElementSize(options) {
  const [ref, { width, height }] = useResizeObserver$2(options);
  return { ref, width, height };
}
function shallowCompare$1(prevValue, currValue) {
  if (!prevValue || !currValue)
    return !1;
  if (prevValue === currValue)
    return !0;
  if (prevValue.length !== currValue.length)
    return !1;
  for (let i2 = 0; i2 < prevValue.length; i2 += 1)
    if (!shallowEqual$1(prevValue[i2], currValue[i2]))
      return !1;
  return !0;
}
function useShallowCompare(dependencies) {
  const ref = useRef([]), updateRef = useRef(0);
  return shallowCompare$1(ref.current, dependencies) || (ref.current = dependencies, updateRef.current += 1), [updateRef.current];
}
function useShallowEffect(cb, dependencies) {
  useEffect(cb, useShallowCompare(dependencies));
}
const eventListerOptions = {
  passive: !0
};
function useViewportSize() {
  const [windowSize, setWindowSize] = useState({
    width: 0,
    height: 0
  }), setSize = useCallback(() => {
    setWindowSize({ width: window.innerWidth || 0, height: window.innerHeight || 0 });
  }, []);
  return useWindowEvent("resize", setSize, eventListerOptions), useWindowEvent("orientationchange", setSize, eventListerOptions), useEffect(setSize, []), windowSize;
}
function parseHotkey(hotkey) {
  const keys2 = hotkey.toLowerCase().split("+").map((part) => part.trim()), modifiers = {
    alt: keys2.includes("alt"),
    ctrl: keys2.includes("ctrl"),
    meta: keys2.includes("meta"),
    mod: keys2.includes("mod"),
    shift: keys2.includes("shift"),
    plus: keys2.includes("[plus]")
  }, reservedKeys = ["alt", "ctrl", "meta", "shift", "mod"], freeKey = keys2.find((key2) => !reservedKeys.includes(key2));
  return {
    ...modifiers,
    key: freeKey === "[plus]" ? "+" : freeKey
  };
}
function isExactHotkey(hotkey, event, usePhysicalKeys) {
  const { alt, ctrl, meta, mod, shift: shift2, key: key2 } = hotkey, { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey, code: pressedCode } = event;
  if (alt !== altKey)
    return !1;
  if (mod) {
    if (!ctrlKey && !metaKey)
      return !1;
  } else if (ctrl !== ctrlKey || meta !== metaKey)
    return !1;
  return shift2 !== shiftKey ? !1 : !!(key2 && (!usePhysicalKeys && pressedKey.toLowerCase() === key2.toLowerCase() || pressedCode.replace("Key", "").toLowerCase() === key2.toLowerCase()));
}
function getHotkeyMatcher(hotkey, usePhysicalKeys) {
  return (event) => isExactHotkey(parseHotkey(hotkey), event, usePhysicalKeys);
}
function getHotkeyHandler(hotkeys) {
  return (event) => {
    const _event = "nativeEvent" in event ? event.nativeEvent : event;
    hotkeys.forEach(
      ([hotkey, handler, options = { preventDefault: !0, usePhysicalKeys: !1 }]) => {
        getHotkeyMatcher(hotkey, options.usePhysicalKeys)(_event) && (options.preventDefault && event.preventDefault(), handler(_event));
      }
    );
  };
}
function shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable = !1) {
  return event.target instanceof HTMLElement ? (triggerOnContentEditable || !event.target.isContentEditable) && !tagsToIgnore.includes(event.target.tagName) : !0;
}
function useHotkeys(hotkeys, tagsToIgnore = ["INPUT", "TEXTAREA", "SELECT"], triggerOnContentEditable = !1) {
  useEffect(() => {
    const keydownListener = (event) => {
      hotkeys.forEach(
        ([hotkey, handler, options = { preventDefault: !0, usePhysicalKeys: !1 }]) => {
          getHotkeyMatcher(hotkey, options.usePhysicalKeys)(event) && shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable) && (options.preventDefault && event.preventDefault(), handler(event));
        }
      );
    };
    return document.documentElement.addEventListener("keydown", keydownListener), () => document.documentElement.removeEventListener("keydown", keydownListener);
  }, [hotkeys]);
}
function useHover$1() {
  const [hovered, setHovered] = useState(!1), ref = useRef(null), onMouseEnter = useCallback(() => setHovered(!0), []), onMouseLeave = useCallback(() => setHovered(!1), []);
  return useEffect(() => {
    const node2 = ref.current;
    if (node2)
      return node2.addEventListener("mouseenter", onMouseEnter), node2.addEventListener("mouseleave", onMouseLeave), () => {
        node2?.removeEventListener("mouseenter", onMouseEnter), node2?.removeEventListener("mouseleave", onMouseLeave);
      };
  }, [ref.current]), { ref, hovered };
}
function useDisclosure(initialState = !1, callbacks) {
  const { onOpen, onClose } = callbacks || {}, [opened, setOpened] = useState(initialState), open = useCallback(() => {
    setOpened((isOpened) => isOpened || (onOpen?.(), !0));
  }, [onOpen]), close = useCallback(() => {
    setOpened((isOpened) => isOpened && (onClose?.(), !1));
  }, [onClose]), toggle = useCallback(() => {
    opened ? close() : open();
  }, [close, open, opened]);
  return [opened, { open, close, toggle }];
}
function containsRelatedTarget(event) {
  return event.currentTarget instanceof HTMLElement && event.relatedTarget instanceof HTMLElement ? event.currentTarget.contains(event.relatedTarget) : !1;
}
function useFocusWithin({
  onBlur,
  onFocus
} = {}) {
  const ref = useRef(null), [focused, setFocused] = useState(!1), focusedRef = useRef(!1), _setFocused = (value) => {
    setFocused(value), focusedRef.current = value;
  }, handleFocusIn = (event) => {
    focusedRef.current || (_setFocused(!0), onFocus?.(event));
  }, handleFocusOut = (event) => {
    focusedRef.current && !containsRelatedTarget(event) && (_setFocused(!1), onBlur?.(event));
  };
  return useEffect(() => {
    const node2 = ref.current;
    if (node2)
      return node2.addEventListener("focusin", handleFocusIn), node2.addEventListener("focusout", handleFocusOut), () => {
        node2?.removeEventListener("focusin", handleFocusIn), node2?.removeEventListener("focusout", handleFocusOut);
      };
  }, [handleFocusIn, handleFocusOut]), { ref, focused };
}
function useTimeout(callback, delay2, options = { autoInvoke: !1 }) {
  const timeoutRef = useRef(null), start2 = useCallback(
    (...callbackParams) => {
      timeoutRef.current || (timeoutRef.current = window.setTimeout(() => {
        callback(callbackParams), timeoutRef.current = null;
      }, delay2));
    },
    [delay2]
  ), clear = useCallback(() => {
    timeoutRef.current && (window.clearTimeout(timeoutRef.current), timeoutRef.current = null);
  }, []);
  return useEffect(() => (options.autoInvoke && start2(), clear), [clear, start2]), { start: start2, clear };
}
function usePrevious$1(value) {
  const ref = useRef(void 0);
  return useEffect(() => {
    ref.current = value;
  }, [value]), ref.current;
}
function useInViewport() {
  const observer = useRef(null), [inViewport, setInViewport] = useState(!1);
  return { ref: useCallback((node2) => {
    typeof IntersectionObserver < "u" && (node2 && !observer.current ? observer.current = new IntersectionObserver(
      (entries) => setInViewport(entries.some((entry) => entry.isIntersecting))
    ) : observer.current?.disconnect(), node2 ? observer.current?.observe(node2) : setInViewport(!1));
  }, []), inViewport };
}
function useMutationObserver(callback, options, target) {
  const observer = useRef(null), ref = useRef(null);
  return useEffect(() => {
    const targetElement = typeof target == "function" ? target() : target;
    return (targetElement || ref.current) && (observer.current = new MutationObserver(callback), observer.current.observe(targetElement || ref.current, options)), () => {
      observer.current?.disconnect();
    };
  }, [callback, options]), ref;
}
function useMounted() {
  const [mounted, setMounted] = useState(!1);
  return useEffect(() => setMounted(!0), []), mounted;
}
function useStateHistory(initialValue) {
  const [state, setState] = useState({
    history: [initialValue],
    current: 0
  }), set2 = useCallback(
    (val) => setState((currentState) => {
      const nextState = [...currentState.history.slice(0, currentState.current + 1), val];
      return {
        history: nextState,
        current: nextState.length - 1
      };
    }),
    []
  ), back = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.max(0, currentState.current - steps)
    })),
    []
  ), forward = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.min(currentState.history.length - 1, currentState.current + steps)
    })),
    []
  ), reset = useCallback(() => {
    setState({ history: [initialValue], current: 0 });
  }, [initialValue]), handlers = useMemo(() => ({ back, forward, reset, set: set2 }), [back, forward, reset, set2]);
  return [state.history[state.current], handlers, state];
}
function useIsFirstRender() {
  const renderRef = useRef(!0);
  return renderRef.current === !0 ? (renderRef.current = !1, !0) : renderRef.current;
}
function getEnv() {
  return typeof process < "u" && process.env ? "production" : "development";
}
function memoize(func) {
  const cache = /* @__PURE__ */ new Map();
  return (...args) => {
    const key2 = JSON.stringify(args);
    if (cache.has(key2))
      return cache.get(key2);
    const result = func(...args);
    return cache.set(key2, result), result;
  };
}
function findClosestNumber(value, numbers) {
  return numbers.length === 0 ? value : numbers.reduce(
    (prev, curr) => Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev
  );
}
function getRefProp(element) {
  const version2 = React__default.version;
  return typeof React__default.version != "string" || version2.startsWith("18.") ? element?.ref : element?.props?.ref;
}
function r$7(e2) {
  var t2, f2, n2 = "";
  if (typeof e2 == "string" || typeof e2 == "number") n2 += e2;
  else if (typeof e2 == "object") if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$7(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$7(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
  const merged = {};
  return objects.forEach((obj) => {
    Object.entries(obj).forEach(([key2, value]) => {
      merged[key2] ? merged[key2] = clsx(merged[key2], value) : merged[key2] = value;
    });
  }), merged;
}
function resolveClassNames({ theme: theme2, classNames, props, stylesCtx }) {
  const resolvedClassNames = (Array.isArray(classNames) ? classNames : [classNames]).map(
    (item) => typeof item == "function" ? item(theme2, props, stylesCtx) : item || EMPTY_CLASS_NAMES
  );
  return mergeClassNames(resolvedClassNames);
}
function resolveStyles({ theme: theme2, styles, props, stylesCtx }) {
  return (Array.isArray(styles) ? styles : [styles]).reduce((acc, style2) => typeof style2 == "function" ? { ...acc, ...style2(theme2, props, stylesCtx) } : { ...acc, ...style2 }, {});
}
const MantineContext = createContext(null);
function useMantineContext() {
  const ctx = useContext(MantineContext);
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  return ctx;
}
function useMantineCssVariablesResolver() {
  return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
  return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
  return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
  return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
  return useMantineContext().headless;
}
function useMantineSxTransform() {
  return useMantineContext().stylesTransform?.sx;
}
function useMantineStylesTransform() {
  return useMantineContext().stylesTransform?.styles;
}
function useMantineEnv() {
  return useMantineContext().env || "default";
}
function isHexColor(hex2) {
  return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(hex2);
}
function hexToRgba(color2) {
  let hexString = color2.replace("#", "");
  if (hexString.length === 3) {
    const shorthandHex = hexString.split("");
    hexString = [
      shorthandHex[0],
      shorthandHex[0],
      shorthandHex[1],
      shorthandHex[1],
      shorthandHex[2],
      shorthandHex[2]
    ].join("");
  }
  if (hexString.length === 8) {
    const alpha2 = parseInt(hexString.slice(6, 8), 16) / 255;
    return {
      r: parseInt(hexString.slice(0, 2), 16),
      g: parseInt(hexString.slice(2, 4), 16),
      b: parseInt(hexString.slice(4, 6), 16),
      a: alpha2
    };
  }
  const parsed = parseInt(hexString, 16), r2 = parsed >> 16 & 255, g = parsed >> 8 & 255, b2 = parsed & 255;
  return {
    r: r2,
    g,
    b: b2,
    a: 1
  };
}
function rgbStringToRgba(color2) {
  const [r2, g, b2, a2] = color2.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: r2, g, b: b2, a: a2 || 1 };
}
function hslStringToRgba(hslaString) {
  const hslaRegex = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i, matches = hslaString.match(hslaRegex);
  if (!matches)
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  const h = parseInt(matches[1], 10), s2 = parseInt(matches[2], 10) / 100, l2 = parseInt(matches[3], 10) / 100, a2 = matches[5] ? parseFloat(matches[5]) : void 0, chroma = (1 - Math.abs(2 * l2 - 1)) * s2, huePrime = h / 60, x2 = chroma * (1 - Math.abs(huePrime % 2 - 1)), m2 = l2 - chroma / 2;
  let r2, g, b2;
  return huePrime >= 0 && huePrime < 1 ? (r2 = chroma, g = x2, b2 = 0) : huePrime >= 1 && huePrime < 2 ? (r2 = x2, g = chroma, b2 = 0) : huePrime >= 2 && huePrime < 3 ? (r2 = 0, g = chroma, b2 = x2) : huePrime >= 3 && huePrime < 4 ? (r2 = 0, g = x2, b2 = chroma) : huePrime >= 4 && huePrime < 5 ? (r2 = x2, g = 0, b2 = chroma) : (r2 = chroma, g = 0, b2 = x2), {
    r: Math.round((r2 + m2) * 255),
    g: Math.round((g + m2) * 255),
    b: Math.round((b2 + m2) * 255),
    a: a2 || 1
  };
}
function toRgba(color2) {
  return isHexColor(color2) ? hexToRgba(color2) : color2.startsWith("rgb") ? rgbStringToRgba(color2) : color2.startsWith("hsl") ? hslStringToRgba(color2) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function darken(color2, alpha2) {
  if (color2.startsWith("var("))
    return `color-mix(in srgb, ${color2}, black ${alpha2 * 100}%)`;
  const { r: r2, g, b: b2, a: a2 } = toRgba(color2), f2 = 1 - alpha2, dark = (input2) => Math.round(input2 * f2);
  return `rgba(${dark(r2)}, ${dark(g)}, ${dark(b2)}, ${a2})`;
}
function getPrimaryShade(theme2, colorScheme) {
  return typeof theme2.primaryShade == "number" ? theme2.primaryShade : colorScheme === "dark" ? theme2.primaryShade.dark : theme2.primaryShade.light;
}
function gammaCorrect(c2) {
  return c2 <= 0.03928 ? c2 / 12.92 : ((c2 + 0.055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
  const match = oklchColor.match(/oklch\((.*?)%\s/);
  return match ? parseFloat(match[1]) : null;
}
function luminance(color2) {
  if (color2.startsWith("oklch("))
    return (getLightnessFromOklch(color2) || 0) / 100;
  const { r: r2, g, b: b2 } = toRgba(color2), sR = r2 / 255, sG = g / 255, sB = b2 / 255, rLinear = gammaCorrect(sR), gLinear = gammaCorrect(sG), bLinear = gammaCorrect(sB);
  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}
function isLightColor(color2, luminanceThreshold = 0.179) {
  return color2.startsWith("var(") ? !1 : luminance(color2) > luminanceThreshold;
}
function parseThemeColor({
  color: color2,
  theme: theme2,
  colorScheme
}) {
  if (typeof color2 != "string")
    throw new Error(
      `[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color2}`
    );
  if (color2 === "bright")
    return {
      color: color2,
      value: colorScheme === "dark" ? theme2.white : theme2.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme2.white : theme2.black,
        theme2.luminanceThreshold
      ),
      variable: "--mantine-color-bright"
    };
  if (color2 === "dimmed")
    return {
      color: color2,
      value: colorScheme === "dark" ? theme2.colors.dark[2] : theme2.colors.gray[7],
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme2.colors.dark[2] : theme2.colors.gray[6],
        theme2.luminanceThreshold
      ),
      variable: "--mantine-color-dimmed"
    };
  if (color2 === "white" || color2 === "black")
    return {
      color: color2,
      value: color2 === "white" ? theme2.white : theme2.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        color2 === "white" ? theme2.white : theme2.black,
        theme2.luminanceThreshold
      ),
      variable: `--mantine-color-${color2}`
    };
  const [_color, shade] = color2.split("."), colorShade = shade ? Number(shade) : void 0, isThemeColor = _color in theme2.colors;
  if (isThemeColor) {
    const colorValue = colorShade !== void 0 ? theme2.colors[_color][colorShade] : theme2.colors[_color][getPrimaryShade(theme2, colorScheme || "light")];
    return {
      color: _color,
      value: colorValue,
      shade: colorShade,
      isThemeColor,
      isLight: isLightColor(colorValue, theme2.luminanceThreshold),
      variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
    };
  }
  return {
    color: color2,
    value: color2,
    isThemeColor,
    isLight: isLightColor(color2, theme2.luminanceThreshold),
    shade: colorShade,
    variable: void 0
  };
}
function getThemeColor(color2, theme2) {
  const parsed = parseThemeColor({ color: color2 || theme2.primaryColor, theme: theme2 });
  return parsed.variable ? `var(${parsed.variable})` : color2;
}
function getGradient(gradient, theme2) {
  const merged = {
    from: gradient?.from || theme2.defaultGradient.from,
    to: gradient?.to || theme2.defaultGradient.to,
    deg: gradient?.deg ?? theme2.defaultGradient.deg ?? 0
  }, fromColor = getThemeColor(merged.from, theme2), toColor = getThemeColor(merged.to, theme2);
  return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}
function rgba$2(color2, alpha2) {
  if (typeof color2 != "string" || alpha2 > 1 || alpha2 < 0)
    return "rgba(0, 0, 0, 1)";
  if (color2.startsWith("var(")) {
    const mixPercentage = (1 - alpha2) * 100;
    return `color-mix(in srgb, ${color2}, transparent ${mixPercentage}%)`;
  }
  if (color2.startsWith("oklch"))
    return color2.includes("/") ? color2.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`) : color2.replace(")", ` / ${alpha2})`);
  const { r: r2, g, b: b2 } = toRgba(color2);
  return `rgba(${r2}, ${g}, ${b2}, ${alpha2})`;
}
const alpha$1 = rgba$2, defaultVariantColorsResolver = ({
  color: color2,
  theme: theme2,
  variant,
  gradient,
  autoContrast
}) => {
  const parsed = parseThemeColor({ color: color2, theme: theme2 }), _autoContrast = typeof autoContrast == "boolean" ? autoContrast : theme2.autoContrast;
  if (variant === "filled") {
    const textColor = _autoContrast && parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: `var(--mantine-color-${color2}-filled)`,
      hover: `var(--mantine-color-${color2}-filled-hover)`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: color2,
      hover: darken(color2, 0.1),
      color: textColor,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "light") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: `var(--mantine-color-${color2}-light)`,
          hover: `var(--mantine-color-${color2}-light-hover)`,
          color: `var(--mantine-color-${color2}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme2.colors[parsed.color][parsed.shade];
      return {
        background: rgba$2(parsedColor, 0.1),
        hover: rgba$2(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: rgba$2(color2, 0.1),
      hover: rgba$2(color2, 0.12),
      color: color2,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "outline")
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: "transparent",
      hover: `var(--mantine-color-${color2}-outline-hover)`,
      color: `var(--mantine-color-${color2}-outline)`,
      border: `${rem(1)} solid var(--mantine-color-${color2}-outline)`
    } : {
      background: "transparent",
      hover: rgba$2(theme2.colors[parsed.color][parsed.shade], 0.05),
      color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
    } : {
      background: "transparent",
      hover: rgba$2(color2, 0.05),
      color: color2,
      border: `${rem(1)} solid ${color2}`
    };
  if (variant === "subtle") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color2}-light-hover)`,
          color: `var(--mantine-color-${color2}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme2.colors[parsed.color][parsed.shade];
      return {
        background: "transparent",
        hover: rgba$2(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: rgba$2(color2, 0.12),
      color: color2,
      border: `${rem(1)} solid transparent`
    };
  }
  return variant === "transparent" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${color2}-light-color)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: color2,
    border: `${rem(1)} solid transparent`
  } : variant === "white" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "var(--mantine-color-white)",
    hover: darken(theme2.white, 0.01),
    color: `var(--mantine-color-${color2}-filled)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme2.white, 0.01),
    color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme2.white, 0.01),
    color: color2,
    border: `${rem(1)} solid transparent`
  } : variant === "gradient" ? {
    background: getGradient(gradient, theme2),
    hover: getGradient(gradient, theme2),
    color: "var(--mantine-color-white)",
    border: "none"
  } : variant === "default" ? {
    background: "var(--mantine-color-default)",
    hover: "var(--mantine-color-default-hover)",
    color: "var(--mantine-color-default-color)",
    border: `${rem(1)} solid var(--mantine-color-default-border)`
  } : {};
}, DEFAULT_COLORS = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
}, DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", DEFAULT_THEME = {
  scale: 1,
  fontSmoothing: !0,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: DEFAULT_COLORS,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: defaultVariantColorsResolver,
  autoContrast: !1,
  luminanceThreshold: 0.3,
  fontFamily: DEFAULT_FONT_FAMILY,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: !1,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: rem(34), lineHeight: "1.3" },
      h2: { fontSize: rem(26), lineHeight: "1.35" },
      h3: { fontSize: rem(22), lineHeight: "1.4" },
      h4: { fontSize: rem(18), lineHeight: "1.45" },
      h5: { fontSize: rem(16), lineHeight: "1.5" },
      h6: { fontSize: rem(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: rem(12),
    sm: rem(14),
    md: rem(16),
    lg: rem(18),
    xl: rem(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: rem(2),
    sm: rem(4),
    md: rem(8),
    lg: rem(16),
    xl: rem(32)
  },
  spacing: {
    xs: rem(10),
    sm: rem(12),
    md: rem(16),
    lg: rem(20),
    xl: rem(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(
      15
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
    md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(
      25
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
    lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(
      23
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
    xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(
      28
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
  },
  other: {},
  components: {}
};
function isMantineColorScheme(value) {
  return value === "auto" || value === "dark" || value === "light";
}
function localStorageColorSchemeManager({
  key: key2 = "mantine-color-scheme-value"
} = {}) {
  let handleStorageEvent;
  return {
    get: (defaultValue) => {
      if (typeof window > "u")
        return defaultValue;
      try {
        const storedColorScheme = window.localStorage.getItem(key2);
        return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
      } catch {
        return defaultValue;
      }
    },
    set: (value) => {
      try {
        window.localStorage.setItem(key2, value);
      } catch (error) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          error
        );
      }
    },
    subscribe: (onUpdate) => {
      handleStorageEvent = (event) => {
        event.storageArea === window.localStorage && event.key === key2 && isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
      }, window.addEventListener("storage", handleStorageEvent);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", handleStorageEvent);
    },
    clear: () => {
      window.localStorage.removeItem(key2);
    }
  };
}
const INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more  https://mantine.dev/theming/colors/#primary-color", INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
  return shade < 0 || shade > 9 ? !1 : parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme2) {
  if (!(theme2.primaryColor in theme2.colors))
    throw new Error(INVALID_PRIMARY_COLOR_ERROR);
  if (typeof theme2.primaryShade == "object" && (!isValidPrimaryShade(theme2.primaryShade.dark) || !isValidPrimaryShade(theme2.primaryShade.light)))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
  if (typeof theme2.primaryShade == "number" && !isValidPrimaryShade(theme2.primaryShade))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
}
function mergeMantineTheme(currentTheme, themeOverride) {
  if (!themeOverride)
    return validateMantineTheme(currentTheme), currentTheme;
  const result = deepMerge(currentTheme, themeOverride);
  return themeOverride.fontFamily && !themeOverride.headings?.fontFamily && (result.headings.fontFamily = themeOverride.fontFamily), validateMantineTheme(result), result;
}
const MantineThemeContext = createContext(null), useSafeMantineTheme = () => useContext(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
  const ctx = useContext(MantineThemeContext);
  if (!ctx)
    throw new Error(
      "@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"
    );
  return ctx;
}
function MantineThemeProvider({
  theme: theme2,
  children: children2,
  inherit: inherit2 = !0
}) {
  const parentTheme = useSafeMantineTheme(), mergedTheme = useMemo(
    () => mergeMantineTheme(inherit2 ? parentTheme : DEFAULT_THEME, theme2),
    [theme2, parentTheme, inherit2]
  );
  return /* @__PURE__ */ jsx(MantineThemeContext.Provider, { value: mergedTheme, children: children2 });
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";
function MantineClasses() {
  const theme2 = useMantineTheme(), nonce = useMantineStyleNonce(), classes2 = keys$1(theme2.breakpoints).reduce((acc, breakpoint) => {
    const isPxBreakpoint = theme2.breakpoints[breakpoint].includes("px"), pxValue = px$1(theme2.breakpoints[breakpoint]), maxWidthBreakpoint = isPxBreakpoint ? `${pxValue - 0.1}px` : em(pxValue - 0.1), minWidthBreakpoint = isPxBreakpoint ? `${pxValue}px` : em(pxValue);
    return `${acc}@media (max-width: ${maxWidthBreakpoint}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${minWidthBreakpoint}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "classes",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: classes2 }
    }
  );
}
function cssVariablesObjectToString(variables) {
  return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}
function wrapWithSelector(selectors, code) {
  return (Array.isArray(selectors) ? selectors : [selectors]).reduce((acc, selector3) => `${selector3}{${acc}}`, code);
}
function convertCssVariables(input2, selector3) {
  const sharedVariables = cssVariablesObjectToString(input2.variables), shared = sharedVariables ? wrapWithSelector(selector3, sharedVariables) : "", dark = cssVariablesObjectToString(input2.dark), light = cssVariablesObjectToString(input2.light), darkForced = dark ? wrapWithSelector(selector3 === ":host" ? `${selector3}([data-mantine-color-scheme="dark"])` : `${selector3}[data-mantine-color-scheme="dark"]`, dark) : "", lightForced = light ? wrapWithSelector(selector3 === ":host" ? `${selector3}([data-mantine-color-scheme="light"])` : `${selector3}[data-mantine-color-scheme="light"]`, light) : "";
  return `${shared}${darkForced}${lightForced}`;
}
function getContrastColor({ color: color2, theme: theme2, autoContrast }) {
  return (typeof autoContrast == "boolean" ? autoContrast : theme2.autoContrast) && parseThemeColor({ color: color2 || theme2.primaryColor, theme: theme2 }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme2, colorScheme) {
  return getContrastColor({
    color: theme2.colors[theme2.primaryColor][getPrimaryShade(theme2, colorScheme)],
    theme: theme2,
    autoContrast: null
  });
}
function getCSSColorVariables({
  theme: theme2,
  color: color2,
  colorScheme,
  name = color2,
  withColorValues = !0
}) {
  if (!theme2.colors[color2])
    return {};
  if (colorScheme === "light") {
    const primaryShade2 = getPrimaryShade(theme2, "light"), dynamicVariables2 = {
      [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
      [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
      [`--mantine-color-${name}-light`]: alpha$1(theme2.colors[color2][primaryShade2], 0.1),
      [`--mantine-color-${name}-light-hover`]: alpha$1(theme2.colors[color2][primaryShade2], 0.12),
      [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline-hover`]: alpha$1(theme2.colors[color2][primaryShade2], 0.05)
    };
    return withColorValues ? {
      [`--mantine-color-${name}-0`]: theme2.colors[color2][0],
      [`--mantine-color-${name}-1`]: theme2.colors[color2][1],
      [`--mantine-color-${name}-2`]: theme2.colors[color2][2],
      [`--mantine-color-${name}-3`]: theme2.colors[color2][3],
      [`--mantine-color-${name}-4`]: theme2.colors[color2][4],
      [`--mantine-color-${name}-5`]: theme2.colors[color2][5],
      [`--mantine-color-${name}-6`]: theme2.colors[color2][6],
      [`--mantine-color-${name}-7`]: theme2.colors[color2][7],
      [`--mantine-color-${name}-8`]: theme2.colors[color2][8],
      [`--mantine-color-${name}-9`]: theme2.colors[color2][9],
      ...dynamicVariables2
    } : dynamicVariables2;
  }
  const primaryShade = getPrimaryShade(theme2, "dark"), dynamicVariables = {
    [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
    [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
    [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
    [`--mantine-color-${name}-light`]: alpha$1(
      theme2.colors[color2][Math.max(0, primaryShade - 2)],
      0.15
    ),
    [`--mantine-color-${name}-light-hover`]: alpha$1(
      theme2.colors[color2][Math.max(0, primaryShade - 2)],
      0.2
    ),
    [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
    [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
    [`--mantine-color-${name}-outline-hover`]: alpha$1(
      theme2.colors[color2][Math.max(primaryShade - 4, 0)],
      0.05
    )
  };
  return withColorValues ? {
    [`--mantine-color-${name}-0`]: theme2.colors[color2][0],
    [`--mantine-color-${name}-1`]: theme2.colors[color2][1],
    [`--mantine-color-${name}-2`]: theme2.colors[color2][2],
    [`--mantine-color-${name}-3`]: theme2.colors[color2][3],
    [`--mantine-color-${name}-4`]: theme2.colors[color2][4],
    [`--mantine-color-${name}-5`]: theme2.colors[color2][5],
    [`--mantine-color-${name}-6`]: theme2.colors[color2][6],
    [`--mantine-color-${name}-7`]: theme2.colors[color2][7],
    [`--mantine-color-${name}-8`]: theme2.colors[color2][8],
    [`--mantine-color-${name}-9`]: theme2.colors[color2][9],
    ...dynamicVariables
  } : dynamicVariables;
}
function isVirtualColor(value) {
  return !!value && typeof value == "object" && "mantine-virtual-color" in value;
}
function assignSizeVariables(variables, sizes2, name) {
  keys$1(sizes2).forEach(
    (size2) => Object.assign(variables, { [`--mantine-${name}-${size2}`]: sizes2[size2] })
  );
}
const defaultCssVariablesResolver = (theme2) => {
  const lightPrimaryShade = getPrimaryShade(theme2, "light"), defaultRadius = theme2.defaultRadius in theme2.radius ? theme2.radius[theme2.defaultRadius] : rem(theme2.defaultRadius), result = {
    variables: {
      "--mantine-scale": theme2.scale.toString(),
      "--mantine-cursor-type": theme2.cursorType,
      "--mantine-color-scheme": "light dark",
      "--mantine-webkit-font-smoothing": theme2.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": theme2.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": theme2.white,
      "--mantine-color-black": theme2.black,
      "--mantine-line-height": theme2.lineHeights.md,
      "--mantine-font-family": theme2.fontFamily,
      "--mantine-font-family-monospace": theme2.fontFamilyMonospace,
      "--mantine-font-family-headings": theme2.headings.fontFamily,
      "--mantine-heading-font-weight": theme2.headings.fontWeight,
      "--mantine-heading-text-wrap": theme2.headings.textWrap,
      "--mantine-radius-default": defaultRadius,
      // Primary colors
      "--mantine-primary-color-filled": `var(--mantine-color-${theme2.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${theme2.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${theme2.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${theme2.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${theme2.primaryColor}-light-color)`
    },
    light: {
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme2, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": theme2.black,
      "--mantine-color-body": theme2.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${theme2.primaryColor}-${lightPrimaryShade})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)"
    },
    dark: {
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme2, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${theme2.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)"
    }
  };
  assignSizeVariables(result.variables, theme2.breakpoints, "breakpoint"), assignSizeVariables(result.variables, theme2.spacing, "spacing"), assignSizeVariables(result.variables, theme2.fontSizes, "font-size"), assignSizeVariables(result.variables, theme2.lineHeights, "line-height"), assignSizeVariables(result.variables, theme2.shadows, "shadow"), assignSizeVariables(result.variables, theme2.radius, "radius"), theme2.colors[theme2.primaryColor].forEach((_, index2) => {
    result.variables[`--mantine-primary-color-${index2}`] = `var(--mantine-color-${theme2.primaryColor}-${index2})`;
  }), keys$1(theme2.colors).forEach((color2) => {
    const value = theme2.colors[color2];
    if (isVirtualColor(value)) {
      Object.assign(
        result.light,
        getCSSColorVariables({
          theme: theme2,
          name: value.name,
          color: value.light,
          colorScheme: "light",
          withColorValues: !0
        })
      ), Object.assign(
        result.dark,
        getCSSColorVariables({
          theme: theme2,
          name: value.name,
          color: value.dark,
          colorScheme: "dark",
          withColorValues: !0
        })
      );
      return;
    }
    value.forEach((shade, index2) => {
      result.variables[`--mantine-color-${color2}-${index2}`] = shade;
    }), Object.assign(
      result.light,
      getCSSColorVariables({
        theme: theme2,
        color: color2,
        colorScheme: "light",
        withColorValues: !1
      })
    ), Object.assign(
      result.dark,
      getCSSColorVariables({
        theme: theme2,
        color: color2,
        colorScheme: "dark",
        withColorValues: !1
      })
    );
  });
  const headings2 = theme2.headings.sizes;
  return keys$1(headings2).forEach((heading) => {
    result.variables[`--mantine-${heading}-font-size`] = headings2[heading].fontSize, result.variables[`--mantine-${heading}-line-height`] = headings2[heading].lineHeight, result.variables[`--mantine-${heading}-font-weight`] = headings2[heading].fontWeight || theme2.headings.fontWeight;
  }), result;
};
function getMergedVariables({ theme: theme2, generator }) {
  const defaultResolver = defaultCssVariablesResolver(theme2), providerGenerator = generator?.(theme2);
  return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}
const defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input2) {
  const cleaned = {
    variables: {},
    light: {},
    dark: {}
  };
  return keys$1(input2.variables).forEach((key2) => {
    defaultCssVariables.variables[key2] !== input2.variables[key2] && (cleaned.variables[key2] = input2.variables[key2]);
  }), keys$1(input2.light).forEach((key2) => {
    defaultCssVariables.light[key2] !== input2.light[key2] && (cleaned.light[key2] = input2.light[key2]);
  }), keys$1(input2.dark).forEach((key2) => {
    defaultCssVariables.dark[key2] !== input2.dark[key2] && (cleaned.dark[key2] = input2.dark[key2]);
  }), cleaned;
}
function getColorSchemeCssVariables(selector3) {
  return `
  ${selector3}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }
  ${selector3}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }
`;
}
function MantineCssVariables({
  cssVariablesSelector,
  deduplicateCssVariables
}) {
  const theme2 = useMantineTheme(), nonce = useMantineStyleNonce(), generator = useMantineCssVariablesResolver(), mergedVariables = getMergedVariables({ theme: theme2, generator }), shouldCleanVariables = cssVariablesSelector === ":root" && deduplicateCssVariables, cleanedVariables = shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables, css2 = convertCssVariables(cleanedVariables, cssVariablesSelector);
  return css2 ? /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": !0,
      nonce: nonce?.(),
      dangerouslySetInnerHTML: {
        __html: `${css2}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}`
      }
    }
  ) : null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";
function suppressNextjsWarning() {
  const originalError = console.error;
  console.error = (...args) => {
    args.length > 1 && typeof args[0] == "string" && args[0].toLowerCase().includes("extra attributes from the server") && typeof args[1] == "string" && args[1].toLowerCase().includes("data-mantine-color-scheme") || originalError(...args);
  };
}
function setColorSchemeAttribute(colorScheme, getRootElement) {
  const hasDarkColorScheme = typeof window < "u" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches, computedColorScheme = colorScheme !== "auto" ? colorScheme : hasDarkColorScheme ? "dark" : "light";
  getRootElement()?.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({
  manager,
  defaultColorScheme,
  getRootElement,
  forceColorScheme
}) {
  const media = useRef(null), [value, setValue] = useState(() => manager.get(defaultColorScheme)), colorSchemeValue = forceColorScheme || value, setColorScheme = useCallback(
    (colorScheme) => {
      forceColorScheme || (setColorSchemeAttribute(colorScheme, getRootElement), setValue(colorScheme), manager.set(colorScheme));
    },
    [manager.set, colorSchemeValue, forceColorScheme]
  ), clearColorScheme = useCallback(() => {
    setValue(defaultColorScheme), setColorSchemeAttribute(defaultColorScheme, getRootElement), manager.clear();
  }, [manager.clear, defaultColorScheme]);
  return useEffect(() => (manager.subscribe(setColorScheme), manager.unsubscribe), [manager.subscribe, manager.unsubscribe]), useIsomorphicEffect(() => {
    setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement);
  }, []), useEffect(() => {
    if (forceColorScheme)
      return setColorSchemeAttribute(forceColorScheme, getRootElement), () => {
      };
    forceColorScheme === void 0 && setColorSchemeAttribute(value, getRootElement), typeof window < "u" && "matchMedia" in window && (media.current = window.matchMedia("(prefers-color-scheme: dark)"));
    const listener = (event) => {
      value === "auto" && setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement);
    };
    return media.current?.addEventListener("change", listener), () => media.current?.removeEventListener("change", listener);
  }, [value, forceColorScheme]), { colorScheme: colorSchemeValue, setColorScheme, clearColorScheme };
}
function useRespectReduceMotion({
  respectReducedMotion,
  getRootElement
}) {
  useIsomorphicEffect(() => {
    respectReducedMotion && getRootElement()?.setAttribute("data-respect-reduced-motion", "true");
  }, [respectReducedMotion]);
}
suppressNextjsWarning();
function MantineProvider({
  theme: theme2,
  children: children2,
  getStyleNonce,
  withStaticClasses = !0,
  withGlobalClasses = !0,
  deduplicateCssVariables = !0,
  withCssVariables = !0,
  cssVariablesSelector = ":root",
  classNamesPrefix = "mantine",
  colorSchemeManager = localStorageColorSchemeManager(),
  defaultColorScheme = "light",
  getRootElement = () => document.documentElement,
  cssVariablesResolver,
  forceColorScheme,
  stylesTransform,
  env
}) {
  const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
    defaultColorScheme,
    forceColorScheme,
    manager: colorSchemeManager,
    getRootElement
  });
  return useRespectReduceMotion({
    respectReducedMotion: theme2?.respectReducedMotion || !1,
    getRootElement
  }), /* @__PURE__ */ jsx(
    MantineContext.Provider,
    {
      value: {
        colorScheme,
        setColorScheme,
        clearColorScheme,
        getRootElement,
        classNamesPrefix,
        getStyleNonce,
        cssVariablesResolver,
        cssVariablesSelector,
        withStaticClasses,
        stylesTransform,
        env
      },
      children: /* @__PURE__ */ jsxs(MantineThemeProvider, { theme: theme2, children: [
        withCssVariables && /* @__PURE__ */ jsx(
          MantineCssVariables,
          {
            cssVariablesSelector,
            deduplicateCssVariables
          }
        ),
        withGlobalClasses && /* @__PURE__ */ jsx(MantineClasses, {}),
        children2
      ] })
    }
  );
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function useResolvedStylesApi({
  classNames,
  styles,
  props,
  stylesCtx
}) {
  const theme2 = useMantineTheme();
  return {
    resolvedClassNames: resolveClassNames({
      theme: theme2,
      classNames,
      props,
      stylesCtx: stylesCtx || void 0
    }),
    resolvedStyles: resolveStyles({
      theme: theme2,
      styles,
      props,
      stylesCtx: stylesCtx || void 0
    })
  };
}
const FOCUS_CLASS_NAMES = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function getGlobalClassNames({ theme: theme2, options, unstyled }) {
  return clsx(
    options?.focusable && !unstyled && (theme2.focusClassName || FOCUS_CLASS_NAMES[theme2.focusRing]),
    options?.active && !unstyled && theme2.activeClassName
  );
}
function getOptionsClassNames({
  selector: selector3,
  stylesCtx,
  options,
  props,
  theme: theme2
}) {
  return resolveClassNames({
    theme: theme2,
    classNames: options?.classNames,
    props: options?.props || props,
    stylesCtx
  })[selector3];
}
function getResolvedClassNames({
  selector: selector3,
  stylesCtx,
  theme: theme2,
  classNames,
  props
}) {
  return resolveClassNames({ theme: theme2, classNames, props, stylesCtx })[selector3];
}
function getRootClassName({ rootSelector, selector: selector3, className }) {
  return rootSelector === selector3 ? className : void 0;
}
function getSelectorClassName({ selector: selector3, classes: classes2, unstyled }) {
  return unstyled ? void 0 : classes2[selector3];
}
function getStaticClassNames({
  themeName,
  classNamesPrefix,
  selector: selector3,
  withStaticClass
}) {
  return withStaticClass === !1 ? [] : themeName.map((n2) => `${classNamesPrefix}-${n2}-${selector3}`);
}
function getThemeClassNames({
  themeName,
  theme: theme2,
  selector: selector3,
  props,
  stylesCtx
}) {
  return themeName.map(
    (n2) => resolveClassNames({
      theme: theme2,
      classNames: theme2.components[n2]?.classNames,
      props,
      stylesCtx
    })?.[selector3]
  );
}
function getVariantClassName({
  options,
  classes: classes2,
  selector: selector3,
  unstyled
}) {
  return options?.variant && !unstyled ? classes2[`${selector3}--${options.variant}`] : void 0;
}
function getClassName({
  theme: theme2,
  options,
  themeName,
  selector: selector3,
  classNamesPrefix,
  classNames,
  classes: classes2,
  unstyled,
  className,
  rootSelector,
  props,
  stylesCtx,
  withStaticClasses,
  headless,
  transformedStyles
}) {
  return clsx(
    getGlobalClassNames({ theme: theme2, options, unstyled: unstyled || headless }),
    getThemeClassNames({ theme: theme2, themeName, selector: selector3, props, stylesCtx }),
    getVariantClassName({ options, classes: classes2, selector: selector3, unstyled }),
    getResolvedClassNames({ selector: selector3, stylesCtx, theme: theme2, classNames, props }),
    getResolvedClassNames({ selector: selector3, stylesCtx, theme: theme2, classNames: transformedStyles, props }),
    getOptionsClassNames({ selector: selector3, stylesCtx, options, props, theme: theme2 }),
    getRootClassName({ rootSelector, selector: selector3, className }),
    getSelectorClassName({ selector: selector3, classes: classes2, unstyled: unstyled || headless }),
    withStaticClasses && !headless && getStaticClassNames({
      themeName,
      classNamesPrefix,
      selector: selector3,
      withStaticClass: options?.withStaticClass
    }),
    options?.className
  );
}
function getThemeStyles({
  theme: theme2,
  themeName,
  props,
  stylesCtx,
  selector: selector3
}) {
  return themeName.map(
    (n2) => resolveStyles({
      theme: theme2,
      styles: theme2.components[n2]?.styles,
      props,
      stylesCtx
    })[selector3]
  ).reduce((acc, val) => ({ ...acc, ...val }), {});
}
function resolveStyle({ style: style2, theme: theme2 }) {
  return Array.isArray(style2) ? [...style2].reduce(
    (acc, item) => ({ ...acc, ...resolveStyle({ style: item, theme: theme2 }) }),
    {}
  ) : typeof style2 == "function" ? style2(theme2) : style2 ?? {};
}
function mergeVars(vars) {
  return vars.reduce((acc, current) => (current && Object.keys(current).forEach((key2) => {
    acc[key2] = { ...acc[key2], ...filterProps$1(current[key2]) };
  }), acc), {});
}
function resolveVars({
  vars,
  varsResolver: varsResolver2,
  theme: theme2,
  props,
  stylesCtx,
  selector: selector3,
  themeName,
  headless
}) {
  return mergeVars([
    headless ? {} : varsResolver2?.(theme2, props, stylesCtx),
    ...themeName.map((name) => theme2.components?.[name]?.vars?.(theme2, props, stylesCtx)),
    vars?.(theme2, props, stylesCtx)
  ])?.[selector3];
}
function getStyle({
  theme: theme2,
  themeName,
  selector: selector3,
  options,
  props,
  stylesCtx,
  rootSelector,
  styles,
  style: style2,
  vars,
  varsResolver: varsResolver2,
  headless,
  withStylesTransform
}) {
  return {
    ...!withStylesTransform && getThemeStyles({ theme: theme2, themeName, props, stylesCtx, selector: selector3 }),
    ...!withStylesTransform && resolveStyles({ theme: theme2, styles, props, stylesCtx })[selector3],
    ...!withStylesTransform && resolveStyles({ theme: theme2, styles: options?.styles, props: options?.props || props, stylesCtx })[selector3],
    ...resolveVars({ theme: theme2, props, stylesCtx, vars, varsResolver: varsResolver2, selector: selector3, themeName, headless }),
    ...rootSelector === selector3 ? resolveStyle({ style: style2, theme: theme2 }) : null,
    ...resolveStyle({ style: options?.style, theme: theme2 })
  };
}
function useStylesTransform({ props, stylesCtx, themeName }) {
  const theme2 = useMantineTheme(), stylesTransform = useMantineStylesTransform()?.();
  return {
    getTransformedStyles: (styles) => stylesTransform ? [
      ...styles.map(
        (style2) => stylesTransform(style2, { props, theme: theme2, ctx: stylesCtx })
      ),
      ...themeName.map(
        (n2) => stylesTransform(theme2.components[n2]?.styles, { props, theme: theme2, ctx: stylesCtx })
      )
    ].filter(Boolean) : [],
    withStylesTransform: !!stylesTransform
  };
}
function useStyles({
  name,
  classes: classes2,
  props,
  stylesCtx,
  className,
  style: style2,
  rootSelector = "root",
  unstyled,
  classNames,
  styles,
  vars,
  varsResolver: varsResolver2
}) {
  const theme2 = useMantineTheme(), classNamesPrefix = useMantineClassNamesPrefix(), withStaticClasses = useMantineWithStaticClasses(), headless = useMantineIsHeadless(), themeName = (Array.isArray(name) ? name : [name]).filter((n2) => n2), { withStylesTransform, getTransformedStyles } = useStylesTransform({
    props,
    stylesCtx,
    themeName
  });
  return (selector3, options) => ({
    className: getClassName({
      theme: theme2,
      options,
      themeName,
      selector: selector3,
      classNamesPrefix,
      classNames,
      classes: classes2,
      unstyled,
      className,
      rootSelector,
      props,
      stylesCtx,
      withStaticClasses,
      headless,
      transformedStyles: getTransformedStyles([options?.styles, styles])
    }),
    style: getStyle({
      theme: theme2,
      themeName,
      selector: selector3,
      options,
      props,
      stylesCtx,
      rootSelector,
      styles,
      style: style2,
      vars,
      varsResolver: varsResolver2,
      headless,
      withStylesTransform
    })
  });
}
function getAutoContrastValue(autoContrast, theme2) {
  return typeof autoContrast == "boolean" ? autoContrast : theme2.autoContrast;
}
function disableTransition(nonce) {
  const style2 = document.createElement("style");
  return style2.setAttribute("data-mantine-styles", "inline"), style2.innerHTML = "*, *::before, *::after {transition: none !important;}", style2.setAttribute("data-mantine-disable-transition", "true"), nonce && style2.setAttribute("nonce", nonce), document.head.appendChild(style2), () => document.querySelectorAll("[data-mantine-disable-transition]").forEach((element) => element.remove());
}
function useMantineColorScheme({ keepTransitions } = {}) {
  const clearStylesRef = useRef(noop$5), timeoutRef = useRef(-1), ctx = useContext(MantineContext), nonce = useMantineStyleNonce(), nonceValue = useRef(nonce?.());
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  const setColorScheme = (value) => {
    ctx.setColorScheme(value), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      clearStylesRef.current?.();
    }, 10);
  }, clearColorScheme = () => {
    ctx.clearColorScheme(), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      clearStylesRef.current?.();
    }, 10);
  }, osColorScheme = useColorScheme("light", { getInitialValueInEffect: !1 }), computedColorScheme = ctx.colorScheme === "auto" ? osColorScheme : ctx.colorScheme, toggleColorScheme = useCallback(
    () => setColorScheme(computedColorScheme === "light" ? "dark" : "light"),
    [setColorScheme, computedColorScheme]
  );
  return useEffect(
    () => () => {
      clearStylesRef.current?.(), window.clearTimeout(timeoutRef.current);
    },
    []
  ), {
    colorScheme: ctx.colorScheme,
    setColorScheme,
    clearColorScheme,
    toggleColorScheme
  };
}
function useComputedColorScheme(defaultValue, options = { getInitialValueInEffect: !0 }) {
  const osColorScheme = useColorScheme(defaultValue, options), { colorScheme } = useMantineColorScheme();
  return colorScheme === "auto" ? osColorScheme : colorScheme;
}
function useProps(component, defaultProps2, props) {
  const theme2 = useMantineTheme(), contextPropsPayload = theme2.components[component]?.defaultProps, contextProps = typeof contextPropsPayload == "function" ? contextPropsPayload(theme2) : contextPropsPayload;
  return { ...defaultProps2, ...contextProps, ...filterProps$1(props) };
}
function cssObjectToString(css2) {
  return keys$1(css2).reduce(
    (acc, rule) => css2[rule] !== void 0 ? `${acc}${camelToKebabCase(rule)}:${css2[rule]};` : acc,
    ""
  ).trim();
}
function stylesToString({ selector: selector3, styles, media, container: container2 }) {
  const baseStyles = styles ? cssObjectToString(styles) : "", mediaQueryStyles = Array.isArray(media) ? media.map((item) => `@media${item.query}{${selector3}{${cssObjectToString(item.styles)}}}`) : [], containerStyles = Array.isArray(container2) ? container2.map(
    (item) => `@container ${item.query}{${selector3}{${cssObjectToString(item.styles)}}}`
  ) : [];
  return `${baseStyles ? `${selector3}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}
function InlineStyles(props) {
  const nonce = useMantineStyleNonce();
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "inline",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: stylesToString(props) }
    }
  );
}
function extractStyleProps(others) {
  const {
    m: m2,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p: p2,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c: c2,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset: inset2,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx,
    ...rest
  } = others;
  return { styleProps: filterProps$1({
    m: m2,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p: p2,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c: c2,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset: inset2,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx
  }), rest };
}
const STYlE_PROPS_DATA = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};
function colorResolver(color2, theme2) {
  const parsedColor = parseThemeColor({ color: color2, theme: theme2 });
  return parsedColor.color === "dimmed" ? "var(--mantine-color-dimmed)" : parsedColor.color === "bright" ? "var(--mantine-color-bright)" : parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color2, theme2) {
  const parsedColor = parseThemeColor({ color: color2, theme: theme2 });
  return parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-text)` : colorResolver(color2, theme2);
}
function borderResolver(value, theme2) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const [size2, style2, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
    let result = `${rem(size2)}`;
    return style2 && (result += ` ${style2}`), colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme2)}`), result.trim();
  }
  return value;
}
const values = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
  return typeof fontFamily == "string" && fontFamily in values ? values[fontFamily] : fontFamily;
}
const headings$2 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function fontSizeResolver(value, theme2) {
  return typeof value == "string" && value in theme2.fontSizes ? `var(--mantine-font-size-${value})` : typeof value == "string" && headings$2.includes(value) ? `var(--mantine-${value}-font-size)` : typeof value == "number" || typeof value == "string" ? rem(value) : value;
}
function identityResolver(value) {
  return value;
}
const headings$1 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function lineHeightResolver(value, theme2) {
  return typeof value == "string" && value in theme2.lineHeights ? `var(--mantine-line-height-${value})` : typeof value == "string" && headings$1.includes(value) ? `var(--mantine-${value}-line-height)` : value;
}
function sizeResolver(value) {
  return typeof value == "number" ? rem(value) : value;
}
function spacingResolver(value, theme2) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const mod = value.replace("-", "");
    if (!(mod in theme2.spacing))
      return rem(value);
    const variable = `--mantine-spacing-${mod}`;
    return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
  }
  return value;
}
const resolvers = {
  color: colorResolver,
  textColor: textColorResolver,
  fontSize: fontSizeResolver,
  spacing: spacingResolver,
  identity: identityResolver,
  size: sizeResolver,
  lineHeight: lineHeightResolver,
  fontFamily: fontFamilyResolver,
  border: borderResolver
};
function replaceMediaQuery(query) {
  return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({
  media,
  ...props
}) {
  const sortedMedia = Object.keys(media).sort((a2, b2) => Number(replaceMediaQuery(a2)) - Number(replaceMediaQuery(b2))).map((query) => ({ query, styles: media[query] }));
  return { ...props, media: sortedMedia };
}
function hasResponsiveStyles(styleProp) {
  if (typeof styleProp != "object" || styleProp === null)
    return !1;
  const breakpoints = Object.keys(styleProp);
  return !(breakpoints.length === 1 && breakpoints[0] === "base");
}
function getBaseValue(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getBreakpointKeys(value) {
  return typeof value == "object" && value !== null ? keys$1(value).filter((key2) => key2 !== "base") : [];
}
function getBreakpointValue(value, breakpoint) {
  return typeof value == "object" && value !== null && breakpoint in value ? value[breakpoint] : value;
}
function parseStyleProps({
  styleProps,
  data,
  theme: theme2
}) {
  return sortMediaQueries(
    keys$1(styleProps).reduce(
      (acc, styleProp) => {
        if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx")
          return acc;
        const propertyData = data[styleProp], properties2 = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property], baseValue = getBaseValue(styleProps[styleProp]);
        if (!hasResponsiveStyles(styleProps[styleProp]))
          return properties2.forEach((property) => {
            acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme2);
          }), acc;
        acc.hasResponsiveStyles = !0;
        const breakpoints = getBreakpointKeys(styleProps[styleProp]);
        return properties2.forEach((property) => {
          baseValue && (acc.styles[property] = resolvers[propertyData.type](baseValue, theme2)), breakpoints.forEach((breakpoint) => {
            const bp = `(min-width: ${theme2.breakpoints[breakpoint]})`;
            acc.media[bp] = {
              ...acc.media[bp],
              [property]: resolvers[propertyData.type](
                getBreakpointValue(styleProps[styleProp], breakpoint),
                theme2
              )
            };
          });
        }), acc;
      },
      {
        hasResponsiveStyles: !1,
        styles: {},
        inlineStyles: {},
        media: {}
      }
    )
  );
}
function useRandomClassName() {
  return `__m__-${useId$2().replace(/:/g, "")}`;
}
function getStyleObject(style2, theme2) {
  return Array.isArray(style2) ? [...style2].reduce(
    (acc, item) => ({ ...acc, ...getStyleObject(item, theme2) }),
    {}
  ) : typeof style2 == "function" ? style2(theme2) : style2 ?? {};
}
function transformModKey(key2) {
  return key2.startsWith("data-") ? key2 : `data-${key2}`;
}
function getMod(props) {
  return Object.keys(props).reduce((acc, key2) => {
    const value = props[key2];
    return value === void 0 || value === "" || value === !1 || value === null || (acc[transformModKey(key2)] = props[key2]), acc;
  }, {});
}
function getBoxMod(mod) {
  return mod ? typeof mod == "string" ? { [transformModKey(mod)]: !0 } : Array.isArray(mod) ? [...mod].reduce(
    (acc, value) => ({ ...acc, ...getBoxMod(value) }),
    {}
  ) : getMod(mod) : null;
}
function mergeStyles(styles, theme2) {
  return Array.isArray(styles) ? [...styles].reduce(
    (acc, item) => ({ ...acc, ...mergeStyles(item, theme2) }),
    {}
  ) : typeof styles == "function" ? styles(theme2) : styles ?? {};
}
function getBoxStyle$1({
  theme: theme2,
  style: style2,
  vars,
  styleProps
}) {
  const _style = mergeStyles(style2, theme2), _vars = mergeStyles(vars, theme2);
  return { ..._style, ..._vars, ...styleProps };
}
const _Box = forwardRef(
  ({
    component,
    style: style2,
    __vars,
    className,
    variant,
    mod,
    size: size2,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    renderRoot,
    __size,
    ...others
  }, ref) => {
    const theme2 = useMantineTheme(), Element2 = component || "div", { styleProps, rest } = extractStyleProps(others), transformedSx = useMantineSxTransform()?.()?.(styleProps.sx), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
      styleProps,
      theme: theme2,
      data: STYlE_PROPS_DATA
    }), props = {
      ref,
      style: getBoxStyle$1({
        theme: theme2,
        style: style2,
        vars: __vars,
        styleProps: parsedStyleProps.inlineStyles
      }),
      className: clsx(className, transformedSx, {
        [responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
        "mantine-light-hidden": lightHidden,
        "mantine-dark-hidden": darkHidden,
        [`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
        [`mantine-visible-from-${visibleFrom}`]: visibleFrom
      }),
      "data-variant": variant,
      "data-size": isNumberLike(size2) ? void 0 : size2 || void 0,
      size: __size,
      ...getBoxMod(mod),
      ...rest
    };
    return /* @__PURE__ */ jsxs(Fragment$1, { children: [
      parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
        InlineStyles,
        {
          selector: `.${responsiveClassName}`,
          styles: parsedStyleProps.styles,
          media: parsedStyleProps.media
        }
      ),
      typeof renderRoot == "function" ? renderRoot(props) : /* @__PURE__ */ jsx(Element2, { ...props })
    ] });
  }
);
_Box.displayName = "@mantine/core/Box";
const Box$1 = _Box;
function identity$3(value) {
  return value;
}
function getWithProps(Component2) {
  const _Component = Component2;
  return (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(_Component, { ...fixedProps, ...props, ref }));
    return Extended.extend = _Component.extend, Extended.displayName = `WithProps(${_Component.displayName})`, Extended;
  };
}
function factory(ui) {
  const Component2 = forwardRef(ui);
  return Component2.extend = identity$3, Component2.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component2, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component2.extend, Extended.displayName = `WithProps(${Component2.displayName})`, Extended;
  }, Component2;
}
function polymorphicFactory(ui) {
  const Component2 = forwardRef(ui);
  return Component2.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component2, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component2.extend, Extended.displayName = `WithProps(${Component2.displayName})`, Extended;
  }, Component2.extend = identity$3, Component2;
}
const DirectionContext = createContext({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function useDirection() {
  return useContext(DirectionContext);
}
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(node2) {
  return isNode$1(node2) ? (node2.nodeName || "").toLowerCase() : "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode$1(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode$1(value) {
  return hasWindow() ? value instanceof Node || value instanceof getWindow(value).Node : !1;
}
function isElement(value) {
  return hasWindow() ? value instanceof Element || value instanceof getWindow(value).Element : !1;
}
function isHTMLElement(value) {
  return hasWindow() ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : !1;
}
function isShadowRoot(value) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector3) => {
    try {
      return element.matches(selector3);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit(), css2 = isElement(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : !1) || (css2.containerType ? css2.containerType !== "normal" : !1) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : !1) || !webkit && (css2.filter ? css2.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  for (; isHTMLElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    if (isContainingBlock(currentNode))
      return currentNode;
    if (isTopLayer(currentNode))
      return null;
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  return isElement(element) ? {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  } : {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html")
    return node2;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  return isLastTraversableNode(parentNode) ? node2.ownerDocument ? node2.ownerDocument.body : node2.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  list2 === void 0 && (list2 = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node2), isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win2 = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win2);
    return list2.concat(win2, win2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win2) {
  return win2.parent && Object.getPrototypeOf(win2.parent) ? win2.frameElement : null;
}
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  for (; ((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null; ) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child)
    return !1;
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child))
    return !0;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    for (; next; ) {
      if (parent === next)
        return !0;
      next = next.parentNode || next.host;
    }
  }
  return !1;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? uaData.platform : navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map((_ref) => {
    let {
      brand,
      version: version2
    } = _ref;
    return brand + "/" + version2;
  }).join(" ") : navigator.userAgent;
}
function isVirtualPointerEvent(event) {
  return isJSDOM() ? !1 : !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333 for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
function isMouseLikePointerType(pointerType, strict) {
  const values2 = ["mouse", "pen"];
  return values2.push("", void 0), values2.includes(pointerType);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node2) {
  return node2?.ownerDocument || document;
}
function isEventTargetWithin(event, node2) {
  if (node2 == null)
    return !1;
  if ("composedPath" in event)
    return event.composedPath().includes(node2);
  const e2 = event;
  return e2.target != null && node2.contains(e2.target);
}
function getTarget(event) {
  return "composedPath" in event ? event.composedPath()[0] : event.target;
}
const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
const min$1 = Math.min, max$1 = Math.max, round = Math.round, floor = Math.floor, createCoords = (v) => ({
  x: v,
  y: v
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$3(start2, value, end) {
  return max$1(start2, min$1(value, end));
}
function evaluate(value, param) {
  return typeof value == "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1);
  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  return rects.reference[length] > rects.floating[length] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"], rl = ["right", "left"], tb = ["top", "bottom"], bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      return rtl ? isStart ? rl : lr : isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  return alignment && (list2 = list2.map((side) => side + "-" + alignment), flipAlignment && (list2 = list2.concat(list2.map(getOppositeAlignmentPlacement)))), list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding != "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === "y", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config, validMiddleware = middleware.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  }), {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2], {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX ?? x2, y2 = nextY ?? y2, middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    }, reset && resetCount <= 50 && (resetCount++, typeof reset == "object" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({
      reference,
      floating,
      strategy
    }) : reset.rects), {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i2 = -1);
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  options === void 0 && (options = {});
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state, {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = !1,
    padding = 0
  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) == null || _await$platform$isEle ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  })), rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state, {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null)
      return {};
    const paddingObject = getPaddingObject(padding), coords = {
      x: x2,
      y: y2
    }, axis = getAlignmentAxis(placement), length = getAxisLength(axis), arrowDimensions = await platform2.getDimensions(element), isYAxis = axis === "y", minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length], startDiff = coords[axis] - rects.reference[axis], arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) && (clientSize = elements.floating[clientProp] || rects.floating[length]);
    const centerToReference = endDiff / 2 - startDiff / 2, largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1, minPadding = min$1(paddingObject[minProp], largestPossiblePadding), maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding), min$1$1 = minPadding, max2 = clientSize - arrowDimensions[length] - maxPadding, center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference, offset2 = clamp$3(min$1$1, center, max2), shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0, alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
}), flip$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)
        return {};
      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      const placements = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow(state, detectOverflowOptions), overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      if (overflowsData = [...overflowsData, {
        placement,
        overflows
      }], !overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements[nextIndex];
        if (nextPlacement)
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement)
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return !0;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              placement2 && (resetPlacement = placement2);
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        if (placement !== resetPlacement)
          return {
            reset: {
              placement: resetPlacement
            }
          };
      }
      return {};
    }
  };
};
function getBoundingRect(rects) {
  const minX = min$1(...rects.map((rect) => rect.left)), minY = min$1(...rects.map((rect) => rect.top)), maxX = max$1(...rects.map((rect) => rect.right)), maxY = max$1(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a2, b2) => a2.y - b2.y), groups = [];
  let prevRect = null;
  for (let i2 = 0; i2 < sortedRects.length; i2++) {
    const rect = sortedRects[i2];
    !prevRect || rect.y - prevRect.y > prevRect.height / 2 ? groups.push([rect]) : groups[groups.length - 1].push(rect), prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
const inline$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state, {
        padding = 2,
        x: x2,
        y: y2
      } = evaluate(options, state), nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []), clientRects = getRectsByLine(nativeClientRects), fallback = rectToClientRect(getBoundingRect(nativeClientRects)), paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null)
          return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0], lastRect = clientRects[clientRects.length - 1], isTop = getSide(placement) === "top", top2 = firstRect.top, bottom2 = lastRect.bottom, left2 = isTop ? firstRect.left : lastRect.left, right2 = isTop ? firstRect.right : lastRect.right, width2 = right2 - left2, height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left", maxRight = max$1(...clientRects.map((rect) => rect.right)), minLeft = min$1(...clientRects.map((rect) => rect.left)), measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight), top = measureRects[0].top, bottom = measureRects[measureRects.length - 1].bottom, left = minLeft, right = maxRight, width = right - left, height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      return rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height ? {
        reset: {
          rects: resetRects
        }
      } : {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === "y", mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue == "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  return alignment && typeof alignmentAxis == "number" && (crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$3 = function(options) {
  return options === void 0 && (options = 0), {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state, diffCoords = await convertValueToCoords(state, options);
      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, shift$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !1,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left", maxSide = mainAxis === "y" ? "bottom" : "right", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$3(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left", maxSide = crossAxis === "y" ? "bottom" : "right", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$3(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
}, limitShift$2 = function(options) {
  return options === void 0 && (options = {}), {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state, {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state), computedOffset = typeof rawOffset == "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width", limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis, limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > limitMax && (mainAxisCoord = limitMax);
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height", isOriginSide = ["top", "left"].includes(getSide(placement)), limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide && ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0) + (isOriginSide ? 0 : computedOffset.crossAxis), limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        crossAxisCoord < limitMin ? crossAxisCoord = limitMin : crossAxisCoord > limitMax && (crossAxisCoord = limitMax);
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
}, size$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state, {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions), side = getSide(placement), alignment = getAlignment(placement), isYAxis = getSideAxis(placement) === "y", {
        width,
        height
      } = rects.floating;
      let heightSide, widthSide;
      side === "top" || side === "bottom" ? (heightSide = side, widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right") : (widthSide = side, heightSide = alignment === "end" ? "top" : "bottom");
      const maximumClippingHeight = height - overflow.top - overflow.bottom, maximumClippingWidth = width - overflow.left - overflow.right, overflowAvailableHeight = min$1(height - overflow[heightSide], maximumClippingHeight), overflowAvailableWidth = min$1(width - overflow[widthSide], maximumClippingWidth), noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight, availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x && (availableWidth = maximumClippingWidth), (_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y && (availableHeight = maximumClippingHeight), noShift && !alignment) {
        const xMin = max$1(overflow.left, 0), xMax = max$1(overflow.right, 0), yMin = max$1(overflow.top, 0), yMax = max$1(overflow.bottom, 0);
        isYAxis ? availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right)) : availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      return width !== nextDimensions.width || height !== nextDimensions.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(element) {
  const css2 = getComputedStyle$2(element);
  let width = parseFloat(css2.width) || 0, height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return isElement(element) ? element : element.contextElement;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width, y2 = ($ ? round(rect.height) : rect.height) / height;
  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win2 = getWindow(element);
  return !isWebKit() || !win2.visualViewport ? noOffsets : {
    x: win2.visualViewport.offsetLeft,
    y: win2.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale2 = getScale(offsetParent)) : scale2 = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x, y2 = (clientRect.top + visualOffsets.y) / scale2.y, width = clientRect.width / scale2.x, height = clientRect.height / scale2.y;
  if (domElement) {
    const win2 = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win2, currentIFrame = getFrameElement(currentWin);
    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css2 = getComputedStyle$2(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x2 += left, y2 += top, currentWin = getWindow(currentIFrame), currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  return rect ? rect.left + leftScroll : getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  ignoreScrollbarX === void 0 && (ignoreScrollbarX = !1);
  const htmlRect = documentElement.getBoundingClientRect(), x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  )), y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;
  if (offsetParent === documentElement || topLayer && isFixed)
    return rect;
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  }, scale2 = createCoords(1);
  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement(offsetParent);
  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent))) {
    const offsetRect = getBoundingClientRect(offsetParent);
    scale2 = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, !0) : createCoords(0);
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element), scroll = getNodeScroll(element), body2 = element.ownerDocument.body, width = max$1(html.scrollWidth, html.clientWidth, body2.scrollWidth, body2.clientWidth), height = max$1(html.scrollHeight, html.clientHeight, body2.scrollHeight, body2.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  return getComputedStyle$2(body2).direction === "rtl" && (x2 += max$1(html.clientWidth, body2.clientWidth) - width), {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win2 = getWindow(element), html = getDocumentElement(element), visualViewport = win2.visualViewport;
  let width = html.clientWidth, height = html.clientHeight, x2 = 0, y2 = 0;
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height;
    const visualViewportBased = isWebKit();
    (!visualViewportBased || visualViewportBased && strategy === "fixed") && (x2 = visualViewport.offsetLeft, y2 = visualViewport.offsetTop);
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, !0, strategy === "fixed"), top = clientRect.top + element.clientTop, left = clientRect.left + element.clientLeft, scale2 = isHTMLElement(element) ? getScale(element) : createCoords(1), width = element.clientWidth * scale2.x, height = element.clientHeight * scale2.y, x2 = left * scale2.x, y2 = top * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport")
    rect = getViewportRect(element, strategy);
  else if (clippingAncestor === "document")
    rect = getDocumentRect(getDocumentElement(element));
  else if (isElement(clippingAncestor))
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult)
    return cachedResult;
  let result = getOverflowAncestors(element, [], !1).filter((el) => isElement(el) && getNodeName(el) !== "body"), currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  for (; isElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    const computedStyle = getComputedStyle$2(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
    !currentNodeIsContaining && computedStyle.position === "fixed" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);
  }
  return cache.set(element, result), result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    return accRect.top = max$1(rect.top, accRect.top), accRect.right = min$1(rect.right, accRect.right), accRect.bottom = min$1(rect.bottom, accRect.bottom), accRect.left = max$1(rect.left, accRect.left), accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions$1(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === "fixed", rect = getBoundingClientRect(element, !0, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    if ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
    } else documentElement && (offsets.x = getWindowScrollBarX(documentElement));
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0), x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x, y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$2(element).position === "fixed")
    return null;
  if (polyfill)
    return polyfill(element);
  let rawOffsetParent = element.offsetParent;
  return getDocumentElement(element) === rawOffsetParent && (rawOffsetParent = rawOffsetParent.ownerDocument.body), rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win2 = getWindow(element);
  if (isTopLayer(element))
    return win2;
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))
        return svgOffsetParent;
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win2 : offsetParent || getContainingBlock(element) || win2;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$2(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions: getDimensions$1,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect(), {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root2.clientWidth - (left + width)), insetBottom = floor(root2.clientHeight - (top + height)), insetLeft = floor(left), options = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max$1(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 1e3);
      }
      ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect()) && refresh(), isFirstUpdate = !1;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  return refresh(!0), cleanup;
}
function autoUpdate(reference, floating, update, options) {
  options === void 0 && (options = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref) => {
    let [firstEntry] = _ref;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
    })), update();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return update(), () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update), ancestorResize && ancestor.removeEventListener("resize", update);
    }), cleanupIo?.(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
const offset$2 = offset$3, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, arrow$2 = arrow$3, inline$1 = inline$2, limitShift$1 = limitShift$2, computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map(), mergedOptions = {
    platform,
    ...options
  }, platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$2 = typeof document < "u" ? useLayoutEffect$1 : useEffect;
function deepEqual$2(a2, b2) {
  if (a2 === b2)
    return !0;
  if (typeof a2 != typeof b2)
    return !1;
  if (typeof a2 == "function" && a2.toString() === b2.toString())
    return !0;
  let length, i2, keys2;
  if (a2 && b2 && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      if (length = a2.length, length !== b2.length) return !1;
      for (i2 = length; i2-- !== 0; )
        if (!deepEqual$2(a2[i2], b2[i2]))
          return !1;
      return !0;
    }
    if (keys2 = Object.keys(a2), length = keys2.length, length !== Object.keys(b2).length)
      return !1;
    for (i2 = length; i2-- !== 0; )
      if (!{}.hasOwnProperty.call(b2, keys2[i2]))
        return !1;
    for (i2 = length; i2-- !== 0; ) {
      const key2 = keys2[i2];
      if (!(key2 === "_owner" && a2.$$typeof) && !deepEqual$2(a2[key2], b2[key2]))
        return !1;
    }
    return !0;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  return typeof window > "u" ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = React.useRef(value);
  return index$2(() => {
    ref.current = value;
  }), ref;
}
function useFloating$1(options) {
  options === void 0 && (options = {});
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = !0,
    whileElementsMounted,
    open
  } = options, [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: !1
  }), [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  deepEqual$2(latestMiddleware, middleware) || setLatestMiddleware(middleware);
  const [_reference, _setReference] = React.useState(null), [_floating, _setFloating] = React.useState(null), setReference = React.useCallback((node2) => {
    node2 !== referenceRef.current && (referenceRef.current = node2, _setReference(node2));
  }, []), setFloating = React.useCallback((node2) => {
    node2 !== floatingRef.current && (floatingRef.current = node2, _setFloating(node2));
  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React.useRef(null), floatingRef = React.useRef(null), dataRef = React.useRef(data), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef$1(whileElementsMounted), platformRef = useLatestRef$1(platform2), openRef = useLatestRef$1(open), update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current)
      return;
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    platformRef.current && (config.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== !1
      };
      isMountedRef.current && !deepEqual$2(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {
        setData(fullData);
      }));
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$2(() => {
    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData((data2) => ({
      ...data2,
      isPositioned: !1
    })));
  }, [open]);
  const isMountedRef = React.useRef(!1);
  index$2(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), index$2(() => {
    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {
      if (whileElementsMountedRef.current)
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]), elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]), floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating)
      return initialStyles;
    const x2 = roundByDPR(elements.floating, data.x), y2 = roundByDPR(elements.floating, data.y);
    return transform2 ? {
      ...initialStyles,
      transform: "translate(" + x2 + "px, " + y2 + "px)",
      ...getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options == "function" ? options(state) : options;
      return element && isRef(element) ? element.current != null ? arrow$2({
        element: element.current,
        padding
      }).fn(state) : {} : element ? arrow$2({
        element,
        padding
      }).fn(state) : {};
    }
  };
}, offset$1 = (options, deps) => ({
  ...offset$2(options),
  options: [options, deps]
}), shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
}), flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
}), inline = (options, deps) => ({
  ...inline$1(options),
  options: [options, deps]
}), arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
function useMergeRefs(refs) {
  return React.useMemo(() => refs.every((ref) => ref == null) ? null : (value) => {
    refs.forEach((ref) => {
      typeof ref == "function" ? ref(value) : ref != null && (ref.current = value);
    });
  }, refs);
}
const SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
  });
  return useSafeInsertionEffect(() => {
    ref.current = callback;
  }), React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index$1 = typeof document < "u" ? useLayoutEffect$1 : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id2, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index$1(() => {
    id2 == null && setId(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), id2;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function useLatestRef(value) {
  const ref = useRef(value);
  return index$1(() => {
    ref.current = value;
  }), ref;
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  return pointerType && !isMouseLikePointerType(pointerType) ? 0 : typeof value == "number" ? value : value?.[prop];
}
function useHover(context2, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context2, {
    enabled = !0,
    delay: delay2 = 0,
    handleClose = null,
    mouseOnly = !1,
    restMs = 0,
    move = !0
  } = props, tree = useFloatingTree(), parentId = useFloatingParentNodeId(), handleCloseRef = useLatestRef(handleClose), delayRef = useLatestRef(delay2), openRef = useLatestRef(open), pointerTypeRef = React.useRef(), timeoutRef = React.useRef(-1), handlerRef = React.useRef(), restTimeoutRef = React.useRef(-1), blockMouseMoveRef = React.useRef(!0), performedPointerEventsMutationRef = React.useRef(!1), unbindMouseMoveRef = React.useRef(() => {
  }), restTimeoutPendingRef = React.useRef(!1), isHoverOpen = React.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return type?.includes("mouse") && type !== "mousedown";
  }, [dataRef]);
  React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      open2 || (clearTimeout(timeoutRef.current), clearTimeout(restTimeoutRef.current), blockMouseMoveRef.current = !0, restTimeoutPendingRef.current = !1);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]), React.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) return;
    function onLeave(event) {
      isHoverOpen() && onOpenChange(!1, event, "hover");
    }
    const html = getDocument(elements.floating).documentElement;
    return html.addEventListener("mouseleave", onLeave), () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React.useCallback(function(event, runElseBranch, reason) {
    runElseBranch === void 0 && (runElseBranch = !0), reason === void 0 && (reason = "hover");
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    closeDelay && !handlerRef.current ? (clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => onOpenChange(!1, event, reason), closeDelay)) : runElseBranch && (clearTimeout(timeoutRef.current), onOpenChange(!1, event, reason));
  }, [delayRef, onOpenChange]), cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current(), handlerRef.current = void 0;
  }), clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body2 = getDocument(elements.floating).body;
      body2.style.pointerEvents = "", body2.removeAttribute(safePolygonIdentifier), performedPointerEventsMutationRef.current = !1;
    }
  }), isClickLikeOpenEvent = useEffectEvent(() => dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : !1);
  React.useEffect(() => {
    if (!enabled) return;
    function onMouseEnter(event) {
      if (clearTimeout(timeoutRef.current), blockMouseMoveRef.current = !1, mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, "open"))
        return;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      openDelay ? timeoutRef.current = window.setTimeout(() => {
        openRef.current || onOpenChange(!0, event, "hover");
      }, openDelay) : open || onOpenChange(!0, event, "hover");
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      if (clearTimeout(restTimeoutRef.current), restTimeoutPendingRef.current = !1, handleCloseRef.current && dataRef.current.floatingContext) {
        open || clearTimeout(timeoutRef.current), handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event, !0, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler), unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      (pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : !0) && closeWithDelay(event);
    }
    function onScrollMouseLeave(event) {
      isClickLikeOpenEvent() || dataRef.current.floatingContext && (handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event);
        }
      })(event));
    }
    if (isElement(elements.domReference)) {
      var _elements$floating;
      const ref = elements.domReference;
      return open && ref.addEventListener("mouseleave", onScrollMouseLeave), (_elements$floating = elements.floating) == null || _elements$floating.addEventListener("mouseleave", onScrollMouseLeave), move && ref.addEventListener("mousemove", onMouseEnter, {
        once: !0
      }), ref.addEventListener("mouseenter", onMouseEnter), ref.addEventListener("mouseleave", onMouseLeave), () => {
        var _elements$floating2;
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave), (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener("mouseleave", onScrollMouseLeave), move && ref.removeEventListener("mousemove", onMouseEnter), ref.removeEventListener("mouseenter", onMouseEnter), ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [elements, enabled, context2, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent]), index$1(() => {
    var _handleCloseRef$curre;
    if (enabled && open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = !0;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body2 = getDocument(elements.floating).body;
        body2.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference, parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node2) => node2.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        return parentFloating && (parentFloating.style.pointerEvents = ""), body2.style.pointerEvents = "none", ref.style.pointerEvents = "auto", floatingEl.style.pointerEvents = "auto", () => {
          body2.style.pointerEvents = "", ref.style.pointerEvents = "", floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]), index$1(() => {
    open || (pointerTypeRef.current = void 0, restTimeoutPendingRef.current = !1, cleanupMouseMoveHandler(), clearPointerEvents());
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]), React.useEffect(() => () => {
    cleanupMouseMoveHandler(), clearTimeout(timeoutRef.current), clearTimeout(restTimeoutRef.current), clearPointerEvents();
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          !blockMouseMoveRef.current && !openRef.current && onOpenChange(!0, nativeEvent, "hover");
        }
        mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || open || restMs === 0 || restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2 || (clearTimeout(restTimeoutRef.current), pointerTypeRef.current === "touch" ? handleMouseMove() : (restTimeoutPendingRef.current = !0, restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs)));
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMs]), floating = React.useMemo(() => ({
    onMouseEnter() {
      clearTimeout(timeoutRef.current);
    },
    onMouseLeave(event) {
      isClickLikeOpenEvent() || closeWithDelay(event.nativeEvent, !1);
    }
  }), [closeWithDelay, isClickLikeOpenEvent]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
const NOOP = () => {
}, FloatingDelayGroupContext = /* @__PURE__ */ React.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: !1
}), useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
function FloatingDelayGroup(props) {
  const {
    children: children2,
    delay: delay2,
    timeoutMs = 0
  } = props, [state, setState] = React.useReducer((prev, next) => ({
    ...prev,
    ...next
  }), {
    delay: delay2,
    timeoutMs,
    initialDelay: delay2,
    currentId: null,
    isInstantPhase: !1
  }), initialCurrentIdRef = React.useRef(null), setCurrentId = React.useCallback((currentId) => {
    setState({
      currentId
    });
  }, []);
  return index$1(() => {
    state.currentId ? initialCurrentIdRef.current === null ? initialCurrentIdRef.current = state.currentId : state.isInstantPhase || setState({
      isInstantPhase: !0
    }) : (state.isInstantPhase && setState({
      isInstantPhase: !1
    }), initialCurrentIdRef.current = null);
  }, [state.currentId, state.isInstantPhase]), /* @__PURE__ */ React.createElement(FloatingDelayGroupContext.Provider, {
    value: React.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setCurrentId])
  }, children2);
}
function useDelayGroup(context2, options) {
  options === void 0 && (options = {});
  const {
    open,
    onOpenChange,
    floatingId
  } = context2, {
    id: optionId,
    enabled = !0
  } = options, id2 = optionId ?? floatingId, groupContext = useDelayGroupContext(), {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = groupContext;
  return index$1(() => {
    enabled && currentId && (setState({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    }), currentId !== id2 && onOpenChange(!1));
  }, [enabled, id2, onOpenChange, setState, currentId, initialDelay]), index$1(() => {
    function unset() {
      onOpenChange(!1), setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (enabled && currentId && !open && currentId === id2) {
      if (timeoutMs) {
        const timeout2 = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout2);
        };
      }
      unset();
    }
  }, [enabled, open, setState, currentId, id2, onOpenChange, initialDelay, timeoutMs]), index$1(() => {
    enabled && (setCurrentId === NOOP || !open || setCurrentId(id2));
  }, [enabled, open, setCurrentId, id2]), groupContext;
}
function getChildren(nodes, id2) {
  let allChildren = nodes.filter((node2) => {
    var _node$context;
    return node2.parentId === id2 && ((_node$context = node2.context) == null ? void 0 : _node$context.open);
  }), currentChildren = allChildren;
  for (; currentChildren.length; )
    currentChildren = nodes.filter((node2) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n2) => {
        var _node$context2;
        return node2.parentId === n2.id && ((_node$context2 = node2.context) == null ? void 0 : _node$context2.open);
      });
    }), allChildren = allChildren.concat(currentChildren);
  return allChildren;
}
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable", bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable == "boolean" ? normalizable : (_normalizable$escapeK = normalizable?.escapeKey) != null ? _normalizable$escapeK : !1,
    outsidePress: typeof normalizable == "boolean" ? normalizable : (_normalizable$outside = normalizable?.outsidePress) != null ? _normalizable$outside : !0
  };
};
function useDismiss(context2, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context2, {
    enabled = !0,
    escapeKey = !0,
    outsidePress: unstable_outsidePress = !0,
    outsidePressEvent = "pointerdown",
    referencePress = !1,
    referencePressEvent = "pointerdown",
    ancestorScroll = !1,
    bubbles,
    capture
  } = props, tree = useFloatingTree(), outsidePressFn = useEffectEvent(typeof unstable_outsidePress == "function" ? unstable_outsidePress : () => !1), outsidePress = typeof unstable_outsidePress == "function" ? outsidePressFn : unstable_outsidePress, insideReactTreeRef = React.useRef(!1), endedOrStartedInsideRef = React.useRef(!1), {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles), {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture), isComposingRef = React.useRef(!1), closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape" || isComposingRef.current)
      return;
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId, children2 = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles && (event.stopPropagation(), children2.length > 0)) {
      let shouldDismiss = !0;
      if (children2.forEach((child) => {
        var _child$context;
        if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  }), closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event), (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  }), closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = !1;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    if (endedOrStartedInsideRef.current = !1, outsidePressEvent === "click" && endedOrStartedInside || insideReactTree || typeof outsidePress == "function" && !outsidePress(event))
      return;
    const target = getTarget(event), inertSelector = "[" + createAttribute("inert") + "]", markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    for (; targetRootAncestor && !isLastTraversableNode(targetRootAncestor); ) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent))
        break;
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker)))
      return;
    if (isHTMLElement(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth, canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY && getComputedStyle$2(target).direction === "rtl" && (xCond = event.offsetX <= target.offsetWidth - target.clientWidth), xCond || canScrollX && event.offsetY > target.clientHeight)
        return;
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId, targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node2) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node2.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren)
      return;
    const children2 = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children2.length > 0) {
      let shouldDismiss = !0;
      if (children2.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, event, "outside-press");
  }), closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event), (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React.useEffect(() => {
    if (!open || !enabled)
      return;
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles, dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(!1, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout), isComposingRef.current = !0;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc = getDocument(elements.floating);
    escapeKey && (doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.addEventListener("compositionstart", handleCompositionStart), doc.addEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    return ancestorScroll && (isElement(elements.domReference) && (ancestors = getOverflowAncestors(elements.domReference)), isElement(elements.floating) && (ancestors = ancestors.concat(getOverflowAncestors(elements.floating))), !isElement(elements.reference) && elements.reference && elements.reference.contextElement && (ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement)))), ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    }), ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: !0
      });
    }), () => {
      escapeKey && (doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.removeEventListener("compositionstart", handleCompositionStart), doc.removeEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      }), window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]), React.useEffect(() => {
    insideReactTreeRef.current = !1;
  }, [outsidePress, outsidePressEvent]);
  const reference = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    [bubbleHandlerKeys[referencePressEvent]]: (event) => {
      referencePress && onOpenChange(!1, event.nativeEvent, "reference-press");
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]), floating = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = !0;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = !0;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      insideReactTreeRef.current = !0;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = !1,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options, floatingId = useId(), dataRef = React.useRef({}), [events] = React.useState(() => createPubSub()), nested = useFloatingParentNodeId() != null, [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0, events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    }), onOpenChangeProp?.(open2, event, reason);
  }), refs = React.useMemo(() => ({
    setPositionReference
  }), []), elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  options === void 0 && (options = {});
  const {
    nodeId
  } = options, internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [_domReference, setDomReference] = React.useState(null), [positionReference, _setPositionReference] = React.useState(null), domReference = computedElements?.domReference || _domReference, domReferenceRef = React.useRef(null), tree = useFloatingTree();
  index$1(() => {
    domReference && (domReferenceRef.current = domReference);
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  }), setPositionReference = React.useCallback((node2) => {
    const computedPositionReference = isElement(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      contextElement: node2
    } : node2;
    _setPositionReference(computedPositionReference), position.refs.setReference(computedPositionReference);
  }, [position.refs]), setReference = React.useCallback((node2) => {
    (isElement(node2) || node2 === null) && (domReferenceRef.current = node2, setDomReference(node2)), (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node2 !== null && !isElement(node2)) && position.refs.setReference(node2);
  }, [position.refs]), refs = React.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]), context2 = React.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  return index$1(() => {
    rootContext.dataRef.current.floatingContext = context2;
    const node2 = tree?.nodesRef.current.find((node22) => node22.id === nodeId);
    node2 && (node2.context = context2);
  }), React.useMemo(() => ({
    ...position,
    context: context2,
    refs,
    elements
  }), [position, refs, elements, context2]);
}
function useFocus(context2, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context2, {
    enabled = !0,
    visibleOnly = !0
  } = props, blockFocusRef = React.useRef(!1), timeoutRef = React.useRef(), keyboardModalityRef = React.useRef(!0);
  React.useEffect(() => {
    if (!enabled) return;
    const win2 = getWindow(elements.domReference);
    function onBlur() {
      !open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference)) && (blockFocusRef.current = !0);
    }
    function onKeyDown() {
      keyboardModalityRef.current = !0;
    }
    return win2.addEventListener("blur", onBlur), win2.addEventListener("keydown", onKeyDown, !0), () => {
      win2.removeEventListener("blur", onBlur), win2.removeEventListener("keydown", onKeyDown, !0);
    };
  }, [elements.domReference, open, enabled]), React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      (reason === "reference-press" || reason === "escape-key") && (blockFocusRef.current = !0);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]), React.useEffect(() => () => {
    clearTimeout(timeoutRef.current);
  }, []);
  const reference = React.useMemo(() => ({
    onPointerDown(event) {
      isVirtualPointerEvent(event.nativeEvent) || (keyboardModalityRef.current = !1);
    },
    onMouseLeave() {
      blockFocusRef.current = !1;
    },
    onFocus(event) {
      if (blockFocusRef.current) return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target))
        try {
          if (isSafari() && isMac()) throw Error();
          if (!target.matches(":focus-visible")) return;
        } catch {
          if (!keyboardModalityRef.current && !isTypeableElement(target))
            return;
        }
      onOpenChange(!0, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = !1;
      const relatedTarget = event.relatedTarget, nativeEvent = event.nativeEvent, movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        !relatedTarget && activeEl === elements.domReference || contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard || onOpenChange(!1, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps$1(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map(), isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      return typeof propsOrGetProps == "function" ? userProps ? propsOrGetProps(userProps) : null : propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => (props && Object.entries(props).forEach((_ref) => {
      let [key2, value] = _ref;
      if (!(isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key2)))
        if (key2.indexOf("on") === 0) {
          if (map.has(key2) || map.set(key2, []), typeof value == "function") {
            var _map$get;
            (_map$get = map.get(key2)) == null || _map$get.push(value), acc[key2] = function() {
              for (var _map$get2, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
                args[_key] = arguments[_key];
              return (_map$get2 = map.get(key2)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else
          acc[key2] = value;
    }), acc), {})
  };
}
function useInteractions(propsList) {
  propsList === void 0 && (propsList = []);
  const referenceDeps = propsList.map((key2) => key2?.reference), floatingDeps = propsList.map((key2) => key2?.floating), itemDeps = propsList.map((key2) => key2?.item), getReferenceProps = React.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  ), getFloatingProps = React.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  ), getItemProps = React.useCallback(
    (userProps) => mergeProps$1(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function useRole(context2, props) {
  var _componentRoleToAriaR;
  props === void 0 && (props = {});
  const {
    open,
    floatingId
  } = context2, {
    enabled = !0,
    role = "dialog"
  } = props, ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role, referenceId = useId(), isNested = useFloatingParentNodeId() != null, reference = React.useMemo(() => ariaRole === "tooltip" || role === "label" ? {
    ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
  } : {
    "aria-expanded": open ? "true" : "false",
    "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
    "aria-controls": open ? floatingId : void 0,
    ...ariaRole === "listbox" && {
      role: "combobox"
    },
    ...ariaRole === "menu" && {
      id: referenceId
    },
    ...ariaRole === "menu" && isNested && {
      role: "menuitem"
    },
    ...role === "select" && {
      "aria-autocomplete": "none"
    },
    ...role === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [ariaRole, floatingId, isNested, open, referenceId, role]), floating = React.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    return ariaRole === "tooltip" || role === "label" ? floatingProps : {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]), item = React.useCallback((_ref) => {
    let {
      active,
      selected: selected2
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-option"
      }
    };
    switch (role) {
      case "select":
        return {
          ...commonProps,
          "aria-selected": active && selected2
        };
      case "combobox":
        return {
          ...commonProps,
          ...active && {
            "aria-selected": !0
          }
        };
    }
    return {};
  }, [floatingId, role]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext(
  "ScrollArea.Root component was not found in tree"
);
function useResizeObserver$1(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useIsomorphicEffect(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF), rAF = window.requestAnimationFrame(handleResize);
      });
      return resizeObserver.observe(element), () => {
        window.cancelAnimationFrame(rAF), resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
const Corner = forwardRef((props, ref) => {
  const { style: style2, ...others } = props, ctx = useScrollAreaContext(), [width, setWidth] = useState(0), [height, setHeight] = useState(0), hasSize = !!(width && height);
  return useResizeObserver$1(ctx.scrollbarX, () => {
    const h = ctx.scrollbarX?.offsetHeight || 0;
    ctx.onCornerHeightChange(h), setHeight(h);
  }), useResizeObserver$1(ctx.scrollbarY, () => {
    const w = ctx.scrollbarY?.offsetWidth || 0;
    ctx.onCornerWidthChange(w), setWidth(w);
  }), hasSize ? /* @__PURE__ */ jsx("div", { ...others, ref, style: { ...style2, width, height } }) : null;
}), ScrollAreaCorner = forwardRef((props, ref) => {
  const ctx = useScrollAreaContext(), hasBothScrollbarsVisible = !!(ctx.scrollbarX && ctx.scrollbarY);
  return ctx.type !== "scroll" && hasBothScrollbarsVisible ? /* @__PURE__ */ jsx(Corner, { ...props, ref }) : null;
}), defaultProps$1z = {
  scrollHideDelay: 1e3,
  type: "hover"
}, ScrollAreaRoot = forwardRef((_props, ref) => {
  const props = useProps("ScrollAreaRoot", defaultProps$1z, _props), { type, scrollHideDelay, scrollbars, ...others } = props, [scrollArea2, setScrollArea] = useState(null), [viewport, setViewport] = useState(null), [content2, setContent] = useState(null), [scrollbarX, setScrollbarX] = useState(null), [scrollbarY, setScrollbarY] = useState(null), [cornerWidth, setCornerWidth] = useState(0), [cornerHeight, setCornerHeight] = useState(0), [scrollbarXEnabled, setScrollbarXEnabled] = useState(!1), [scrollbarYEnabled, setScrollbarYEnabled] = useState(!1), rootRef = useMergedRef(ref, (node2) => setScrollArea(node2));
  return /* @__PURE__ */ jsx(
    ScrollAreaProvider,
    {
      value: {
        type,
        scrollHideDelay,
        scrollArea: scrollArea2,
        viewport,
        onViewportChange: setViewport,
        content: content2,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight
      },
      children: /* @__PURE__ */ jsx(
        Box$1,
        {
          ...others,
          ref: rootRef,
          __vars: {
            "--sa-corner-width": scrollbars !== "xy" ? "0px" : `${cornerWidth}px`,
            "--sa-corner-height": scrollbars !== "xy" ? "0px" : `${cornerHeight}px`
          }
        }
      )
    }
  );
});
ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot";
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes2) {
  const ratio = getThumbRatio(sizes2.viewport, sizes2.content), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, thumbSize = (sizes2.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function linearScale(input2, output) {
  return (value) => {
    if (input2[0] === input2[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input2[1] - input2[0]);
    return output[0] + ratio * (value - input2[0]);
  };
}
function clamp$2(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function getThumbOffsetFromScroll(scrollPos, sizes2, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes2), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, scrollbar = sizes2.scrollbar.size - scrollbarPadding, maxScrollPos = sizes2.content - sizes2.viewport, maxThumbPos = scrollbar - thumbSizePx, scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0], scrollWithoutMomentum = clamp$2(scrollPos, scrollClampRange);
  return linearScale([0, maxScrollPos], [0, maxThumbPos])(scrollWithoutMomentum);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes2, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes2), thumbCenter = thumbSizePx / 2, offset2 = pointerOffset || thumbCenter, thumbOffsetFromEnd = thumbSizePx - offset2, minPointerPos = sizes2.scrollbar.paddingStart + offset2, maxPointerPos = sizes2.scrollbar.size - sizes2.scrollbar.paddingEnd - thumbOffsetFromEnd, maxScrollPos = sizes2.content - sizes2.viewport, scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  return linearScale([minPointerPos, maxPointerPos], scrollRange)(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
  return (event) => {
    originalEventHandler?.(event), (checkForDefaultPrevented === !1 || !event.defaultPrevented) && ourEventHandler?.(event);
  };
}
const [ScrollbarProvider, useScrollbarContext] = createSafeContext(
  "ScrollAreaScrollbar was not found in tree"
), Scrollbar = forwardRef((props, forwardedRef) => {
  const {
    sizes: sizes2,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props, context2 = useScrollAreaContext(), [scrollbar, setScrollbar] = useState(null), composeRefs = useMergedRef(forwardedRef, (node2) => setScrollbar(node2)), rectRef = useRef(null), prevWebkitUserSelectRef = useRef(""), { viewport } = context2, maxScrollPos = sizes2.content - sizes2.viewport, handleWheelScroll = useCallbackRef(onWheelScroll), handleThumbPositionChange = useCallbackRef(onThumbPositionChange), handleResize = useDebouncedCallback$1(onResize, 10), handleDragScroll = (event) => {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left, y2 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y: y2 });
    }
  };
  return useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      scrollbar?.contains(element) && handleWheelScroll(event, maxScrollPos);
    };
    return document.addEventListener("wheel", handleWheel, { passive: !1 }), () => document.removeEventListener("wheel", handleWheel, { passive: !1 });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]), useEffect(handleThumbPositionChange, [sizes2, handleThumbPositionChange]), useResizeObserver$1(scrollbar, handleResize), useResizeObserver$1(context2.content, handleResize), /* @__PURE__ */ jsx(
    ScrollbarProvider,
    {
      value: {
        scrollbar,
        hasThumb,
        onThumbChange: useCallbackRef(onThumbChange),
        onThumbPointerUp: useCallbackRef(onThumbPointerUp),
        onThumbPositionChange: handleThumbPositionChange,
        onThumbPointerDown: useCallbackRef(onThumbPointerDown)
      },
      children: /* @__PURE__ */ jsx(
        "div",
        {
          ...scrollbarProps,
          ref: composeRefs,
          "data-mantine-scrollbar": !0,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            event.preventDefault(), event.button === 0 && (event.target.setPointerCapture(event.pointerId), rectRef.current = scrollbar.getBoundingClientRect(), prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", handleDragScroll(event));
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            element.hasPointerCapture(event.pointerId) && (event.preventDefault(), element.releasePointerCapture(event.pointerId));
          }),
          onLostPointerCapture: () => {
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current, rectRef.current = null;
          }
        }
      )
    }
  );
}), ScrollAreaScrollbarX = forwardRef(
  (props, forwardedRef) => {
    const { sizes: sizes2, onSizesChange, style: style2, ...others } = props, ctx = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);
    return useEffect(() => {
      ref.current && setComputedStyle(getComputedStyle(ref.current));
    }, [ref]), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        "data-orientation": "horizontal",
        ...others,
        ref: composeRefs,
        sizes: sizes2,
        style: {
          ...style2,
          "--sa-thumb-width": `${getThumbSize(sizes2)}px`
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
        onWheelScroll: (event, maxScrollPos) => {
          if (ctx.viewport) {
            const scrollPos = ctx.viewport.scrollLeft + event.deltaX;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && ctx.viewport && computedStyle && onSizesChange({
            content: ctx.viewport.scrollWidth,
            viewport: ctx.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX";
const ScrollAreaScrollbarY = forwardRef(
  (props, forwardedRef) => {
    const { sizes: sizes2, onSizesChange, style: style2, ...others } = props, context2 = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs = useMergedRef(forwardedRef, ref, context2.onScrollbarYChange);
    return useEffect(() => {
      ref.current && setComputedStyle(window.getComputedStyle(ref.current));
    }, []), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        ...others,
        "data-orientation": "vertical",
        ref: composeRefs,
        sizes: sizes2,
        style: {
          "--sa-thumb-height": `${getThumbSize(sizes2)}px`,
          ...style2
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
        onWheelScroll: (event, maxScrollPos) => {
          if (context2.viewport) {
            const scrollPos = context2.viewport.scrollTop + event.deltaY;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && context2.viewport && computedStyle && onSizesChange({
            content: context2.viewport.scrollHeight,
            viewport: context2.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY";
const ScrollAreaScrollbarVisible = forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props, { dir } = useDirection(), context2 = useScrollAreaContext(), thumbRef = useRef(null), pointerOffsetRef = useRef(0), [sizes2, setSizes] = useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), thumbRatio = getThumbRatio(sizes2.viewport, sizes2.content), commonProps = {
    ...scrollbarProps,
    sizes: sizes2,
    onSizesChange: setSizes,
    hasThumb: thumbRatio > 0 && thumbRatio < 1,
    onThumbChange: (thumb) => {
      thumbRef.current = thumb;
    },
    onThumbPointerUp: () => {
      pointerOffsetRef.current = 0;
    },
    onThumbPointerDown: (pointerPos) => {
      pointerOffsetRef.current = pointerPos;
    }
  }, getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes2, direction);
  return orientation === "horizontal" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarX,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context2.viewport && thumbRef.current) {
          const scrollPos = context2.viewport.scrollLeft, offset2 = getThumbOffsetFromScroll(scrollPos, sizes2, dir);
          thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context2.viewport && (context2.viewport.scrollLeft = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context2.viewport && (context2.viewport.scrollLeft = getScrollPosition(pointerPos, dir));
      }
    }
  ) : orientation === "vertical" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarY,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context2.viewport && thumbRef.current) {
          const scrollPos = context2.viewport.scrollTop, offset2 = getThumbOffsetFromScroll(scrollPos, sizes2);
          sizes2.scrollbar.size === 0 ? thumbRef.current.style.setProperty("--thumb-opacity", "0") : thumbRef.current.style.setProperty("--thumb-opacity", "1"), thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context2.viewport && (context2.viewport.scrollTop = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context2.viewport && (context2.viewport.scrollTop = getScrollPosition(pointerPos));
      }
    }
  ) : null;
});
ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible";
const ScrollAreaScrollbarAuto = forwardRef(
  (props, ref) => {
    const context2 = useScrollAreaContext(), { forceMount, ...scrollbarProps } = props, [visible2, setVisible] = useState(!1), isHorizontal = props.orientation === "horizontal", handleResize = useDebouncedCallback$1(() => {
      if (context2.viewport) {
        const isOverflowX = context2.viewport.offsetWidth < context2.viewport.scrollWidth, isOverflowY = context2.viewport.offsetHeight < context2.viewport.scrollHeight;
        setVisible(isHorizontal ? isOverflowX : isOverflowY);
      }
    }, 10);
    return useResizeObserver$1(context2.viewport, handleResize), useResizeObserver$1(context2.content, handleResize), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto";
const ScrollAreaScrollbarHover = forwardRef(
  (props, ref) => {
    const { forceMount, ...scrollbarProps } = props, context2 = useScrollAreaContext(), [visible2, setVisible] = useState(!1);
    return useEffect(() => {
      const { scrollArea: scrollArea2 } = context2;
      let hideTimer = 0;
      if (scrollArea2) {
        const handlePointerEnter = () => {
          window.clearTimeout(hideTimer), setVisible(!0);
        }, handlePointerLeave = () => {
          hideTimer = window.setTimeout(() => setVisible(!1), context2.scrollHideDelay);
        };
        return scrollArea2.addEventListener("pointerenter", handlePointerEnter), scrollArea2.addEventListener("pointerleave", handlePointerLeave), () => {
          window.clearTimeout(hideTimer), scrollArea2.removeEventListener("pointerenter", handlePointerEnter), scrollArea2.removeEventListener("pointerleave", handlePointerLeave);
        };
      }
    }, [context2.scrollArea, context2.scrollHideDelay]), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarAuto,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover";
const ScrollAreaScrollbarScroll = forwardRef(
  (props, red) => {
    const { forceMount, ...scrollbarProps } = props, context2 = useScrollAreaContext(), isHorizontal = props.orientation === "horizontal", [state, setState] = useState("hidden"), debounceScrollEnd = useDebouncedCallback$1(() => setState("idle"), 100);
    return useEffect(() => {
      if (state === "idle") {
        const hideTimer = window.setTimeout(() => setState("hidden"), context2.scrollHideDelay);
        return () => window.clearTimeout(hideTimer);
      }
    }, [state, context2.scrollHideDelay]), useEffect(() => {
      const { viewport } = context2, scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
      if (viewport) {
        let prevScrollPos = viewport[scrollDirection];
        const handleScroll2 = () => {
          const scrollPos = viewport[scrollDirection];
          prevScrollPos !== scrollPos && (setState("scrolling"), debounceScrollEnd()), prevScrollPos = scrollPos;
        };
        return viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [context2.viewport, isHorizontal, debounceScrollEnd]), forceMount || state !== "hidden" ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": state === "hidden" ? "hidden" : "visible",
        ...scrollbarProps,
        ref: red,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState("interacting")),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState("idle"))
      }
    ) : null;
  }
), ScrollAreaScrollbar = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props, context2 = useScrollAreaContext(), { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context2, isHorizontal = props.orientation === "horizontal";
    return useEffect(() => (isHorizontal ? onScrollbarXEnabledChange(!0) : onScrollbarYEnabledChange(!0), () => {
      isHorizontal ? onScrollbarXEnabledChange(!1) : onScrollbarYEnabledChange(!1);
    }), [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]), context2.type === "hover" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context2.type === "scroll" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context2.type === "auto" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context2.type === "always" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar";
function addUnlinkedScrollListener(node2, handler = () => {
}) {
  let prevPosition = { left: node2.scrollLeft, top: node2.scrollTop }, rAF = 0;
  return function loop() {
    const position = { left: node2.scrollLeft, top: node2.scrollTop }, isHorizontalScroll = prevPosition.left !== position.left, isVerticalScroll = prevPosition.top !== position.top;
    (isHorizontalScroll || isVerticalScroll) && handler(), prevPosition = position, rAF = window.requestAnimationFrame(loop);
  }(), () => window.cancelAnimationFrame(rAF);
}
const Thumb$1 = forwardRef((props, forwardedRef) => {
  const { style: style2, ...others } = props, scrollAreaContext = useScrollAreaContext(), scrollbarContext = useScrollbarContext(), { onThumbPositionChange } = scrollbarContext, composedRef = useMergedRef(forwardedRef, (node2) => scrollbarContext.onThumbChange(node2)), removeUnlinkedScrollListenerRef = useRef(void 0), debounceScrollEnd = useDebouncedCallback$1(() => {
    removeUnlinkedScrollListenerRef.current && (removeUnlinkedScrollListenerRef.current(), removeUnlinkedScrollListenerRef.current = void 0);
  }, 100);
  return useEffect(() => {
    const { viewport } = scrollAreaContext;
    if (viewport) {
      const handleScroll2 = () => {
        if (debounceScrollEnd(), !removeUnlinkedScrollListenerRef.current) {
          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
          removeUnlinkedScrollListenerRef.current = listener, onThumbPositionChange();
        }
      };
      return onThumbPositionChange(), viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]), /* @__PURE__ */ jsx(
    "div",
    {
      "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
      ...others,
      ref: composedRef,
      style: {
        width: "var(--sa-thumb-width)",
        height: "var(--sa-thumb-height)",
        ...style2
      },
      onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
        const thumbRect = event.target.getBoundingClientRect(), x2 = event.clientX - thumbRect.left, y2 = event.clientY - thumbRect.top;
        scrollbarContext.onThumbPointerDown({ x: x2, y: y2 });
      }),
      onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
    }
  );
});
Thumb$1.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaThumb = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props, scrollbarContext = useScrollbarContext();
    return forceMount || scrollbarContext.hasThumb ? /* @__PURE__ */ jsx(Thumb$1, { ref: forwardedRef, ...thumbProps }) : null;
  }
);
ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaViewport = forwardRef(
  ({ children: children2, style: style2, ...others }, ref) => {
    const ctx = useScrollAreaContext(), rootRef = useMergedRef(ref, ctx.onViewportChange);
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        ...others,
        ref: rootRef,
        style: {
          overflowX: ctx.scrollbarXEnabled ? "scroll" : "hidden",
          overflowY: ctx.scrollbarYEnabled ? "scroll" : "hidden",
          ...style2
        },
        children: /* @__PURE__ */ jsx("div", { style: { minWidth: "100%", display: "table" }, ref: ctx.onContentChange, children: children2 })
      }
    );
  }
);
ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport";
var classes$I = { root: "m_d57069b5", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268" };
const defaultProps$1y = {
  scrollHideDelay: 1e3,
  type: "hover",
  scrollbars: "xy"
}, varsResolver$L = (_, { scrollbarSize, overscrollBehavior }) => ({
  root: {
    "--scrollarea-scrollbar-size": rem(scrollbarSize),
    "--scrollarea-over-scroll-behavior": overscrollBehavior
  }
}), ScrollArea = factory((_props, ref) => {
  const props = useProps("ScrollArea", defaultProps$1y, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    scrollbarSize,
    vars,
    type,
    scrollHideDelay,
    viewportProps,
    viewportRef,
    onScrollPositionChange,
    children: children2,
    offsetScrollbars,
    scrollbars,
    onBottomReached,
    onTopReached,
    overscrollBehavior,
    ...others
  } = props, [scrollbarHovered, setScrollbarHovered] = useState(!1), [verticalThumbVisible, setVerticalThumbVisible] = useState(!1), [horizontalThumbVisible, setHorizontalThumbVisible] = useState(!1), getStyles2 = useStyles({
    name: "ScrollArea",
    props,
    classes: classes$I,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$L
  }), localViewportRef = useRef(null), combinedViewportRef = useMergeRefs([viewportRef, localViewportRef]);
  return useEffect(() => {
    if (!localViewportRef.current || offsetScrollbars !== "present")
      return;
    const element = localViewportRef.current, observer = new ResizeObserver(() => {
      const { scrollHeight, clientHeight, scrollWidth, clientWidth } = element;
      setVerticalThumbVisible(scrollHeight > clientHeight), setHorizontalThumbVisible(scrollWidth > clientWidth);
    });
    return observer.observe(element), () => observer.disconnect();
  }, [localViewportRef, offsetScrollbars]), /* @__PURE__ */ jsxs(
    ScrollAreaRoot,
    {
      type: type === "never" ? "always" : type,
      scrollHideDelay,
      ref,
      scrollbars,
      ...getStyles2("root"),
      ...others,
      children: [
        /* @__PURE__ */ jsx(
          ScrollAreaViewport,
          {
            ...viewportProps,
            ...getStyles2("viewport", { style: viewportProps?.style }),
            ref: combinedViewportRef,
            "data-offset-scrollbars": offsetScrollbars === !0 ? "xy" : offsetScrollbars || void 0,
            "data-scrollbars": scrollbars || void 0,
            "data-horizontal-hidden": offsetScrollbars === "present" && !horizontalThumbVisible ? "true" : void 0,
            "data-vertical-hidden": offsetScrollbars === "present" && !verticalThumbVisible ? "true" : void 0,
            onScroll: (e2) => {
              viewportProps?.onScroll?.(e2), onScrollPositionChange?.({ x: e2.currentTarget.scrollLeft, y: e2.currentTarget.scrollTop });
              const { scrollTop, scrollHeight, clientHeight } = e2.currentTarget;
              scrollTop - (scrollHeight - clientHeight) >= 0 && onBottomReached?.(), scrollTop === 0 && onTopReached?.();
            },
            children: children2
          }
        ),
        (scrollbars === "xy" || scrollbars === "x") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "horizontal",
            "data-hidden": type === "never" || offsetScrollbars === "present" && !horizontalThumbVisible ? !0 : void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        (scrollbars === "xy" || scrollbars === "y") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "vertical",
            "data-hidden": type === "never" || offsetScrollbars === "present" && !verticalThumbVisible ? !0 : void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        /* @__PURE__ */ jsx(
          ScrollAreaCorner,
          {
            ...getStyles2("corner"),
            "data-hovered": scrollbarHovered || void 0,
            "data-hidden": type === "never" || void 0
          }
        )
      ]
    }
  );
});
ScrollArea.displayName = "@mantine/core/ScrollArea";
const ScrollAreaAutosize = factory((props, ref) => {
  const {
    children: children2,
    classNames,
    styles,
    scrollbarSize,
    scrollHideDelay,
    type,
    dir,
    offsetScrollbars,
    viewportRef,
    onScrollPositionChange,
    unstyled,
    variant,
    viewportProps,
    scrollbars,
    style: style2,
    vars,
    onBottomReached,
    onTopReached,
    ...others
  } = useProps("ScrollAreaAutosize", defaultProps$1y, props);
  return /* @__PURE__ */ jsx(Box$1, { ...others, ref, style: [{ display: "flex", overflow: "auto" }, style2], children: /* @__PURE__ */ jsx(Box$1, { style: { display: "flex", flexDirection: "column", flex: 1 }, children: /* @__PURE__ */ jsx(
    ScrollArea,
    {
      classNames,
      styles,
      scrollHideDelay,
      scrollbarSize,
      type,
      dir,
      offsetScrollbars,
      viewportRef,
      onScrollPositionChange,
      unstyled,
      variant,
      viewportProps,
      vars,
      scrollbars,
      onBottomReached,
      onTopReached,
      children: children2
    }
  ) }) });
});
ScrollArea.classes = classes$I;
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
ScrollAreaAutosize.classes = classes$I;
ScrollArea.Autosize = ScrollAreaAutosize;
var classes$H = { root: "m_87cf2631" };
const defaultProps$1x = {
  __staticSelector: "UnstyledButton"
}, UnstyledButton = polymorphicFactory(
  (_props, ref) => {
    const props = useProps("UnstyledButton", defaultProps$1x, _props), {
      className,
      component = "button",
      __staticSelector,
      unstyled,
      classNames,
      styles,
      style: style2,
      ...others
    } = props, getStyles2 = useStyles({
      name: __staticSelector,
      props,
      classes: classes$H,
      className,
      style: style2,
      classNames,
      styles,
      unstyled
    });
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        ...getStyles2("root", { focusable: !0 }),
        component,
        ref,
        type: component === "button" ? "button" : void 0,
        ...others
      }
    );
  }
);
UnstyledButton.classes = classes$H;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";
var classes$G = { root: "m_515a97f8" };
const defaultProps$1w = {}, VisuallyHidden = factory((_props, ref) => {
  const props = useProps("VisuallyHidden", defaultProps$1w, _props), { classNames, className, style: style2, styles, unstyled, vars, ...others } = props, getStyles2 = useStyles({
    name: "VisuallyHidden",
    classes: classes$G,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled
  });
  return /* @__PURE__ */ jsx(Box$1, { component: "span", ref, ...getStyles2("root"), ...others });
});
VisuallyHidden.classes = classes$G;
VisuallyHidden.displayName = "@mantine/core/VisuallyHidden";
var classes$F = { root: "m_1b7284a3" };
const defaultProps$1v = {}, varsResolver$K = (_, { radius, shadow }) => ({
  root: {
    "--paper-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--paper-shadow": getShadow(shadow)
  }
}), Paper = polymorphicFactory((_props, ref) => {
  const props = useProps("Paper", defaultProps$1v, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    withBorder,
    vars,
    radius,
    shadow,
    variant,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Paper",
    props,
    classes: classes$F,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$K
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      mod: [{ "data-with-border": withBorder }, mod],
      ...getStyles2("root"),
      variant,
      ...others
    }
  );
});
Paper.classes = classes$F;
Paper.displayName = "@mantine/core/Paper";
function getFloatingPosition(dir, position) {
  if (dir === "rtl" && (position.includes("right") || position.includes("left"))) {
    const [side, placement] = position.split("-"), flippedPosition = side === "right" ? "left" : "right";
    return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;
  }
  return position;
}
function horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {
  return placement === "center" || arrowPosition === "center" ? { top: arrowY } : placement === "end" ? { bottom: arrowOffset } : placement === "start" ? { top: arrowOffset } : {};
}
function verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {
  return placement === "center" || arrowPosition === "center" ? { left: arrowX } : placement === "end" ? { [dir === "ltr" ? "right" : "left"]: arrowOffset } : placement === "start" ? { [dir === "ltr" ? "left" : "right"]: arrowOffset } : {};
}
const radiusByFloatingSide = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function getArrowPositionStyles({
  position,
  arrowSize,
  arrowOffset,
  arrowRadius,
  arrowPosition,
  arrowX,
  arrowY,
  dir
}) {
  const [side, placement = "center"] = position.split("-"), baseStyles = {
    width: arrowSize,
    height: arrowSize,
    transform: "rotate(45deg)",
    position: "absolute",
    [radiusByFloatingSide[side]]: arrowRadius
  }, arrowPlacement = -arrowSize / 2;
  return side === "left" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    right: arrowPlacement,
    borderLeftColor: "transparent",
    borderBottomColor: "transparent",
    clipPath: "polygon(100% 0, 0 0, 100% 100%)"
  } : side === "right" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    left: arrowPlacement,
    borderRightColor: "transparent",
    borderTopColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 100%)"
  } : side === "top" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    bottom: arrowPlacement,
    borderTopColor: "transparent",
    borderLeftColor: "transparent",
    clipPath: "polygon(0 100%, 100% 100%, 100% 0)"
  } : side === "bottom" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    top: arrowPlacement,
    borderBottomColor: "transparent",
    borderRightColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 0)"
  } : {};
}
const FloatingArrow = forwardRef(
  ({
    position,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    visible: visible2,
    arrowX,
    arrowY,
    style: style2,
    ...others
  }, ref) => {
    const { dir } = useDirection();
    return visible2 ? /* @__PURE__ */ jsx(
      "div",
      {
        ...others,
        ref,
        style: {
          ...style2,
          ...getArrowPositionStyles({
            position,
            arrowSize,
            arrowOffset,
            arrowRadius,
            arrowPosition,
            dir,
            arrowX,
            arrowY
          })
        }
      }
    ) : null;
  }
);
FloatingArrow.displayName = "@mantine/core/FloatingArrow";
var classes$E = { root: "m_9814e45f" };
const defaultProps$1u = {
  zIndex: getDefaultZIndex("modal")
}, varsResolver$J = (_, { gradient, color: color2, backgroundOpacity, blur, radius, zIndex }) => ({
  root: {
    "--overlay-bg": gradient || (color2 !== void 0 || backgroundOpacity !== void 0) && rgba$2(color2 || "#000", backgroundOpacity ?? 0.6) || void 0,
    "--overlay-filter": blur ? `blur(${rem(blur)})` : void 0,
    "--overlay-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--overlay-z-index": zIndex?.toString()
  }
}), Overlay$1 = polymorphicFactory((_props, ref) => {
  const props = useProps("Overlay", defaultProps$1u, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    fixed,
    center,
    children: children2,
    radius,
    zIndex,
    gradient,
    blur,
    color: color2,
    backgroundOpacity,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Overlay",
    props,
    classes: classes$E,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$J
  });
  return /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root"), mod: [{ center, fixed }, mod], ...others, children: children2 });
});
Overlay$1.classes = classes$E;
Overlay$1.displayName = "@mantine/core/Overlay";
function createPortalNode(props) {
  const node2 = document.createElement("div");
  return node2.setAttribute("data-portal", "true"), typeof props.className == "string" && node2.classList.add(...props.className.split(" ").filter(Boolean)), typeof props.style == "object" && Object.assign(node2.style, props.style), typeof props.id == "string" && node2.setAttribute("id", props.id), node2;
}
function getTargetNode({
  target,
  reuseTargetNode,
  ...others
}) {
  if (target)
    return typeof target == "string" ? document.querySelector(target) || createPortalNode(others) : target;
  if (reuseTargetNode) {
    const existingNode = document.querySelector("[data-mantine-shared-portal-node]");
    if (existingNode)
      return existingNode;
    const node2 = createPortalNode(others);
    return node2.setAttribute("data-mantine-shared-portal-node", "true"), document.body.appendChild(node2), node2;
  }
  return createPortalNode(others);
}
const defaultProps$1t = {}, Portal = factory((props, ref) => {
  const { children: children2, target, reuseTargetNode, ...others } = useProps("Portal", defaultProps$1t, props), [mounted, setMounted] = useState(!1), nodeRef2 = useRef(null);
  return useIsomorphicEffect(() => (setMounted(!0), nodeRef2.current = getTargetNode({ target, reuseTargetNode, ...others }), assignRef(ref, nodeRef2.current), !target && !reuseTargetNode && nodeRef2.current && document.body.appendChild(nodeRef2.current), () => {
    !target && !reuseTargetNode && nodeRef2.current && document.body.removeChild(nodeRef2.current);
  }), [target]), !mounted || !nodeRef2.current ? null : createPortal(/* @__PURE__ */ jsx(Fragment$1, { children: children2 }), nodeRef2.current);
});
Portal.displayName = "@mantine/core/Portal";
const OptionalPortal = factory(
  ({ withinPortal = !0, children: children2, ...others }, ref) => useMantineEnv() === "test" || !withinPortal ? /* @__PURE__ */ jsx(Fragment$1, { children: children2 }) : /* @__PURE__ */ jsx(Portal, { ref, ...others, children: children2 })
);
OptionalPortal.displayName = "@mantine/core/OptionalPortal";
const popIn = (from) => ({
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: `scale(.9) translateY(${from === "bottom" ? 10 : -10}px)` },
  transitionProperty: "transform, opacity"
}), transitions$1 = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  "fade-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-30px)" },
    transitionProperty: "opacity, transform"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: {
    ...popIn("bottom"),
    common: { transformOrigin: "center center" }
  },
  "pop-bottom-left": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom left" }
  },
  "pop-bottom-right": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom right" }
  },
  "pop-top-left": {
    ...popIn("top"),
    common: { transformOrigin: "top left" }
  },
  "pop-top-right": {
    ...popIn("top"),
    common: { transformOrigin: "top right" }
  }
}, transitionStatuses = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function getTransitionStyles({
  transition,
  state,
  duration,
  timingFunction
}) {
  const shared = {
    WebkitBackfaceVisibility: "hidden",
    willChange: "transform, opacity",
    transitionDuration: `${duration}ms`,
    transitionTimingFunction: timingFunction
  };
  return typeof transition == "string" ? transition in transitions$1 ? {
    transitionProperty: transitions$1[transition].transitionProperty,
    ...shared,
    ...transitions$1[transition].common,
    ...transitions$1[transition][transitionStatuses[state]]
  } : {} : {
    transitionProperty: transition.transitionProperty,
    ...shared,
    ...transition.common,
    ...transition[transitionStatuses[state]]
  };
}
function useTransition({
  duration,
  exitDuration,
  timingFunction,
  mounted,
  onEnter,
  onExit,
  onEntered,
  onExited,
  enterDelay,
  exitDelay
}) {
  const theme2 = useMantineTheme(), shouldReduceMotion = useReducedMotion$1(), reduceMotion = theme2.respectReducedMotion ? shouldReduceMotion : !1, [transitionDuration, setTransitionDuration] = useState(reduceMotion ? 0 : duration), [transitionStatus, setStatus] = useState(mounted ? "entered" : "exited"), transitionTimeoutRef = useRef(-1), delayTimeoutRef = useRef(-1), rafRef = useRef(-1), handleStateChange = (shouldMount) => {
    const preHandler = shouldMount ? onEnter : onExit, handler = shouldMount ? onEntered : onExited;
    window.clearTimeout(transitionTimeoutRef.current);
    const newTransitionDuration = reduceMotion ? 0 : shouldMount ? duration : exitDuration;
    setTransitionDuration(newTransitionDuration), newTransitionDuration === 0 ? (typeof preHandler == "function" && preHandler(), typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited")) : rafRef.current = requestAnimationFrame(() => {
      ReactDOM__default.flushSync(() => {
        setStatus(shouldMount ? "pre-entering" : "pre-exiting");
      }), rafRef.current = requestAnimationFrame(() => {
        typeof preHandler == "function" && preHandler(), setStatus(shouldMount ? "entering" : "exiting"), transitionTimeoutRef.current = window.setTimeout(() => {
          typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited");
        }, newTransitionDuration);
      });
    });
  }, handleTransitionWithDelay = (shouldMount) => {
    if (window.clearTimeout(delayTimeoutRef.current), typeof (shouldMount ? enterDelay : exitDelay) != "number") {
      handleStateChange(shouldMount);
      return;
    }
    delayTimeoutRef.current = window.setTimeout(
      () => {
        handleStateChange(shouldMount);
      },
      shouldMount ? enterDelay : exitDelay
    );
  };
  return useDidUpdate(() => {
    handleTransitionWithDelay(mounted);
  }, [mounted]), useEffect(
    () => () => {
      window.clearTimeout(transitionTimeoutRef.current), cancelAnimationFrame(rafRef.current);
    },
    []
  ), {
    transitionDuration,
    transitionStatus,
    transitionTimingFunction: timingFunction || "ease"
  };
}
function Transition$1({
  keepMounted,
  transition = "fade",
  duration = 250,
  exitDuration = duration,
  mounted,
  children: children2,
  timingFunction = "ease",
  onExit,
  onEntered,
  onEnter,
  onExited,
  enterDelay,
  exitDelay
}) {
  const env = useMantineEnv(), { transitionDuration, transitionStatus, transitionTimingFunction } = useTransition({
    mounted,
    exitDuration,
    duration,
    timingFunction,
    onExit,
    onEntered,
    onEnter,
    onExited,
    enterDelay,
    exitDelay
  });
  return transitionDuration === 0 || env === "test" ? mounted ? /* @__PURE__ */ jsx(Fragment$1, { children: children2({}) }) : keepMounted ? children2({ display: "none" }) : null : transitionStatus === "exited" ? keepMounted ? children2({ display: "none" }) : null : /* @__PURE__ */ jsx(Fragment$1, { children: children2(
    getTransitionStyles({
      transition,
      duration: transitionDuration,
      state: transitionStatus,
      timingFunction: transitionTimingFunction
    })
  ) });
}
Transition$1.displayName = "@mantine/core/Transition";
const [PopoverContextProvider, usePopoverContext] = createSafeContext(
  "Popover component was not found in the tree"
);
function FocusTrap({
  children: children2,
  active = !0,
  refProp = "ref",
  innerRef
}) {
  const focusTrapRef = useFocusTrap(active), ref = useMergedRef(focusTrapRef, innerRef);
  return isElement$1(children2) ? cloneElement(children2, { [refProp]: ref }) : children2;
}
function FocusTrapInitialFocus(props) {
  return /* @__PURE__ */ jsx(VisuallyHidden, { tabIndex: -1, "data-autofocus": !0, ...props });
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus";
FocusTrap.InitialFocus = FocusTrapInitialFocus;
var classes$D = { dropdown: "m_38a85659", arrow: "m_a31dc6c1", overlay: "m_3d7bc908" };
const defaultProps$1s = {}, PopoverDropdown = factory((_props, ref) => {
  const props = useProps("PopoverDropdown", defaultProps$1s, _props), {
    className,
    style: style2,
    vars,
    children: children2,
    onKeyDownCapture,
    variant,
    classNames,
    styles,
    ...others
  } = props, ctx = usePopoverContext(), returnFocus = useFocusReturn({
    opened: ctx.opened,
    shouldReturnFocus: ctx.returnFocus
  }), accessibleProps = ctx.withRoles ? {
    "aria-labelledby": ctx.getTargetId(),
    id: ctx.getDropdownId(),
    role: "dialog",
    tabIndex: -1
  } : {}, mergedRef = useMergedRef(ref, ctx.floating);
  return ctx.disabled ? null : /* @__PURE__ */ jsx(OptionalPortal, { ...ctx.portalProps, withinPortal: ctx.withinPortal, children: /* @__PURE__ */ jsx(
    Transition$1,
    {
      mounted: ctx.opened,
      ...ctx.transitionProps,
      transition: ctx.transitionProps?.transition || "fade",
      duration: ctx.transitionProps?.duration ?? 150,
      keepMounted: ctx.keepMounted,
      exitDuration: typeof ctx.transitionProps?.exitDuration == "number" ? ctx.transitionProps.exitDuration : ctx.transitionProps?.duration,
      children: (transitionStyles) => /* @__PURE__ */ jsx(FocusTrap, { active: ctx.trapFocus && ctx.opened, innerRef: mergedRef, children: /* @__PURE__ */ jsxs(
        Box$1,
        {
          ...accessibleProps,
          ...others,
          variant,
          onKeyDownCapture: closeOnEscape(
            () => {
              ctx.onClose?.(), ctx.onDismiss?.();
            },
            {
              active: ctx.closeOnEscape,
              onTrigger: returnFocus,
              onKeyDown: onKeyDownCapture
            }
          ),
          "data-position": ctx.placement,
          "data-fixed": ctx.floatingStrategy === "fixed" || void 0,
          ...ctx.getStyles("dropdown", {
            className,
            props,
            classNames,
            styles,
            style: [
              {
                ...transitionStyles,
                zIndex: ctx.zIndex,
                top: ctx.y ?? 0,
                left: ctx.x ?? 0,
                width: ctx.width === "target" ? void 0 : rem(ctx.width)
              },
              ctx.resolvedStyles.dropdown,
              styles?.dropdown,
              style2
            ]
          }),
          children: [
            children2,
            /* @__PURE__ */ jsx(
              FloatingArrow,
              {
                ref: ctx.arrowRef,
                arrowX: ctx.arrowX,
                arrowY: ctx.arrowY,
                visible: ctx.withArrow,
                position: ctx.placement,
                arrowSize: ctx.arrowSize,
                arrowRadius: ctx.arrowRadius,
                arrowOffset: ctx.arrowOffset,
                arrowPosition: ctx.arrowPosition,
                ...ctx.getStyles("arrow", {
                  props,
                  classNames,
                  styles
                })
              }
            )
          ]
        }
      ) })
    }
  ) });
});
PopoverDropdown.classes = classes$D;
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";
const defaultProps$1r = {
  refProp: "ref",
  popupType: "dialog"
}, PopoverTarget = factory((props, ref) => {
  const { children: children2, refProp, popupType, ...others } = useProps(
    "PopoverTarget",
    defaultProps$1r,
    props
  );
  if (!isElement$1(children2))
    throw new Error(
      "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const forwardedProps = others, ctx = usePopoverContext(), targetRef = useMergedRef(ctx.reference, getRefProp(children2), ref), accessibleProps = ctx.withRoles ? {
    "aria-haspopup": popupType,
    "aria-expanded": ctx.opened,
    "aria-controls": ctx.getDropdownId(),
    id: ctx.getTargetId()
  } : {};
  return cloneElement(children2, {
    ...forwardedProps,
    ...accessibleProps,
    ...ctx.targetProps,
    className: clsx(
      ctx.targetProps.className,
      forwardedProps.className,
      children2.props.className
    ),
    [refProp]: targetRef,
    ...ctx.controlled ? null : { onClick: ctx.onToggle }
  });
});
PopoverTarget.displayName = "@mantine/core/PopoverTarget";
function useFloatingAutoUpdate({
  opened,
  floating,
  position,
  positionDependencies
}) {
  const [delayedUpdate, setDelayedUpdate] = useState(0);
  useEffect(() => {
    if (floating.refs.reference.current && floating.refs.floating.current && opened)
      return autoUpdate(
        floating.refs.reference.current,
        floating.refs.floating.current,
        floating.update
      );
  }, [
    floating.refs.reference.current,
    floating.refs.floating.current,
    opened,
    delayedUpdate,
    position
  ]), useDidUpdate(() => {
    floating.update();
  }, positionDependencies), useDidUpdate(() => {
    setDelayedUpdate((c2) => c2 + 1);
  }, [opened]);
}
function getDefaultMiddlewares$1(middlewares) {
  if (middlewares === void 0)
    return { shift: !0, flip: !0 };
  const result = { ...middlewares };
  return middlewares.shift === void 0 && (result.shift = !0), middlewares.flip === void 0 && (result.flip = !0), result;
}
function getPopoverMiddlewares(options, getFloating) {
  const middlewaresOptions = getDefaultMiddlewares$1(options.middlewares), middlewares = [offset$1(options.offset)];
  return middlewaresOptions.shift && middlewares.push(
    shift(
      typeof middlewaresOptions.shift == "boolean" ? { limiter: limitShift(), padding: 5 } : { limiter: limitShift(), padding: 5, ...middlewaresOptions.shift }
    )
  ), middlewaresOptions.flip && middlewares.push(
    typeof middlewaresOptions.flip == "boolean" ? flip() : flip(middlewaresOptions.flip)
  ), middlewaresOptions.inline && middlewares.push(
    typeof middlewaresOptions.inline == "boolean" ? inline() : inline(middlewaresOptions.inline)
  ), middlewares.push(arrow({ element: options.arrowRef, padding: options.arrowOffset })), (middlewaresOptions.size || options.width === "target") && middlewares.push(
    size({
      ...typeof middlewaresOptions.size == "boolean" ? {} : middlewaresOptions.size,
      apply({ rects, availableWidth, availableHeight, ...rest }) {
        const styles = getFloating().refs.floating.current?.style ?? {};
        middlewaresOptions.size && (typeof middlewaresOptions.size == "object" && middlewaresOptions.size.apply ? middlewaresOptions.size.apply({ rects, availableWidth, availableHeight, ...rest }) : Object.assign(styles, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        })), options.width === "target" && Object.assign(styles, {
          width: `${rects.reference.width}px`
        });
      }
    })
  ), middlewares;
}
function usePopover(options) {
  const [_opened, setOpened] = useUncontrolled({
    value: options.opened,
    defaultValue: options.defaultOpened,
    finalValue: !1,
    onChange: options.onChange
  }), previouslyOpened = useRef(_opened), onClose = () => {
    _opened && setOpened(!1);
  }, onToggle = () => setOpened(!_opened), floating = useFloating({
    strategy: options.strategy,
    placement: options.position,
    middleware: getPopoverMiddlewares(options, () => floating)
  });
  return useFloatingAutoUpdate({
    opened: _opened,
    position: options.position,
    positionDependencies: options.positionDependencies || [],
    floating
  }), useDidUpdate(() => {
    options.onPositionChange?.(floating.placement);
  }, [floating.placement]), useDidUpdate(() => {
    _opened !== previouslyOpened.current && (_opened ? options.onOpen?.() : options.onClose?.()), previouslyOpened.current = _opened;
  }, [_opened, options.onClose, options.onOpen]), {
    floating,
    controlled: typeof options.opened == "boolean",
    opened: _opened,
    onClose,
    onToggle
  };
}
const defaultProps$1q = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transitionProps: { transition: "fade", duration: 150 },
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !0,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  withOverlay: !1,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: getDefaultZIndex("popover"),
  __staticSelector: "Popover",
  width: "max-content"
}, varsResolver$I = (_, { radius, shadow }) => ({
  dropdown: {
    "--popover-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--popover-shadow": getShadow(shadow)
  }
});
function Popover(_props) {
  const props = useProps("Popover", defaultProps$1q, _props), {
    children: children2,
    position,
    offset: offset2,
    onPositionChange,
    positionDependencies,
    opened,
    transitionProps,
    onExitTransitionEnd,
    onEnterTransitionEnd,
    width,
    middlewares,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    unstyled,
    classNames,
    styles,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    closeOnEscape: closeOnEscape2,
    clickOutsideEvents,
    trapFocus,
    onClose,
    onDismiss,
    onOpen,
    onChange,
    zIndex,
    radius,
    shadow,
    id: id2,
    defaultOpened,
    __staticSelector,
    withRoles,
    disabled,
    returnFocus,
    variant,
    keepMounted,
    vars,
    floatingStrategy,
    withOverlay,
    overlayProps,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    props,
    classes: classes$D,
    classNames,
    styles,
    unstyled,
    rootSelector: "dropdown",
    vars,
    varsResolver: varsResolver$I
  }), { resolvedStyles } = useResolvedStylesApi({ classNames, styles, props }), arrowRef = useRef(null), [targetNode, setTargetNode] = useState(null), [dropdownNode, setDropdownNode] = useState(null), { dir } = useDirection(), uid = useId$1(id2), popover = usePopover({
    middlewares,
    width,
    position: getFloatingPosition(dir, position),
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    arrowRef,
    arrowOffset,
    onPositionChange,
    positionDependencies,
    opened,
    defaultOpened,
    onChange,
    onOpen,
    onClose,
    onDismiss,
    strategy: floatingStrategy
  });
  useClickOutside(
    () => {
      closeOnClickOutside && (popover.onClose(), onDismiss?.());
    },
    clickOutsideEvents,
    [targetNode, dropdownNode]
  );
  const reference = useCallback(
    (node2) => {
      setTargetNode(node2), popover.floating.refs.setReference(node2);
    },
    [popover.floating.refs.setReference]
  ), floating = useCallback(
    (node2) => {
      setDropdownNode(node2), popover.floating.refs.setFloating(node2);
    },
    [popover.floating.refs.setFloating]
  ), onExited = useCallback(() => {
    transitionProps?.onExited?.(), onExitTransitionEnd?.();
  }, [transitionProps?.onExited, onExitTransitionEnd]), onEntered = useCallback(() => {
    transitionProps?.onEntered?.(), onEnterTransitionEnd?.();
  }, [transitionProps?.onEntered, onEnterTransitionEnd]);
  return /* @__PURE__ */ jsxs(
    PopoverContextProvider,
    {
      value: {
        returnFocus,
        disabled,
        controlled: popover.controlled,
        reference,
        floating,
        x: popover.floating.x,
        y: popover.floating.y,
        arrowX: popover.floating?.middlewareData?.arrow?.x,
        arrowY: popover.floating?.middlewareData?.arrow?.y,
        opened: popover.opened,
        arrowRef,
        transitionProps: { ...transitionProps, onExited, onEntered },
        width,
        withArrow,
        arrowSize,
        arrowOffset,
        arrowRadius,
        arrowPosition,
        placement: popover.floating.placement,
        trapFocus,
        withinPortal,
        portalProps,
        zIndex,
        radius,
        shadow,
        closeOnEscape: closeOnEscape2,
        onDismiss,
        onClose: popover.onClose,
        onToggle: popover.onToggle,
        getTargetId: () => `${uid}-target`,
        getDropdownId: () => `${uid}-dropdown`,
        withRoles,
        targetProps: others,
        __staticSelector,
        classNames,
        styles,
        unstyled,
        variant,
        keepMounted,
        getStyles: getStyles2,
        resolvedStyles,
        floatingStrategy
      },
      children: [
        children2,
        withOverlay && /* @__PURE__ */ jsx(
          Transition$1,
          {
            transition: "fade",
            mounted: popover.opened,
            duration: transitionProps?.duration || 250,
            exitDuration: transitionProps?.exitDuration || 250,
            children: (transitionStyles) => /* @__PURE__ */ jsx(OptionalPortal, { withinPortal, children: /* @__PURE__ */ jsx(
              Overlay$1,
              {
                ...overlayProps,
                ...getStyles2("overlay", {
                  className: overlayProps?.className,
                  style: [transitionStyles, overlayProps?.style]
                })
              }
            ) })
          }
        )
      ]
    }
  );
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
Popover.extend = (input2) => input2;
var classes$C = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" };
const Bars = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box$1, { component: "span", className: clsx(classes$C.barsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$C.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$C.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$C.bar })
] }));
Bars.displayName = "@mantine/core/Bars";
const Dots = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box$1, { component: "span", className: clsx(classes$C.dotsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$C.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$C.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$C.dot })
] }));
Dots.displayName = "@mantine/core/Dots";
const Oval = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsx(Box$1, { component: "span", className: clsx(classes$C.ovalLoader, className), ...others, ref }));
Oval.displayName = "@mantine/core/Oval";
const defaultLoaders = {
  bars: Bars,
  oval: Oval,
  dots: Dots
}, defaultProps$1p = {
  loaders: defaultLoaders,
  type: "oval"
}, varsResolver$H = (theme2, { size: size2, color: color2 }) => ({
  root: {
    "--loader-size": getSize(size2, "loader-size"),
    "--loader-color": color2 ? getThemeColor(color2, theme2) : void 0
  }
}), Loader = factory((_props, ref) => {
  const props = useProps("Loader", defaultProps$1p, _props), {
    size: size2,
    color: color2,
    type,
    vars,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    loaders,
    variant,
    children: children2,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Loader",
    props,
    classes: classes$C,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$H
  });
  return children2 ? /* @__PURE__ */ jsx(Box$1, { ...getStyles2("root"), ref, ...others, children: children2 }) : /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("root"),
      ref,
      component: loaders[type],
      variant,
      size: size2,
      ...others
    }
  );
});
Loader.defaultLoaders = defaultLoaders;
Loader.classes = classes$C;
Loader.displayName = "@mantine/core/Loader";
var classes$B = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21", groupSection: "m_437b6484" };
const defaultProps$1o = {
  orientation: "horizontal"
}, varsResolver$G = (_, { borderWidth: borderWidth2 }) => ({
  group: { "--ai-border-width": rem(borderWidth2) }
}), ActionIconGroup = factory((_props, ref) => {
  const props = useProps("ActionIconGroup", defaultProps$1o, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth: borderWidth2,
    variant,
    mod,
    ...others
  } = useProps("ActionIconGroup", defaultProps$1o, _props), getStyles2 = useStyles({
    name: "ActionIconGroup",
    props,
    classes: classes$B,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$G,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ActionIconGroup.classes = classes$B;
ActionIconGroup.displayName = "@mantine/core/ActionIconGroup";
const defaultProps$1n = {}, varsResolver$F = (theme2, { radius, color: color2, gradient, variant, autoContrast, size: size2 }) => {
  const colors2 = theme2.variantColorResolver({
    color: color2 || theme2.primaryColor,
    theme: theme2,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    groupSection: {
      "--section-height": getSize(size2, "section-height"),
      "--section-padding-x": getSize(size2, "section-padding-x"),
      "--section-fz": getFontSize(size2),
      "--section-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--section-bg": color2 || variant ? colors2.background : void 0,
      "--section-color": colors2.color,
      "--section-bd": color2 || variant ? colors2.border : void 0
    }
  };
}, ActionIconGroupSection = factory((_props, ref) => {
  const props = useProps("ActionIconGroupSection", defaultProps$1n, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    variant,
    gradient,
    radius,
    autoContrast,
    ...others
  } = useProps("ActionIconGroupSection", defaultProps$1n, _props), getStyles2 = useStyles({
    name: "ActionIconGroupSection",
    props,
    classes: classes$B,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$F,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ jsx(Box$1, { ...getStyles2("groupSection"), ref, variant, ...others });
});
ActionIconGroupSection.classes = classes$B;
ActionIconGroupSection.displayName = "@mantine/core/ActionIconGroupSection";
const defaultProps$1m = {}, varsResolver$E = (theme2, { size: size2, radius, variant, gradient, color: color2, autoContrast }) => {
  const colors2 = theme2.variantColorResolver({
    color: color2 || theme2.primaryColor,
    theme: theme2,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ai-size": getSize(size2, "ai-size"),
      "--ai-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--ai-bg": color2 || variant ? colors2.background : void 0,
      "--ai-hover": color2 || variant ? colors2.hover : void 0,
      "--ai-hover-color": color2 || variant ? colors2.hoverColor : void 0,
      "--ai-color": colors2.color,
      "--ai-bd": color2 || variant ? colors2.border : void 0
    }
  };
}, ActionIcon$1 = polymorphicFactory((_props, ref) => {
  const props = useProps("ActionIcon", defaultProps$1m, _props), {
    className,
    unstyled,
    variant,
    classNames,
    styles,
    style: style2,
    loading,
    loaderProps,
    size: size2,
    color: color2,
    radius,
    __staticSelector,
    gradient,
    vars,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["ActionIcon", __staticSelector],
    props,
    className,
    style: style2,
    classes: classes$B,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$E
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      ...others,
      unstyled,
      variant,
      size: size2,
      disabled: disabled || loading,
      ref,
      mod: [{ loading, disabled: disabled || dataDisabled }, mod],
      children: [
        /* @__PURE__ */ jsx(Transition$1, { mounted: !!loading, transition: "slide-down", duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(Loader, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...loaderProps }) }) }),
        /* @__PURE__ */ jsx(Box$1, { component: "span", mod: { loading }, ...getStyles2("icon"), children: children2 })
      ]
    }
  );
});
ActionIcon$1.classes = classes$B;
ActionIcon$1.displayName = "@mantine/core/ActionIcon";
ActionIcon$1.Group = ActionIconGroup;
ActionIcon$1.GroupSection = ActionIconGroupSection;
const CloseIcon = forwardRef(
  ({ size: size2 = "var(--cb-icon-size, 70%)", style: style2, ...others }, ref) => /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...style2, width: size2, height: size2 },
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  )
);
CloseIcon.displayName = "@mantine/core/CloseIcon";
var classes$A = { root: "m_86a44da5", "root--subtle": "m_220c80f2" };
const defaultProps$1l = {
  variant: "subtle"
}, varsResolver$D = (_, { size: size2, radius, iconSize: iconSize2 }) => ({
  root: {
    "--cb-size": getSize(size2, "cb-size"),
    "--cb-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--cb-icon-size": rem(iconSize2)
  }
}), CloseButton = polymorphicFactory((_props, ref) => {
  const props = useProps("CloseButton", defaultProps$1l, _props), {
    iconSize: iconSize2,
    children: children2,
    vars,
    radius,
    className,
    classNames,
    style: style2,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    disabled,
    variant,
    icon: icon2,
    mod,
    __staticSelector,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector || "CloseButton",
    props,
    className,
    style: style2,
    classes: classes$A,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$D
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...others,
      unstyled,
      variant,
      disabled,
      mod: [{ disabled: disabled || dataDisabled }, mod],
      ...getStyles2("root", { variant, active: !disabled && !dataDisabled }),
      children: [
        icon2 || /* @__PURE__ */ jsx(CloseIcon, {}),
        children2
      ]
    }
  );
});
CloseButton.classes = classes$A;
CloseButton.displayName = "@mantine/core/CloseButton";
function filterFalsyChildren(children2) {
  return Children.toArray(children2).filter(Boolean);
}
var classes$z = { root: "m_4081bf90" };
const defaultProps$1k = {
  preventGrowOverflow: !0,
  gap: "md",
  align: "center",
  justify: "flex-start",
  wrap: "wrap"
}, varsResolver$C = (_, { grow, preventGrowOverflow, gap, align, justify, wrap: wrap2 }, { childWidth }) => ({
  root: {
    "--group-child-width": grow && preventGrowOverflow ? childWidth : void 0,
    "--group-gap": getSpacing(gap),
    "--group-align": align,
    "--group-justify": justify,
    "--group-wrap": wrap2
  }
}), Group = factory((_props, ref) => {
  const props = useProps("Group", defaultProps$1k, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    children: children2,
    gap,
    align,
    justify,
    wrap: wrap2,
    grow,
    preventGrowOverflow,
    vars,
    variant,
    __size,
    mod,
    ...others
  } = props, filteredChildren = filterFalsyChildren(children2), childrenCount = filteredChildren.length, resolvedGap = getSpacing(gap ?? "md"), stylesCtx = { childWidth: `calc(${100 / childrenCount}% - (${resolvedGap} - ${resolvedGap} / ${childrenCount}))` }, getStyles2 = useStyles({
    name: "Group",
    props,
    stylesCtx,
    className,
    style: style2,
    classes: classes$z,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$C
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("root"),
      ref,
      variant,
      mod: [{ grow }, mod],
      size: __size,
      ...others,
      children: filteredChildren
    }
  );
});
Group.classes = classes$z;
Group.displayName = "@mantine/core/Group";
const [ModalBaseProvider, useModalBaseContext] = createSafeContext(
  "ModalBase component was not found in tree"
);
function useLockScroll({ opened, transitionDuration }) {
  const [shouldLockScroll, setShouldLockScroll] = useState(opened), timeout2 = useRef(-1), _transitionDuration = useReducedMotion$1() ? 0 : transitionDuration;
  return useEffect(() => (opened ? (setShouldLockScroll(!0), window.clearTimeout(timeout2.current)) : _transitionDuration === 0 ? setShouldLockScroll(!1) : timeout2.current = window.setTimeout(() => setShouldLockScroll(!1), _transitionDuration), () => window.clearTimeout(timeout2.current)), [opened, _transitionDuration]), shouldLockScroll;
}
function useModal({
  id: id2,
  transitionProps,
  opened,
  trapFocus,
  closeOnEscape: closeOnEscape2,
  onClose,
  returnFocus
}) {
  const _id = useId$1(id2), [titleMounted, setTitleMounted] = useState(!1), [bodyMounted, setBodyMounted] = useState(!1), transitionDuration = typeof transitionProps?.duration == "number" ? transitionProps?.duration : 200, shouldLockScroll = useLockScroll({ opened, transitionDuration });
  return useWindowEvent(
    "keydown",
    (event) => {
      event.key === "Escape" && closeOnEscape2 && opened && event.target?.getAttribute("data-mantine-stop-propagation") !== "true" && onClose();
    },
    { capture: !0 }
  ), useFocusReturn({ opened, shouldReturnFocus: trapFocus && returnFocus }), {
    _id,
    titleMounted,
    bodyMounted,
    shouldLockScroll,
    setTitleMounted,
    setBodyMounted
  };
}
const ModalBase = forwardRef(
  ({
    keepMounted,
    opened,
    onClose,
    id: id2,
    transitionProps,
    onExitTransitionEnd,
    onEnterTransitionEnd,
    trapFocus,
    closeOnEscape: closeOnEscape2,
    returnFocus,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    lockScroll,
    children: children2,
    zIndex,
    shadow,
    padding,
    __vars,
    unstyled,
    removeScrollProps,
    ...others
  }, ref) => {
    const { _id, titleMounted, bodyMounted, shouldLockScroll, setTitleMounted, setBodyMounted } = useModal({ id: id2, transitionProps, opened, trapFocus, closeOnEscape: closeOnEscape2, onClose, returnFocus }), { key: removeScrollKey, ...otherRemoveScrollProps } = removeScrollProps || {};
    return /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      ModalBaseProvider,
      {
        value: {
          opened,
          onClose,
          closeOnClickOutside,
          onExitTransitionEnd,
          onEnterTransitionEnd,
          transitionProps: { ...transitionProps, keepMounted },
          getTitleId: () => `${_id}-title`,
          getBodyId: () => `${_id}-body`,
          titleMounted,
          bodyMounted,
          setTitleMounted,
          setBodyMounted,
          trapFocus,
          closeOnEscape: closeOnEscape2,
          zIndex,
          unstyled
        },
        children: /* @__PURE__ */ jsx(
          RemoveScroll,
          {
            enabled: shouldLockScroll && lockScroll,
            ...otherRemoveScrollProps,
            children: /* @__PURE__ */ jsx(
              Box$1,
              {
                ref,
                ...others,
                __vars: {
                  ...__vars,
                  "--mb-z-index": (zIndex || getDefaultZIndex("modal")).toString(),
                  "--mb-shadow": getShadow(shadow),
                  "--mb-padding": getSpacing(padding)
                },
                children: children2
              }
            )
          },
          removeScrollKey
        )
      }
    ) });
  }
);
ModalBase.displayName = "@mantine/core/ModalBase";
function useModalBodyId() {
  const ctx = useModalBaseContext();
  return useEffect(() => (ctx.setBodyMounted(!0), () => ctx.setBodyMounted(!1)), []), ctx.getBodyId();
}
var classes$y = { title: "m_615af6c9", header: "m_b5489c3c", inner: "m_60c222c7", content: "m_fd1ab0aa", close: "m_606cb269", body: "m_5df29311" };
const ModalBaseBody = forwardRef(
  ({ className, ...others }, ref) => {
    const bodyId = useModalBodyId(), ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        ref,
        ...others,
        id: bodyId,
        className: clsx({ [classes$y.body]: !ctx.unstyled }, className)
      }
    );
  }
);
ModalBaseBody.displayName = "@mantine/core/ModalBaseBody";
const ModalBaseCloseButton = forwardRef(
  ({ className, onClick, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      CloseButton,
      {
        ref,
        ...others,
        onClick: (event) => {
          ctx.onClose(), onClick?.(event);
        },
        className: clsx({ [classes$y.close]: !ctx.unstyled }, className),
        unstyled: ctx.unstyled
      }
    );
  }
);
ModalBaseCloseButton.displayName = "@mantine/core/ModalBaseCloseButton";
const ModalBaseContent = forwardRef(
  ({ transitionProps, className, innerProps, onKeyDown, style: style2, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Transition$1,
      {
        mounted: ctx.opened,
        transition: "pop",
        ...ctx.transitionProps,
        onExited: () => {
          ctx.onExitTransitionEnd?.(), ctx.transitionProps?.onExited?.();
        },
        onEntered: () => {
          ctx.onEnterTransitionEnd?.(), ctx.transitionProps?.onEntered?.();
        },
        ...transitionProps,
        children: (transitionStyles) => /* @__PURE__ */ jsx(
          "div",
          {
            ...innerProps,
            className: clsx({ [classes$y.inner]: !ctx.unstyled }, innerProps.className),
            children: /* @__PURE__ */ jsx(FocusTrap, { active: ctx.opened && ctx.trapFocus, innerRef: ref, children: /* @__PURE__ */ jsx(
              Paper,
              {
                ...others,
                component: "section",
                role: "dialog",
                tabIndex: -1,
                "aria-modal": !0,
                "aria-describedby": ctx.bodyMounted ? ctx.getBodyId() : void 0,
                "aria-labelledby": ctx.titleMounted ? ctx.getTitleId() : void 0,
                style: [style2, transitionStyles],
                className: clsx({ [classes$y.content]: !ctx.unstyled }, className),
                unstyled: ctx.unstyled,
                children: others.children
              }
            ) })
          }
        )
      }
    );
  }
);
ModalBaseContent.displayName = "@mantine/core/ModalBaseContent";
const ModalBaseHeader = forwardRef(
  ({ className, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        component: "header",
        ref,
        className: clsx({ [classes$y.header]: !ctx.unstyled }, className),
        ...others
      }
    );
  }
);
ModalBaseHeader.displayName = "@mantine/core/ModalBaseHeader";
const DEFAULT_TRANSITION = {
  duration: 200,
  timingFunction: "ease",
  transition: "fade"
};
function useModalTransition(transitionOverride) {
  const ctx = useModalBaseContext();
  return { ...DEFAULT_TRANSITION, ...ctx.transitionProps, ...transitionOverride };
}
const ModalBaseOverlay = forwardRef(
  ({ onClick, transitionProps, style: style2, visible: visible2, ...others }, ref) => {
    const ctx = useModalBaseContext(), transition = useModalTransition(transitionProps);
    return /* @__PURE__ */ jsx(
      Transition$1,
      {
        mounted: visible2 !== void 0 ? visible2 : ctx.opened,
        ...transition,
        transition: "fade",
        children: (transitionStyles) => /* @__PURE__ */ jsx(
          Overlay$1,
          {
            ref,
            fixed: !0,
            style: [style2, transitionStyles],
            zIndex: ctx.zIndex,
            unstyled: ctx.unstyled,
            onClick: (event) => {
              onClick?.(event), ctx.closeOnClickOutside && ctx.onClose();
            },
            ...others
          }
        )
      }
    );
  }
);
ModalBaseOverlay.displayName = "@mantine/core/ModalBaseOverlay";
function useModalTitle() {
  const ctx = useModalBaseContext();
  return useEffect(() => (ctx.setTitleMounted(!0), () => ctx.setTitleMounted(!1)), []), ctx.getTitleId();
}
const ModalBaseTitle = forwardRef(
  ({ className, ...others }, ref) => {
    const id2 = useModalTitle(), ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        component: "h2",
        ref,
        className: clsx({ [classes$y.title]: !ctx.unstyled }, className),
        ...others,
        id: id2
      }
    );
  }
);
ModalBaseTitle.displayName = "@mantine/core/ModalBaseTitle";
function NativeScrollArea({ children: children2 }) {
  return /* @__PURE__ */ jsx(Fragment$1, { children: children2 });
}
const [InputContext, useInputContext] = createOptionalContext({
  size: "sm"
}), defaultProps$1j = {}, InputClearButton = factory((_props, ref) => {
  const props = useProps("InputClearButton", defaultProps$1j, _props), { size: size2, variant, vars, classNames, styles, ...others } = props, ctx = useInputContext(), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return /* @__PURE__ */ jsx(
    CloseButton,
    {
      variant: variant || "transparent",
      ref,
      size: size2 || ctx?.size || "sm",
      classNames: resolvedClassNames,
      styles: resolvedStyles,
      __staticSelector: "InputClearButton",
      ...others
    }
  );
});
InputClearButton.displayName = "@mantine/core/InputClearButton";
const [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0,
  getStyles: null,
  inputId: void 0,
  labelId: void 0
});
var classes$x = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" };
const defaultProps$1i = {}, varsResolver$B = (_, { size: size2 }) => ({
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputDescription = factory((_props, ref) => {
  const props = useProps("InputDescription", defaultProps$1i, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    __staticSelector,
    __inheritStyles = !0,
    variant,
    ...others
  } = useProps("InputDescription", defaultProps$1i, props), ctx = useInputWrapperContext(), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "description",
    vars,
    varsResolver: varsResolver$B
  }), getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("description", ctx?.getStyles ? { className, style: style2 } : void 0),
      ...others
    }
  );
});
InputDescription.classes = classes$x;
InputDescription.displayName = "@mantine/core/InputDescription";
const defaultProps$1h = {}, varsResolver$A = (_, { size: size2 }) => ({
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputError = factory((_props, ref) => {
  const props = useProps("InputError", defaultProps$1h, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    __staticSelector,
    __inheritStyles = !0,
    variant,
    ...others
  } = props, _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "error",
    vars,
    varsResolver: varsResolver$A
  }), ctx = useInputWrapperContext(), getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("error", ctx?.getStyles ? { className, style: style2 } : void 0),
      ...others
    }
  );
});
InputError.classes = classes$x;
InputError.displayName = "@mantine/core/InputError";
const defaultProps$1g = {
  labelElement: "label"
}, varsResolver$z = (_, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  }
}), InputLabel = factory((_props, ref) => {
  const props = useProps("InputLabel", defaultProps$1g, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    labelElement,
    size: size2,
    required,
    htmlFor,
    onMouseDown,
    children: children2,
    __staticSelector,
    variant,
    mod,
    ...others
  } = useProps("InputLabel", defaultProps$1g, props), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "label",
    vars,
    varsResolver: varsResolver$z
  }), ctx = useInputWrapperContext(), getStyles2 = ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("label", ctx?.getStyles ? { className, style: style2 } : void 0),
      component: labelElement,
      variant,
      size: size2,
      ref,
      htmlFor: labelElement === "label" ? htmlFor : void 0,
      mod: [{ required }, mod],
      onMouseDown: (event) => {
        onMouseDown?.(event), !event.defaultPrevented && event.detail > 1 && event.preventDefault();
      },
      ...others,
      children: [
        children2,
        required && /* @__PURE__ */ jsx("span", { ...getStyles2("required"), "aria-hidden": !0, children: " *" })
      ]
    }
  );
});
InputLabel.classes = classes$x;
InputLabel.displayName = "@mantine/core/InputLabel";
const defaultProps$1f = {}, InputPlaceholder = factory((_props, ref) => {
  const props = useProps("InputPlaceholder", defaultProps$1f, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    __staticSelector,
    variant,
    error,
    mod,
    ...others
  } = useProps("InputPlaceholder", defaultProps$1f, props), getStyles2 = useStyles({
    name: ["InputPlaceholder", __staticSelector],
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "placeholder"
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("placeholder"),
      mod: [{ error: !!error }, mod],
      component: "span",
      variant,
      ref,
      ...others
    }
  );
});
InputPlaceholder.classes = classes$x;
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";
function getInputOffsets(inputWrapperOrder, { hasDescription, hasError }) {
  const inputIndex = inputWrapperOrder.findIndex((part) => part === "input"), aboveInput = inputWrapperOrder.slice(0, inputIndex), belowInput = inputWrapperOrder.slice(inputIndex + 1), offsetTop = hasDescription && aboveInput.includes("description") || hasError && aboveInput.includes("error");
  return { offsetBottom: hasDescription && belowInput.includes("description") || hasError && belowInput.includes("error"), offsetTop };
}
const defaultProps$1e = {
  labelElement: "label",
  inputContainer: (children2) => children2,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, varsResolver$y = (_, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  },
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  },
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputWrapper = factory((_props, ref) => {
  const props = useProps("InputWrapper", defaultProps$1e, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    variant,
    __staticSelector,
    inputContainer,
    inputWrapperOrder,
    label: label2,
    error,
    description: description2,
    labelProps,
    descriptionProps,
    errorProps,
    labelElement,
    children: children2,
    withAsterisk,
    id: id2,
    required,
    __stylesApiProps,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["InputWrapper", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$y
  }), sharedProps = {
    size: size2,
    variant,
    __staticSelector
  }, idBase = useId$1(id2), isRequired = typeof withAsterisk == "boolean" ? withAsterisk : required, errorId = errorProps?.id || `${idBase}-error`, descriptionId = descriptionProps?.id || `${idBase}-description`, inputId = idBase, hasError = !!error && typeof error != "boolean", hasDescription = !!description2, _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`, describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : void 0, labelId = labelProps?.id || `${idBase}-label`, _label = label2 && /* @__PURE__ */ jsx(
    InputLabel,
    {
      labelElement,
      id: labelId,
      htmlFor: inputId,
      required: isRequired,
      ...sharedProps,
      ...labelProps,
      children: label2
    },
    "label"
  ), _description = hasDescription && /* @__PURE__ */ jsx(
    InputDescription,
    {
      ...descriptionProps,
      ...sharedProps,
      size: descriptionProps?.size || sharedProps.size,
      id: descriptionProps?.id || descriptionId,
      children: description2
    },
    "description"
  ), _input = /* @__PURE__ */ jsx(Fragment, { children: inputContainer(children2) }, "input"), _error = hasError && /* @__PURE__ */ createElement(
    InputError,
    {
      ...errorProps,
      ...sharedProps,
      size: errorProps?.size || sharedProps.size,
      key: "error",
      id: errorProps?.id || errorId
    },
    error
  ), content2 = inputWrapperOrder.map((part) => {
    switch (part) {
      case "label":
        return _label;
      case "input":
        return _input;
      case "description":
        return _description;
      case "error":
        return _error;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ jsx(
    InputWrapperProvider,
    {
      value: {
        getStyles: getStyles2,
        describedBy,
        inputId,
        labelId,
        ...getInputOffsets(inputWrapperOrder, { hasDescription, hasError })
      },
      children: /* @__PURE__ */ jsx(
        Box$1,
        {
          ref,
          variant,
          size: size2,
          mod: [{ error: !!error }, mod],
          ...getStyles2("root"),
          ...others,
          children: content2
        }
      )
    }
  );
});
InputWrapper.classes = classes$x;
InputWrapper.displayName = "@mantine/core/InputWrapper";
const defaultProps$1d = {
  variant: "default",
  leftSectionPointerEvents: "none",
  rightSectionPointerEvents: "none",
  withAria: !0,
  withErrorStyles: !0
}, varsResolver$x = (_, props, ctx) => ({
  wrapper: {
    "--input-margin-top": ctx.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-margin-bottom": ctx.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-height": getSize(props.size, "input-height"),
    "--input-fz": getFontSize(props.size),
    "--input-radius": props.radius === void 0 ? void 0 : getRadius$1(props.radius),
    "--input-left-section-width": props.leftSectionWidth !== void 0 ? rem(props.leftSectionWidth) : void 0,
    "--input-right-section-width": props.rightSectionWidth !== void 0 ? rem(props.rightSectionWidth) : void 0,
    "--input-padding-y": props.multiline ? getSize(props.size, "input-padding-y") : void 0,
    "--input-left-section-pointer-events": props.leftSectionPointerEvents,
    "--input-right-section-pointer-events": props.rightSectionPointerEvents
  }
}), Input = polymorphicFactory((_props, ref) => {
  const props = useProps("Input", defaultProps$1d, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    required,
    __staticSelector,
    __stylesApiProps,
    size: size2,
    wrapperProps,
    error,
    disabled,
    leftSection,
    leftSectionProps,
    leftSectionWidth,
    rightSection,
    rightSectionProps,
    rightSectionWidth,
    rightSectionPointerEvents,
    leftSectionPointerEvents,
    variant,
    vars,
    pointer: pointer2,
    multiline,
    radius,
    id: id2,
    withAria,
    withErrorStyles,
    mod,
    inputSize,
    __clearSection,
    __clearable,
    __defaultRightSection,
    ...others
  } = props, { styleProps, rest } = extractStyleProps(others), ctx = useInputWrapperContext(), stylesCtx = { offsetBottom: ctx?.offsetBottom, offsetTop: ctx?.offsetTop }, getStyles2 = useStyles({
    name: ["Input", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    stylesCtx,
    rootSelector: "wrapper",
    vars,
    varsResolver: varsResolver$x
  }), ariaAttributes = withAria ? {
    required,
    disabled,
    "aria-invalid": !!error,
    "aria-describedby": ctx?.describedBy,
    id: ctx?.inputId || id2
  } : {}, _rightSection = rightSection || __clearable && __clearSection || __defaultRightSection;
  return /* @__PURE__ */ jsx(InputContext, { value: { size: size2 || "sm" }, children: /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("wrapper"),
      ...styleProps,
      ...wrapperProps,
      mod: [
        {
          error: !!error && withErrorStyles,
          pointer: pointer2,
          disabled,
          multiline,
          "data-with-right-section": !!_rightSection,
          "data-with-left-section": !!leftSection
        },
        mod
      ],
      variant,
      size: size2,
      children: [
        leftSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...leftSectionProps,
            "data-position": "left",
            ...getStyles2("section", {
              className: leftSectionProps?.className,
              style: leftSectionProps?.style
            }),
            children: leftSection
          }
        ),
        /* @__PURE__ */ jsx(
          Box$1,
          {
            component: "input",
            ...rest,
            ...ariaAttributes,
            ref,
            required,
            mod: { disabled, error: !!error && withErrorStyles },
            variant,
            __size: inputSize,
            ...getStyles2("input")
          }
        ),
        _rightSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...rightSectionProps,
            "data-position": "right",
            ...getStyles2("section", {
              className: rightSectionProps?.className,
              style: rightSectionProps?.style
            }),
            children: _rightSection
          }
        )
      ]
    }
  ) });
});
Input.classes = classes$x;
Input.Wrapper = InputWrapper;
Input.Label = InputLabel;
Input.Error = InputError;
Input.Description = InputDescription;
Input.Placeholder = InputPlaceholder;
Input.ClearButton = InputClearButton;
Input.displayName = "@mantine/core/Input";
function useInputProps(component, defaultProps2, _props) {
  const props = useProps(component, defaultProps2, _props), {
    label: label2,
    description: description2,
    error,
    required,
    classNames,
    styles,
    className,
    unstyled,
    __staticSelector,
    __stylesApiProps,
    errorProps,
    labelProps,
    descriptionProps,
    wrapperProps: _wrapperProps,
    id: id2,
    size: size2,
    style: style2,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    variant,
    vars,
    mod,
    ...others
  } = props, { styleProps, rest } = extractStyleProps(others), wrapperProps = {
    label: label2,
    description: description2,
    error,
    required,
    classNames,
    className,
    __staticSelector,
    __stylesApiProps: __stylesApiProps || props,
    errorProps,
    labelProps,
    descriptionProps,
    unstyled,
    styles,
    size: size2,
    style: style2,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    variant,
    id: id2,
    mod,
    ..._wrapperProps
  };
  return {
    ...rest,
    classNames,
    styles,
    unstyled,
    wrapperProps: { ...wrapperProps, ...styleProps },
    inputProps: {
      required,
      classNames,
      styles,
      unstyled,
      size: size2,
      __staticSelector,
      __stylesApiProps: __stylesApiProps || props,
      error,
      variant,
      id: id2
    }
  };
}
const defaultProps$1c = {
  __staticSelector: "InputBase",
  withAria: !0
}, InputBase = polymorphicFactory((props, ref) => {
  const { inputProps, wrapperProps, ...others } = useInputProps("InputBase", defaultProps$1c, props);
  return /* @__PURE__ */ jsx(Input.Wrapper, { ...wrapperProps, children: /* @__PURE__ */ jsx(Input, { ...inputProps, ...others, ref }) });
});
InputBase.classes = { ...Input.classes, ...Input.Wrapper.classes };
InputBase.displayName = "@mantine/core/InputBase";
const FLEX_STYLE_PROPS_DATA = {
  gap: { type: "spacing", property: "gap" },
  rowGap: { type: "spacing", property: "rowGap" },
  columnGap: { type: "spacing", property: "columnGap" },
  align: { type: "identity", property: "alignItems" },
  justify: { type: "identity", property: "justifyContent" },
  wrap: { type: "identity", property: "flexWrap" },
  direction: { type: "identity", property: "flexDirection" }
};
var classes$w = { root: "m_8bffd616" };
const defaultProps$1b = {}, Flex = polymorphicFactory((_props, ref) => {
  const props = useProps("Flex", defaultProps$1b, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    gap,
    rowGap,
    columnGap,
    align,
    justify,
    wrap: wrap2,
    direction,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Flex",
    classes: classes$w,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars
  }), theme2 = useMantineTheme(), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
    styleProps: { gap, rowGap, columnGap, align, justify, wrap: wrap2, direction },
    theme: theme2,
    data: FLEX_STYLE_PROPS_DATA
  });
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
      InlineStyles,
      {
        selector: `.${responsiveClassName}`,
        styles: parsedStyleProps.styles,
        media: parsedStyleProps.media
      }
    ),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        ref,
        ...getStyles2("root", {
          className: responsiveClassName,
          style: filterProps$1(parsedStyleProps.inlineStyles)
        }),
        ...others
      }
    )
  ] });
});
Flex.classes = classes$w;
Flex.displayName = "@mantine/core/Flex";
function isParent(parentElement, childElement) {
  if (!childElement || !parentElement)
    return !1;
  let parent = childElement.parentNode;
  for (; parent != null; ) {
    if (parent === parentElement)
      return !0;
    parent = parent.parentNode;
  }
  return !1;
}
function useFloatingIndicator({
  target,
  parent,
  ref,
  displayAfterTransitionEnd
}) {
  const transitionTimeout = useRef(-1), [initialized, setInitialized] = useState(!1), [hidden2, setHidden] = useState(
    typeof displayAfterTransitionEnd == "boolean" ? displayAfterTransitionEnd : !1
  ), updatePosition = () => {
    if (!target || !parent || !ref.current)
      return;
    const targetRect = target.getBoundingClientRect(), parentRect = parent.getBoundingClientRect(), targetComputedStyle = window.getComputedStyle(target), parentComputedStyle = window.getComputedStyle(parent), borderTopWidth = toInt(targetComputedStyle.borderTopWidth) + toInt(parentComputedStyle.borderTopWidth), borderLeftWidth = toInt(targetComputedStyle.borderLeftWidth) + toInt(parentComputedStyle.borderLeftWidth), position = {
      top: targetRect.top - parentRect.top - borderTopWidth,
      left: targetRect.left - parentRect.left - borderLeftWidth,
      width: targetRect.width,
      height: targetRect.height
    };
    ref.current.style.transform = `translateY(${position.top}px) translateX(${position.left}px)`, ref.current.style.width = `${position.width}px`, ref.current.style.height = `${position.height}px`;
  }, updatePositionWithoutAnimation = () => {
    window.clearTimeout(transitionTimeout.current), ref.current && (ref.current.style.transitionDuration = "0ms"), updatePosition(), transitionTimeout.current = window.setTimeout(() => {
      ref.current && (ref.current.style.transitionDuration = "");
    }, 30);
  }, targetResizeObserver = useRef(null), parentResizeObserver = useRef(null);
  return useEffect(() => {
    if (updatePosition(), target)
      return targetResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), targetResizeObserver.current.observe(target), parent && (parentResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), parentResizeObserver.current.observe(parent)), () => {
        targetResizeObserver.current?.disconnect(), parentResizeObserver.current?.disconnect();
      };
  }, [parent, target]), useEffect(() => {
    if (parent) {
      const handleTransitionEnd = (event) => {
        isParent(event.target, parent) && (updatePositionWithoutAnimation(), setHidden(!1));
      };
      return parent.addEventListener("transitionend", handleTransitionEnd), () => {
        parent.removeEventListener("transitionend", handleTransitionEnd);
      };
    }
  }, [parent]), useTimeout(
    () => {
      getEnv() !== "test" && setInitialized(!0);
    },
    20,
    { autoInvoke: !0 }
  ), useMutationObserver(
    (mutations) => {
      mutations.forEach((mutation) => {
        mutation.type === "attributes" && mutation.attributeName === "dir" && updatePositionWithoutAnimation();
      });
    },
    { attributes: !0, attributeFilter: ["dir"] },
    () => document.documentElement
  ), { initialized, hidden: hidden2 };
}
var classes$v = { root: "m_96b553a6" };
const defaultProps$1a = {}, varsResolver$w = (_theme, { transitionDuration }) => ({
  root: {
    "--transition-duration": typeof transitionDuration == "number" ? `${transitionDuration}ms` : transitionDuration
  }
}), FloatingIndicator = factory((_props, ref) => {
  const props = useProps("FloatingIndicator", defaultProps$1a, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    target,
    parent,
    transitionDuration,
    mod,
    displayAfterTransitionEnd,
    ...others
  } = props, getStyles2 = useStyles({
    name: "FloatingIndicator",
    classes: classes$v,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$w
  }), innerRef = useRef(null), { initialized, hidden: hidden2 } = useFloatingIndicator({
    target,
    parent,
    ref: innerRef,
    displayAfterTransitionEnd
  }), mergedRef = useMergedRef(ref, innerRef);
  return !target || !parent ? null : /* @__PURE__ */ jsx(Box$1, { ref: mergedRef, mod: [{ initialized, hidden: hidden2 }, mod], ...getStyles2("root"), ...others });
});
FloatingIndicator.displayName = "@mantine/core/FloatingIndicator";
FloatingIndicator.classes = classes$v;
var classes$u = { root: "m_66836ed3", wrapper: "m_a5d60502", body: "m_667c2793", title: "m_6a03f287", label: "m_698f4f23", icon: "m_667f2a6a", message: "m_7fa78076", closeButton: "m_87f54839" };
const defaultProps$19 = {}, varsResolver$v = (theme2, { radius, color: color2, variant, autoContrast }) => {
  const colors2 = theme2.variantColorResolver({
    color: color2 || theme2.primaryColor,
    theme: theme2,
    variant: variant || "light",
    autoContrast
  });
  return {
    root: {
      "--alert-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--alert-bg": color2 || variant ? colors2.background : void 0,
      "--alert-color": colors2.color,
      "--alert-bd": color2 || variant ? colors2.border : void 0
    }
  };
}, Alert = factory((_props, ref) => {
  const props = useProps("Alert", defaultProps$19, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    radius,
    color: color2,
    title: title2,
    children: children2,
    id: id2,
    icon: icon2,
    withCloseButton,
    onClose,
    closeButtonLabel,
    variant,
    autoContrast,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Alert",
    classes: classes$u,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$v
  }), rootId = useId$1(id2), titleId = title2 && `${rootId}-title` || void 0, bodyId = `${rootId}-body`;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      id: rootId,
      ...getStyles2("root", { variant }),
      variant,
      ref,
      ...others,
      role: "alert",
      "aria-describedby": bodyId,
      "aria-labelledby": titleId,
      children: /* @__PURE__ */ jsxs("div", { ...getStyles2("wrapper"), children: [
        icon2 && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon2 }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title2 && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), "data-with-close-button": withCloseButton || void 0, children: /* @__PURE__ */ jsx("span", { id: titleId, ...getStyles2("label"), children: title2 }) }),
          children2 && /* @__PURE__ */ jsx("div", { id: bodyId, ...getStyles2("message"), "data-variant": variant, children: children2 })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            ...getStyles2("closeButton"),
            onClick: onClose,
            variant: "transparent",
            size: 16,
            iconSize: 16,
            "aria-label": closeButtonLabel,
            unstyled
          }
        )
      ] })
    }
  );
});
Alert.classes = classes$u;
Alert.displayName = "@mantine/core/Alert";
var classes$t = { root: "m_b6d8b162" };
function getTextTruncate(truncate) {
  if (truncate === "start")
    return "start";
  if (truncate === "end" || truncate)
    return "end";
}
const defaultProps$18 = {
  inherit: !1
}, varsResolver$u = (theme2, { variant, lineClamp, gradient, size: size2, color: color2 }) => ({
  root: {
    "--text-fz": getFontSize(size2),
    "--text-lh": getLineHeight(size2),
    "--text-gradient": variant === "gradient" ? getGradient(gradient, theme2) : void 0,
    "--text-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
    "--text-color": color2 ? getThemeColor(color2, theme2) : void 0
  }
}), Text = polymorphicFactory((_props, ref) => {
  const props = useProps("Text", defaultProps$18, _props), {
    lineClamp,
    truncate,
    inline: inline2,
    inherit: inherit2,
    gradient,
    span,
    __staticSelector,
    vars,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    variant,
    mod,
    size: size2,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["Text", __staticSelector],
    props,
    classes: classes$t,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$u
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("root", { focusable: !0 }),
      ref,
      component: span ? "span" : "p",
      variant,
      mod: [
        {
          "data-truncate": getTextTruncate(truncate),
          "data-line-clamp": typeof lineClamp == "number",
          "data-inline": inline2,
          "data-inherit": inherit2
        },
        mod
      ],
      size: size2,
      ...others
    }
  );
});
Text.classes = classes$t;
Text.displayName = "@mantine/core/Text";
var classes$s = { root: "m_849cf0da" };
const defaultProps$17 = {
  underline: "hover"
}, Anchor = polymorphicFactory((props, ref) => {
  const { underline, className, unstyled, mod, ...others } = useProps(
    "Anchor",
    defaultProps$17,
    props
  );
  return /* @__PURE__ */ jsx(
    Text,
    {
      component: "a",
      ref,
      className: clsx({ [classes$s.root]: !unstyled }, className),
      ...others,
      mod: [{ underline }, mod],
      __staticSelector: "Anchor",
      unstyled
    }
  );
});
Anchor.classes = classes$s;
Anchor.displayName = "@mantine/core/Anchor";
function parseItem(item) {
  return typeof item == "string" ? { value: item, label: item } : "value" in item && !("label" in item) ? { value: item.value, label: item.value, disabled: item.disabled } : typeof item == "number" ? { value: item.toString(), label: item.toString() } : "group" in item ? {
    group: item.group,
    items: item.items.map((i2) => parseItem(i2))
  } : item;
}
function getParsedComboboxData(data) {
  return data ? data.map((item) => parseItem(item)) : [];
}
function getOptionsLockup(options) {
  return options.reduce((acc, item) => "group" in item ? { ...acc, ...getOptionsLockup(item.items) } : (acc[item.value] = item, acc), {});
}
var classes$r = { dropdown: "m_88b62a41", search: "m_985517d8", options: "m_b2821a6e", option: "m_92253aa5", empty: "m_2530cd1d", header: "m_858f94bd", footer: "m_82b967cb", group: "m_254f3e4f", groupLabel: "m_2bb2e9e5", chevron: "m_2943220b", optionsDropdownOption: "m_390b5f4", optionsDropdownCheckIcon: "m_8ee53fc2" };
const defaultProps$16 = {
  error: null
}, varsResolver$t = (theme2, { size: size2, color: color2 }) => ({
  chevron: {
    "--combobox-chevron-size": getSize(size2, "combobox-chevron-size"),
    "--combobox-chevron-color": color2 ? getThemeColor(color2, theme2) : void 0
  }
}), ComboboxChevron = factory((_props, ref) => {
  const props = useProps("ComboboxChevron", defaultProps$16, _props), { size: size2, error, style: style2, className, classNames, styles, unstyled, vars, mod, ...others } = props, getStyles2 = useStyles({
    name: "ComboboxChevron",
    classes: classes$r,
    props,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$t,
    rootSelector: "chevron"
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: "svg",
      ...others,
      ...getStyles2("chevron"),
      size: size2,
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      mod: ["combobox-chevron", { error }, mod],
      ref,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
});
ComboboxChevron.classes = classes$r;
ComboboxChevron.displayName = "@mantine/core/ComboboxChevron";
const [ComboboxProvider, useComboboxContext] = createSafeContext(
  "Combobox component was not found in tree"
), ComboboxClearButton = forwardRef(
  ({ size: size2, onMouseDown, onClick, onClear, ...others }, ref) => /* @__PURE__ */ jsx(
    Input.ClearButton,
    {
      ref,
      tabIndex: -1,
      "aria-hidden": !0,
      ...others,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onClick: (event) => {
        onClear(), onClick?.(event);
      }
    }
  )
);
ComboboxClearButton.displayName = "@mantine/core/ComboboxClearButton";
const defaultProps$15 = {}, ComboboxDropdown = factory((props, ref) => {
  const { classNames, styles, className, style: style2, hidden: hidden2, ...others } = useProps(
    "ComboboxDropdown",
    defaultProps$15,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Popover.Dropdown,
    {
      ...others,
      ref,
      role: "presentation",
      "data-hidden": hidden2 || void 0,
      ...ctx.getStyles("dropdown", { className, style: style2, classNames, styles })
    }
  );
});
ComboboxDropdown.classes = classes$r;
ComboboxDropdown.displayName = "@mantine/core/ComboboxDropdown";
const defaultProps$14 = {
  refProp: "ref"
}, ComboboxDropdownTarget = factory((props, ref) => {
  const { children: children2, refProp } = useProps("ComboboxDropdownTarget", defaultProps$14, props);
  if (useComboboxContext(), !isElement$1(children2))
    throw new Error(
      "Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  return /* @__PURE__ */ jsx(Popover.Target, { ref, refProp, children: children2 });
});
ComboboxDropdownTarget.displayName = "@mantine/core/ComboboxDropdownTarget";
const defaultProps$13 = {}, ComboboxEmpty = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxEmpty",
    defaultProps$13,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("empty", { className, classNames, styles, style: style2 }),
      ...others
    }
  );
});
ComboboxEmpty.classes = classes$r;
ComboboxEmpty.displayName = "@mantine/core/ComboboxEmpty";
function useComboboxTargetProps({
  onKeyDown,
  withKeyboardNavigation,
  withAriaAttributes,
  withExpandedAttribute,
  targetType,
  autoComplete
}) {
  const ctx = useComboboxContext(), [selectedOptionId, setSelectedOptionId] = useState(null), handleKeyDown = (event) => {
    if (onKeyDown?.(event), !ctx.readOnly && withKeyboardNavigation) {
      if (event.nativeEvent.isComposing)
        return;
      if (event.nativeEvent.code === "ArrowDown" && (event.preventDefault(), ctx.store.dropdownOpened ? setSelectedOptionId(ctx.store.selectNextOption()) : (ctx.store.openDropdown("keyboard"), setSelectedOptionId(ctx.store.selectActiveOption()), ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), event.nativeEvent.code === "ArrowUp" && (event.preventDefault(), ctx.store.dropdownOpened ? setSelectedOptionId(ctx.store.selectPreviousOption()) : (ctx.store.openDropdown("keyboard"), setSelectedOptionId(ctx.store.selectActiveOption()), ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") {
        if (event.nativeEvent.keyCode === 229)
          return;
        const selectedOptionIndex = ctx.store.getSelectedOptionIndex();
        ctx.store.dropdownOpened && selectedOptionIndex !== -1 ? (event.preventDefault(), ctx.store.clickSelectedOption()) : targetType === "button" && (event.preventDefault(), ctx.store.openDropdown("keyboard"));
      }
      event.key === "Escape" && ctx.store.closeDropdown("keyboard"), event.nativeEvent.code === "Space" && targetType === "button" && (event.preventDefault(), ctx.store.toggleDropdown("keyboard"));
    }
  };
  return {
    ...withAriaAttributes ? {
      "aria-haspopup": "listbox",
      "aria-expanded": withExpandedAttribute && !!(ctx.store.listId && ctx.store.dropdownOpened) || void 0,
      "aria-controls": ctx.store.dropdownOpened ? ctx.store.listId : void 0,
      "aria-activedescendant": ctx.store.dropdownOpened && selectedOptionId || void 0,
      autoComplete,
      "data-expanded": ctx.store.dropdownOpened || void 0,
      "data-mantine-stop-propagation": ctx.store.dropdownOpened || void 0
    } : {},
    onKeyDown: handleKeyDown
  };
}
const defaultProps$12 = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, ComboboxEventsTarget = factory((props, ref) => {
  const {
    children: children2,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxEventsTarget", defaultProps$12, props);
  if (!isElement$1(children2))
    throw new Error(
      "Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useComboboxContext(), targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: children2.props.onKeyDown,
    autoComplete
  });
  return cloneElement(children2, {
    ...targetProps,
    ...others,
    [refProp]: useMergedRef(ref, ctx.store.targetRef, getRefProp(children2))
  });
});
ComboboxEventsTarget.displayName = "@mantine/core/ComboboxEventsTarget";
const defaultProps$11 = {}, ComboboxFooter = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxFooter",
    defaultProps$11,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("footer", { className, classNames, style: style2, styles }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }
  );
});
ComboboxFooter.classes = classes$r;
ComboboxFooter.displayName = "@mantine/core/ComboboxFooter";
const defaultProps$10 = {}, ComboboxGroup = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, children: children2, label: label2, ...others } = useProps(
    "ComboboxGroup",
    defaultProps$10,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ref,
      ...ctx.getStyles("group", { className, classNames, style: style2, styles }),
      ...others,
      children: [
        label2 && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("groupLabel", { classNames, styles }), children: label2 }),
        children2
      ]
    }
  );
});
ComboboxGroup.classes = classes$r;
ComboboxGroup.displayName = "@mantine/core/ComboboxGroup";
const defaultProps$$ = {}, ComboboxHeader = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxHeader",
    defaultProps$$,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("header", { className, classNames, style: style2, styles }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }
  );
});
ComboboxHeader.classes = classes$r;
ComboboxHeader.displayName = "@mantine/core/ComboboxHeader";
function ComboboxHiddenInput({
  value,
  valuesDivider = ",",
  ...others
}) {
  return /* @__PURE__ */ jsx(
    "input",
    {
      type: "hidden",
      value: Array.isArray(value) ? value.join(valuesDivider) : value || "",
      ...others
    }
  );
}
ComboboxHiddenInput.displayName = "@mantine/core/ComboboxHiddenInput";
const defaultProps$_ = {}, ComboboxOption = factory((_props, ref) => {
  const props = useProps("ComboboxOption", defaultProps$_, _props), {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onClick,
    id: id2,
    active,
    onMouseDown,
    onMouseOver,
    disabled,
    selected: selected2,
    mod,
    ...others
  } = props, ctx = useComboboxContext(), uuid = useId$2(), _id = id2 || uuid;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...ctx.getStyles("option", { className, classNames, styles, style: style2 }),
      ...others,
      ref,
      id: _id,
      mod: [
        "combobox-option",
        { "combobox-active": active, "combobox-disabled": disabled, "combobox-selected": selected2 },
        mod
      ],
      role: "option",
      onClick: (event) => {
        disabled ? event.preventDefault() : (ctx.onOptionSubmit?.(props.value, props), onClick?.(event));
      },
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onMouseOver: (event) => {
        ctx.resetSelectionOnOptionHover && ctx.store.resetSelectedOption(), onMouseOver?.(event);
      }
    }
  );
});
ComboboxOption.classes = classes$r;
ComboboxOption.displayName = "@mantine/core/ComboboxOption";
const defaultProps$Z = {}, ComboboxOptions = factory((_props, ref) => {
  const props = useProps("ComboboxOptions", defaultProps$Z, _props), { classNames, className, style: style2, styles, id: id2, onMouseDown, labelledBy, ...others } = props, ctx = useComboboxContext(), _id = useId$1(id2);
  return useEffect(() => {
    ctx.store.setListId(_id);
  }, [_id]), /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("options", { className, style: style2, classNames, styles }),
      ...others,
      id: _id,
      role: "listbox",
      "aria-labelledby": labelledBy,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      }
    }
  );
});
ComboboxOptions.classes = classes$r;
ComboboxOptions.displayName = "@mantine/core/ComboboxOptions";
const defaultProps$Y = {
  withAriaAttributes: !0,
  withKeyboardNavigation: !0
}, ComboboxSearch = factory((_props, ref) => {
  const props = useProps("ComboboxSearch", defaultProps$Y, _props), {
    classNames,
    styles,
    unstyled,
    vars,
    withAriaAttributes,
    onKeyDown,
    withKeyboardNavigation,
    size: size2,
    ...others
  } = props, ctx = useComboboxContext(), _styles = ctx.getStyles("search"), targetProps = useComboboxTargetProps({
    targetType: "input",
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute: !1,
    onKeyDown,
    autoComplete: "off"
  });
  return /* @__PURE__ */ jsx(
    Input,
    {
      ref: useMergedRef(ref, ctx.store.searchRef),
      classNames: [{ input: _styles.className }, classNames],
      styles: [{ input: _styles.style }, styles],
      size: size2 || ctx.size,
      ...targetProps,
      ...others,
      __staticSelector: "Combobox"
    }
  );
});
ComboboxSearch.classes = classes$r;
ComboboxSearch.displayName = "@mantine/core/ComboboxSearch";
const defaultProps$X = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, ComboboxTarget = factory((props, ref) => {
  const {
    children: children2,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxTarget", defaultProps$X, props);
  if (!isElement$1(children2))
    throw new Error(
      "Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useComboboxContext(), targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: children2.props.onKeyDown,
    autoComplete
  }), clonedElement = cloneElement(children2, {
    ...targetProps,
    ...others
  });
  return /* @__PURE__ */ jsx(Popover.Target, { ref: useMergedRef(ref, ctx.store.targetRef), children: clonedElement });
});
ComboboxTarget.displayName = "@mantine/core/ComboboxTarget";
function getPreviousIndex(currentIndex, elements, loop) {
  for (let i2 = currentIndex - 1; i2 >= 0; i2 -= 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  if (loop) {
    for (let i2 = elements.length - 1; i2 > -1; i2 -= 1)
      if (!elements[i2].hasAttribute("data-combobox-disabled"))
        return i2;
  }
  return currentIndex;
}
function getNextIndex(currentIndex, elements, loop) {
  for (let i2 = currentIndex + 1; i2 < elements.length; i2 += 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  if (loop) {
    for (let i2 = 0; i2 < elements.length; i2 += 1)
      if (!elements[i2].hasAttribute("data-combobox-disabled"))
        return i2;
  }
  return currentIndex;
}
function getFirstIndex(elements) {
  for (let i2 = 0; i2 < elements.length; i2 += 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  return -1;
}
function useCombobox({
  defaultOpened,
  opened,
  onOpenedChange,
  onDropdownClose,
  onDropdownOpen,
  loop = !0,
  scrollBehavior = "instant"
} = {}) {
  const [dropdownOpened, setDropdownOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange: onOpenedChange
  }), listId = useRef(null), selectedOptionIndex = useRef(-1), searchRef = useRef(null), targetRef = useRef(null), focusSearchTimeout = useRef(-1), focusTargetTimeout = useRef(-1), selectedIndexUpdateTimeout = useRef(-1), openDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened || (setDropdownOpened(!0), onDropdownOpen?.(eventSource));
    },
    [setDropdownOpened, onDropdownOpen, dropdownOpened]
  ), closeDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened && (setDropdownOpened(!1), onDropdownClose?.(eventSource));
    },
    [setDropdownOpened, onDropdownClose, dropdownOpened]
  ), toggleDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened ? closeDropdown(eventSource) : openDropdown(eventSource);
    },
    [closeDropdown, openDropdown, dropdownOpened]
  ), clearSelectedItem = useCallback(() => {
    const selected2 = document.querySelector(`#${listId.current} [data-combobox-selected]`);
    selected2?.removeAttribute("data-combobox-selected"), selected2?.removeAttribute("aria-selected");
  }, []), selectOption = useCallback(
    (index2) => {
      const items = document.getElementById(listId.current)?.querySelectorAll("[data-combobox-option]");
      if (!items)
        return null;
      const nextIndex = index2 >= items.length ? 0 : index2 < 0 ? items.length - 1 : index2;
      return selectedOptionIndex.current = nextIndex, items?.[nextIndex] && !items[nextIndex].hasAttribute("data-combobox-disabled") ? (clearSelectedItem(), items[nextIndex].setAttribute("data-combobox-selected", "true"), items[nextIndex].setAttribute("aria-selected", "true"), items[nextIndex].scrollIntoView({ block: "nearest", behavior: scrollBehavior }), items[nextIndex].id) : null;
    },
    [scrollBehavior, clearSelectedItem]
  ), selectActiveOption = useCallback(() => {
    const activeOption = document.querySelector(
      `#${listId.current} [data-combobox-active]`
    );
    if (activeOption) {
      const items = document.querySelectorAll(
        `#${listId.current} [data-combobox-option]`
      ), index2 = Array.from(items).findIndex((option) => option === activeOption);
      return selectOption(index2);
    }
    return selectOption(0);
  }, [selectOption]), selectNextOption = useCallback(
    () => selectOption(
      getNextIndex(
        selectedOptionIndex.current,
        document.querySelectorAll(`#${listId.current} [data-combobox-option]`),
        loop
      )
    ),
    [selectOption, loop]
  ), selectPreviousOption = useCallback(
    () => selectOption(
      getPreviousIndex(
        selectedOptionIndex.current,
        document.querySelectorAll(`#${listId.current} [data-combobox-option]`),
        loop
      )
    ),
    [selectOption, loop]
  ), selectFirstOption = useCallback(
    () => selectOption(
      getFirstIndex(
        document.querySelectorAll(`#${listId.current} [data-combobox-option]`)
      )
    ),
    [selectOption]
  ), updateSelectedOptionIndex = useCallback(
    (target = "selected", options) => {
      selectedIndexUpdateTimeout.current = window.setTimeout(() => {
        const items = document.querySelectorAll(
          `#${listId.current} [data-combobox-option]`
        ), index2 = Array.from(items).findIndex(
          (option) => option.hasAttribute(`data-combobox-${target}`)
        );
        selectedOptionIndex.current = index2, options?.scrollIntoView && items[index2]?.scrollIntoView({ block: "nearest", behavior: scrollBehavior });
      }, 0);
    },
    []
  ), resetSelectedOption = useCallback(() => {
    selectedOptionIndex.current = -1, clearSelectedItem();
  }, [clearSelectedItem]), clickSelectedOption = useCallback(() => {
    document.querySelectorAll(
      `#${listId.current} [data-combobox-option]`
    )?.[selectedOptionIndex.current]?.click();
  }, []), setListId = useCallback((id2) => {
    listId.current = id2;
  }, []), focusSearchInput = useCallback(() => {
    focusSearchTimeout.current = window.setTimeout(() => searchRef.current.focus(), 0);
  }, []), focusTarget = useCallback(() => {
    focusTargetTimeout.current = window.setTimeout(() => targetRef.current.focus(), 0);
  }, []), getSelectedOptionIndex = useCallback(() => selectedOptionIndex.current, []);
  return useEffect(
    () => () => {
      window.clearTimeout(focusSearchTimeout.current), window.clearTimeout(focusTargetTimeout.current), window.clearTimeout(selectedIndexUpdateTimeout.current);
    },
    []
  ), {
    dropdownOpened,
    openDropdown,
    closeDropdown,
    toggleDropdown,
    selectedOptionIndex: selectedOptionIndex.current,
    getSelectedOptionIndex,
    selectOption,
    selectFirstOption,
    selectActiveOption,
    selectNextOption,
    selectPreviousOption,
    resetSelectedOption,
    updateSelectedOptionIndex,
    listId: listId.current,
    setListId,
    clickSelectedOption,
    searchRef,
    focusSearchInput,
    targetRef,
    focusTarget
  };
}
const defaultProps$W = {
  keepMounted: !0,
  withinPortal: !0,
  resetSelectionOnOptionHover: !1,
  width: "target",
  transitionProps: { transition: "fade", duration: 0 }
}, varsResolver$s = (_, { size: size2, dropdownPadding }) => ({
  options: {
    "--combobox-option-fz": getFontSize(size2),
    "--combobox-option-padding": getSize(size2, "combobox-option-padding")
  },
  dropdown: {
    "--combobox-padding": dropdownPadding === void 0 ? void 0 : rem(dropdownPadding),
    "--combobox-option-fz": getFontSize(size2),
    "--combobox-option-padding": getSize(size2, "combobox-option-padding")
  }
});
function Combobox(_props) {
  const props = useProps("Combobox", defaultProps$W, _props), {
    classNames,
    styles,
    unstyled,
    children: children2,
    store: controlledStore,
    vars,
    onOptionSubmit,
    onClose,
    size: size2,
    dropdownPadding,
    resetSelectionOnOptionHover,
    __staticSelector,
    readOnly,
    ...others
  } = props, uncontrolledStore = useCombobox(), store = controlledStore || uncontrolledStore, getStyles2 = useStyles({
    name: __staticSelector || "Combobox",
    classes: classes$r,
    props,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$s
  }), onDropdownClose = () => {
    onClose?.(), store.closeDropdown();
  };
  return /* @__PURE__ */ jsx(
    ComboboxProvider,
    {
      value: {
        getStyles: getStyles2,
        store,
        onOptionSubmit,
        size: size2,
        resetSelectionOnOptionHover,
        readOnly
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          opened: store.dropdownOpened,
          ...others,
          onChange: (_opened) => !_opened && onDropdownClose(),
          withRoles: !1,
          unstyled,
          children: children2
        }
      )
    }
  );
}
const extendCombobox = (c2) => c2;
Combobox.extend = extendCombobox;
Combobox.classes = classes$r;
Combobox.displayName = "@mantine/core/Combobox";
Combobox.Target = ComboboxTarget;
Combobox.Dropdown = ComboboxDropdown;
Combobox.Options = ComboboxOptions;
Combobox.Option = ComboboxOption;
Combobox.Search = ComboboxSearch;
Combobox.Empty = ComboboxEmpty;
Combobox.Chevron = ComboboxChevron;
Combobox.Footer = ComboboxFooter;
Combobox.Header = ComboboxHeader;
Combobox.EventsTarget = ComboboxEventsTarget;
Combobox.DropdownTarget = ComboboxDropdownTarget;
Combobox.Group = ComboboxGroup;
Combobox.ClearButton = ComboboxClearButton;
Combobox.HiddenInput = ComboboxHiddenInput;
function CheckIcon({ size: size2, style: style2, ...others }) {
  const _style = size2 !== void 0 ? { width: rem(size2), height: rem(size2), ...style2 } : style2;
  return /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: _style,
      "aria-hidden": !0,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
function isOptionsGroup(item) {
  return "group" in item;
}
function defaultOptionsFilter({
  options,
  search,
  limit
}) {
  const parsedSearch = search.trim().toLowerCase(), result = [];
  for (let i2 = 0; i2 < options.length; i2 += 1) {
    const item = options[i2];
    if (result.length === limit)
      return result;
    isOptionsGroup(item) && result.push({
      group: item.group,
      items: defaultOptionsFilter({
        options: item.items,
        search,
        limit: limit - result.length
      })
    }), isOptionsGroup(item) || item.label.toLowerCase().includes(parsedSearch) && result.push(item);
  }
  return result;
}
function isEmptyComboboxData(data) {
  if (data.length === 0)
    return !0;
  for (const item of data)
    if (!("group" in item) || item.items.length > 0)
      return !1;
  return !0;
}
function validateOptions(options, valuesSet = /* @__PURE__ */ new Set()) {
  if (Array.isArray(options))
    for (const option of options)
      if (isOptionsGroup(option))
        validateOptions(option.items, valuesSet);
      else {
        if (typeof option.value > "u")
          throw new Error("[@mantine/core] Each option must have value property");
        if (typeof option.value != "string")
          throw new Error(
            `[@mantine/core] Option value must be a string, other data formats are not supported, got ${typeof option.value}`
          );
        if (valuesSet.has(option.value))
          throw new Error(
            `[@mantine/core] Duplicate options are not supported. Option with value "${option.value}" was provided more than once`
          );
        valuesSet.add(option.value);
      }
}
function isValueChecked(value, optionValue) {
  return Array.isArray(value) ? value.includes(optionValue) : value === optionValue;
}
function Option({
  data,
  withCheckIcon,
  value,
  checkIconPosition,
  unstyled,
  renderOption
}) {
  if (!isOptionsGroup(data)) {
    const checked = isValueChecked(value, data.value), check = withCheckIcon && checked && /* @__PURE__ */ jsx(CheckIcon, { className: classes$r.optionsDropdownCheckIcon }), defaultContent = /* @__PURE__ */ jsxs(Fragment$1, { children: [
      checkIconPosition === "left" && check,
      /* @__PURE__ */ jsx("span", { children: data.label }),
      checkIconPosition === "right" && check
    ] });
    return /* @__PURE__ */ jsx(
      Combobox.Option,
      {
        value: data.value,
        disabled: data.disabled,
        className: clsx({ [classes$r.optionsDropdownOption]: !unstyled }),
        "data-reverse": checkIconPosition === "right" || void 0,
        "data-checked": checked || void 0,
        "aria-selected": checked,
        active: checked,
        children: typeof renderOption == "function" ? renderOption({ option: data, checked }) : defaultContent
      }
    );
  }
  const options = data.items.map((item) => /* @__PURE__ */ jsx(
    Option,
    {
      data: item,
      value,
      unstyled,
      withCheckIcon,
      checkIconPosition,
      renderOption
    },
    item.value
  ));
  return /* @__PURE__ */ jsx(Combobox.Group, { label: data.group, children: options });
}
function OptionsDropdown({
  data,
  hidden: hidden2,
  hiddenWhenEmpty,
  filter: filter2,
  search,
  limit,
  maxDropdownHeight,
  withScrollArea = !0,
  filterOptions = !0,
  withCheckIcon = !1,
  value,
  checkIconPosition,
  nothingFoundMessage,
  unstyled,
  labelId,
  renderOption,
  scrollAreaProps,
  "aria-label": ariaLabel
}) {
  validateOptions(data);
  const filteredData = typeof search == "string" ? (filter2 || defaultOptionsFilter)({
    options: data,
    search: filterOptions ? search : "",
    limit: limit ?? 1 / 0
  }) : data, isEmpty = isEmptyComboboxData(filteredData), options = filteredData.map((item) => /* @__PURE__ */ jsx(
    Option,
    {
      data: item,
      withCheckIcon,
      value,
      checkIconPosition,
      unstyled,
      renderOption
    },
    isOptionsGroup(item) ? item.group : item.value
  ));
  return /* @__PURE__ */ jsx(Combobox.Dropdown, { hidden: hidden2 || hiddenWhenEmpty && isEmpty, "data-composed": !0, children: /* @__PURE__ */ jsxs(Combobox.Options, { labelledBy: labelId, "aria-label": ariaLabel, children: [
    withScrollArea ? /* @__PURE__ */ jsx(
      ScrollArea.Autosize,
      {
        mah: maxDropdownHeight ?? 220,
        type: "scroll",
        scrollbarSize: "var(--combobox-padding)",
        offsetScrollbars: "y",
        ...scrollAreaProps,
        children: options
      }
    ) : options,
    isEmpty && nothingFoundMessage && /* @__PURE__ */ jsx(Combobox.Empty, { children: nothingFoundMessage })
  ] }) });
}
var classes$q = { root: "m_347db0ec", "root--dot": "m_fbd81e3d", label: "m_5add502a", section: "m_91fdda9b" };
const defaultProps$V = {}, varsResolver$r = (theme2, { radius, color: color2, gradient, variant, size: size2, autoContrast }) => {
  const colors2 = theme2.variantColorResolver({
    color: color2 || theme2.primaryColor,
    theme: theme2,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--badge-height": getSize(size2, "badge-height"),
      "--badge-padding-x": getSize(size2, "badge-padding-x"),
      "--badge-fz": getSize(size2, "badge-fz"),
      "--badge-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--badge-bg": color2 || variant ? colors2.background : void 0,
      "--badge-color": color2 || variant ? colors2.color : void 0,
      "--badge-bd": color2 || variant ? colors2.border : void 0,
      "--badge-dot-color": variant === "dot" ? getThemeColor(color2, theme2) : void 0
    }
  };
}, Badge = polymorphicFactory((_props, ref) => {
  const props = useProps("Badge", defaultProps$V, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    radius,
    color: color2,
    gradient,
    leftSection,
    rightSection,
    children: children2,
    variant,
    fullWidth,
    autoContrast,
    circle,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Badge",
    props,
    classes: classes$q,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$r
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      variant,
      mod: [
        {
          block: fullWidth,
          circle,
          "with-right-section": !!rightSection,
          "with-left-section": !!leftSection
        },
        mod
      ],
      ...getStyles2("root", { variant }),
      ref,
      ...others,
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "left", children: leftSection }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "right", children: rightSection })
      ]
    }
  );
});
Badge.classes = classes$q;
Badge.displayName = "@mantine/core/Badge";
var classes$p = { root: "m_fea6bf1a", burger: "m_d4fb9cad" };
const defaultProps$U = {}, varsResolver$q = (theme2, { color: color2, size: size2, lineSize, transitionDuration, transitionTimingFunction }) => ({
  root: {
    "--burger-color": color2 ? getThemeColor(color2, theme2) : void 0,
    "--burger-size": getSize(size2, "burger-size"),
    "--burger-line-size": lineSize ? rem(lineSize) : void 0,
    "--burger-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
    "--burger-transition-timing-function": transitionTimingFunction
  }
}), Burger = factory((_props, ref) => {
  const props = useProps("Burger", defaultProps$U, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    opened,
    children: children2,
    transitionDuration,
    transitionTimingFunction,
    lineSize,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Burger",
    classes: classes$p,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$q
  });
  return /* @__PURE__ */ jsxs(UnstyledButton, { ...getStyles2("root"), ref, ...others, children: [
    /* @__PURE__ */ jsx(Box$1, { mod: ["reduce-motion", { opened }], ...getStyles2("burger") }),
    children2
  ] });
});
Burger.classes = classes$p;
Burger.displayName = "@mantine/core/Burger";
var classes$o = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844", groupSection: "m_70be2a01" };
const defaultProps$T = {
  orientation: "horizontal"
}, varsResolver$p = (_, { borderWidth: borderWidth2 }) => ({
  group: { "--button-border-width": rem(borderWidth2) }
}), ButtonGroup = factory((_props, ref) => {
  const props = useProps("ButtonGroup", defaultProps$T, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth: borderWidth2,
    variant,
    mod,
    ...others
  } = useProps("ButtonGroup", defaultProps$T, _props), getStyles2 = useStyles({
    name: "ButtonGroup",
    props,
    classes: classes$o,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$p,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ButtonGroup.classes = classes$o;
ButtonGroup.displayName = "@mantine/core/ButtonGroup";
const defaultProps$S = {}, varsResolver$o = (theme2, { radius, color: color2, gradient, variant, autoContrast, size: size2 }) => {
  const colors2 = theme2.variantColorResolver({
    color: color2 || theme2.primaryColor,
    theme: theme2,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    groupSection: {
      "--section-height": getSize(size2, "section-height"),
      "--section-padding-x": getSize(size2, "section-padding-x"),
      "--section-fz": size2?.includes("compact") ? getFontSize(size2.replace("compact-", "")) : getFontSize(size2),
      "--section-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--section-bg": color2 || variant ? colors2.background : void 0,
      "--section-color": colors2.color,
      "--section-bd": color2 || variant ? colors2.border : void 0
    }
  };
}, ButtonGroupSection = factory((_props, ref) => {
  const props = useProps("ButtonGroupSection", defaultProps$S, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    variant,
    gradient,
    radius,
    autoContrast,
    ...others
  } = useProps("ButtonGroupSection", defaultProps$S, _props), getStyles2 = useStyles({
    name: "ButtonGroupSection",
    props,
    classes: classes$o,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$o,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ jsx(Box$1, { ...getStyles2("groupSection"), ref, variant, ...others });
});
ButtonGroupSection.classes = classes$o;
ButtonGroupSection.displayName = "@mantine/core/ButtonGroupSection";
const loaderTransition = {
  in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${rem(1)}))` },
  out: { opacity: 0, transform: "translate(-50%, -200%)" },
  common: { transformOrigin: "center" },
  transitionProperty: "transform, opacity"
}, defaultProps$R = {}, varsResolver$n = (theme2, { radius, color: color2, gradient, variant, size: size2, justify, autoContrast }) => {
  const colors2 = theme2.variantColorResolver({
    color: color2 || theme2.primaryColor,
    theme: theme2,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--button-justify": justify,
      "--button-height": getSize(size2, "button-height"),
      "--button-padding-x": getSize(size2, "button-padding-x"),
      "--button-fz": size2?.includes("compact") ? getFontSize(size2.replace("compact-", "")) : getFontSize(size2),
      "--button-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--button-bg": color2 || variant ? colors2.background : void 0,
      "--button-hover": color2 || variant ? colors2.hover : void 0,
      "--button-color": colors2.color,
      "--button-bd": color2 || variant ? colors2.border : void 0,
      "--button-hover-color": color2 || variant ? colors2.hoverColor : void 0
    }
  };
}, Button = polymorphicFactory((_props, ref) => {
  const props = useProps("Button", defaultProps$R, _props), {
    style: style2,
    vars,
    className,
    color: color2,
    disabled,
    children: children2,
    leftSection,
    rightSection,
    fullWidth,
    variant,
    radius,
    loading,
    loaderProps,
    gradient,
    classNames,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Button",
    props,
    classes: classes$o,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$n
  }), hasLeftSection = !!leftSection, hasRightSection = !!rightSection;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      unstyled,
      variant,
      disabled: disabled || loading,
      mod: [
        {
          disabled: disabled || dataDisabled,
          loading,
          block: fullWidth,
          "with-left-section": hasLeftSection,
          "with-right-section": hasRightSection
        },
        mod
      ],
      ...others,
      children: [
        /* @__PURE__ */ jsx(Transition$1, { mounted: !!loading, transition: loaderTransition, duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(
          Loader,
          {
            color: "var(--button-color)",
            size: "calc(var(--button-height) / 1.8)",
            ...loaderProps
          }
        ) }) }),
        /* @__PURE__ */ jsxs("span", { ...getStyles2("inner"), children: [
          leftSection && /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("section"), mod: { position: "left" }, children: leftSection }),
          /* @__PURE__ */ jsx(Box$1, { component: "span", mod: { loading }, ...getStyles2("label"), children: children2 }),
          rightSection && /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("section"), mod: { position: "right" }, children: rightSection })
        ] })
      ]
    }
  );
});
Button.classes = classes$o;
Button.displayName = "@mantine/core/Button";
Button.Group = ButtonGroup;
Button.GroupSection = ButtonGroupSection;
const [CardProvider, useCardContext] = createSafeContext(
  "Card component was not found in tree"
);
var classes$n = { root: "m_e615b15f", section: "m_599a2148" };
const defaultProps$Q = {}, CardSection = polymorphicFactory((_props, ref) => {
  const props = useProps("CardSection", defaultProps$Q, _props), { classNames, className, style: style2, styles, vars, withBorder, inheritPadding, mod, ...others } = props, ctx = useCardContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      mod: [{ "with-border": withBorder, "inherit-padding": inheritPadding }, mod],
      ...ctx.getStyles("section", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
CardSection.classes = classes$n;
CardSection.displayName = "@mantine/core/CardSection";
const defaultProps$P = {}, varsResolver$m = (_, { padding }) => ({
  root: {
    "--card-padding": getSpacing(padding)
  }
}), Card = polymorphicFactory((_props, ref) => {
  const props = useProps("Card", defaultProps$P, _props), { classNames, className, style: style2, styles, unstyled, vars, children: children2, padding, ...others } = props, getStyles2 = useStyles({
    name: "Card",
    props,
    classes: classes$n,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$m
  }), _children = Children.toArray(children2), content2 = _children.map((child, index2) => typeof child == "object" && child && "type" in child && child.type === CardSection ? cloneElement(child, {
    "data-first-section": index2 === 0 || void 0,
    "data-last-section": index2 === _children.length - 1 || void 0
  }) : child);
  return /* @__PURE__ */ jsx(CardProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsx(Paper, { ref, unstyled, ...getStyles2("root"), ...others, children: content2 }) });
});
Card.classes = classes$n;
Card.displayName = "@mantine/core/Card";
Card.Section = CardSection;
var classes$m = { root: "m_b183c0a2" };
const defaultProps$O = {}, varsResolver$l = (theme2, { color: color2 }) => ({
  root: {
    "--code-bg": color2 ? getThemeColor(color2, theme2) : void 0
  }
}), Code = factory((_props, ref) => {
  const props = useProps("Code", defaultProps$O, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    block,
    variant,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Code",
    props,
    classes: classes$m,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$l
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: block ? "pre" : "code",
      variant,
      ref,
      mod: [{ block }, mod],
      ...getStyles2("root"),
      ...others,
      dir: "ltr"
    }
  );
});
Code.classes = classes$m;
Code.displayName = "@mantine/core/Code";
var classes$l = { root: "m_de3d2490", colorOverlay: "m_862f3d1b", shadowOverlay: "m_98ae7f22", alphaOverlay: "m_95709ac0", childrenOverlay: "m_93e74e3" };
const defaultProps$N = {
  withShadow: !0
}, varsResolver$k = (_, { radius, size: size2 }) => ({
  root: {
    "--cs-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--cs-size": rem(size2)
  }
}), ColorSwatch = polymorphicFactory((_props, ref) => {
  const props = useProps("ColorSwatch", defaultProps$N, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    size: size2,
    radius,
    withShadow,
    children: children2,
    variant,
    ...others
  } = useProps("ColorSwatch", defaultProps$N, props), getStyles2 = useStyles({
    name: "ColorSwatch",
    props,
    classes: classes$l,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$k
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ref,
      variant,
      size: size2,
      ...getStyles2("root", { focusable: !0 }),
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("alphaOverlay") }),
        withShadow && /* @__PURE__ */ jsx("span", { ...getStyles2("shadowOverlay") }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("colorOverlay", { style: { backgroundColor: color2 } }) }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("childrenOverlay"), children: children2 })
      ]
    }
  );
});
ColorSwatch.classes = classes$l;
ColorSwatch.displayName = "@mantine/core/ColorSwatch";
var classes$k = { root: "m_7485cace" };
const defaultProps$M = {}, varsResolver$j = (_, { size: size2, fluid }) => ({
  root: {
    "--container-size": fluid ? void 0 : getSize(size2, "container-size")
  }
}), Container = factory((_props, ref) => {
  const props = useProps("Container", defaultProps$M, _props), { classNames, className, style: style2, styles, unstyled, vars, fluid, mod, ...others } = props, getStyles2 = useStyles({
    name: "Container",
    classes: classes$k,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$j
  });
  return /* @__PURE__ */ jsx(Box$1, { ref, mod: [{ fluid }, mod], ...getStyles2("root"), ...others });
});
Container.classes = classes$k;
Container.displayName = "@mantine/core/Container";
const defaultProps$L = {
  timeout: 1e3
};
function CopyButton$1(props) {
  const { children: children2, timeout: timeout2, value, ...others } = useProps("CopyButton", defaultProps$L, props), clipboard = useClipboard({ timeout: timeout2 });
  return /* @__PURE__ */ jsx(Fragment$1, { children: children2({ copy: () => clipboard.copy(value), copied: clipboard.copied, ...others }) });
}
CopyButton$1.displayName = "@mantine/core/CopyButton";
var classes$j = { root: "m_3eebeb36", label: "m_9e365f20" };
const defaultProps$K = {
  orientation: "horizontal"
}, varsResolver$i = (theme2, { color: color2, variant, size: size2 }) => ({
  root: {
    "--divider-color": color2 ? getThemeColor(color2, theme2) : void 0,
    "--divider-border-style": variant,
    "--divider-size": getSize(size2, "divider-size")
  }
}), Divider$1 = factory((_props, ref) => {
  const props = useProps("Divider", defaultProps$K, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    orientation,
    label: label2,
    labelPosition,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Divider",
    classes: classes$j,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$i
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      mod: [{ orientation, "with-label": !!label2 }, mod],
      ...getStyles2("root"),
      ...others,
      role: "separator",
      children: label2 && /* @__PURE__ */ jsx(Box$1, { component: "span", mod: { position: labelPosition }, ...getStyles2("label"), children: label2 })
    }
  );
});
Divider$1.classes = classes$j;
Divider$1.displayName = "@mantine/core/Divider";
const [DrawerProvider, useDrawerContext] = createSafeContext(
  "Drawer component was not found in tree"
);
var classes$i = { root: "m_f11b401e", header: "m_5a7c2c9", content: "m_b8a05bbd", inner: "m_31cd769a" };
const defaultProps$J = {}, DrawerBody = factory((_props, ref) => {
  const props = useProps("DrawerBody", defaultProps$J, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseBody,
    {
      ref,
      ...ctx.getStyles("body", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerBody.classes = classes$i;
DrawerBody.displayName = "@mantine/core/DrawerBody";
const defaultProps$I = {}, DrawerCloseButton = factory((_props, ref) => {
  const props = useProps("DrawerCloseButton", defaultProps$I, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseCloseButton,
    {
      ref,
      ...ctx.getStyles("close", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerCloseButton.classes = classes$i;
DrawerCloseButton.displayName = "@mantine/core/DrawerCloseButton";
const defaultProps$H = {}, DrawerContent = factory((_props, ref) => {
  const props = useProps("DrawerContent", defaultProps$H, _props), { classNames, className, style: style2, styles, vars, children: children2, radius, __hidden, ...others } = props, ctx = useDrawerContext(), Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ jsx(
    ModalBaseContent,
    {
      ...ctx.getStyles("content", { className, style: style2, styles, classNames }),
      innerProps: ctx.getStyles("inner", { className, style: style2, styles, classNames }),
      ref,
      ...others,
      radius: radius || ctx.radius || 0,
      "data-hidden": __hidden || void 0,
      children: /* @__PURE__ */ jsx(Scroll, { style: { height: "calc(100vh - var(--drawer-offset) * 2)" }, children: children2 })
    }
  );
});
DrawerContent.classes = classes$i;
DrawerContent.displayName = "@mantine/core/DrawerContent";
const defaultProps$G = {}, DrawerHeader = factory((_props, ref) => {
  const props = useProps("DrawerHeader", defaultProps$G, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseHeader,
    {
      ref,
      ...ctx.getStyles("header", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerHeader.classes = classes$i;
DrawerHeader.displayName = "@mantine/core/DrawerHeader";
const defaultProps$F = {}, DrawerOverlay = factory((_props, ref) => {
  const props = useProps("DrawerOverlay", defaultProps$F, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseOverlay,
    {
      ref,
      ...ctx.getStyles("overlay", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerOverlay.classes = classes$i;
DrawerOverlay.displayName = "@mantine/core/DrawerOverlay";
function getDrawerAlign(position) {
  switch (position) {
    case "top":
      return "flex-start";
    case "bottom":
      return "flex-end";
    default:
      return;
  }
}
function getDrawerFlex(position) {
  if (position === "top" || position === "bottom")
    return "0 0 calc(100% - var(--drawer-offset, 0rem) * 2)";
}
const transitions = {
  top: "slide-down",
  bottom: "slide-up",
  left: "slide-right",
  right: "slide-left"
}, rtlTransitions = {
  top: "slide-down",
  bottom: "slide-up",
  right: "slide-right",
  left: "slide-left"
}, defaultProps$E = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  position: "left"
}, varsResolver$h = (_, { position, size: size2, offset: offset2 }) => ({
  root: {
    "--drawer-size": getSize(size2, "drawer-size"),
    "--drawer-flex": getDrawerFlex(position),
    "--drawer-height": position === "left" || position === "right" ? void 0 : "var(--drawer-size)",
    "--drawer-align": getDrawerAlign(position),
    "--drawer-justify": position === "right" ? "flex-end" : void 0,
    "--drawer-offset": rem(offset2)
  }
}), DrawerRoot = factory((_props, ref) => {
  const props = useProps("DrawerRoot", defaultProps$E, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    scrollAreaComponent,
    position,
    transitionProps,
    radius,
    ...others
  } = props, { dir } = useDirection(), getStyles2 = useStyles({
    name: "Drawer",
    classes: classes$i,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$h
  }), drawerTransition = (dir === "rtl" ? rtlTransitions : transitions)[position];
  return /* @__PURE__ */ jsx(DrawerProvider, { value: { scrollAreaComponent, getStyles: getStyles2, radius }, children: /* @__PURE__ */ jsx(
    ModalBase,
    {
      ref,
      ...getStyles2("root"),
      transitionProps: { transition: drawerTransition, ...transitionProps },
      unstyled,
      ...others
    }
  ) });
});
DrawerRoot.classes = classes$i;
DrawerRoot.displayName = "@mantine/core/DrawerRoot";
const [DrawerStackProvider, useDrawerStackContext] = createOptionalContext();
function DrawerStack({ children: children2 }) {
  const [stack, setStack] = useState([]), [maxZIndex, setMaxZIndex] = useState(getDefaultZIndex("modal"));
  return /* @__PURE__ */ jsx(
    DrawerStackProvider,
    {
      value: {
        stack,
        addModal: (id2, zIndex) => {
          setStack((current) => [.../* @__PURE__ */ new Set([...current, id2])]), setMaxZIndex(
            (current) => typeof zIndex == "number" && typeof current == "number" ? Math.max(current, zIndex) : current
          );
        },
        removeModal: (id2) => setStack((current) => current.filter((currentId) => currentId !== id2)),
        getZIndex: (id2) => `calc(${maxZIndex} + ${stack.indexOf(id2)} + 1)`,
        currentId: stack[stack.length - 1],
        maxZIndex
      },
      children: children2
    }
  );
}
DrawerStack.displayName = "@mantine/core/DrawerStack";
const defaultProps$D = {}, DrawerTitle = factory((_props, ref) => {
  const props = useProps("DrawerTitle", defaultProps$D, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseTitle,
    {
      ref,
      ...ctx.getStyles("title", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerTitle.classes = classes$i;
DrawerTitle.displayName = "@mantine/core/DrawerTitle";
const defaultProps$C = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  withOverlay: !0,
  withCloseButton: !0
}, Drawer = factory((_props, ref) => {
  const {
    title: title2,
    withOverlay,
    overlayProps,
    withCloseButton,
    closeButtonProps,
    children: children2,
    opened,
    stackId,
    zIndex,
    ...others
  } = useProps("Drawer", defaultProps$C, _props), ctx = useDrawerStackContext(), hasHeader = !!title2 || withCloseButton, stackProps = ctx && stackId ? {
    closeOnEscape: ctx.currentId === stackId,
    trapFocus: ctx.currentId === stackId,
    zIndex: ctx.getZIndex(stackId)
  } : {}, overlayVisible = withOverlay === !1 ? !1 : stackId && ctx ? ctx.currentId === stackId : opened;
  return useEffect(() => {
    ctx && stackId && (opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId));
  }, [opened, stackId, zIndex]), /* @__PURE__ */ jsxs(
    DrawerRoot,
    {
      ref,
      opened,
      zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
      ...others,
      ...stackProps,
      children: [
        withOverlay && /* @__PURE__ */ jsx(
          DrawerOverlay,
          {
            visible: overlayVisible,
            transitionProps: ctx && stackId ? { duration: 0 } : void 0,
            ...overlayProps
          }
        ),
        /* @__PURE__ */ jsxs(DrawerContent, { __hidden: ctx && stackId && opened ? stackId !== ctx.currentId : !1, children: [
          hasHeader && /* @__PURE__ */ jsxs(DrawerHeader, { children: [
            title2 && /* @__PURE__ */ jsx(DrawerTitle, { children: title2 }),
            withCloseButton && /* @__PURE__ */ jsx(DrawerCloseButton, { ...closeButtonProps })
          ] }),
          /* @__PURE__ */ jsx(DrawerBody, { children: children2 })
        ] })
      ]
    }
  );
});
Drawer.classes = classes$i;
Drawer.displayName = "@mantine/core/Drawer";
Drawer.Root = DrawerRoot;
Drawer.Overlay = DrawerOverlay;
Drawer.Content = DrawerContent;
Drawer.Body = DrawerBody;
Drawer.Header = DrawerHeader;
Drawer.Title = DrawerTitle;
Drawer.CloseButton = DrawerCloseButton;
Drawer.Stack = DrawerStack;
function useDelayedHover({ open, close, openDelay, closeDelay }) {
  const openTimeout = useRef(-1), closeTimeout = useRef(-1), clearTimeouts = () => {
    window.clearTimeout(openTimeout.current), window.clearTimeout(closeTimeout.current);
  }, openDropdown = () => {
    clearTimeouts(), openDelay === 0 || openDelay === void 0 ? open() : openTimeout.current = window.setTimeout(open, openDelay);
  }, closeDropdown = () => {
    clearTimeouts(), closeDelay === 0 || closeDelay === void 0 ? close() : closeTimeout.current = window.setTimeout(close, closeDelay);
  };
  return useEffect(() => clearTimeouts, []), { openDropdown, closeDropdown };
}
const [GridProvider, useGridContext] = createSafeContext(
  "Grid component was not found in tree"
), getColumnFlexBasis = (colSpan, columns) => colSpan === "content" ? "auto" : colSpan === "auto" ? "0rem" : colSpan ? `${100 / (columns / colSpan)}%` : void 0, getColumnMaxWidth = (colSpan, columns, grow) => grow || colSpan === "auto" ? "100%" : colSpan === "content" ? "unset" : getColumnFlexBasis(colSpan, columns), getColumnFlexGrow = (colSpan, grow) => {
  if (colSpan)
    return colSpan === "auto" || grow ? "1" : "auto";
}, getColumnOffset = (offset2, columns) => offset2 === 0 ? "0" : offset2 ? `${100 / (columns / offset2)}%` : void 0;
function GridColVariables({ span, order, offset: offset2, selector: selector3 }) {
  const theme2 = useMantineTheme(), ctx = useGridContext(), _breakpoints = ctx.breakpoints || theme2.breakpoints, baseSpan = getBaseValue$1(span) === void 0 ? 12 : getBaseValue$1(span), baseStyles = filterProps$1({
    "--col-order": getBaseValue$1(order)?.toString(),
    "--col-flex-grow": getColumnFlexGrow(baseSpan, ctx.grow),
    "--col-flex-basis": getColumnFlexBasis(baseSpan, ctx.columns),
    "--col-width": baseSpan === "content" ? "auto" : void 0,
    "--col-max-width": getColumnMaxWidth(baseSpan, ctx.columns, ctx.grow),
    "--col-offset": getColumnOffset(getBaseValue$1(offset2), ctx.columns)
  }), queries = keys$1(_breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof order == "object" && order[breakpoint] !== void 0 && (acc[breakpoint]["--col-order"] = order[breakpoint]?.toString()), typeof span == "object" && span[breakpoint] !== void 0 && (acc[breakpoint]["--col-flex-grow"] = getColumnFlexGrow(span[breakpoint], ctx.grow), acc[breakpoint]["--col-flex-basis"] = getColumnFlexBasis(span[breakpoint], ctx.columns), acc[breakpoint]["--col-width"] = span[breakpoint] === "content" ? "auto" : void 0, acc[breakpoint]["--col-max-width"] = getColumnMaxWidth(
      span[breakpoint],
      ctx.columns,
      ctx.grow
    )), typeof offset2 == "object" && offset2[breakpoint] !== void 0 && (acc[breakpoint]["--col-offset"] = getColumnOffset(offset2[breakpoint], ctx.columns)), acc),
    {}
  ), values2 = getSortedBreakpoints(keys$1(queries), _breakpoints).filter(
    (breakpoint) => keys$1(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: ctx.type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(
    InlineStyles,
    {
      styles: baseStyles,
      media: ctx.type === "container" ? void 0 : values2,
      container: ctx.type === "container" ? values2 : void 0,
      selector: selector3
    }
  );
}
var classes$h = { container: "m_8478a6da", root: "m_410352e9", inner: "m_dee7bd2f", col: "m_96bdd299" };
const defaultProps$B = {
  span: 12
}, GridCol = factory((_props, ref) => {
  const props = useProps("GridCol", defaultProps$B, _props), { classNames, className, style: style2, styles, vars, span, order, offset: offset2, ...others } = props, ctx = useGridContext(), responsiveClassName = useRandomClassName();
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      GridColVariables,
      {
        selector: `.${responsiveClassName}`,
        span,
        order,
        offset: offset2
      }
    ),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        ref,
        ...ctx.getStyles("col", {
          className: clsx(className, responsiveClassName),
          style: style2,
          classNames,
          styles
        }),
        ...others
      }
    )
  ] });
});
GridCol.classes = classes$h;
GridCol.displayName = "@mantine/core/GridCol";
function GridVariables({ gutter, selector: selector3, breakpoints, type }) {
  const theme2 = useMantineTheme(), _breakpoints = breakpoints || theme2.breakpoints, baseStyles = filterProps$1({
    "--grid-gutter": getSpacing(getBaseValue$1(gutter))
  }), queries = keys$1(_breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof gutter == "object" && gutter[breakpoint] !== void 0 && (acc[breakpoint]["--grid-gutter"] = getSpacing(gutter[breakpoint])), acc),
    {}
  ), values2 = getSortedBreakpoints(keys$1(queries), _breakpoints).filter(
    (breakpoint) => keys$1(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(
    InlineStyles,
    {
      styles: baseStyles,
      media: type === "container" ? void 0 : values2,
      container: type === "container" ? values2 : void 0,
      selector: selector3
    }
  );
}
const defaultProps$A = {
  gutter: "md",
  grow: !1,
  columns: 12
}, varsResolver$g = (_, { justify, align, overflow }) => ({
  root: {
    "--grid-justify": justify,
    "--grid-align": align,
    "--grid-overflow": overflow
  }
}), Grid = factory((_props, ref) => {
  const props = useProps("Grid", defaultProps$A, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    grow,
    gutter,
    columns,
    align,
    justify,
    children: children2,
    breakpoints,
    type,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Grid",
    classes: classes$h,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$g
  }), responsiveClassName = useRandomClassName();
  return type === "container" && breakpoints ? /* @__PURE__ */ jsxs(GridProvider, { value: { getStyles: getStyles2, grow, columns: columns || 12, breakpoints, type }, children: [
    /* @__PURE__ */ jsx(GridVariables, { selector: `.${responsiveClassName}`, ...props }),
    /* @__PURE__ */ jsx("div", { ...getStyles2("container"), children: /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others, children: /* @__PURE__ */ jsx("div", { ...getStyles2("inner"), children: children2 }) }) })
  ] }) : /* @__PURE__ */ jsxs(GridProvider, { value: { getStyles: getStyles2, grow, columns: columns || 12, breakpoints, type }, children: [
    /* @__PURE__ */ jsx(GridVariables, { selector: `.${responsiveClassName}`, ...props }),
    /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others, children: /* @__PURE__ */ jsx("div", { ...getStyles2("inner"), children: children2 }) })
  ] });
});
Grid.classes = classes$h;
Grid.displayName = "@mantine/core/Grid";
Grid.Col = GridCol;
function getMarkColor({ color: color2, theme: theme2, defaultShade }) {
  const parsed = parseThemeColor({ color: color2, theme: theme2 });
  return parsed.isThemeColor ? parsed.shade === void 0 ? `var(--mantine-color-${parsed.color}-${defaultShade})` : `var(${parsed.variable})` : color2;
}
var classes$g = { root: "m_bcb3f3c2" };
const defaultProps$z = {
  color: "yellow"
}, varsResolver$f = (theme2, { color: color2 }) => ({
  root: {
    "--mark-bg-dark": getMarkColor({ color: color2, theme: theme2, defaultShade: 5 }),
    "--mark-bg-light": getMarkColor({ color: color2, theme: theme2, defaultShade: 2 })
  }
}), Mark = factory((_props, ref) => {
  const props = useProps("Mark", defaultProps$z, _props), { classNames, className, style: style2, styles, unstyled, vars, color: color2, variant, ...others } = props, getStyles2 = useStyles({
    name: "Mark",
    props,
    className,
    style: style2,
    classes: classes$g,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$f
  });
  return /* @__PURE__ */ jsx(Box$1, { component: "mark", ref, variant, ...getStyles2("root"), ...others });
});
Mark.classes = classes$g;
Mark.displayName = "@mantine/core/Mark";
function escapeRegex(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
}
function highlighter(value, _highlight) {
  if (_highlight == null)
    return [{ chunk: value, highlighted: !1 }];
  const highlight = Array.isArray(_highlight) ? _highlight.map(escapeRegex) : escapeRegex(_highlight);
  if (!(Array.isArray(highlight) ? highlight.filter((part) => part.trim().length > 0).length > 0 : highlight.trim() !== ""))
    return [{ chunk: value, highlighted: !1 }];
  const matcher2 = typeof highlight == "string" ? highlight.trim() : highlight.filter((part) => part.trim().length !== 0).map((part) => part.trim()).sort((a2, b2) => b2.length - a2.length).join("|"), re = new RegExp(`(${matcher2})`, "gi");
  return value.split(re).map((part) => ({ chunk: part, highlighted: re.test(part) })).filter(({ chunk }) => chunk);
}
const defaultProps$y = {}, Highlight = polymorphicFactory((props, ref) => {
  const { unstyled, children: children2, highlight, highlightStyles, color: color2, ...others } = useProps(
    "Highlight",
    defaultProps$y,
    props
  ), highlightChunks = highlighter(children2, highlight);
  return /* @__PURE__ */ jsx(Text, { unstyled, ref, ...others, __staticSelector: "Highlight", children: highlightChunks.map(
    ({ chunk, highlighted }, i2) => highlighted ? /* @__PURE__ */ jsx(
      Mark,
      {
        unstyled,
        color: color2,
        style: highlightStyles,
        "data-highlight": chunk,
        children: chunk
      },
      i2
    ) : /* @__PURE__ */ jsx("span", { children: chunk }, i2)
  ) });
});
Highlight.classes = Text.classes;
Highlight.displayName = "@mantine/core/Highlight";
const [HoverCardContextProvider, useHoverCardContext] = createSafeContext(
  "HoverCard component was not found in the tree"
), defaultProps$x = {};
function HoverCardDropdown(props) {
  const { children: children2, onMouseEnter, onMouseLeave, ...others } = useProps(
    "HoverCardDropdown",
    defaultProps$x,
    props
  ), ctx = useHoverCardContext(), handleMouseEnter = createEventHandler(onMouseEnter, ctx.openDropdown), handleMouseLeave = createEventHandler(onMouseLeave, ctx.closeDropdown);
  return /* @__PURE__ */ jsx(Popover.Dropdown, { onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...others, children: children2 });
}
HoverCardDropdown.displayName = "@mantine/core/HoverCardDropdown";
const defaultProps$w = {
  refProp: "ref"
}, HoverCardTarget = forwardRef((props, ref) => {
  const { children: children2, refProp, eventPropsWrapperName, ...others } = useProps(
    "HoverCardTarget",
    defaultProps$w,
    props
  );
  if (!isElement$1(children2))
    throw new Error(
      "HoverCard.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useHoverCardContext(), onMouseEnter = createEventHandler(children2.props.onMouseEnter, ctx.openDropdown), onMouseLeave = createEventHandler(children2.props.onMouseLeave, ctx.closeDropdown), eventListeners = { onMouseEnter, onMouseLeave };
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, ref, ...others, children: cloneElement(
    children2,
    eventPropsWrapperName ? { [eventPropsWrapperName]: eventListeners } : eventListeners
  ) });
});
HoverCardTarget.displayName = "@mantine/core/HoverCardTarget";
const defaultProps$v = {
  openDelay: 0,
  closeDelay: 150,
  initiallyOpened: !1
};
function HoverCard(props) {
  const { children: children2, onOpen, onClose, openDelay, closeDelay, initiallyOpened, ...others } = useProps(
    "HoverCard",
    defaultProps$v,
    props
  ), [opened, { open, close }] = useDisclosure(initiallyOpened, { onClose, onOpen }), { openDropdown, closeDropdown } = useDelayedHover({ open, close, openDelay, closeDelay });
  return /* @__PURE__ */ jsx(HoverCardContextProvider, { value: { openDropdown, closeDropdown }, children: /* @__PURE__ */ jsx(Popover, { ...others, opened, __staticSelector: "HoverCard", children: children2 }) });
}
HoverCard.displayName = "@mantine/core/HoverCard";
HoverCard.Target = HoverCardTarget;
HoverCard.Dropdown = HoverCardDropdown;
HoverCard.extend = (input2) => input2;
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
var useIsomorphicLayoutEffect_cjs = {}, hasRequiredUseIsomorphicLayoutEffect_cjs;
function requireUseIsomorphicLayoutEffect_cjs() {
  return hasRequiredUseIsomorphicLayoutEffect_cjs || (hasRequiredUseIsomorphicLayoutEffect_cjs = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var react = React__default, isClient = typeof document < "u", index2 = isClient ? react.useLayoutEffect : react.useEffect;
    exports.default = index2;
  }(useIsomorphicLayoutEffect_cjs)), useIsomorphicLayoutEffect_cjs;
}
var classes$f = { root: "m_6e45937b", loader: "m_e8eb006c", overlay: "m_df587f17" };
const defaultProps$u = {
  transitionProps: { transition: "fade", duration: 0 },
  overlayProps: { backgroundOpacity: 0.75 },
  zIndex: getDefaultZIndex("overlay")
}, varsResolver$e = (_, { zIndex }) => ({
  root: {
    "--lo-z-index": zIndex?.toString()
  }
}), LoadingOverlay = factory((_props, ref) => {
  const props = useProps("LoadingOverlay", defaultProps$u, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    transitionProps,
    loaderProps,
    overlayProps,
    visible: visible2,
    zIndex,
    ...others
  } = props, theme2 = useMantineTheme(), getStyles2 = useStyles({
    name: "LoadingOverlay",
    classes: classes$f,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$e
  }), _overlayProps = { ...defaultProps$u.overlayProps, ...overlayProps };
  return /* @__PURE__ */ jsx(Transition$1, { transition: "fade", ...transitionProps, mounted: !!visible2, children: (transitionStyles) => /* @__PURE__ */ jsxs(Box$1, { ...getStyles2("root", { style: transitionStyles }), ref, ...others, children: [
    /* @__PURE__ */ jsx(Loader, { ...getStyles2("loader"), unstyled, ...loaderProps }),
    /* @__PURE__ */ jsx(
      Overlay$1,
      {
        ..._overlayProps,
        ...getStyles2("overlay"),
        darkHidden: !0,
        unstyled,
        color: overlayProps?.color || theme2.white
      }
    ),
    /* @__PURE__ */ jsx(
      Overlay$1,
      {
        ..._overlayProps,
        ...getStyles2("overlay"),
        lightHidden: !0,
        unstyled,
        color: overlayProps?.color || theme2.colors.dark[5]
      }
    )
  ] }) });
});
LoadingOverlay.classes = classes$f;
LoadingOverlay.displayName = "@mantine/core/LoadingOverlay";
const [MenuContextProvider, useMenuContext] = createSafeContext(
  "Menu component was not found in the tree"
);
var classes$e = { dropdown: "m_dc9b7c9f", label: "m_9bfac126", divider: "m_efdf90cb", item: "m_99ac2aa1", itemLabel: "m_5476e0d3", itemSection: "m_8b75e504" };
const defaultProps$t = {}, MenuDivider = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "MenuDivider",
    defaultProps$t,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("divider", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
MenuDivider.classes = classes$e;
MenuDivider.displayName = "@mantine/core/MenuDivider";
const defaultProps$s = {}, MenuDropdown = factory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onMouseEnter,
    onMouseLeave,
    onKeyDown,
    children: children2,
    ...others
  } = useProps("MenuDropdown", defaultProps$s, props), wrapperRef = useRef(null), ctx = useMenuContext(), handleKeyDown = createEventHandler(onKeyDown, (event) => {
    (event.key === "ArrowUp" || event.key === "ArrowDown") && (event.preventDefault(), wrapperRef.current?.querySelectorAll("[data-menu-item]:not(:disabled)")[0]?.focus());
  }), handleMouseEnter = createEventHandler(
    onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), handleMouseLeave = createEventHandler(
    onMouseLeave,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.closeDropdown()
  );
  return /* @__PURE__ */ jsxs(
    Popover.Dropdown,
    {
      ...others,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      role: "menu",
      "aria-orientation": "vertical",
      ref: useMergedRef(ref, wrapperRef),
      ...ctx.getStyles("dropdown", {
        className,
        style: style2,
        styles,
        classNames,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      onKeyDown: handleKeyDown,
      children: [
        ctx.withInitialFocusPlaceholder && /* @__PURE__ */ jsx("div", { tabIndex: -1, "data-autofocus": !0, "data-mantine-stop-propagation": !0, style: { outline: 0 } }),
        children2
      ]
    }
  );
});
MenuDropdown.classes = classes$e;
MenuDropdown.displayName = "@mantine/core/MenuDropdown";
const defaultProps$r = {}, MenuItem = polymorphicFactory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    color: color2,
    closeMenuOnClick,
    leftSection,
    rightSection,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    ...others
  } = useProps("MenuItem", defaultProps$r, props), ctx = useMenuContext(), theme2 = useMantineTheme(), { dir } = useDirection(), itemRef = useRef(null), itemIndex = ctx.getItemIndex(itemRef.current), _others = others, handleMouseLeave = createEventHandler(_others.onMouseLeave, () => ctx.setHovered(-1)), handleMouseEnter = createEventHandler(
    _others.onMouseEnter,
    () => ctx.setHovered(ctx.getItemIndex(itemRef.current))
  ), handleClick = createEventHandler(_others.onClick, () => {
    dataDisabled || (typeof closeMenuOnClick == "boolean" ? closeMenuOnClick && ctx.closeDropdownImmediately() : ctx.closeOnItemClick && ctx.closeDropdownImmediately());
  }), handleFocus = createEventHandler(
    _others.onFocus,
    () => ctx.setHovered(ctx.getItemIndex(itemRef.current))
  ), colors2 = color2 ? theme2.variantColorResolver({ color: color2, theme: theme2, variant: "light" }) : void 0, parsedThemeColor = color2 ? parseThemeColor({ color: color2, theme: theme2 }) : null;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...others,
      unstyled: ctx.unstyled,
      tabIndex: ctx.menuItemTabIndex,
      onFocus: handleFocus,
      ...ctx.getStyles("item", { className, style: style2, styles, classNames }),
      ref: useMergedRef(itemRef, ref),
      role: "menuitem",
      disabled,
      "data-menu-item": !0,
      "data-disabled": disabled || dataDisabled || void 0,
      "data-hovered": ctx.hovered === itemIndex ? !0 : void 0,
      "data-mantine-stop-propagation": !0,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick,
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-menu-item]:not([data-disabled])",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: ctx.loop,
        dir,
        orientation: "vertical",
        onKeyDown: _others.onKeyDown
      }),
      __vars: {
        "--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors2?.color,
        "--menu-item-hover": colors2?.hover
      },
      children: [
        leftSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemLabel", { styles, classNames }), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "right", children: rightSection })
      ]
    }
  );
});
MenuItem.classes = classes$e;
MenuItem.displayName = "@mantine/core/MenuItem";
const defaultProps$q = {}, MenuLabel = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "MenuLabel",
    defaultProps$q,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("label", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
MenuLabel.classes = classes$e;
MenuLabel.displayName = "@mantine/core/MenuLabel";
const defaultProps$p = {
  refProp: "ref"
}, MenuTarget = forwardRef((props, ref) => {
  const { children: children2, refProp, ...others } = useProps("MenuTarget", defaultProps$p, props);
  if (!isElement$1(children2))
    throw new Error(
      "Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useMenuContext(), _childrenProps = children2.props, onClick = createEventHandler(_childrenProps.onClick, () => {
    ctx.trigger === "click" ? ctx.toggleDropdown() : ctx.trigger === "click-hover" && (ctx.setOpenedViaClick(!0), ctx.opened || ctx.openDropdown());
  }), onMouseEnter = createEventHandler(
    _childrenProps.onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), onMouseLeave = createEventHandler(_childrenProps.onMouseLeave, () => {
    (ctx.trigger === "hover" || ctx.trigger === "click-hover" && !ctx.openedViaClick) && ctx.closeDropdown();
  });
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, popupType: "menu", ref, ...others, children: cloneElement(children2, {
    onClick,
    onMouseEnter,
    onMouseLeave,
    "data-expanded": ctx.opened ? !0 : void 0
  }) });
});
MenuTarget.displayName = "@mantine/core/MenuTarget";
const defaultProps$o = {
  trapFocus: !0,
  closeOnItemClick: !0,
  withInitialFocusPlaceholder: !0,
  clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100,
  menuItemTabIndex: -1
};
function Menu(_props) {
  const props = useProps("Menu", defaultProps$o, _props), {
    children: children2,
    onOpen,
    onClose,
    opened,
    defaultOpened,
    trapFocus,
    onChange,
    closeOnItemClick,
    loop,
    closeOnEscape: closeOnEscape2,
    trigger,
    openDelay,
    closeDelay,
    classNames,
    styles,
    unstyled,
    variant,
    vars,
    menuItemTabIndex,
    keepMounted,
    withInitialFocusPlaceholder,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Menu",
    classes: classes$e,
    props,
    classNames,
    styles,
    unstyled
  }), [hovered, { setHovered, resetHovered }] = useHovered(), [_opened, setOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange
  }), [openedViaClick, setOpenedViaClick] = useState(!1), close = () => {
    setOpened(!1), setOpenedViaClick(!1), _opened && onClose?.();
  }, open = () => {
    setOpened(!0), !_opened && onOpen?.();
  }, toggleDropdown = () => {
    _opened ? close() : open();
  }, { openDropdown, closeDropdown } = useDelayedHover({ open, close, closeDelay, openDelay }), getItemIndex = (node2) => getContextItemIndex("[data-menu-item]", "[data-menu-dropdown]", node2), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return useDidUpdate(() => {
    resetHovered();
  }, [_opened]), /* @__PURE__ */ jsx(
    MenuContextProvider,
    {
      value: {
        getStyles: getStyles2,
        opened: _opened,
        toggleDropdown,
        getItemIndex,
        hovered,
        setHovered,
        openedViaClick,
        setOpenedViaClick,
        closeOnItemClick,
        closeDropdown: trigger === "click" ? close : closeDropdown,
        openDropdown: trigger === "click" ? open : openDropdown,
        closeDropdownImmediately: close,
        loop,
        trigger,
        unstyled,
        menuItemTabIndex,
        withInitialFocusPlaceholder
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          ...others,
          opened: _opened,
          onChange: toggleDropdown,
          defaultOpened,
          trapFocus: keepMounted ? !1 : trapFocus,
          closeOnEscape: closeOnEscape2,
          __staticSelector: "Menu",
          classNames: resolvedClassNames,
          styles: resolvedStyles,
          unstyled,
          variant,
          keepMounted,
          children: children2
        }
      )
    }
  );
}
Menu.extend = (input2) => input2;
Menu.withProps = getWithProps(Menu);
Menu.classes = classes$e;
Menu.displayName = "@mantine/core/Menu";
Menu.Item = MenuItem;
Menu.Label = MenuLabel;
Menu.Dropdown = MenuDropdown;
Menu.Target = MenuTarget;
Menu.Divider = MenuDivider;
const [ModalProvider, useModalContext] = createSafeContext(
  "Modal component was not found in tree"
);
var classes$d = { root: "m_9df02822", content: "m_54c44539", inner: "m_1f958f16", header: "m_d0e2b9cd" };
const defaultProps$n = {}, ModalBody = factory((_props, ref) => {
  const props = useProps("ModalBody", defaultProps$n, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseBody,
    {
      ref,
      ...ctx.getStyles("body", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalBody.classes = classes$d;
ModalBody.displayName = "@mantine/core/ModalBody";
const defaultProps$m = {}, ModalContent = factory((_props, ref) => {
  const props = useProps("ModalContent", defaultProps$m, _props), { classNames, className, style: style2, styles, vars, children: children2, __hidden, ...others } = props, ctx = useModalContext(), Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ jsx(
    ModalBaseContent,
    {
      ...ctx.getStyles("content", { className, style: style2, styles, classNames }),
      innerProps: ctx.getStyles("inner", { className, style: style2, styles, classNames }),
      "data-full-screen": ctx.fullScreen || void 0,
      "data-modal-content": !0,
      "data-hidden": __hidden || void 0,
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        Scroll,
        {
          style: {
            maxHeight: ctx.fullScreen ? "100dvh" : `calc(100dvh - (${rem(ctx.yOffset)} * 2))`
          },
          children: children2
        }
      )
    }
  );
});
ModalContent.classes = classes$d;
ModalContent.displayName = "@mantine/core/ModalContent";
const defaultProps$l = {}, ModalOverlay = factory((_props, ref) => {
  const props = useProps("ModalOverlay", defaultProps$l, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseOverlay,
    {
      ref,
      ...ctx.getStyles("overlay", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalOverlay.classes = classes$d;
ModalOverlay.displayName = "@mantine/core/ModalOverlay";
const defaultProps$k = {
  __staticSelector: "Modal",
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  yOffset: "5dvh"
}, varsResolver$d = (_, { radius, size: size2, yOffset, xOffset }) => ({
  root: {
    "--modal-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--modal-size": getSize(size2, "modal-size"),
    "--modal-y-offset": rem(yOffset),
    "--modal-x-offset": rem(xOffset)
  }
}), ModalRoot = factory((_props, ref) => {
  const props = useProps("ModalRoot", defaultProps$k, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    yOffset,
    scrollAreaComponent,
    radius,
    fullScreen,
    centered,
    xOffset,
    __staticSelector,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    classes: classes$d,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$d
  });
  return /* @__PURE__ */ jsx(ModalProvider, { value: { yOffset, scrollAreaComponent, getStyles: getStyles2, fullScreen }, children: /* @__PURE__ */ jsx(
    ModalBase,
    {
      ref,
      ...getStyles2("root"),
      "data-full-screen": fullScreen || void 0,
      "data-centered": centered || void 0,
      unstyled,
      ...others
    }
  ) });
});
ModalRoot.classes = classes$d;
ModalRoot.displayName = "@mantine/core/ModalRoot";
const [PillsInputProvider, usePillsInputContext] = createOptionalContext(), [PillGroupProvider, usePillGroupContext] = createOptionalContext();
var classes$c = { root: "m_7cda1cd6", "root--default": "m_44da308b", "root--contrast": "m_e3a01f8", label: "m_1e0e6180", remove: "m_ae386778", group: "m_1dcfd90b" };
const defaultProps$j = {}, varsResolver$c = (_, { gap }, { size: size2 }) => ({
  group: {
    "--pg-gap": gap !== void 0 ? getSize(gap) : getSize(size2, "pg-gap")
  }
}), PillGroup = factory((_props, ref) => {
  const props = useProps("PillGroup", defaultProps$j, _props), { classNames, className, style: style2, styles, unstyled, vars, size: size2, disabled, ...others } = props, _size = usePillsInputContext()?.size || size2 || void 0, getStyles2 = useStyles({
    name: "PillGroup",
    classes: classes$c,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$c,
    stylesCtx: { size: _size },
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(PillGroupProvider, { value: { size: _size, disabled }, children: /* @__PURE__ */ jsx(Box$1, { ref, size: _size, ...getStyles2("group"), ...others }) });
});
PillGroup.classes = classes$c;
PillGroup.displayName = "@mantine/core/PillGroup";
const defaultProps$i = {
  variant: "default"
}, varsResolver$b = (_, { radius }, { size: size2 }) => ({
  root: {
    "--pill-fz": getSize(size2, "pill-fz"),
    "--pill-height": getSize(size2, "pill-height"),
    "--pill-radius": radius === void 0 ? void 0 : getRadius$1(radius)
  }
}), Pill = factory((_props, ref) => {
  const props = useProps("Pill", defaultProps$i, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    variant,
    children: children2,
    withRemoveButton,
    onRemove: onRemove2,
    removeButtonProps,
    radius,
    size: size2,
    disabled,
    mod,
    ...others
  } = props, ctx = usePillGroupContext(), pillsInputCtx = usePillsInputContext(), _size = size2 || ctx?.size || void 0, _variant = pillsInputCtx?.variant === "filled" ? "contrast" : variant || "default", getStyles2 = useStyles({
    name: "Pill",
    classes: classes$c,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$b,
    stylesCtx: { size: _size }
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      component: "span",
      ref,
      variant: _variant,
      size: _size,
      ...getStyles2("root", { variant: _variant }),
      mod: [
        { "with-remove": withRemoveButton && !disabled, disabled: disabled || ctx?.disabled },
        mod
      ],
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children: children2 }),
        withRemoveButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            variant: "transparent",
            radius,
            tabIndex: -1,
            "aria-hidden": !0,
            unstyled,
            ...removeButtonProps,
            ...getStyles2("remove", {
              className: removeButtonProps?.className,
              style: removeButtonProps?.style
            }),
            onMouseDown: (event) => {
              event.preventDefault(), event.stopPropagation(), removeButtonProps?.onMouseDown?.(event);
            },
            onClick: (event) => {
              event.stopPropagation(), onRemove2?.(), removeButtonProps?.onClick?.(event);
            }
          }
        )
      ]
    }
  );
});
Pill.classes = classes$c;
Pill.displayName = "@mantine/core/Pill";
Pill.Group = PillGroup;
var classes$b = { root: "m_a513464", icon: "m_a4ceffb", loader: "m_b0920b15", body: "m_a49ed24", title: "m_3feedf16", description: "m_3d733a3a", closeButton: "m_919a4d88" };
const defaultProps$h = {
  withCloseButton: !0
}, varsResolver$a = (theme2, { radius, color: color2 }) => ({
  root: {
    "--notification-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--notification-color": color2 ? getThemeColor(color2, theme2) : void 0
  }
}), Notification = factory((_props, ref) => {
  const props = useProps("Notification", defaultProps$h, _props), {
    className,
    color: color2,
    radius,
    loading,
    withCloseButton,
    withBorder,
    title: title2,
    icon: icon2,
    children: children2,
    onClose,
    closeButtonProps,
    classNames,
    style: style2,
    styles,
    unstyled,
    variant,
    vars,
    mod,
    loaderProps,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Notification",
    classes: classes$b,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$a
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("root"),
      mod: [{ "data-with-icon": !!icon2 || loading, "data-with-border": withBorder }, mod],
      ref,
      variant,
      ...others,
      role: "alert",
      children: [
        icon2 && !loading && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon2 }),
        loading && /* @__PURE__ */ jsx(Loader, { size: 28, color: color2, ...loaderProps, ...getStyles2("loader") }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title2 && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), children: title2 }),
          /* @__PURE__ */ jsx(Box$1, { ...getStyles2("description"), mod: { "data-with-title": !!title2 }, children: children2 })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            iconSize: 16,
            color: "gray",
            ...closeButtonProps,
            unstyled,
            onClick: onClose,
            ...getStyles2("closeButton")
          }
        )
      ]
    }
  );
});
Notification.classes = classes$b;
Notification.displayName = "@mantine/core/Notification";
const defaultTransition = {
  duration: 100,
  transition: "fade"
};
function getTransitionProps(transitionProps, componentTransition) {
  return { ...defaultTransition, ...componentTransition, ...transitionProps };
}
function useFloatingTooltip({
  offset: offset2,
  position,
  defaultOpened
}) {
  const [opened, setOpened] = useState(defaultOpened), boundaryRef = useRef(null), { x: x2, y: y2, elements, refs, update, placement } = useFloating({
    placement: position,
    middleware: [
      shift({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), horizontalOffset = placement.includes("right") ? offset2 : position.includes("left") ? offset2 * -1 : 0, verticalOffset = placement.includes("bottom") ? offset2 : position.includes("top") ? offset2 * -1 : 0, handleMouseMove = useCallback(
    ({ clientX, clientY }) => {
      refs.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: clientX,
            y: clientY,
            left: clientX + horizontalOffset,
            top: clientY + verticalOffset,
            right: clientX,
            bottom: clientY
          };
        }
      });
    },
    [elements.reference]
  );
  return useEffect(() => {
    if (refs.floating.current) {
      const boundary = boundaryRef.current;
      boundary.addEventListener("mousemove", handleMouseMove);
      const parents = getOverflowAncestors(refs.floating.current);
      return parents.forEach((parent) => {
        parent.addEventListener("scroll", update);
      }), () => {
        boundary.removeEventListener("mousemove", handleMouseMove), parents.forEach((parent) => {
          parent.removeEventListener("scroll", update);
        });
      };
    }
  }, [elements.reference, refs.floating.current, update, handleMouseMove, opened]), { handleMouseMove, x: x2, y: y2, opened, setOpened, boundaryRef, floating: refs.setFloating };
}
var classes$a = { tooltip: "m_1b3c8819", arrow: "m_f898399f" };
const defaultProps$g = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  defaultOpened: !1,
  position: "right",
  zIndex: getDefaultZIndex("popover")
}, varsResolver$9 = (theme2, { radius, color: color2 }) => ({
  tooltip: {
    "--tooltip-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--tooltip-bg": color2 ? getThemeColor(color2, theme2) : void 0,
    "--tooltip-color": color2 ? "var(--mantine-color-white)" : void 0
  }
}), TooltipFloating = factory((_props, ref) => {
  const props = useProps("TooltipFloating", defaultProps$g, _props), {
    children: children2,
    refProp,
    withinPortal,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    radius,
    color: color2,
    label: label2,
    offset: offset2,
    position,
    multiline,
    zIndex,
    disabled,
    defaultOpened,
    variant,
    vars,
    portalProps,
    ...others
  } = props, theme2 = useMantineTheme(), getStyles2 = useStyles({
    name: "TooltipFloating",
    props,
    classes: classes$a,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver$9
  }), { handleMouseMove, x: x2, y: y2, opened, boundaryRef, floating, setOpened } = useFloatingTooltip({
    offset: offset2,
    position,
    defaultOpened
  });
  if (!isElement$1(children2))
    throw new Error(
      "[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const targetRef = useMergedRef(boundaryRef, getRefProp(children2), ref), _childrenProps = children2.props, onMouseEnter = (event) => {
    _childrenProps.onMouseEnter?.(event), handleMouseMove(event), setOpened(!0);
  }, onMouseLeave = (event) => {
    _childrenProps.onMouseLeave?.(event), setOpened(!1);
  };
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Box$1,
      {
        ...others,
        ...getStyles2("tooltip", {
          style: {
            ...getStyleObject(style2, theme2),
            zIndex,
            display: !disabled && opened ? "block" : "none",
            top: (y2 && Math.round(y2)) ?? "",
            left: (x2 && Math.round(x2)) ?? ""
          }
        }),
        variant,
        ref: floating,
        mod: { multiline },
        children: label2
      }
    ) }),
    cloneElement(children2, {
      ..._childrenProps,
      [refProp]: targetRef,
      onMouseEnter,
      onMouseLeave
    })
  ] });
});
TooltipFloating.classes = classes$a;
TooltipFloating.displayName = "@mantine/core/TooltipFloating";
const TooltipGroupContext = createContext(!1), TooltipGroupProvider = TooltipGroupContext.Provider, useTooltipGroupContext = () => useContext(TooltipGroupContext), defaultProps$f = {
  openDelay: 0,
  closeDelay: 0
};
function TooltipGroup(props) {
  const { openDelay, closeDelay, children: children2 } = useProps("TooltipGroup", defaultProps$f, props);
  return /* @__PURE__ */ jsx(TooltipGroupProvider, { value: !0, children: /* @__PURE__ */ jsx(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay }, children: children2 }) });
}
TooltipGroup.displayName = "@mantine/core/TooltipGroup";
TooltipGroup.extend = (c2) => c2;
function getDefaultMiddlewares(middlewares) {
  if (middlewares === void 0)
    return { shift: !0, flip: !0 };
  const result = { ...middlewares };
  return middlewares.shift === void 0 && (result.shift = !0), middlewares.flip === void 0 && (result.flip = !0), result;
}
function getTooltipMiddlewares(settings) {
  const middlewaresOptions = getDefaultMiddlewares(settings.middlewares), middlewares = [offset$1(settings.offset)];
  return middlewaresOptions.shift && middlewares.push(
    shift(
      typeof middlewaresOptions.shift == "boolean" ? { padding: 8 } : { padding: 8, ...middlewaresOptions.shift }
    )
  ), middlewaresOptions.flip && middlewares.push(
    typeof middlewaresOptions.flip == "boolean" ? flip() : flip(middlewaresOptions.flip)
  ), middlewares.push(arrow({ element: settings.arrowRef, padding: settings.arrowOffset })), middlewaresOptions.inline ? middlewares.push(
    typeof middlewaresOptions.inline == "boolean" ? inline() : inline(middlewaresOptions.inline)
  ) : settings.inline && middlewares.push(inline()), middlewares;
}
function useTooltip(settings) {
  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened), opened = typeof settings.opened == "boolean" ? settings.opened : uncontrolledOpened, withinGroup = useTooltipGroupContext(), uid = useId$1(), onChange = useCallback(
    (_opened) => {
      setUncontrolledOpened(_opened), _opened && setCurrentId(uid);
    },
    [uid]
  ), {
    x: x2,
    y: y2,
    context: context2,
    refs,
    update,
    placement,
    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }
  } = useFloating({
    strategy: settings.strategy,
    placement: settings.position,
    open: opened,
    onOpenChange: onChange,
    middleware: getTooltipMiddlewares(settings)
  }), { delay: groupDelay, currentId, setCurrentId } = useDelayGroup(context2, { id: uid }), { getReferenceProps, getFloatingProps } = useInteractions([
    useHover(context2, {
      enabled: settings.events?.hover,
      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },
      mouseOnly: !settings.events?.touch
    }),
    useFocus(context2, { enabled: settings.events?.focus, visibleOnly: !0 }),
    useRole(context2, { role: "tooltip" }),
    // Cannot be used with controlled tooltip, page jumps
    useDismiss(context2, { enabled: typeof settings.opened > "u" })
  ]);
  useFloatingAutoUpdate({
    opened,
    position: settings.position,
    positionDependencies: settings.positionDependencies,
    floating: { refs, update }
  }), useDidUpdate(() => {
    settings.onPositionChange?.(placement);
  }, [placement]);
  const isGroupPhase = opened && currentId && currentId !== uid;
  return {
    x: x2,
    y: y2,
    arrowX,
    arrowY,
    reference: refs.setReference,
    floating: refs.setFloating,
    getFloatingProps,
    getReferenceProps,
    isGroupPhase,
    opened,
    placement
  };
}
const defaultProps$e = {
  position: "top",
  refProp: "ref",
  withinPortal: !0,
  inline: !1,
  defaultOpened: !1,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transitionProps: { duration: 100, transition: "fade" },
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: getDefaultZIndex("popover"),
  positionDependencies: [],
  middlewares: { flip: !0, shift: !0, inline: !1 }
}, varsResolver$8 = (theme2, { radius, color: color2 }) => ({
  tooltip: {
    "--tooltip-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--tooltip-bg": color2 ? getThemeColor(color2, theme2) : void 0,
    "--tooltip-color": color2 ? "var(--mantine-color-white)" : void 0
  }
}), Tooltip$5 = factory((_props, ref) => {
  const props = useProps("Tooltip", defaultProps$e, _props), {
    children: children2,
    position,
    refProp,
    label: label2,
    openDelay,
    closeDelay,
    onPositionChange,
    opened,
    defaultOpened,
    withinPortal,
    radius,
    color: color2,
    classNames,
    styles,
    unstyled,
    style: style2,
    className,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    offset: offset2,
    transitionProps,
    multiline,
    events,
    zIndex,
    disabled,
    positionDependencies,
    onClick,
    onMouseEnter,
    onMouseLeave,
    inline: inline2,
    variant,
    keepMounted,
    vars,
    portalProps,
    mod,
    floatingStrategy,
    middlewares,
    ...others
  } = useProps("Tooltip", defaultProps$e, props), { dir } = useDirection(), arrowRef = useRef(null), tooltip = useTooltip({
    position: getFloatingPosition(dir, position),
    closeDelay,
    openDelay,
    onPositionChange,
    opened,
    defaultOpened,
    events,
    arrowRef,
    arrowOffset,
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    positionDependencies: [...positionDependencies, children2],
    inline: inline2,
    strategy: floatingStrategy,
    middlewares
  }), getStyles2 = useStyles({
    name: "Tooltip",
    props,
    classes: classes$a,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver$8
  });
  if (!isElement$1(children2))
    throw new Error(
      "[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const targetRef = useMergedRef(tooltip.reference, getRefProp(children2), ref), transition = getTransitionProps(transitionProps, { duration: 100, transition: "fade" }), _childrenProps = children2.props;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Transition$1,
      {
        ...transition,
        keepMounted,
        mounted: !disabled && !!tooltip.opened,
        duration: tooltip.isGroupPhase ? 10 : transition.duration,
        children: (transitionStyles) => /* @__PURE__ */ jsxs(
          Box$1,
          {
            ...others,
            "data-fixed": floatingStrategy === "fixed" || void 0,
            variant,
            mod: [{ multiline }, mod],
            ...tooltip.getFloatingProps({
              ref: tooltip.floating,
              className: getStyles2("tooltip").className,
              style: {
                ...getStyles2("tooltip").style,
                ...transitionStyles,
                zIndex,
                top: tooltip.y ?? 0,
                left: tooltip.x ?? 0
              }
            }),
            children: [
              label2,
              /* @__PURE__ */ jsx(
                FloatingArrow,
                {
                  ref: arrowRef,
                  arrowX: tooltip.arrowX,
                  arrowY: tooltip.arrowY,
                  visible: withArrow,
                  position: tooltip.placement,
                  arrowSize,
                  arrowOffset,
                  arrowRadius,
                  arrowPosition,
                  ...getStyles2("arrow")
                }
              )
            ]
          }
        )
      }
    ) }),
    cloneElement(
      children2,
      tooltip.getReferenceProps({
        onClick,
        onMouseEnter,
        onMouseLeave,
        onMouseMove: props.onMouseMove,
        onPointerDown: props.onPointerDown,
        onPointerEnter: props.onPointerEnter,
        className: clsx(className, _childrenProps.className),
        ..._childrenProps,
        [refProp]: targetRef
      })
    )
  ] });
});
Tooltip$5.classes = classes$a;
Tooltip$5.displayName = "@mantine/core/Tooltip";
Tooltip$5.Floating = TooltipFloating;
Tooltip$5.Group = TooltipGroup;
var classes$9 = { root: "m_cf365364", indicator: "m_9e182ccd", label: "m_1738fcb2", input: "m_1714d588", control: "m_69686b9b", innerLabel: "m_78882f40" };
const defaultProps$d = {
  withItemsBorders: !0
}, varsResolver$7 = (theme2, { radius, color: color2, transitionDuration, size: size2, transitionTimingFunction }) => ({
  root: {
    "--sc-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--sc-color": color2 ? getThemeColor(color2, theme2) : void 0,
    "--sc-shadow": color2 ? void 0 : "var(--mantine-shadow-xs)",
    "--sc-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
    "--sc-transition-timing-function": transitionTimingFunction,
    "--sc-padding": getSize(size2, "sc-padding"),
    "--sc-font-size": getFontSize(size2)
  }
}), SegmentedControl = factory((_props, ref) => {
  const props = useProps("SegmentedControl", defaultProps$d, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    data,
    value,
    defaultValue,
    onChange,
    size: size2,
    name,
    disabled,
    readOnly,
    fullWidth,
    orientation,
    radius,
    color: color2,
    transitionDuration,
    transitionTimingFunction,
    variant,
    autoContrast,
    withItemsBorders,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "SegmentedControl",
    props,
    classes: classes$9,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$7
  }), theme2 = useMantineTheme(), _data = data.map(
    (item) => typeof item == "string" ? { label: item, value: item } : item
  ), initialized = useMounted(), [key2, setKey] = useState(randomId()), [parent, setParent] = useState(null), [refs, setRefs] = useState({}), setElementRef = (element, val) => {
    refs[val] = element, setRefs(refs);
  }, [_value, handleValueChange] = useUncontrolled({
    value,
    defaultValue,
    finalValue: Array.isArray(data) ? _data.find((item) => !item.disabled)?.value ?? data[0]?.value ?? null : null,
    onChange
  }), uuid = useId$1(name), controls = _data.map((item) => /* @__PURE__ */ createElement(
    Box$1,
    {
      ...getStyles2("control"),
      mod: { active: _value === item.value, orientation },
      key: item.value
    },
    /* @__PURE__ */ createElement(
      "input",
      {
        ...getStyles2("input"),
        disabled: disabled || item.disabled,
        type: "radio",
        name: uuid,
        value: item.value,
        id: `${uuid}-${item.value}`,
        checked: _value === item.value,
        onChange: () => !readOnly && handleValueChange(item.value),
        "data-focus-ring": theme2.focusRing,
        key: `${item.value}-input`
      }
    ),
    /* @__PURE__ */ createElement(
      Box$1,
      {
        component: "label",
        ...getStyles2("label"),
        mod: {
          active: _value === item.value && !(disabled || item.disabled),
          disabled: disabled || item.disabled,
          "read-only": readOnly
        },
        htmlFor: `${uuid}-${item.value}`,
        ref: (node2) => setElementRef(node2, item.value),
        __vars: {
          "--sc-label-color": color2 !== void 0 ? getContrastColor({ color: color2, theme: theme2, autoContrast }) : void 0
        },
        key: `${item.value}-label`
      },
      /* @__PURE__ */ jsx("span", { ...getStyles2("innerLabel"), children: item.label })
    )
  )), mergedRef = useMergedRef(ref, (node2) => setParent(node2));
  return useShallowEffect(() => {
    setKey(randomId());
  }, [data]), data.length === 0 ? null : /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("root"),
      variant,
      size: size2,
      ref: mergedRef,
      mod: [
        {
          "full-width": fullWidth,
          orientation,
          initialized,
          "with-items-borders": withItemsBorders
        },
        mod
      ],
      ...others,
      role: "radiogroup",
      "data-disabled": disabled,
      children: [
        typeof _value == "string" && /* @__PURE__ */ jsx(
          FloatingIndicator,
          {
            target: refs[_value],
            parent,
            component: "span",
            transitionDuration: "var(--sc-transition-duration)",
            ...getStyles2("indicator")
          },
          key2
        ),
        controls
      ]
    }
  );
});
SegmentedControl.classes = classes$9;
SegmentedControl.displayName = "@mantine/core/SegmentedControl";
const defaultProps$c = {
  searchable: !1,
  withCheckIcon: !0,
  allowDeselect: !0,
  checkIconPosition: "left"
}, Select = factory((_props, ref) => {
  const props = useProps("Select", defaultProps$c, _props), {
    classNames,
    styles,
    unstyled,
    vars,
    dropdownOpened,
    defaultDropdownOpened,
    onDropdownClose,
    onDropdownOpen,
    onFocus,
    onBlur,
    onClick,
    onChange,
    data,
    value,
    defaultValue,
    selectFirstOptionOnChange,
    onOptionSubmit,
    comboboxProps,
    readOnly,
    disabled,
    filter: filter2,
    limit,
    withScrollArea,
    maxDropdownHeight,
    size: size2,
    searchable,
    rightSection,
    checkIconPosition,
    withCheckIcon,
    nothingFoundMessage,
    name,
    form,
    searchValue,
    defaultSearchValue,
    onSearchChange,
    allowDeselect,
    error,
    rightSectionPointerEvents,
    id: id2,
    clearable,
    clearButtonProps,
    hiddenInputProps,
    renderOption,
    onClear,
    autoComplete,
    scrollAreaProps,
    __defaultRightSection,
    __clearSection,
    __clearable,
    chevronColor,
    ...others
  } = props, parsedData = useMemo(() => getParsedComboboxData(data), [data]), optionsLockup = useMemo(() => getOptionsLockup(parsedData), [parsedData]), _id = useId$1(id2), [_value, setValue, controlled] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  }), selectedOption = typeof _value == "string" ? optionsLockup[_value] : void 0, previousSelectedOption = usePrevious$1(selectedOption), [search, setSearch2] = useUncontrolled({
    value: searchValue,
    defaultValue: defaultSearchValue,
    finalValue: selectedOption ? selectedOption.label : "",
    onChange: onSearchChange
  }), combobox = useCombobox({
    opened: dropdownOpened,
    defaultOpened: defaultDropdownOpened,
    onDropdownOpen: () => {
      onDropdownOpen?.(), combobox.updateSelectedOptionIndex("active", { scrollIntoView: !0 });
    },
    onDropdownClose: () => {
      onDropdownClose?.(), combobox.resetSelectedOption();
    }
  }), handleSearchChange = (value2) => {
    setSearch2(value2), combobox.resetSelectedOption();
  }, { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    props,
    styles,
    classNames
  });
  useEffect(() => {
    selectFirstOptionOnChange && combobox.selectFirstOption();
  }, [selectFirstOptionOnChange, search]), useEffect(() => {
    value === null && handleSearchChange(""), typeof value == "string" && selectedOption && (previousSelectedOption?.value !== selectedOption.value || previousSelectedOption?.label !== selectedOption.label) && handleSearchChange(selectedOption.label);
  }, [value, selectedOption]);
  const clearButton = /* @__PURE__ */ jsx(
    Combobox.ClearButton,
    {
      ...clearButtonProps,
      onClear: () => {
        setValue(null, null), handleSearchChange(""), onClear?.();
      }
    }
  ), _clearable = clearable && !!_value && !disabled && !readOnly;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(
      Combobox,
      {
        store: combobox,
        __staticSelector: "Select",
        classNames: resolvedClassNames,
        styles: resolvedStyles,
        unstyled,
        readOnly,
        onOptionSubmit: (val) => {
          onOptionSubmit?.(val);
          const optionLockup = allowDeselect && optionsLockup[val].value === _value ? null : optionsLockup[val], nextValue = optionLockup ? optionLockup.value : null;
          nextValue !== _value && setValue(nextValue, optionLockup), !controlled && handleSearchChange(typeof nextValue == "string" && optionLockup?.label || ""), combobox.closeDropdown();
        },
        size: size2,
        ...comboboxProps,
        children: [
          /* @__PURE__ */ jsx(Combobox.Target, { targetType: searchable ? "input" : "button", autoComplete, children: /* @__PURE__ */ jsx(
            InputBase,
            {
              id: _id,
              ref,
              __defaultRightSection: /* @__PURE__ */ jsx(
                Combobox.Chevron,
                {
                  size: size2,
                  error,
                  unstyled,
                  color: chevronColor
                }
              ),
              __clearSection: clearButton,
              __clearable: _clearable,
              rightSection,
              rightSectionPointerEvents: rightSectionPointerEvents || (_clearable ? "all" : "none"),
              ...others,
              size: size2,
              __staticSelector: "Select",
              disabled,
              readOnly: readOnly || !searchable,
              value: search,
              onChange: (event) => {
                handleSearchChange(event.currentTarget.value), combobox.openDropdown(), selectFirstOptionOnChange && combobox.selectFirstOption();
              },
              onFocus: (event) => {
                searchable && combobox.openDropdown(), onFocus?.(event);
              },
              onBlur: (event) => {
                searchable && combobox.closeDropdown(), handleSearchChange(_value != null && optionsLockup[_value]?.label || ""), onBlur?.(event);
              },
              onClick: (event) => {
                searchable ? combobox.openDropdown() : combobox.toggleDropdown(), onClick?.(event);
              },
              classNames: resolvedClassNames,
              styles: resolvedStyles,
              unstyled,
              pointer: !searchable,
              error
            }
          ) }),
          /* @__PURE__ */ jsx(
            OptionsDropdown,
            {
              data: parsedData,
              hidden: readOnly || disabled,
              filter: filter2,
              search,
              limit,
              hiddenWhenEmpty: !nothingFoundMessage,
              withScrollArea,
              maxDropdownHeight,
              filterOptions: searchable && selectedOption?.label !== search,
              value: _value,
              checkIconPosition,
              withCheckIcon,
              nothingFoundMessage,
              unstyled,
              labelId: others.label ? `${_id}-label` : void 0,
              "aria-label": others.label ? void 0 : others["aria-label"],
              renderOption,
              scrollAreaProps
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      Combobox.HiddenInput,
      {
        value: _value,
        name,
        form,
        disabled,
        ...hiddenInputProps
      }
    )
  ] });
});
Select.classes = { ...InputBase.classes, ...Combobox.classes };
Select.displayName = "@mantine/core/Select";
function SimpleGridMediaVariables({
  spacing,
  verticalSpacing,
  cols,
  selector: selector3
}) {
  const theme2 = useMantineTheme(), _verticalSpacing = verticalSpacing === void 0 ? spacing : verticalSpacing, baseStyles = filterProps$1({
    "--sg-spacing-x": getSpacing(getBaseValue$1(spacing)),
    "--sg-spacing-y": getSpacing(getBaseValue$1(_verticalSpacing)),
    "--sg-cols": getBaseValue$1(cols)?.toString()
  }), queries = keys$1(theme2.breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof spacing == "object" && spacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint])), typeof _verticalSpacing == "object" && _verticalSpacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint])), typeof cols == "object" && cols[breakpoint] !== void 0 && (acc[breakpoint]["--sg-cols"] = cols[breakpoint]), acc),
    {}
  ), media = getSortedBreakpoints(keys$1(queries), theme2.breakpoints).filter(
    (breakpoint) => keys$1(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: `(min-width: ${theme2.breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(InlineStyles, { styles: baseStyles, media, selector: selector3 });
}
function getBreakpoints(values2) {
  return typeof values2 == "object" && values2 !== null ? keys$1(values2) : [];
}
function sortBreakpoints(breakpoints) {
  return breakpoints.sort((a2, b2) => px$1(a2) - px$1(b2));
}
function getUniqueBreakpoints({
  spacing,
  verticalSpacing,
  cols
}) {
  const breakpoints = Array.from(
    /* @__PURE__ */ new Set([
      ...getBreakpoints(spacing),
      ...getBreakpoints(verticalSpacing),
      ...getBreakpoints(cols)
    ])
  );
  return sortBreakpoints(breakpoints);
}
function SimpleGridContainerVariables({
  spacing,
  verticalSpacing,
  cols,
  selector: selector3
}) {
  const _verticalSpacing = verticalSpacing === void 0 ? spacing : verticalSpacing, baseStyles = filterProps$1({
    "--sg-spacing-x": getSpacing(getBaseValue$1(spacing)),
    "--sg-spacing-y": getSpacing(getBaseValue$1(_verticalSpacing)),
    "--sg-cols": getBaseValue$1(cols)?.toString()
  }), uniqueBreakpoints = getUniqueBreakpoints({ spacing, verticalSpacing, cols }), queries = uniqueBreakpoints.reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof spacing == "object" && spacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint])), typeof _verticalSpacing == "object" && _verticalSpacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint])), typeof cols == "object" && cols[breakpoint] !== void 0 && (acc[breakpoint]["--sg-cols"] = cols[breakpoint]), acc),
    {}
  ), media = uniqueBreakpoints.map((breakpoint) => ({
    query: `simple-grid (min-width: ${breakpoint})`,
    styles: queries[breakpoint]
  }));
  return /* @__PURE__ */ jsx(InlineStyles, { styles: baseStyles, container: media, selector: selector3 });
}
var classes$8 = { container: "m_925c2d2c", root: "m_2415a157" };
const defaultProps$b = {
  cols: 1,
  spacing: "md",
  type: "media"
}, SimpleGrid = factory((_props, ref) => {
  const props = useProps("SimpleGrid", defaultProps$b, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    cols,
    verticalSpacing,
    spacing,
    type,
    ...others
  } = props, getStyles2 = useStyles({
    name: "SimpleGrid",
    classes: classes$8,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars
  }), responsiveClassName = useRandomClassName();
  return type === "container" ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(SimpleGridContainerVariables, { ...props, selector: `.${responsiveClassName}` }),
    /* @__PURE__ */ jsx("div", { ...getStyles2("container"), children: /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others }) })
  ] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(SimpleGridMediaVariables, { ...props, selector: `.${responsiveClassName}` }),
    /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others })
  ] });
});
SimpleGrid.classes = classes$8;
SimpleGrid.displayName = "@mantine/core/SimpleGrid";
const [SliderProvider, useSliderContext] = createSafeContext(
  "SliderProvider was not found in tree"
), SliderRoot = forwardRef(
  ({ size: size2, disabled, variant, color: color2, thumbSize, radius, ...others }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext();
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        tabIndex: -1,
        variant,
        size: size2,
        ref,
        ...getStyles2("root"),
        ...others
      }
    );
  }
);
SliderRoot.displayName = "@mantine/core/SliderRoot";
const Thumb = forwardRef(
  ({
    max: max2,
    min: min2,
    value,
    position,
    label: label2,
    dragging,
    onMouseDown,
    onKeyDownCapture,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    onFocus,
    onBlur,
    showLabelOnHover,
    isHovered,
    children: children2 = null,
    disabled
  }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext(), [focused, setFocused] = useState(!1), isVisible = labelAlwaysOn || dragging || focused || showLabelOnHover && isHovered;
    return /* @__PURE__ */ jsxs(
      Box$1,
      {
        tabIndex: 0,
        role: "slider",
        "aria-label": thumbLabel,
        "aria-valuemax": max2,
        "aria-valuemin": min2,
        "aria-valuenow": value,
        ref,
        __vars: { "--slider-thumb-offset": `${position}%` },
        ...getStyles2("thumb", { focusable: !0 }),
        mod: { dragging, disabled },
        onFocus: (event) => {
          setFocused(!0), typeof onFocus == "function" && onFocus(event);
        },
        onBlur: (event) => {
          setFocused(!1), typeof onBlur == "function" && onBlur(event);
        },
        onTouchStart: onMouseDown,
        onMouseDown,
        onKeyDownCapture,
        onClick: (event) => event.stopPropagation(),
        children: [
          children2,
          /* @__PURE__ */ jsx(
            Transition$1,
            {
              mounted: label2 != null && !!isVisible,
              transition: "fade",
              duration: 0,
              ...labelTransitionProps,
              children: (transitionStyles) => /* @__PURE__ */ jsx("div", { ...getStyles2("label", { style: transitionStyles }), children: label2 })
            }
          )
        ]
      }
    );
  }
);
Thumb.displayName = "@mantine/core/SliderThumb";
function getPosition({ value, min: min2, max: max2 }) {
  const position = (value - min2) / (max2 - min2) * 100;
  return Math.min(Math.max(position, 0), 100);
}
function isMarkFilled({ mark, offset: offset2, value, inverted = !1 }) {
  return inverted ? typeof offset2 == "number" && mark.value <= offset2 || mark.value >= value : typeof offset2 == "number" ? mark.value >= offset2 && mark.value <= value : mark.value <= value;
}
function Marks({ marks, min: min2, max: max2, disabled, value, offset: offset2, inverted }) {
  const { getStyles: getStyles2 } = useSliderContext();
  if (!marks)
    return null;
  const items = marks.map((mark, index2) => /* @__PURE__ */ createElement(
    Box$1,
    {
      ...getStyles2("markWrapper"),
      __vars: { "--mark-offset": `${getPosition({ value: mark.value, min: min2, max: max2 })}%` },
      key: index2
    },
    /* @__PURE__ */ jsx(
      Box$1,
      {
        ...getStyles2("mark"),
        mod: { filled: isMarkFilled({ mark, value, offset: offset2, inverted }), disabled }
      }
    ),
    mark.label && /* @__PURE__ */ jsx("div", { ...getStyles2("markLabel"), children: mark.label })
  ));
  return /* @__PURE__ */ jsx("div", { children: items });
}
Marks.displayName = "@mantine/core/SliderMarks";
function Track({
  filled,
  children: children2,
  offset: offset2,
  disabled,
  marksOffset,
  inverted,
  containerProps,
  ...others
}) {
  const { getStyles: getStyles2 } = useSliderContext();
  return /* @__PURE__ */ jsx(Box$1, { ...getStyles2("trackContainer"), mod: { disabled }, ...containerProps, children: /* @__PURE__ */ jsxs(Box$1, { ...getStyles2("track"), mod: { inverted, disabled }, children: [
    /* @__PURE__ */ jsx(
      Box$1,
      {
        mod: { inverted, disabled },
        __vars: {
          "--slider-bar-width": `calc(${filled}% + var(--slider-size))`,
          "--slider-bar-offset": `calc(${offset2}% - var(--slider-size))`
        },
        ...getStyles2("bar")
      }
    ),
    children2,
    /* @__PURE__ */ jsx(Marks, { ...others, offset: marksOffset, disabled, inverted })
  ] }) });
}
Track.displayName = "@mantine/core/SliderTrack";
function getChangeValue({
  value,
  containerWidth,
  min: min2,
  max: max2,
  step,
  precision
}) {
  const dx = (containerWidth ? Math.min(Math.max(value, 0), containerWidth) / containerWidth : value) * (max2 - min2), nextValue = (dx !== 0 ? Math.round(dx / step) * step : 0) + min2, nextValueWithinStep = Math.max(nextValue, min2);
  return precision !== void 0 ? Number(nextValueWithinStep.toFixed(precision)) : nextValueWithinStep;
}
function getFloatingValue(value, precision) {
  return parseFloat(value.toFixed(precision));
}
function getPrecision(step) {
  if (!step)
    return 0;
  const split = step.toString().split(".");
  return split.length > 1 ? split[1].length : 0;
}
function getNextMarkValue(currentValue, marks) {
  const nextMark = [...marks].sort((a2, b2) => a2.value - b2.value).find((mark) => mark.value > currentValue);
  return nextMark ? nextMark.value : currentValue;
}
function getPreviousMarkValue(currentValue, marks) {
  const previousMark = [...marks].sort((a2, b2) => b2.value - a2.value).find((mark) => mark.value < currentValue);
  return previousMark ? previousMark.value : currentValue;
}
function getFirstMarkValue(marks) {
  const sortedMarks = [...marks].sort((a2, b2) => a2.value - b2.value);
  return sortedMarks.length > 0 ? sortedMarks[0].value : 0;
}
function getLastMarkValue(marks) {
  const sortedMarks = [...marks].sort((a2, b2) => a2.value - b2.value);
  return sortedMarks.length > 0 ? sortedMarks[sortedMarks.length - 1].value : 100;
}
var classes$7 = { root: "m_dd36362e", label: "m_c9357328", thumb: "m_c9a9a60a", trackContainer: "m_a8645c2", track: "m_c9ade57f", bar: "m_38aeed47", markWrapper: "m_b7b0423a", mark: "m_dd33bc19", markLabel: "m_68c77a5b" };
const defaultProps$a = {
  radius: "xl",
  min: 0,
  max: 100,
  step: 1,
  marks: [],
  label: (f2) => f2,
  labelTransitionProps: { transition: "fade", duration: 0 },
  labelAlwaysOn: !1,
  thumbLabel: "",
  showLabelOnHover: !0,
  disabled: !1,
  scale: (v) => v
}, varsResolver$6 = (theme2, { size: size2, color: color2, thumbSize, radius }) => ({
  root: {
    "--slider-size": getSize(size2, "slider-size"),
    "--slider-color": color2 ? getThemeColor(color2, theme2) : void 0,
    "--slider-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--slider-thumb-size": thumbSize !== void 0 ? rem(thumbSize) : "calc(var(--slider-size) * 2)"
  }
}), Slider = factory((_props, ref) => {
  const props = useProps("Slider", defaultProps$a, _props), {
    classNames,
    styles,
    value,
    onChange,
    onChangeEnd,
    size: size2,
    min: min2,
    max: max2,
    step,
    precision: _precision,
    defaultValue,
    name,
    marks,
    label: label2,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    showLabelOnHover,
    thumbChildren,
    disabled,
    unstyled,
    scale: scale2,
    inverted,
    className,
    style: style2,
    vars,
    hiddenInputProps,
    restrictToMarks,
    thumbProps,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Slider",
    props,
    classes: classes$7,
    classNames,
    className,
    styles,
    style: style2,
    vars,
    varsResolver: varsResolver$6,
    unstyled
  }), { dir } = useDirection(), [hovered, setHovered] = useState(!1), [_value, setValue] = useUncontrolled({
    value: typeof value == "number" ? clamp$4(value, min2, max2) : value,
    defaultValue: typeof defaultValue == "number" ? clamp$4(defaultValue, min2, max2) : defaultValue,
    finalValue: clamp$4(0, min2, max2),
    onChange
  }), valueRef = useRef(_value), onChangeEndRef = useRef(onChangeEnd);
  useEffect(() => {
    onChangeEndRef.current = onChangeEnd;
  }, [onChangeEnd]);
  const root2 = useRef(null), thumb = useRef(null), position = getPosition({ value: _value, min: min2, max: max2 }), scaledValue = scale2(_value), _label = typeof label2 == "function" ? label2(scaledValue) : label2, precision = _precision ?? getPrecision(step), handleChange = useCallback(
    ({ x: x2 }) => {
      if (!disabled) {
        const nextValue = getChangeValue({
          value: x2,
          min: min2,
          max: max2,
          step,
          precision
        });
        setValue(
          restrictToMarks && marks?.length ? findClosestNumber(
            nextValue,
            marks.map((mark) => mark.value)
          ) : nextValue
        ), valueRef.current = nextValue;
      }
    },
    [disabled, min2, max2, step, precision, setValue, marks, restrictToMarks]
  ), handleScrubEnd = useCallback(() => {
    if (!disabled && onChangeEndRef.current) {
      const finalValue = restrictToMarks && marks?.length ? findClosestNumber(
        valueRef.current,
        marks.map((mark) => mark.value)
      ) : valueRef.current;
      onChangeEndRef.current(finalValue);
    }
  }, [disabled, marks, restrictToMarks]), { ref: container2, active } = useMove(handleChange, { onScrubEnd: handleScrubEnd }, dir), callOnChangeEnd = useCallback(
    (value2) => {
      !disabled && onChangeEndRef.current && onChangeEndRef.current(value2);
    },
    [disabled]
  ), handleTrackKeydownCapture = (event) => {
    if (!disabled)
      switch (event.key) {
        case "ArrowUp": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = getNextMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value + step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowRight": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = dir === "rtl" ? getPreviousMarkValue(_value, marks) : getNextMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value - step : _value + step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowDown": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = getPreviousMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value - step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowLeft": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = dir === "rtl" ? getNextMarkValue(_value, marks) : getPreviousMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value + step : _value - step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "Home": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            setValue(getFirstMarkValue(marks)), callOnChangeEnd(getFirstMarkValue(marks));
            break;
          }
          setValue(min2), callOnChangeEnd(min2);
          break;
        }
        case "End": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            setValue(getLastMarkValue(marks)), callOnChangeEnd(getLastMarkValue(marks));
            break;
          }
          setValue(max2), callOnChangeEnd(max2);
          break;
        }
      }
  };
  return /* @__PURE__ */ jsx(SliderProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsxs(
    SliderRoot,
    {
      ...others,
      ref: useMergedRef(ref, root2),
      onKeyDownCapture: handleTrackKeydownCapture,
      onMouseDownCapture: () => root2.current?.focus(),
      size: size2,
      disabled,
      children: [
        /* @__PURE__ */ jsx(
          Track,
          {
            inverted,
            offset: 0,
            filled: position,
            marks,
            min: min2,
            max: max2,
            value: scaledValue,
            disabled,
            containerProps: {
              ref: container2,
              onMouseEnter: showLabelOnHover ? () => setHovered(!0) : void 0,
              onMouseLeave: showLabelOnHover ? () => setHovered(!1) : void 0
            },
            children: /* @__PURE__ */ jsx(
              Thumb,
              {
                max: max2,
                min: min2,
                value: scaledValue,
                position,
                dragging: active,
                label: _label,
                ref: thumb,
                labelTransitionProps,
                labelAlwaysOn,
                thumbLabel,
                showLabelOnHover,
                isHovered: hovered,
                disabled,
                ...thumbProps,
                children: thumbChildren
              }
            )
          }
        ),
        /* @__PURE__ */ jsx("input", { type: "hidden", name, value: scaledValue, ...hiddenInputProps })
      ]
    }
  ) });
});
Slider.classes = classes$7;
Slider.displayName = "@mantine/core/Slider";
const defaultProps$9 = {}, Space = factory((props, ref) => {
  const { w, h, miw, mih, ...others } = useProps("Space", defaultProps$9, props);
  return /* @__PURE__ */ jsx(Box$1, { ref, ...others, w, miw: miw ?? w, h, mih: mih ?? h });
});
Space.displayName = "@mantine/core/Space";
var classes$6 = { root: "m_559cce2d", content: "m_b912df4e", control: "m_b9131032" };
const defaultProps$8 = {
  maxHeight: 100,
  initialState: !1
}, varsResolver$5 = (_, { transitionDuration }) => ({
  root: {
    "--spoiler-transition-duration": transitionDuration !== void 0 ? `${transitionDuration}ms` : void 0
  }
}), Spoiler = factory((_props, ref) => {
  const props = useProps("Spoiler", defaultProps$8, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    initialState,
    maxHeight,
    hideLabel,
    showLabel,
    children: children2,
    controlRef,
    transitionDuration,
    id: id2,
    expanded,
    onExpandedChange,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Spoiler",
    classes: classes$6,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$5
  }), _id = useId$1(id2), regionId = `${_id}-region`, [show, setShowState] = useUncontrolled({
    value: expanded,
    defaultValue: initialState,
    finalValue: !1,
    onChange: onExpandedChange
  }), { ref: contentRef, height } = useElementSize(), spoilerMoreContent = show ? hideLabel : showLabel, spoiler = spoilerMoreContent !== null && maxHeight < height;
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("root"),
      id: _id,
      ref,
      "data-has-spoiler": spoiler || void 0,
      ...others,
      children: [
        spoiler && /* @__PURE__ */ jsx(
          Anchor,
          {
            component: "button",
            type: "button",
            ref: controlRef,
            onClick: () => setShowState(!show),
            "aria-expanded": show,
            "aria-controls": regionId,
            ...getStyles2("control"),
            children: spoilerMoreContent
          }
        ),
        /* @__PURE__ */ jsx(
          "div",
          {
            ...getStyles2("content", {
              style: { maxHeight: show ? height ? rem(height) : void 0 : rem(maxHeight) }
            }),
            "data-reduce-motion": !0,
            role: "region",
            id: regionId,
            children: /* @__PURE__ */ jsx("div", { ref: contentRef, children: children2 })
          }
        )
      ]
    }
  );
});
Spoiler.classes = classes$6;
Spoiler.displayName = "@mantine/core/Spoiler";
var classes$5 = { root: "m_6d731127" };
const defaultProps$7 = {
  gap: "md",
  align: "stretch",
  justify: "flex-start"
}, varsResolver$4 = (_, { gap, align, justify }) => ({
  root: {
    "--stack-gap": getSpacing(gap),
    "--stack-align": align,
    "--stack-justify": justify
  }
}), Stack = factory((_props, ref) => {
  const props = useProps("Stack", defaultProps$7, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    align,
    justify,
    gap,
    variant,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Stack",
    props,
    classes: classes$5,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$4
  });
  return /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root"), variant, ...others });
});
Stack.classes = classes$5;
Stack.displayName = "@mantine/core/Stack";
const [TabsProvider, useTabsContext] = createSafeContext(
  "Tabs component was not found in the tree"
);
var classes$4 = { root: "m_89d60db1", "list--default": "m_576c9d4", list: "m_89d33d6d", panel: "m_b0c91715", tab: "m_4ec4dce6", tabSection: "m_fc420b1f", "tab--default": "m_539e827b", "list--outline": "m_6772fbd5", "tab--outline": "m_b59ab47c", "tab--pills": "m_c3381914" };
const defaultProps$6 = {}, TabsList = factory((_props, ref) => {
  const props = useProps("TabsList", defaultProps$6, _props), { children: children2, className, grow, justify, classNames, styles, style: style2, mod, ...others } = props, ctx = useTabsContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...others,
      ...ctx.getStyles("list", {
        className,
        style: style2,
        classNames,
        styles,
        props,
        variant: ctx.variant
      }),
      ref,
      role: "tablist",
      variant: ctx.variant,
      mod: [
        {
          grow,
          orientation: ctx.orientation,
          placement: ctx.orientation === "vertical" && ctx.placement,
          inverted: ctx.inverted
        },
        mod
      ],
      "aria-orientation": ctx.orientation,
      __vars: { "--tabs-justify": justify },
      children: children2
    }
  );
});
TabsList.classes = classes$4;
TabsList.displayName = "@mantine/core/TabsList";
const defaultProps$5 = {}, TabsPanel = factory((_props, ref) => {
  const props = useProps("TabsPanel", defaultProps$5, _props), { children: children2, className, value, classNames, styles, style: style2, mod, keepMounted, ...others } = props, ctx = useTabsContext(), active = ctx.value === value, content2 = ctx.keepMounted || keepMounted || active ? children2 : null;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...others,
      ...ctx.getStyles("panel", {
        className,
        classNames,
        styles,
        style: [style2, active ? void 0 : { display: "none" }],
        props
      }),
      ref,
      mod: [{ orientation: ctx.orientation }, mod],
      role: "tabpanel",
      id: ctx.getPanelId(value),
      "aria-labelledby": ctx.getTabId(value),
      children: content2
    }
  );
});
TabsPanel.classes = classes$4;
TabsPanel.displayName = "@mantine/core/TabsPanel";
const defaultProps$4 = {}, TabsTab = factory((_props, ref) => {
  const props = useProps("TabsTab", defaultProps$4, _props), {
    className,
    children: children2,
    rightSection,
    leftSection,
    value,
    onClick,
    onKeyDown,
    disabled,
    color: color2,
    style: style2,
    classNames,
    styles,
    vars,
    mod,
    tabIndex,
    ...others
  } = props, theme2 = useMantineTheme(), { dir } = useDirection(), ctx = useTabsContext(), active = value === ctx.value, activateTab = (event) => {
    ctx.onChange(ctx.allowTabDeactivation && value === ctx.value ? null : value), onClick?.(event);
  }, stylesApiProps = { classNames, styles, props };
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...others,
      ...ctx.getStyles("tab", { className, style: style2, variant: ctx.variant, ...stylesApiProps }),
      disabled,
      unstyled: ctx.unstyled,
      variant: ctx.variant,
      mod: [
        {
          active,
          disabled,
          orientation: ctx.orientation,
          inverted: ctx.inverted,
          placement: ctx.orientation === "vertical" && ctx.placement
        },
        mod
      ],
      ref,
      role: "tab",
      id: ctx.getTabId(value),
      "aria-selected": active,
      tabIndex: tabIndex !== void 0 ? tabIndex : active || ctx.value === null ? 0 : -1,
      "aria-controls": ctx.getPanelId(value),
      onClick: activateTab,
      __vars: { "--tabs-color": color2 ? getThemeColor(color2, theme2) : void 0 },
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: '[role="tab"]',
        parentSelector: '[role="tablist"]',
        activateOnFocus: ctx.activateTabWithKeyboard,
        loop: ctx.loop,
        orientation: ctx.orientation || "horizontal",
        dir,
        onKeyDown
      }),
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabLabel", stylesApiProps), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "right", children: rightSection })
      ]
    }
  );
});
TabsTab.classes = classes$4;
TabsTab.displayName = "@mantine/core/TabsTab";
const VALUE_ERROR = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value", defaultProps$3 = {
  keepMounted: !0,
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  allowTabDeactivation: !1,
  unstyled: !1,
  inverted: !1,
  variant: "default",
  placement: "left"
}, varsResolver$3 = (theme2, { radius, color: color2, autoContrast }) => ({
  root: {
    "--tabs-radius": getRadius$1(radius),
    "--tabs-color": getThemeColor(color2, theme2),
    "--tabs-text-color": getAutoContrastValue(autoContrast, theme2) ? getContrastColor({ color: color2, theme: theme2, autoContrast }) : void 0
  }
}), Tabs = factory((_props, ref) => {
  const props = useProps("Tabs", defaultProps$3, _props), {
    defaultValue,
    value,
    onChange,
    orientation,
    children: children2,
    loop,
    id: id2,
    activateTabWithKeyboard,
    allowTabDeactivation,
    variant,
    color: color2,
    radius,
    inverted,
    placement,
    keepMounted,
    classNames,
    styles,
    unstyled,
    className,
    style: style2,
    vars,
    autoContrast,
    mod,
    ...others
  } = props, uid = useId$1(id2), [currentTab, setCurrentTab] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  }), getStyles2 = useStyles({
    name: "Tabs",
    props,
    classes: classes$4,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$3
  });
  return /* @__PURE__ */ jsx(
    TabsProvider,
    {
      value: {
        placement,
        value: currentTab,
        orientation,
        id: uid,
        loop,
        activateTabWithKeyboard,
        getTabId: getSafeId(`${uid}-tab`, VALUE_ERROR),
        getPanelId: getSafeId(`${uid}-panel`, VALUE_ERROR),
        onChange: setCurrentTab,
        allowTabDeactivation,
        variant,
        color: color2,
        radius,
        inverted,
        keepMounted,
        unstyled,
        getStyles: getStyles2
      },
      children: /* @__PURE__ */ jsx(
        Box$1,
        {
          ref,
          id: uid,
          variant,
          mod: [
            {
              orientation,
              inverted: orientation === "horizontal" && inverted,
              placement: orientation === "vertical" && placement
            },
            mod
          ],
          ...getStyles2("root"),
          ...others,
          children: children2
        }
      )
    }
  );
});
Tabs.classes = classes$4;
Tabs.displayName = "@mantine/core/Tabs";
Tabs.Tab = TabsTab;
Tabs.Panel = TabsPanel;
Tabs.List = TabsList;
var classes$3 = { root: "m_7341320d" };
const defaultProps$2 = {}, varsResolver$2 = (theme2, { size: size2, radius, variant, gradient, color: color2, autoContrast }) => {
  const colors2 = theme2.variantColorResolver({
    color: color2 || theme2.primaryColor,
    theme: theme2,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ti-size": getSize(size2, "ti-size"),
      "--ti-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--ti-bg": color2 || variant ? colors2.background : void 0,
      "--ti-color": color2 || variant ? colors2.color : void 0,
      "--ti-bd": color2 || variant ? colors2.border : void 0
    }
  };
}, ThemeIcon = factory((_props, ref) => {
  const props = useProps("ThemeIcon", defaultProps$2, _props), { classNames, className, style: style2, styles, unstyled, vars, autoContrast, ...others } = props, getStyles2 = useStyles({
    name: "ThemeIcon",
    classes: classes$3,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$2
  });
  return /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root"), ...others });
});
ThemeIcon.classes = classes$3;
ThemeIcon.displayName = "@mantine/core/ThemeIcon";
const headings = ["h1", "h2", "h3", "h4", "h5", "h6"], sizes = ["xs", "sm", "md", "lg", "xl"];
function getTitleSize(order, size2) {
  const titleSize = size2 !== void 0 ? size2 : `h${order}`;
  return headings.includes(titleSize) ? {
    fontSize: `var(--mantine-${titleSize}-font-size)`,
    fontWeight: `var(--mantine-${titleSize}-font-weight)`,
    lineHeight: `var(--mantine-${titleSize}-line-height)`
  } : sizes.includes(titleSize) ? {
    fontSize: `var(--mantine-font-size-${titleSize})`,
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  } : {
    fontSize: rem(titleSize),
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  };
}
var classes$2 = { root: "m_8a5d1357" };
const defaultProps$1 = {
  order: 1
}, varsResolver$1 = (_, { order, size: size2, lineClamp, textWrap }) => {
  const sizeVariables = getTitleSize(order, size2);
  return {
    root: {
      "--title-fw": sizeVariables.fontWeight,
      "--title-lh": sizeVariables.lineHeight,
      "--title-fz": sizeVariables.fontSize,
      "--title-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
      "--title-text-wrap": textWrap
    }
  };
}, Title = factory((_props, ref) => {
  const props = useProps("Title", defaultProps$1, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    order,
    vars,
    size: size2,
    variant,
    lineClamp,
    textWrap,
    mod,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Title",
    props,
    classes: classes$2,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$1
  });
  return [1, 2, 3, 4, 5, 6].includes(order) ? /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("root"),
      component: `h${order}`,
      variant,
      ref,
      mod: [{ order, "data-line-clamp": typeof lineClamp == "number" }, mod],
      size: size2,
      ...others
    }
  ) : null;
});
Title.classes = classes$2;
Title.displayName = "@mantine/core/Title";
function getValuesRange(anchor, value, flatValues) {
  if (!anchor || !value)
    return [];
  const anchorIndex = flatValues.indexOf(anchor), valueIndex = flatValues.indexOf(value), start2 = Math.min(anchorIndex, valueIndex), end = Math.max(anchorIndex, valueIndex);
  return flatValues.slice(start2, end + 1);
}
function TreeNode({
  node: node2,
  getStyles: getStyles2,
  rootIndex,
  controller,
  expandOnClick,
  selectOnClick,
  isSubtree,
  level: level2 = 1,
  renderNode,
  flatValues,
  allowRangeSelection,
  expandOnSpace,
  checkOnSpace
}) {
  const ref = useRef(null), nested = (node2.children || []).map((child) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node: child,
      flatValues,
      getStyles: getStyles2,
      rootIndex: void 0,
      level: level2 + 1,
      controller,
      expandOnClick,
      isSubtree: !0,
      renderNode,
      selectOnClick,
      allowRangeSelection,
      expandOnSpace,
      checkOnSpace
    },
    child.value
  )), handleKeyDown = (event) => {
    if (event.nativeEvent.code === "ArrowRight" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node2.value] ? event.currentTarget.querySelector("[role=treeitem]")?.focus() : controller.expand(node2.value)), event.nativeEvent.code === "ArrowLeft" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node2.value] && (node2.children || []).length > 0 ? controller.collapse(node2.value) : isSubtree && findElementAncestor(event.currentTarget, "[role=treeitem]")?.focus()), event.nativeEvent.code === "ArrowDown" || event.nativeEvent.code === "ArrowUp") {
      const root2 = findElementAncestor(event.currentTarget, "[data-tree-root]");
      if (!root2)
        return;
      event.stopPropagation(), event.preventDefault();
      const nodes = Array.from(root2.querySelectorAll("[role=treeitem]")), index2 = nodes.indexOf(event.currentTarget);
      if (index2 === -1)
        return;
      const nextIndex = event.nativeEvent.code === "ArrowDown" ? index2 + 1 : index2 - 1;
      if (nodes[nextIndex]?.focus(), event.shiftKey) {
        const selectNode = nodes[nextIndex];
        selectNode && controller.setSelectedState(
          getValuesRange(controller.anchorNode, selectNode.dataset.value, flatValues)
        );
      }
    }
    event.nativeEvent.code === "Space" && (expandOnSpace && (event.stopPropagation(), event.preventDefault(), controller.toggleExpanded(node2.value)), checkOnSpace && (event.stopPropagation(), event.preventDefault(), controller.isNodeChecked(node2.value) ? controller.uncheckNode(node2.value) : controller.checkNode(node2.value)));
  }, handleNodeClick2 = (event) => {
    event.stopPropagation(), allowRangeSelection && event.shiftKey && controller.anchorNode ? (controller.setSelectedState(getValuesRange(controller.anchorNode, node2.value, flatValues)), ref.current?.focus()) : (expandOnClick && controller.toggleExpanded(node2.value), selectOnClick && controller.select(node2.value), ref.current?.focus());
  }, selected2 = controller.selectedState.includes(node2.value), elementProps = {
    ...getStyles2("label"),
    onClick: handleNodeClick2,
    "data-selected": selected2 || void 0,
    "data-value": node2.value,
    "data-hovered": controller.hoveredNode === node2.value || void 0
  };
  return /* @__PURE__ */ jsxs(
    "li",
    {
      ...getStyles2("node", {
        style: { "--label-offset": `calc(var(--level-offset) * ${level2 - 1})` }
      }),
      role: "treeitem",
      "aria-selected": selected2,
      "data-value": node2.value,
      "data-selected": selected2 || void 0,
      "data-hovered": controller.hoveredNode === node2.value || void 0,
      "data-level": level2,
      tabIndex: rootIndex === 0 ? 0 : -1,
      onKeyDown: handleKeyDown,
      ref,
      onMouseOver: (event) => {
        event.stopPropagation(), controller.setHoveredNode(node2.value);
      },
      onMouseLeave: (event) => {
        event.stopPropagation(), controller.setHoveredNode(null);
      },
      children: [
        typeof renderNode == "function" ? renderNode({
          node: node2,
          level: level2,
          selected: selected2,
          tree: controller,
          expanded: controller.expandedState[node2.value] || !1,
          hasChildren: Array.isArray(node2.children) && node2.children.length > 0,
          elementProps
        }) : /* @__PURE__ */ jsx("div", { ...elementProps, children: node2.label }),
        controller.expandedState[node2.value] && nested.length > 0 && /* @__PURE__ */ jsx("ul", { role: "group", ...getStyles2("subtree"), "data-level": level2, children: nested })
      ]
    }
  );
}
TreeNode.displayName = "@mantine/core/TreeNode";
function getAllCheckedNodes(data, checkedState, acc = []) {
  const currentTreeChecked = [];
  for (const node2 of data)
    if (Array.isArray(node2.children) && node2.children.length > 0) {
      const innerChecked = getAllCheckedNodes(node2.children, checkedState, acc);
      if (innerChecked.currentTreeChecked.length === node2.children.length) {
        const isChecked = innerChecked.currentTreeChecked.every((item2) => item2.checked), item = {
          checked: isChecked,
          indeterminate: !isChecked,
          value: node2.value,
          hasChildren: !0
        };
        currentTreeChecked.push(item), acc.push(item);
      } else if (innerChecked.currentTreeChecked.length > 0) {
        const item = { checked: !1, indeterminate: !0, value: node2.value, hasChildren: !0 };
        currentTreeChecked.push(item), acc.push(item);
      }
    } else if (checkedState.includes(node2.value)) {
      const item = {
        checked: !0,
        indeterminate: !1,
        value: node2.value,
        hasChildren: !1
      };
      currentTreeChecked.push(item), acc.push(item);
    }
  return { result: acc, currentTreeChecked };
}
function findTreeNode(value, data) {
  for (const node2 of data) {
    if (node2.value === value)
      return node2;
    if (Array.isArray(node2.children)) {
      const childNode = findTreeNode(value, node2.children);
      if (childNode)
        return childNode;
    }
  }
  return null;
}
function getChildrenNodesValues(value, data, acc = []) {
  const node2 = findTreeNode(value, data);
  return node2 ? !Array.isArray(node2.children) || node2.children.length === 0 ? [node2.value] : (node2.children.forEach((child) => {
    Array.isArray(child.children) && child.children.length > 0 ? getChildrenNodesValues(child.value, data, acc) : acc.push(child.value);
  }), acc) : acc;
}
function getAllChildrenNodes(data) {
  return data.reduce((acc, node2) => (Array.isArray(node2.children) && node2.children.length > 0 ? acc.push(...getAllChildrenNodes(node2.children)) : acc.push(node2.value), acc), []);
}
function isNodeChecked(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : checkedState.includes(value) ? !0 : getAllCheckedNodes(data, checkedState).result.some((node2) => node2.value === value && node2.checked);
}
const memoizedIsNodeChecked = memoize(isNodeChecked);
function isNodeIndeterminate(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : getAllCheckedNodes(data, checkedState).result.some((node2) => node2.value === value && node2.indeterminate);
}
const memoizedIsNodeIndeterminate = memoize(isNodeIndeterminate);
function getInitialTreeExpandedState(initialState, data, value, acc = {}) {
  return data.forEach((node2) => {
    acc[node2.value] = node2.value in initialState ? initialState[node2.value] : node2.value === value, Array.isArray(node2.children) && getInitialTreeExpandedState(initialState, node2.children, value, acc);
  }), acc;
}
function getInitialCheckedState(initialState, data) {
  const acc = [];
  return initialState.forEach((node2) => acc.push(...getChildrenNodesValues(node2, data))), Array.from(new Set(acc));
}
function useTree({
  initialSelectedState = [],
  initialCheckedState = [],
  initialExpandedState = {},
  multiple = !1,
  onNodeCollapse,
  onNodeExpand
} = {}) {
  const [data, setData] = useState([]), [expandedState, setExpandedState] = useState(initialExpandedState), [selectedState, setSelectedState] = useState(initialSelectedState), [checkedState, setCheckedState] = useState(initialCheckedState), [anchorNode, setAnchorNode] = useState(null), [hoveredNode, setHoveredNode2] = useState(null), initialize = useCallback(
    (_data) => {
      setExpandedState((current) => getInitialTreeExpandedState(current, _data, selectedState)), setCheckedState((current) => getInitialCheckedState(current, _data)), setData(_data);
    },
    [selectedState, checkedState]
  ), toggleExpanded = useCallback(
    (value) => {
      setExpandedState((current) => {
        const nextState = { ...current, [value]: !current[value] };
        return nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value), nextState;
      });
    },
    [onNodeCollapse, onNodeExpand]
  ), collapse = useCallback(
    (value) => {
      setExpandedState((current) => (current[value] !== !1 && onNodeCollapse?.(value), { ...current, [value]: !1 }));
    },
    [onNodeCollapse]
  ), expand = useCallback(
    (value) => {
      setExpandedState((current) => (current[value] !== !0 && onNodeExpand?.(value), { ...current, [value]: !0 }));
    },
    [onNodeExpand]
  ), expandAllNodes = useCallback(() => {
    setExpandedState((current) => {
      const next = { ...current };
      return Object.keys(next).forEach((key2) => {
        next[key2] = !0;
      }), next;
    });
  }, []), collapseAllNodes = useCallback(() => {
    setExpandedState((current) => {
      const next = { ...current };
      return Object.keys(next).forEach((key2) => {
        next[key2] = !1;
      }), next;
    });
  }, []), toggleSelected = useCallback(
    (value) => setSelectedState((current) => multiple ? current.includes(value) ? (setAnchorNode(null), current.filter((item) => item !== value)) : (setAnchorNode(value), [...current, value]) : current.includes(value) ? (setAnchorNode(null), []) : (setAnchorNode(value), [value])),
    []
  ), select2 = useCallback((value) => {
    setAnchorNode(value), setSelectedState(
      (current) => multiple ? current.includes(value) ? current : [...current, value] : [value]
    );
  }, []), deselect = useCallback((value) => {
    anchorNode === value && setAnchorNode(null), setSelectedState((current) => current.filter((item) => item !== value));
  }, []), clearSelected = useCallback(() => {
    setSelectedState([]), setAnchorNode(null);
  }, []), checkNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current) => Array.from(/* @__PURE__ */ new Set([...current, ...checkedNodes])));
    },
    [data]
  ), uncheckNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current) => current.filter((item) => !checkedNodes.includes(item)));
    },
    [data]
  ), checkAllNodes = useCallback(() => {
    setCheckedState(() => getAllChildrenNodes(data));
  }, [data]), uncheckAllNodes = useCallback(() => {
    setCheckedState([]);
  }, []);
  return {
    multiple,
    expandedState,
    selectedState,
    checkedState,
    anchorNode,
    initialize,
    toggleExpanded,
    collapse,
    expand,
    expandAllNodes,
    collapseAllNodes,
    setExpandedState,
    checkNode,
    uncheckNode,
    checkAllNodes,
    uncheckAllNodes,
    setCheckedState,
    toggleSelected,
    select: select2,
    deselect,
    clearSelected,
    setSelectedState,
    hoveredNode,
    setHoveredNode: setHoveredNode2,
    getCheckedNodes: () => getAllCheckedNodes(data, checkedState).result,
    isNodeChecked: (value) => memoizedIsNodeChecked(value, data, checkedState),
    isNodeIndeterminate: (value) => memoizedIsNodeIndeterminate(value, data, checkedState)
  };
}
var classes$1 = { root: "m_f698e191", subtree: "m_75f3ecf", node: "m_f6970eb1", label: "m_dc283425" };
function getFlatValues(data) {
  return data.reduce((acc, item) => (acc.push(item.value), item.children && acc.push(...getFlatValues(item.children)), acc), []);
}
const defaultProps = {
  expandOnClick: !0,
  allowRangeSelection: !0,
  expandOnSpace: !0
}, varsResolver = (_theme, { levelOffset }) => ({
  root: {
    "--level-offset": getSpacing(levelOffset)
  }
}), Tree = factory((_props, ref) => {
  const props = useProps("Tree", defaultProps, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    data,
    expandOnClick,
    tree,
    renderNode,
    selectOnClick,
    clearSelectionOnOutsideClick,
    allowRangeSelection,
    expandOnSpace,
    levelOffset,
    checkOnSpace,
    ...others
  } = props, defaultController = useTree(), controller = tree || defaultController, getStyles2 = useStyles({
    name: "Tree",
    classes: classes$1,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver
  }), clickOutsideRef = useClickOutside(
    () => clearSelectionOnOutsideClick && controller.clearSelected()
  ), mergedRef = useMergedRef(ref, clickOutsideRef), flatValues = useMemo(() => getFlatValues(data), [data]);
  useEffect(() => {
    controller.initialize(data);
  }, [data]);
  const nodes = data.map((node2, index2) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node: node2,
      getStyles: getStyles2,
      rootIndex: index2,
      expandOnClick,
      selectOnClick,
      controller,
      renderNode,
      flatValues,
      allowRangeSelection,
      expandOnSpace,
      checkOnSpace
    },
    node2.value
  ));
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: "ul",
      ref: mergedRef,
      ...getStyles2("root"),
      ...others,
      role: "tree",
      "aria-multiselectable": controller.multiple,
      "data-tree-root": !0,
      children: nodes
    }
  );
});
Tree.displayName = "@mantine/core/Tree";
Tree.classes = classes$1;
var isProduction$1 = !0, prefix = "Invariant failed";
function invariant$1(condition, message) {
  if (!condition) {
    if (isProduction$1)
      throw new Error(prefix);
    var provided = typeof message == "function" ? message() : message, value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
  }
}
var isProduction = !0;
function warning(condition, message) {
  if (!isProduction) {
    if (condition)
      return;
    var text = "Warning: " + message;
    typeof console < "u" && console.warn(text);
    try {
      throw Error(text);
    } catch {
    }
  }
}
const __storeToDerived = /* @__PURE__ */ new WeakMap(), __derivedToStore = /* @__PURE__ */ new WeakMap(), __depsThatHaveWrittenThisTick = {
  current: []
};
let __isFlushing = !1, __batchDepth = 0;
const __pendingUpdates = /* @__PURE__ */ new Set(), __initialBatchValues = /* @__PURE__ */ new Map();
function __flush_internals(relatedVals) {
  const sorted = Array.from(relatedVals).sort((a2, b2) => a2 instanceof Derived && a2.options.deps.includes(b2) ? 1 : b2 instanceof Derived && b2.options.deps.includes(a2) ? -1 : 0);
  for (const derived of sorted) {
    if (__depsThatHaveWrittenThisTick.current.includes(derived))
      continue;
    __depsThatHaveWrittenThisTick.current.push(derived), derived.recompute();
    const stores = __derivedToStore.get(derived);
    if (stores)
      for (const store of stores) {
        const relatedLinkedDerivedVals = __storeToDerived.get(store);
        relatedLinkedDerivedVals && __flush_internals(relatedLinkedDerivedVals);
      }
  }
}
function __notifyListeners(store) {
  store.listeners.forEach(
    (listener) => listener({
      prevVal: store.prevState,
      currentVal: store.state
    })
  );
}
function __notifyDerivedListeners(derived) {
  derived.listeners.forEach(
    (listener) => listener({
      prevVal: derived.prevState,
      currentVal: derived.state
    })
  );
}
function __flush(store) {
  if (__batchDepth > 0 && !__initialBatchValues.has(store) && __initialBatchValues.set(store, store.prevState), __pendingUpdates.add(store), !(__batchDepth > 0) && !__isFlushing)
    try {
      for (__isFlushing = !0; __pendingUpdates.size > 0; ) {
        const stores = Array.from(__pendingUpdates);
        __pendingUpdates.clear();
        for (const store2 of stores) {
          const prevState = __initialBatchValues.get(store2) ?? store2.prevState;
          store2.prevState = prevState, __notifyListeners(store2);
        }
        for (const store2 of stores) {
          const derivedVals = __storeToDerived.get(store2);
          derivedVals && (__depsThatHaveWrittenThisTick.current.push(store2), __flush_internals(derivedVals));
        }
        for (const store2 of stores) {
          const derivedVals = __storeToDerived.get(store2);
          if (derivedVals)
            for (const derived of derivedVals)
              __notifyDerivedListeners(derived);
        }
      }
    } finally {
      __isFlushing = !1, __depsThatHaveWrittenThisTick.current = [], __initialBatchValues.clear();
    }
}
function batch(fn) {
  __batchDepth++;
  try {
    fn();
  } finally {
    if (__batchDepth--, __batchDepth === 0) {
      const pendingUpdateToFlush = Array.from(__pendingUpdates)[0];
      pendingUpdateToFlush && __flush(pendingUpdateToFlush);
    }
  }
}
class Store {
  constructor(initialState, options) {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener), unsub?.();
      };
    }, this.setState = (updater) => {
      var _a, _b, _c;
      this.prevState = this.state, this.state = (_a = this.options) != null && _a.updateFn ? this.options.updateFn(this.prevState)(updater) : updater(this.prevState), (_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null || _c.call(_b), __flush(this);
    }, this.prevState = initialState, this.state = initialState, this.options = options;
  }
}
class Derived {
  constructor(options) {
    this.listeners = /* @__PURE__ */ new Set(), this._subscriptions = [], this.lastSeenDepValues = [], this.getDepVals = () => {
      const prevDepVals = [], currDepVals = [];
      for (const dep of this.options.deps)
        prevDepVals.push(dep.prevState), currDepVals.push(dep.state);
      return this.lastSeenDepValues = currDepVals, {
        prevDepVals,
        currDepVals,
        prevVal: this.prevState ?? void 0
      };
    }, this.recompute = () => {
      var _a, _b;
      this.prevState = this.state;
      const { prevDepVals, currDepVals, prevVal } = this.getDepVals();
      this.state = this.options.fn({
        prevDepVals,
        currDepVals,
        prevVal
      }), (_b = (_a = this.options).onUpdate) == null || _b.call(_a);
    }, this.checkIfRecalculationNeededDeeply = () => {
      for (const dep of this.options.deps)
        dep instanceof Derived && dep.checkIfRecalculationNeededDeeply();
      let shouldRecompute = !1;
      const lastSeenDepValues = this.lastSeenDepValues, { currDepVals } = this.getDepVals();
      for (let i2 = 0; i2 < currDepVals.length; i2++)
        if (currDepVals[i2] !== lastSeenDepValues[i2]) {
          shouldRecompute = !0;
          break;
        }
      shouldRecompute && this.recompute();
    }, this.mount = () => (this.registerOnGraph(), this.checkIfRecalculationNeededDeeply(), () => {
      this.unregisterFromGraph();
      for (const cleanup of this._subscriptions)
        cleanup();
    }), this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options).onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener), unsub?.();
      };
    }, this.options = options, this.state = options.fn({
      prevDepVals: void 0,
      prevVal: void 0,
      currDepVals: this.getDepVals().currDepVals
    });
  }
  registerOnGraph(deps = this.options.deps) {
    for (const dep of deps)
      if (dep instanceof Derived)
        dep.registerOnGraph(), this.registerOnGraph(dep.options.deps);
      else if (dep instanceof Store) {
        let relatedLinkedDerivedVals = __storeToDerived.get(dep);
        relatedLinkedDerivedVals || (relatedLinkedDerivedVals = /* @__PURE__ */ new Set(), __storeToDerived.set(dep, relatedLinkedDerivedVals)), relatedLinkedDerivedVals.add(this);
        let relatedStores = __derivedToStore.get(this);
        relatedStores || (relatedStores = /* @__PURE__ */ new Set(), __derivedToStore.set(this, relatedStores)), relatedStores.add(dep);
      }
  }
  unregisterFromGraph(deps = this.options.deps) {
    for (const dep of deps)
      if (dep instanceof Derived)
        this.unregisterFromGraph(dep.options.deps);
      else if (dep instanceof Store) {
        const relatedLinkedDerivedVals = __storeToDerived.get(dep);
        relatedLinkedDerivedVals && relatedLinkedDerivedVals.delete(this);
        const relatedStores = __derivedToStore.get(this);
        relatedStores && relatedStores.delete(dep);
      }
  }
}
const stateIndexKey = "__TSR_index", popStateEvent = "popstate", beforeUnloadEvent = "beforeunload";
function createHistory(opts) {
  let location = opts.getLocation();
  const subscribers = /* @__PURE__ */ new Set(), notify2 = (action) => {
    location = opts.getLocation(), subscribers.forEach((subscriber) => subscriber({ location, action }));
  }, handleIndexChange = (action) => {
    opts.notifyOnIndexChange ?? !0 ? notify2(action) : location = opts.getLocation();
  }, tryNavigation = async ({
    task,
    navigateOpts,
    ...actionInfo
  }) => {
    var _a, _b;
    if (navigateOpts?.ignoreBlocker ?? !1) {
      task();
      return;
    }
    const blockers = ((_a = opts.getBlockers) == null ? void 0 : _a.call(opts)) ?? [], isPushOrReplace = actionInfo.type === "PUSH" || actionInfo.type === "REPLACE";
    if (typeof document < "u" && blockers.length && isPushOrReplace)
      for (const blocker of blockers) {
        const nextLocation = parseHref(actionInfo.path, actionInfo.state);
        if (await blocker.blockerFn({
          currentLocation: location,
          nextLocation,
          action: actionInfo.type
        })) {
          (_b = opts.onBlocked) == null || _b.call(opts);
          return;
        }
      }
    task();
  };
  return {
    get location() {
      return location;
    },
    get length() {
      return opts.getLength();
    },
    subscribers,
    subscribe: (cb) => (subscribers.add(cb), () => {
      subscribers.delete(cb);
    }),
    push: (path, state, navigateOpts) => {
      const currentIndex = location.state[stateIndexKey];
      state = assignKeyAndIndex(currentIndex + 1, state), tryNavigation({
        task: () => {
          opts.pushState(path, state), notify2({ type: "PUSH" });
        },
        navigateOpts,
        type: "PUSH",
        path,
        state
      });
    },
    replace: (path, state, navigateOpts) => {
      const currentIndex = location.state[stateIndexKey];
      state = assignKeyAndIndex(currentIndex, state), tryNavigation({
        task: () => {
          opts.replaceState(path, state), notify2({ type: "REPLACE" });
        },
        navigateOpts,
        type: "REPLACE",
        path,
        state
      });
    },
    go: (index2, navigateOpts) => {
      tryNavigation({
        task: () => {
          opts.go(index2), handleIndexChange({ type: "GO", index: index2 });
        },
        navigateOpts,
        type: "GO"
      });
    },
    back: (navigateOpts) => {
      tryNavigation({
        task: () => {
          opts.back(navigateOpts?.ignoreBlocker ?? !1), handleIndexChange({ type: "BACK" });
        },
        navigateOpts,
        type: "BACK"
      });
    },
    forward: (navigateOpts) => {
      tryNavigation({
        task: () => {
          opts.forward(navigateOpts?.ignoreBlocker ?? !1), handleIndexChange({ type: "FORWARD" });
        },
        navigateOpts,
        type: "FORWARD"
      });
    },
    canGoBack: () => location.state[stateIndexKey] !== 0,
    createHref: (str) => opts.createHref(str),
    block: (blocker) => {
      var _a;
      if (!opts.setBlockers) return () => {
      };
      const blockers = ((_a = opts.getBlockers) == null ? void 0 : _a.call(opts)) ?? [];
      return opts.setBlockers([...blockers, blocker]), () => {
        var _a2, _b;
        const blockers2 = ((_a2 = opts.getBlockers) == null ? void 0 : _a2.call(opts)) ?? [];
        (_b = opts.setBlockers) == null || _b.call(opts, blockers2.filter((b2) => b2 !== blocker));
      };
    },
    flush: () => {
      var _a;
      return (_a = opts.flush) == null ? void 0 : _a.call(opts);
    },
    destroy: () => {
      var _a;
      return (_a = opts.destroy) == null ? void 0 : _a.call(opts);
    },
    notify: notify2
  };
}
function assignKeyAndIndex(index2, state) {
  return state || (state = {}), {
    ...state,
    key: createRandomKey(),
    [stateIndexKey]: index2
  };
}
function createBrowserHistory(opts) {
  var _a;
  const win2 = opts?.window ?? (typeof document < "u" ? window : void 0), originalPushState = win2.history.pushState, originalReplaceState = win2.history.replaceState;
  let blockers = [];
  const _getBlockers = () => blockers, _setBlockers = (newBlockers) => blockers = newBlockers, createHref = opts?.createHref ?? ((path) => path), parseLocation = opts?.parseLocation ?? (() => parseHref(
    `${win2.location.pathname}${win2.location.search}${win2.location.hash}`,
    win2.history.state
  ));
  (_a = win2.history.state) != null && _a.key || win2.history.replaceState(
    {
      [stateIndexKey]: 0,
      key: createRandomKey()
    },
    ""
  );
  let currentLocation = parseLocation(), rollbackLocation, nextPopIsGo = !1, ignoreNextPop = !1, skipBlockerNextPop = !1, ignoreNextBeforeUnload = !1;
  const getLocation = () => currentLocation;
  let next, scheduled;
  const flush = () => {
    next && (history._ignoreSubscribers = !0, (next.isPush ? win2.history.pushState : win2.history.replaceState)(
      next.state,
      "",
      next.href
    ), history._ignoreSubscribers = !1, next = void 0, scheduled = void 0, rollbackLocation = void 0);
  }, queueHistoryAction = (type, destHref, state) => {
    const href = createHref(destHref);
    scheduled || (rollbackLocation = currentLocation), currentLocation = parseHref(destHref, state), next = {
      href,
      state,
      isPush: next?.isPush || type === "push"
    }, scheduled || (scheduled = Promise.resolve().then(() => flush()));
  }, onPushPop = (type) => {
    currentLocation = parseLocation(), history.notify({ type });
  }, onPushPopEvent = async () => {
    if (ignoreNextPop) {
      ignoreNextPop = !1;
      return;
    }
    const nextLocation = parseLocation(), delta = nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey], isForward = delta === 1, isBack = delta === -1, isGo = !isForward && !isBack || nextPopIsGo;
    nextPopIsGo = !1;
    const action = isGo ? "GO" : isBack ? "BACK" : "FORWARD", notify2 = isGo ? {
      type: "GO",
      index: delta
    } : {
      type: isBack ? "BACK" : "FORWARD"
    };
    if (skipBlockerNextPop)
      skipBlockerNextPop = !1;
    else {
      const blockers2 = _getBlockers();
      if (typeof document < "u" && blockers2.length) {
        for (const blocker of blockers2)
          if (await blocker.blockerFn({
            currentLocation,
            nextLocation,
            action
          })) {
            ignoreNextPop = !0, win2.history.go(1), history.notify(notify2);
            return;
          }
      }
    }
    currentLocation = parseLocation(), history.notify(notify2);
  }, onBeforeUnload = (e2) => {
    if (ignoreNextBeforeUnload) {
      ignoreNextBeforeUnload = !1;
      return;
    }
    let shouldBlock = !1;
    const blockers2 = _getBlockers();
    if (typeof document < "u" && blockers2.length)
      for (const blocker of blockers2) {
        const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? !0;
        if (shouldHaveBeforeUnload === !0) {
          shouldBlock = !0;
          break;
        }
        if (typeof shouldHaveBeforeUnload == "function" && shouldHaveBeforeUnload() === !0) {
          shouldBlock = !0;
          break;
        }
      }
    if (shouldBlock)
      return e2.preventDefault(), e2.returnValue = "";
  }, history = createHistory({
    getLocation,
    getLength: () => win2.history.length,
    pushState: (href, state) => queueHistoryAction("push", href, state),
    replaceState: (href, state) => queueHistoryAction("replace", href, state),
    back: (ignoreBlocker) => (ignoreBlocker && (skipBlockerNextPop = !0), ignoreNextBeforeUnload = !0, win2.history.back()),
    forward: (ignoreBlocker) => {
      ignoreBlocker && (skipBlockerNextPop = !0), ignoreNextBeforeUnload = !0, win2.history.forward();
    },
    go: (n2) => {
      nextPopIsGo = !0, win2.history.go(n2);
    },
    createHref: (href) => createHref(href),
    flush,
    destroy: () => {
      win2.history.pushState = originalPushState, win2.history.replaceState = originalReplaceState, win2.removeEventListener(beforeUnloadEvent, onBeforeUnload, {
        capture: !0
      }), win2.removeEventListener(popStateEvent, onPushPopEvent);
    },
    onBlocked: () => {
      rollbackLocation && currentLocation !== rollbackLocation && (currentLocation = rollbackLocation);
    },
    getBlockers: _getBlockers,
    setBlockers: _setBlockers,
    notifyOnIndexChange: !1
  });
  return win2.addEventListener(beforeUnloadEvent, onBeforeUnload, { capture: !0 }), win2.addEventListener(popStateEvent, onPushPopEvent), win2.history.pushState = function(...args) {
    const res = originalPushState.apply(win2.history, args);
    return history._ignoreSubscribers || onPushPop("PUSH"), res;
  }, win2.history.replaceState = function(...args) {
    const res = originalReplaceState.apply(win2.history, args);
    return history._ignoreSubscribers || onPushPop("REPLACE"), res;
  }, history;
}
function createHashHistory(opts) {
  const win2 = typeof document < "u" ? window : void 0;
  return createBrowserHistory({
    window: win2,
    parseLocation: () => {
      const hashSplit = win2.location.hash.split("#").slice(1), pathPart = hashSplit[0] ?? "/", searchPart = win2.location.search, hashEntries = hashSplit.slice(1), hashPart = hashEntries.length === 0 ? "" : `#${hashEntries.join("#")}`, hashHref = `${pathPart}${searchPart}${hashPart}`;
      return parseHref(hashHref, win2.history.state);
    },
    createHref: (href) => `${win2.location.pathname}${win2.location.search}#${href}`
  });
}
function createMemoryHistory(opts = {
  initialEntries: ["/"]
}) {
  const entries = opts.initialEntries;
  let index2 = opts.initialIndex ? Math.min(Math.max(opts.initialIndex, 0), entries.length - 1) : entries.length - 1;
  const states = entries.map(
    (_entry, index22) => assignKeyAndIndex(index22, void 0)
  );
  return createHistory({
    getLocation: () => parseHref(entries[index2], states[index2]),
    getLength: () => entries.length,
    pushState: (path, state) => {
      index2 < entries.length - 1 && (entries.splice(index2 + 1), states.splice(index2 + 1)), states.push(state), entries.push(path), index2 = Math.max(entries.length - 1, 0);
    },
    replaceState: (path, state) => {
      states[index2] = state, entries[index2] = path;
    },
    back: () => {
      index2 = Math.max(index2 - 1, 0);
    },
    forward: () => {
      index2 = Math.min(index2 + 1, entries.length - 1);
    },
    go: (n2) => {
      index2 = Math.min(Math.max(index2 + n2, 0), entries.length - 1);
    },
    createHref: (path) => path
  });
}
function parseHref(href, state) {
  const hashIndex = href.indexOf("#"), searchIndex = href.indexOf("?");
  return {
    href,
    pathname: href.substring(
      0,
      hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length
    ),
    hash: hashIndex > -1 ? href.substring(hashIndex) : "",
    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
    state: state || { [stateIndexKey]: 0, key: createRandomKey() }
  };
}
function createRandomKey() {
  return (Math.random() + 1).toString(36).substring(7);
}
function last(arr) {
  return arr[arr.length - 1];
}
function isFunction(d2) {
  return typeof d2 == "function";
}
function functionalUpdate(updater, previous) {
  return isFunction(updater) ? updater(previous) : updater;
}
function pick(parent, keys2) {
  return keys2.reduce((obj, key2) => (obj[key2] = parent[key2], obj), {});
}
function replaceEqualDeep(prev, _next) {
  if (prev === _next)
    return prev;
  const next = _next, array2 = isPlainArray(prev) && isPlainArray(next);
  if (array2 || isPlainObject(prev) && isPlainObject(next)) {
    const prevItems = array2 ? prev : Object.keys(prev), prevSize = prevItems.length, nextItems = array2 ? next : Object.keys(next), nextSize = nextItems.length, copy = array2 ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < nextSize; i2++) {
      const key2 = array2 ? i2 : nextItems[i2];
      (!array2 && prevItems.includes(key2) || array2) && prev[key2] === void 0 && next[key2] === void 0 ? (copy[key2] = void 0, equalItems++) : (copy[key2] = replaceEqualDeep(prev[key2], next[key2]), copy[key2] === prev[key2] && prev[key2] !== void 0 && equalItems++);
    }
    return prevSize === nextSize && equalItems === prevSize ? prev : copy;
  }
  return next;
}
function isPlainObject(o2) {
  if (!hasObjectPrototype(o2))
    return !1;
  const ctor = o2.constructor;
  if (typeof ctor > "u")
    return !0;
  const prot = ctor.prototype;
  return !(!hasObjectPrototype(prot) || !prot.hasOwnProperty("isPrototypeOf"));
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function getObjectKeys(obj, ignoreUndefined) {
  let keys2 = Object.keys(obj);
  return ignoreUndefined && (keys2 = keys2.filter((key2) => obj[key2] !== void 0)), keys2;
}
function deepEqual$1(a2, b2, opts) {
  if (a2 === b2)
    return !0;
  if (typeof a2 != typeof b2)
    return !1;
  if (isPlainObject(a2) && isPlainObject(b2)) {
    const ignoreUndefined = opts?.ignoreUndefined ?? !0, aKeys = getObjectKeys(a2, ignoreUndefined), bKeys = getObjectKeys(b2, ignoreUndefined);
    return !opts?.partial && aKeys.length !== bKeys.length ? !1 : bKeys.every((key2) => deepEqual$1(a2[key2], b2[key2], opts));
  }
  return Array.isArray(a2) && Array.isArray(b2) ? a2.length !== b2.length ? !1 : !a2.some((item, index2) => !deepEqual$1(item, b2[index2], opts)) : !1;
}
function createControlledPromise(onResolve) {
  let resolveLoadPromise, rejectLoadPromise;
  const controlledPromise = new Promise((resolve, reject) => {
    resolveLoadPromise = resolve, rejectLoadPromise = reject;
  });
  return controlledPromise.status = "pending", controlledPromise.resolve = (value) => {
    controlledPromise.status = "resolved", controlledPromise.value = value, resolveLoadPromise(value), onResolve?.(value);
  }, controlledPromise.reject = (e2) => {
    controlledPromise.status = "rejected", rejectLoadPromise(e2);
  }, controlledPromise;
}
function hasUriEncodedChars(inputString) {
  return /%[0-9A-Fa-f]{2}/.test(inputString);
}
function joinPaths(paths) {
  return cleanPath(
    paths.filter((val) => val !== void 0).join("/")
  );
}
function cleanPath(path) {
  return path.replace(/\/{2,}/g, "/");
}
function trimPathLeft(path) {
  return path === "/" ? path : path.replace(/^\/{1,}/, "");
}
function trimPathRight(path) {
  return path === "/" ? path : path.replace(/\/{1,}$/, "");
}
function trimPath(path) {
  return trimPathRight(trimPathLeft(path));
}
function removeTrailingSlash(value, basepath2) {
  return value?.endsWith("/") && value !== "/" && value !== `${basepath2}/` ? value.slice(0, -1) : value;
}
function exactPathTest(pathName1, pathName2, basepath2) {
  return removeTrailingSlash(pathName1, basepath2) === removeTrailingSlash(pathName2, basepath2);
}
function resolvePath({
  basepath: basepath2,
  base,
  to,
  trailingSlash = "never",
  caseSensitive
}) {
  var _a, _b;
  base = removeBasepath(basepath2, base, caseSensitive), to = removeBasepath(basepath2, to, caseSensitive);
  let baseSegments = parsePathname(base);
  const toSegments = parsePathname(to);
  baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === "/" && baseSegments.pop(), toSegments.forEach((toSegment, index2) => {
    toSegment.value === "/" ? index2 ? index2 === toSegments.length - 1 && baseSegments.push(toSegment) : baseSegments = [toSegment] : toSegment.value === ".." ? baseSegments.pop() : toSegment.value === "." || baseSegments.push(toSegment);
  }), baseSegments.length > 1 && (((_b = last(baseSegments)) == null ? void 0 : _b.value) === "/" ? trailingSlash === "never" && baseSegments.pop() : trailingSlash === "always" && baseSegments.push({ type: "pathname", value: "/" }));
  const joined = joinPaths([basepath2, ...baseSegments.map((d2) => d2.value)]);
  return cleanPath(joined);
}
function parsePathname(pathname) {
  if (!pathname)
    return [];
  pathname = cleanPath(pathname);
  const segments = [];
  if (pathname.slice(0, 1) === "/" && (pathname = pathname.substring(1), segments.push({
    type: "pathname",
    value: "/"
  })), !pathname)
    return segments;
  const split = pathname.split("/").filter(Boolean);
  return segments.push(
    ...split.map((part) => part === "$" || part === "*" ? {
      type: "wildcard",
      value: part
    } : part.charAt(0) === "$" ? {
      type: "param",
      value: part
    } : {
      type: "pathname",
      value: part.includes("%25") ? part.split("%25").map((segment) => decodeURI(segment)).join("%25") : decodeURI(part)
    })
  ), pathname.slice(-1) === "/" && (pathname = pathname.substring(1), segments.push({
    type: "pathname",
    value: "/"
  })), segments;
}
function interpolatePath({
  path,
  params,
  leaveWildcards,
  leaveParams,
  decodeCharMap
}) {
  const interpolatedPathSegments = parsePathname(path);
  function encodeParam(key2) {
    const value = params[key2], isValueString = typeof value == "string";
    return ["*", "_splat"].includes(key2) ? isValueString ? encodeURI(value) : value : isValueString ? encodePathParam(value, decodeCharMap) : value;
  }
  const usedParams = {}, interpolatedPath = joinPaths(
    interpolatedPathSegments.map((segment) => {
      if (segment.type === "wildcard") {
        usedParams._splat = params._splat;
        const value = encodeParam("_splat");
        return leaveWildcards ? `${segment.value}${value ?? ""}` : value;
      }
      if (segment.type === "param") {
        const key2 = segment.value.substring(1);
        if (usedParams[key2] = params[key2], leaveParams) {
          const value = encodeParam(segment.value);
          return `${segment.value}${value ?? ""}`;
        }
        return encodeParam(key2) ?? "undefined";
      }
      return segment.value;
    })
  );
  return { usedParams, interpolatedPath };
}
function encodePathParam(value, decodeCharMap) {
  let encoded = encodeURIComponent(value);
  if (decodeCharMap)
    for (const [encodedChar, char] of decodeCharMap)
      encoded = encoded.replaceAll(encodedChar, char);
  return encoded;
}
function matchPathname(basepath2, currentPathname, matchLocation) {
  const pathParams = matchByPath(basepath2, currentPathname, matchLocation);
  if (!(matchLocation.to && !pathParams))
    return pathParams ?? {};
}
function removeBasepath(basepath2, pathname, caseSensitive = !1) {
  const normalizedBasepath = caseSensitive ? basepath2 : basepath2.toLowerCase(), normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase();
  switch (!0) {
    // default behaviour is to serve app from the root - pathname
    // left untouched
    case normalizedBasepath === "/":
      return pathname;
    // shortcut for removing the basepath if it matches the pathname
    case normalizedPathname === normalizedBasepath:
      return "";
    // in case pathname is shorter than basepath - there is
    // nothing to remove
    case pathname.length < basepath2.length:
      return pathname;
    // avoid matching partial segments - strict equality handled
    // earlier, otherwise, basepath separated from pathname with
    // separator, therefore lack of separator means partial
    // segment match (`/app` should not match `/application`)
    case normalizedPathname[normalizedBasepath.length] !== "/":
      return pathname;
    // remove the basepath from the pathname if it starts with it
    case normalizedPathname.startsWith(normalizedBasepath):
      return pathname.slice(basepath2.length);
    // otherwise, return the pathname as is
    default:
      return pathname;
  }
}
function matchByPath(basepath2, from, matchLocation) {
  if (basepath2 !== "/" && !from.startsWith(basepath2))
    return;
  from = removeBasepath(basepath2, from, matchLocation.caseSensitive);
  const to = removeBasepath(
    basepath2,
    `${matchLocation.to ?? "$"}`,
    matchLocation.caseSensitive
  ), baseSegments = parsePathname(from), routeSegments = parsePathname(to);
  from.startsWith("/") || baseSegments.unshift({
    type: "pathname",
    value: "/"
  }), to.startsWith("/") || routeSegments.unshift({
    type: "pathname",
    value: "/"
  });
  const params = {};
  return (() => {
    for (let i2 = 0; i2 < Math.max(baseSegments.length, routeSegments.length); i2++) {
      const baseSegment = baseSegments[i2], routeSegment = routeSegments[i2], isLastBaseSegment = i2 >= baseSegments.length - 1, isLastRouteSegment = i2 >= routeSegments.length - 1;
      if (routeSegment) {
        if (routeSegment.type === "wildcard") {
          const _splat = decodeURI(
            joinPaths(baseSegments.slice(i2).map((d2) => d2.value))
          );
          return params["*"] = _splat, params._splat = _splat, !0;
        }
        if (routeSegment.type === "pathname") {
          if (routeSegment.value === "/" && !baseSegment?.value)
            return !0;
          if (baseSegment) {
            if (matchLocation.caseSensitive) {
              if (routeSegment.value !== baseSegment.value)
                return !1;
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase())
              return !1;
          }
        }
        if (!baseSegment)
          return !1;
        if (routeSegment.type === "param") {
          if (baseSegment.value === "/")
            return !1;
          baseSegment.value.charAt(0) !== "$" && (params[routeSegment.value.substring(1)] = decodeURIComponent(
            baseSegment.value
          ));
        }
      }
      if (!isLastBaseSegment && isLastRouteSegment)
        return params["**"] = joinPaths(baseSegments.slice(i2 + 1).map((d2) => d2.value)), !!matchLocation.fuzzy && routeSegment?.value !== "/";
    }
    return !0;
  })() ? params : void 0;
}
function notFound(options = {}) {
  if (options.isNotFound = !0, options.throw) throw options;
  return options;
}
function isNotFound(obj) {
  return !!obj?.isNotFound;
}
const storageKey = "tsr-scroll-restoration-v1_3";
let sessionsStorage = !1;
try {
  sessionsStorage = typeof window < "u" && typeof window.sessionStorage == "object";
} catch {
}
const throttle = (fn, wait) => {
  let timeout2;
  return (...args) => {
    timeout2 || (timeout2 = setTimeout(() => {
      fn(...args), timeout2 = null;
    }, wait));
  };
}, scrollRestorationCache = sessionsStorage ? {
  state: JSON.parse(window.sessionStorage.getItem(storageKey) || "null") || {},
  // This setter is simply to make sure that we set the sessionStorage right
  // after the state is updated. It doesn't necessarily need to be a functional
  // update.
  set: (updater) => (scrollRestorationCache.state = functionalUpdate(updater, scrollRestorationCache.state) || scrollRestorationCache.state, window.sessionStorage.setItem(
    storageKey,
    JSON.stringify(scrollRestorationCache.state)
  ))
} : void 0, defaultGetScrollRestorationKey = (location) => location.state.key || location.href;
function getCssSelector(el) {
  const path = [];
  let parent;
  for (; parent = el.parentNode; )
    path.unshift(
      `${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`
    ), el = parent;
  return `${path.join(" > ")}`.toLowerCase();
}
let ignoreScroll = !1;
function restoreScroll(storageKey2, key2, behavior, shouldScrollRestoration, scrollToTopSelectors) {
  var _a;
  let byKey;
  try {
    byKey = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
  } catch (error) {
    console.error(error);
    return;
  }
  const resolvedKey = key2 || ((_a = window.history.state) == null ? void 0 : _a.key), elementEntries = byKey[resolvedKey];
  ignoreScroll = !0, (() => {
    if (shouldScrollRestoration && elementEntries) {
      for (const elementSelector in elementEntries) {
        const entry = elementEntries[elementSelector];
        if (elementSelector === "window")
          window.scrollTo({
            top: entry.scrollY,
            left: entry.scrollX,
            behavior
          });
        else if (elementSelector) {
          const element = document.querySelector(elementSelector);
          element && (element.scrollLeft = entry.scrollX, element.scrollTop = entry.scrollY);
        }
      }
      return;
    }
    const hash = window.location.hash.split("#")[1];
    if (hash) {
      const hashScrollIntoViewOptions = (window.history.state || {}).__hashScrollIntoViewOptions ?? !0;
      if (hashScrollIntoViewOptions) {
        const el = document.getElementById(hash);
        el && el.scrollIntoView(hashScrollIntoViewOptions);
      }
      return;
    }
    [
      "window",
      ...scrollToTopSelectors?.filter((d2) => d2 !== "window") ?? []
    ].forEach((selector3) => {
      const element = selector3 === "window" ? window : document.querySelector(selector3);
      element && element.scrollTo({
        top: 0,
        left: 0,
        behavior
      });
    });
  })(), ignoreScroll = !1;
}
function setupScrollRestoration(router, force) {
  if ((router.options.scrollRestoration ?? !1) && (router.isScrollRestoring = !0), typeof document > "u" || router.isScrollRestorationSetup)
    return;
  router.isScrollRestorationSetup = !0, ignoreScroll = !1;
  const getKey = router.options.getScrollRestorationKey || defaultGetScrollRestorationKey;
  window.history.scrollRestoration = "manual";
  const onScroll = (event) => {
    if (ignoreScroll || !router.isScrollRestoring)
      return;
    let elementSelector = "";
    if (event.target === document || event.target === window)
      elementSelector = "window";
    else {
      const attrId = event.target.getAttribute(
        "data-scroll-restoration-id"
      );
      attrId ? elementSelector = `[data-scroll-restoration-id="${attrId}"]` : elementSelector = getCssSelector(event.target);
    }
    const restoreKey = getKey(router.state.location);
    scrollRestorationCache.set((state) => {
      const keyEntry = state[restoreKey] = state[restoreKey] || {}, elementEntry = keyEntry[elementSelector] = keyEntry[elementSelector] || {};
      if (elementSelector === "window")
        elementEntry.scrollX = window.scrollX || 0, elementEntry.scrollY = window.scrollY || 0;
      else if (elementSelector) {
        const element = document.querySelector(elementSelector);
        element && (elementEntry.scrollX = element.scrollLeft || 0, elementEntry.scrollY = element.scrollTop || 0);
      }
      return state;
    });
  };
  typeof document < "u" && document.addEventListener("scroll", throttle(onScroll, 100), !0), router.subscribe("onRendered", (event) => {
    const cacheKey = getKey(event.toLocation);
    if (!router.resetNextScroll) {
      router.resetNextScroll = !0;
      return;
    }
    restoreScroll(
      storageKey,
      cacheKey,
      router.options.scrollRestorationBehavior || void 0,
      router.isScrollRestoring || void 0,
      router.options.scrollToTopSelectors || void 0
    ), router.isScrollRestoring && scrollRestorationCache.set((state) => (state[cacheKey] = state[cacheKey] || {}, state));
  });
}
function encode(obj, pfx) {
  let k2, i2, tmp, str = "";
  for (k2 in obj)
    if ((tmp = obj[k2]) !== void 0)
      if (Array.isArray(tmp))
        for (i2 = 0; i2 < tmp.length; i2++)
          str && (str += "&"), str += encodeURIComponent(k2) + "=" + encodeURIComponent(tmp[i2]);
      else
        str && (str += "&"), str += encodeURIComponent(k2) + "=" + encodeURIComponent(tmp);
  return "" + str;
}
function toValue(mix2) {
  if (!mix2) return "";
  const str = hasUriEncodedChars(mix2) ? decodeURIComponent(mix2) : decodeURIComponent(encodeURIComponent(mix2));
  return str === "false" ? !1 : str === "true" ? !0 : +str * 0 === 0 && +str + "" === str ? +str : str;
}
function decode(str, pfx) {
  let tmp, k2;
  const out = {}, arr = str.split("&");
  for (; tmp = arr.shift(); ) {
    const equalIndex = tmp.indexOf("=");
    if (equalIndex !== -1) {
      k2 = tmp.slice(0, equalIndex), k2 = decodeURIComponent(k2);
      const value = tmp.slice(equalIndex + 1);
      out[k2] !== void 0 ? out[k2] = [].concat(out[k2], toValue(value)) : out[k2] = toValue(value);
    } else
      k2 = tmp, k2 = decodeURIComponent(k2), out[k2] = "";
  }
  return out;
}
const defaultParseSearch = parseSearchWith(JSON.parse), defaultStringifySearch = stringifySearchWith(
  JSON.stringify,
  JSON.parse
);
function parseSearchWith(parser) {
  return (searchStr) => {
    searchStr.substring(0, 1) === "?" && (searchStr = searchStr.substring(1));
    const query = decode(searchStr);
    for (const key2 in query) {
      const value = query[key2];
      if (typeof value == "string")
        try {
          query[key2] = parser(value);
        } catch {
        }
    }
    return query;
  };
}
function stringifySearchWith(stringify, parser) {
  function stringifyValue(val) {
    if (typeof val == "object" && val !== null)
      try {
        return stringify(val);
      } catch {
      }
    else if (typeof val == "string" && typeof parser == "function")
      try {
        return parser(val), stringify(val);
      } catch {
      }
    return val;
  }
  return (search) => {
    search = { ...search }, Object.keys(search).forEach((key2) => {
      const val = search[key2];
      typeof val > "u" || val === void 0 ? delete search[key2] : search[key2] = stringifyValue(val);
    });
    const searchStr = encode(search).toString();
    return searchStr ? `?${searchStr}` : "";
  };
}
const rootRouteId = "__root__";
function redirect(opts) {
  if (opts.isRedirect = !0, opts.statusCode = opts.statusCode || opts.code || 307, opts.headers = opts.headers || {}, !opts.reloadDocument) {
    opts.reloadDocument = !1;
    try {
      new URL(`${opts.href}`), opts.reloadDocument = !0;
    } catch {
    }
  }
  if (opts.throw)
    throw opts;
  return opts;
}
function isRedirect(obj) {
  return !!obj?.isRedirect;
}
function isResolvedRedirect(obj) {
  return !!obj?.isRedirect && obj.href;
}
function getLocationChangeInfo(routerState) {
  const fromLocation = routerState.resolvedLocation, toLocation = routerState.location, pathChanged = fromLocation?.pathname !== toLocation.pathname, hrefChanged = fromLocation?.href !== toLocation.href, hashChanged = fromLocation?.hash !== toLocation.hash;
  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged };
}
class RouterCore {
  /**
   * @deprecated Use the `createRouter` function instead
   */
  constructor(options) {
    this.tempLocationKey = `${Math.round(
      Math.random() * 1e7
    )}`, this.resetNextScroll = !0, this.shouldViewTransition = void 0, this.isViewTransitionTypesSupported = void 0, this.subscribers = /* @__PURE__ */ new Set(), this.isScrollRestoring = !1, this.isScrollRestorationSetup = !1, this.startTransition = (fn) => fn(), this.update = (newOptions) => {
      var _a;
      newOptions.notFoundRoute && console.warn(
        "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info."
      );
      const previousOptions = this.options;
      this.options = {
        ...this.options,
        ...newOptions
      }, this.isServer = this.options.isServer ?? typeof document > "u", this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters ? new Map(
        this.options.pathParamsAllowedCharacters.map((char) => [
          encodeURIComponent(char),
          char
        ])
      ) : void 0, (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) && (newOptions.basepath === void 0 || newOptions.basepath === "" || newOptions.basepath === "/" ? this.basepath = "/" : this.basepath = `/${trimPath(newOptions.basepath)}`), // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      (!this.history || this.options.history && this.options.history !== this.history) && (this.history = this.options.history ?? (this.isServer ? createMemoryHistory({
        initialEntries: [this.basepath || "/"]
      }) : createBrowserHistory()), this.latestLocation = this.parseLocation()), this.options.routeTree !== this.routeTree && (this.routeTree = this.options.routeTree, this.buildRouteTree()), this.__store || (this.__store = new Store(getInitialRouterState(this.latestLocation), {
        onUpdate: () => {
          this.__store.state = {
            ...this.state,
            cachedMatches: this.state.cachedMatches.filter(
              (d2) => !["redirected"].includes(d2.status)
            )
          };
        }
      }), setupScrollRestoration(this)), typeof window < "u" && "CSS" in window && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      typeof ((_a = window.CSS) == null ? void 0 : _a.supports) == "function" && (this.isViewTransitionTypesSupported = window.CSS.supports(
        "selector(:active-view-transition-type(a)"
      ));
    }, this.buildRouteTree = () => {
      this.routesById = {}, this.routesByPath = {};
      const notFoundRoute = this.options.notFoundRoute;
      notFoundRoute && (notFoundRoute.init({
        originalIndex: 99999999999,
        defaultSsr: this.options.defaultSsr
      }), this.routesById[notFoundRoute.id] = notFoundRoute);
      const recurseRoutes = (childRoutes) => {
        childRoutes.forEach((childRoute, i2) => {
          childRoute.init({
            originalIndex: i2,
            defaultSsr: this.options.defaultSsr
          });
          const existingRoute = this.routesById[childRoute.id];
          if (invariant$1(
            !existingRoute,
            `Duplicate routes found with id: ${String(childRoute.id)}`
          ), this.routesById[childRoute.id] = childRoute, !childRoute.isRoot && childRoute.path) {
            const trimmedFullPath = trimPathRight(childRoute.fullPath);
            (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) && (this.routesByPath[trimmedFullPath] = childRoute);
          }
          const children2 = childRoute.children;
          children2?.length && recurseRoutes(children2);
        });
      };
      recurseRoutes([this.routeTree]);
      const scoredRoutes = [];
      Object.values(this.routesById).forEach((d2, i2) => {
        var _a;
        if (d2.isRoot || !d2.path)
          return;
        const trimmed = trimPathLeft(d2.fullPath), parsed = parsePathname(trimmed);
        for (; parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === "/"; )
          parsed.shift();
        const scores = parsed.map((segment) => segment.value === "/" ? 0.75 : segment.type === "param" ? 0.5 : segment.type === "wildcard" ? 0.25 : 1);
        scoredRoutes.push({ child: d2, trimmed, parsed, index: i2, scores });
      }), this.flatRoutes = scoredRoutes.sort((a2, b2) => {
        const minLength = Math.min(a2.scores.length, b2.scores.length);
        for (let i2 = 0; i2 < minLength; i2++)
          if (a2.scores[i2] !== b2.scores[i2])
            return b2.scores[i2] - a2.scores[i2];
        if (a2.scores.length !== b2.scores.length)
          return b2.scores.length - a2.scores.length;
        for (let i2 = 0; i2 < minLength; i2++)
          if (a2.parsed[i2].value !== b2.parsed[i2].value)
            return a2.parsed[i2].value > b2.parsed[i2].value ? 1 : -1;
        return a2.index - b2.index;
      }).map((d2, i2) => (d2.child.rank = i2, d2.child));
    }, this.subscribe = (eventType, fn) => {
      const listener = {
        eventType,
        fn
      };
      return this.subscribers.add(listener), () => {
        this.subscribers.delete(listener);
      };
    }, this.emit = (routerEvent) => {
      this.subscribers.forEach((listener) => {
        listener.eventType === routerEvent.type && listener.fn(routerEvent);
      });
    }, this.parseLocation = (previousLocation, locationToParse) => {
      const parse2 = ({
        pathname,
        search,
        hash,
        state
      }) => {
        const parsedSearch = this.options.parseSearch(search), searchStr = this.options.stringifySearch(parsedSearch);
        return {
          pathname,
          searchStr,
          search: replaceEqualDeep(previousLocation?.search, parsedSearch),
          hash: hash.split("#").reverse()[0] ?? "",
          href: `${pathname}${searchStr}${hash}`,
          state: replaceEqualDeep(previousLocation?.state, state)
        };
      }, location = parse2(locationToParse ?? this.history.location), { __tempLocation, __tempKey } = location.state;
      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
        const parsedTempLocation = parse2(__tempLocation);
        return parsedTempLocation.state.key = location.state.key, delete parsedTempLocation.state.__tempLocation, {
          ...parsedTempLocation,
          maskedLocation: location
        };
      }
      return location;
    }, this.resolvePathWithBase = (from, path) => resolvePath({
      basepath: this.basepath,
      base: from,
      to: cleanPath(path),
      trailingSlash: this.options.trailingSlash,
      caseSensitive: this.options.caseSensitive
    }), this.matchRoutes = (pathnameOrNext, locationSearchOrOpts, opts) => typeof pathnameOrNext == "string" ? this.matchRoutesInternal(
      {
        pathname: pathnameOrNext,
        search: locationSearchOrOpts
      },
      opts
    ) : this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts), this.getMatchedRoutes = (next, dest) => {
      let routeParams = {};
      const trimmedPath = trimPathRight(next.pathname), getMatchedParams = (route) => matchPathname(this.basepath, trimmedPath, {
        to: route.fullPath,
        caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,
        fuzzy: !0
      });
      let foundRoute = dest?.to !== void 0 ? this.routesByPath[dest.to] : void 0;
      foundRoute ? routeParams = getMatchedParams(foundRoute) : foundRoute = this.flatRoutes.find((route) => {
        const matchedParams = getMatchedParams(route);
        return matchedParams ? (routeParams = matchedParams, !0) : !1;
      });
      let routeCursor = foundRoute || this.routesById[rootRouteId];
      const matchedRoutes = [routeCursor];
      for (; routeCursor.parentRoute; )
        routeCursor = routeCursor.parentRoute, matchedRoutes.unshift(routeCursor);
      return { matchedRoutes, routeParams, foundRoute };
    }, this.cancelMatch = (id2) => {
      const match = this.getMatch(id2);
      match && (match.abortController.abort(), clearTimeout(match.pendingTimeout));
    }, this.cancelMatches = () => {
      var _a;
      (_a = this.state.pendingMatches) == null || _a.forEach((match) => {
        this.cancelMatch(match.id);
      });
    }, this.buildLocation = (opts) => {
      const build = (dest = {}, matchedRoutesResult) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const fromMatches = dest._fromLocation ? this.matchRoutes(dest._fromLocation, { _buildLocation: !0 }) : this.state.matches, fromMatch = dest.from != null ? fromMatches.find(
          (d2) => matchPathname(this.basepath, trimPathRight(d2.pathname), {
            to: dest.from,
            caseSensitive: !1,
            fuzzy: !1
          })
        ) : void 0, fromPath = fromMatch?.pathname || this.latestLocation.pathname;
        invariant$1(
          dest.from == null || fromMatch != null,
          "Could not find match for from: " + dest.from
        );
        const fromSearch = (_a = this.state.pendingMatches) != null && _a.length ? (_b = last(this.state.pendingMatches)) == null ? void 0 : _b.search : ((_c = last(fromMatches)) == null ? void 0 : _c.search) || this.latestLocation.search, stayingMatches = matchedRoutesResult?.matchedRoutes.filter(
          (d2) => fromMatches.find((e2) => e2.routeId === d2.id)
        );
        let pathname;
        if (dest.to) {
          const resolvePathTo = fromMatch?.fullPath || ((_d = last(fromMatches)) == null ? void 0 : _d.fullPath) || this.latestLocation.pathname;
          pathname = this.resolvePathWithBase(resolvePathTo, `${dest.to}`);
        } else {
          const fromRouteByFromPathRouteId = this.routesById[(_e = stayingMatches?.find((route) => {
            const interpolatedPath = interpolatePath({
              path: route.fullPath,
              params: matchedRoutesResult?.routeParams ?? {},
              decodeCharMap: this.pathParamsDecodeCharMap
            }).interpolatedPath;
            return joinPaths([this.basepath, interpolatedPath]) === fromPath;
          })) == null ? void 0 : _e.id];
          pathname = this.resolvePathWithBase(
            fromPath,
            fromRouteByFromPathRouteId?.to ?? fromPath
          );
        }
        const prevParams = { ...(_f = last(fromMatches)) == null ? void 0 : _f.params };
        let nextParams = (dest.params ?? !0) === !0 ? prevParams : {
          ...prevParams,
          ...functionalUpdate(dest.params, prevParams)
        };
        Object.keys(nextParams).length > 0 && matchedRoutesResult?.matchedRoutes.map((route) => {
          var _a2;
          return ((_a2 = route.options.params) == null ? void 0 : _a2.stringify) ?? route.options.stringifyParams;
        }).filter(Boolean).forEach((fn) => {
          nextParams = { ...nextParams, ...fn(nextParams) };
        }), pathname = interpolatePath({
          path: pathname,
          params: nextParams ?? {},
          leaveWildcards: !1,
          leaveParams: opts.leaveParams,
          decodeCharMap: this.pathParamsDecodeCharMap
        }).interpolatedPath;
        let search = fromSearch;
        if (opts._includeValidateSearch && ((_g = this.options.search) != null && _g.strict)) {
          let validatedSearch = {};
          matchedRoutesResult?.matchedRoutes.forEach((route) => {
            try {
              route.options.validateSearch && (validatedSearch = {
                ...validatedSearch,
                ...validateSearch(route.options.validateSearch, {
                  ...validatedSearch,
                  ...search
                }) ?? {}
              });
            } catch {
            }
          }), search = validatedSearch;
        }
        search = ((search2) => {
          const allMiddlewares = matchedRoutesResult?.matchedRoutes.reduce(
            (acc, route) => {
              var _a2;
              const middlewares = [];
              if ("search" in route.options)
                (_a2 = route.options.search) != null && _a2.middlewares && middlewares.push(...route.options.search.middlewares);
              else if (route.options.preSearchFilters || route.options.postSearchFilters) {
                const legacyMiddleware = ({
                  search: search3,
                  next
                }) => {
                  let nextSearch = search3;
                  "preSearchFilters" in route.options && route.options.preSearchFilters && (nextSearch = route.options.preSearchFilters.reduce(
                    (prev, next2) => next2(prev),
                    search3
                  ));
                  const result = next(nextSearch);
                  return "postSearchFilters" in route.options && route.options.postSearchFilters ? route.options.postSearchFilters.reduce(
                    (prev, next2) => next2(prev),
                    result
                  ) : result;
                };
                middlewares.push(legacyMiddleware);
              }
              if (opts._includeValidateSearch && route.options.validateSearch) {
                const validate2 = ({ search: search3, next }) => {
                  const result = next(search3);
                  try {
                    return {
                      ...result,
                      ...validateSearch(
                        route.options.validateSearch,
                        result
                      ) ?? {}
                    };
                  } catch {
                    return result;
                  }
                };
                middlewares.push(validate2);
              }
              return acc.concat(middlewares);
            },
            []
          ) ?? [], final = ({ search: search3 }) => dest.search ? dest.search === !0 ? search3 : functionalUpdate(dest.search, search3) : {};
          allMiddlewares.push(final);
          const applyNext = (index2, currentSearch) => {
            if (index2 >= allMiddlewares.length)
              return currentSearch;
            const middleware = allMiddlewares[index2];
            return middleware({ search: currentSearch, next: (newSearch) => applyNext(index2 + 1, newSearch) });
          };
          return applyNext(0, search2);
        })(search), search = replaceEqualDeep(fromSearch, search);
        const searchStr = this.options.stringifySearch(search), hash = dest.hash === !0 ? this.latestLocation.hash : dest.hash ? functionalUpdate(dest.hash, this.latestLocation.hash) : void 0, hashStr = hash ? `#${hash}` : "";
        let nextState = dest.state === !0 ? this.latestLocation.state : dest.state ? functionalUpdate(dest.state, this.latestLocation.state) : {};
        return nextState = replaceEqualDeep(this.latestLocation.state, nextState), {
          pathname,
          search,
          searchStr,
          state: nextState,
          hash: hash ?? "",
          href: `${pathname}${searchStr}${hashStr}`,
          unmaskOnReload: dest.unmaskOnReload
        };
      }, buildWithMatches = (dest = {}, maskedDest) => {
        var _a;
        const next = build(dest);
        let maskedNext = maskedDest ? build(maskedDest) : void 0;
        if (!maskedNext) {
          let params = {};
          const foundMask = (_a = this.options.routeMasks) == null ? void 0 : _a.find((d2) => {
            const match = matchPathname(this.basepath, next.pathname, {
              to: d2.from,
              caseSensitive: !1,
              fuzzy: !1
            });
            return match ? (params = match, !0) : !1;
          });
          if (foundMask) {
            const { from: _from, ...maskProps } = foundMask;
            maskedDest = {
              ...pick(opts, ["from"]),
              ...maskProps,
              params
            }, maskedNext = build(maskedDest);
          }
        }
        const nextMatches = this.getMatchedRoutes(next, dest), final = build(dest, nextMatches);
        if (maskedNext) {
          const maskedMatches = this.getMatchedRoutes(maskedNext, maskedDest), maskedFinal = build(maskedDest, maskedMatches);
          final.maskedLocation = maskedFinal;
        }
        return final;
      };
      return opts.mask ? buildWithMatches(opts, {
        ...pick(opts, ["from"]),
        ...opts.mask
      }) : buildWithMatches(opts);
    }, this.commitLocation = ({
      viewTransition,
      ignoreBlocker,
      ...next
    }) => {
      const isSameState = () => {
        const ignoredProps = [
          "key",
          "__TSR_index",
          "__hashScrollIntoViewOptions"
        ];
        ignoredProps.forEach((prop) => {
          next.state[prop] = this.latestLocation.state[prop];
        });
        const isEqual2 = deepEqual$1(next.state, this.latestLocation.state);
        return ignoredProps.forEach((prop) => {
          delete next.state[prop];
        }), isEqual2;
      }, isSameUrl = this.latestLocation.href === next.href, previousCommitPromise = this.commitLocationPromise;
      if (this.commitLocationPromise = createControlledPromise(() => {
        previousCommitPromise?.resolve();
      }), isSameUrl && isSameState())
        this.load();
      else {
        let { maskedLocation, hashScrollIntoView, ...nextHistory } = next;
        maskedLocation && (nextHistory = {
          ...maskedLocation,
          state: {
            ...maskedLocation.state,
            __tempKey: void 0,
            __tempLocation: {
              ...nextHistory,
              search: nextHistory.searchStr,
              state: {
                ...nextHistory.state,
                __tempKey: void 0,
                __tempLocation: void 0,
                key: void 0
              }
            }
          }
        }, (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? !1) && (nextHistory.state.__tempKey = this.tempLocationKey)), nextHistory.state.__hashScrollIntoViewOptions = hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? !0, this.shouldViewTransition = viewTransition, this.history[next.replace ? "replace" : "push"](
          nextHistory.href,
          nextHistory.state,
          { ignoreBlocker }
        );
      }
      return this.resetNextScroll = next.resetScroll ?? !0, this.history.subscribers.size || this.load(), this.commitLocationPromise;
    }, this.buildAndCommitLocation = ({
      replace,
      resetScroll,
      hashScrollIntoView,
      viewTransition,
      ignoreBlocker,
      href,
      ...rest
    } = {}) => {
      if (href) {
        const currentIndex = this.history.location.state.__TSR_index, parsed = parseHref(href, {
          __TSR_index: replace ? currentIndex : currentIndex + 1
        });
        rest.to = parsed.pathname, rest.search = this.options.parseSearch(parsed.search), rest.hash = parsed.hash.slice(1);
      }
      const location = this.buildLocation({
        ...rest,
        _includeValidateSearch: !0
      });
      return this.commitLocation({
        ...location,
        viewTransition,
        replace,
        resetScroll,
        hashScrollIntoView,
        ignoreBlocker
      });
    }, this.navigate = ({ to, reloadDocument, href, ...rest }) => {
      if (reloadDocument) {
        if (!href) {
          const location = this.buildLocation({ to, ...rest });
          href = this.history.createHref(location.href);
        }
        rest.replace ? window.location.replace(href) : window.location.href = href;
        return;
      }
      return this.buildAndCommitLocation({
        ...rest,
        href,
        to
      });
    }, this.load = async (opts) => {
      this.latestLocation = this.parseLocation(this.latestLocation);
      let redirect2, notFound2, loadPromise;
      for (loadPromise = new Promise((resolve) => {
        this.startTransition(async () => {
          var _a;
          try {
            const next = this.latestLocation, prevLocation = this.state.resolvedLocation;
            this.cancelMatches();
            let pendingMatches;
            batch(() => {
              pendingMatches = this.matchRoutes(next), this.__store.setState((s2) => ({
                ...s2,
                status: "pending",
                isLoading: !0,
                location: next,
                pendingMatches,
                // If a cached moved to pendingMatches, remove it from cachedMatches
                cachedMatches: s2.cachedMatches.filter((d2) => !pendingMatches.find((e2) => e2.id === d2.id))
              }));
            }), this.state.redirect || this.emit({
              type: "onBeforeNavigate",
              ...getLocationChangeInfo({
                resolvedLocation: prevLocation,
                location: next
              })
            }), this.emit({
              type: "onBeforeLoad",
              ...getLocationChangeInfo({
                resolvedLocation: prevLocation,
                location: next
              })
            }), await this.loadMatches({
              sync: opts?.sync,
              matches: pendingMatches,
              location: next,
              // eslint-disable-next-line @typescript-eslint/require-await
              onReady: async () => {
                this.startViewTransition(async () => {
                  let exitingMatches, enteringMatches, stayingMatches;
                  batch(() => {
                    this.__store.setState((s2) => {
                      const previousMatches = s2.matches, newMatches = s2.pendingMatches || s2.matches;
                      return exitingMatches = previousMatches.filter(
                        (match) => !newMatches.find((d2) => d2.id === match.id)
                      ), enteringMatches = newMatches.filter(
                        (match) => !previousMatches.find((d2) => d2.id === match.id)
                      ), stayingMatches = previousMatches.filter(
                        (match) => newMatches.find((d2) => d2.id === match.id)
                      ), {
                        ...s2,
                        isLoading: !1,
                        loadedAt: Date.now(),
                        matches: newMatches,
                        pendingMatches: void 0,
                        cachedMatches: [
                          ...s2.cachedMatches,
                          ...exitingMatches.filter((d2) => d2.status !== "error")
                        ]
                      };
                    }), this.clearExpiredCache();
                  }), [
                    [exitingMatches, "onLeave"],
                    [enteringMatches, "onEnter"],
                    [stayingMatches, "onStay"]
                  ].forEach(([matches, hook]) => {
                    matches.forEach((match) => {
                      var _a2, _b;
                      (_b = (_a2 = this.looseRoutesById[match.routeId].options)[hook]) == null || _b.call(_a2, match);
                    });
                  });
                });
              }
            });
          } catch (err) {
            isResolvedRedirect(err) ? (redirect2 = err, this.isServer || this.navigate({
              ...redirect2,
              replace: !0,
              ignoreBlocker: !0
            })) : isNotFound(err) && (notFound2 = err), this.__store.setState((s2) => ({
              ...s2,
              statusCode: redirect2 ? redirect2.statusCode : notFound2 ? 404 : s2.matches.some((d2) => d2.status === "error") ? 500 : 200,
              redirect: redirect2
            }));
          }
          this.latestLoadPromise === loadPromise && ((_a = this.commitLocationPromise) == null || _a.resolve(), this.latestLoadPromise = void 0, this.commitLocationPromise = void 0), resolve();
        });
      }), this.latestLoadPromise = loadPromise, await loadPromise; this.latestLoadPromise && loadPromise !== this.latestLoadPromise; )
        await this.latestLoadPromise;
      this.hasNotFoundMatch() && this.__store.setState((s2) => ({
        ...s2,
        statusCode: 404
      }));
    }, this.startViewTransition = (fn) => {
      const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;
      if (delete this.shouldViewTransition, shouldViewTransition && typeof document < "u" && "startViewTransition" in document && typeof document.startViewTransition == "function") {
        let startViewTransitionParams;
        typeof shouldViewTransition == "object" && this.isViewTransitionTypesSupported ? startViewTransitionParams = {
          update: fn,
          types: shouldViewTransition.types
        } : startViewTransitionParams = fn, document.startViewTransition(startViewTransitionParams);
      } else
        fn();
    }, this.updateMatch = (id2, updater) => {
      var _a;
      let updated;
      const isPending = (_a = this.state.pendingMatches) == null ? void 0 : _a.find((d2) => d2.id === id2), isMatched = this.state.matches.find((d2) => d2.id === id2), isCached = this.state.cachedMatches.find((d2) => d2.id === id2), matchesKey = isPending ? "pendingMatches" : isMatched ? "matches" : isCached ? "cachedMatches" : "";
      return matchesKey && this.__store.setState((s2) => {
        var _a2;
        return {
          ...s2,
          [matchesKey]: (_a2 = s2[matchesKey]) == null ? void 0 : _a2.map(
            (d2) => d2.id === id2 ? updated = updater(d2) : d2
          )
        };
      }), updated;
    }, this.getMatch = (matchId) => [
      ...this.state.cachedMatches,
      ...this.state.pendingMatches ?? [],
      ...this.state.matches
    ].find((d2) => d2.id === matchId), this.loadMatches = async ({
      location,
      matches,
      preload: allPreload,
      onReady,
      updateMatch = this.updateMatch,
      sync
    }) => {
      let firstBadMatchIndex, rendered = !1;
      const triggerOnReady = async () => {
        rendered || (rendered = !0, await onReady?.());
      }, resolvePreload = (matchId) => !!(allPreload && !this.state.matches.find((d2) => d2.id === matchId));
      !this.isServer && !this.state.matches.length && triggerOnReady();
      const handleRedirectAndNotFound = (match, err) => {
        var _a, _b, _c, _d;
        if (isResolvedRedirect(err) && !err.reloadDocument)
          throw err;
        if (isRedirect(err) || isNotFound(err)) {
          if (updateMatch(match.id, (prev) => ({
            ...prev,
            status: isRedirect(err) ? "redirected" : isNotFound(err) ? "notFound" : "error",
            isFetching: !1,
            error: err,
            beforeLoadPromise: void 0,
            loaderPromise: void 0
          })), err.routeId || (err.routeId = match.routeId), (_a = match.beforeLoadPromise) == null || _a.resolve(), (_b = match.loaderPromise) == null || _b.resolve(), (_c = match.loadPromise) == null || _c.resolve(), isRedirect(err))
            throw rendered = !0, err = this.resolveRedirect({ ...err, _fromLocation: location }), err;
          if (isNotFound(err))
            throw this._handleNotFound(matches, err, {
              updateMatch
            }), (_d = this.serverSsr) == null || _d.onMatchSettled({
              router: this,
              match: this.getMatch(match.id)
            }), err;
        }
      };
      try {
        await new Promise((resolveAll, rejectAll) => {
          (async () => {
            var _a, _b, _c, _d;
            try {
              const handleSerialError = (index2, err, routerCode) => {
                var _a2, _b2;
                const { id: matchId, routeId } = matches[index2], route = this.looseRoutesById[routeId];
                if (err instanceof Promise)
                  throw err;
                err.routerCode = routerCode, firstBadMatchIndex = firstBadMatchIndex ?? index2, handleRedirectAndNotFound(this.getMatch(matchId), err);
                try {
                  (_b2 = (_a2 = route.options).onError) == null || _b2.call(_a2, err);
                } catch (errorHandlerErr) {
                  err = errorHandlerErr, handleRedirectAndNotFound(this.getMatch(matchId), err);
                }
                updateMatch(matchId, (prev) => {
                  var _a3, _b3;
                  return (_a3 = prev.beforeLoadPromise) == null || _a3.resolve(), (_b3 = prev.loadPromise) == null || _b3.resolve(), {
                    ...prev,
                    error: err,
                    status: "error",
                    isFetching: !1,
                    updatedAt: Date.now(),
                    abortController: new AbortController(),
                    beforeLoadPromise: void 0
                  };
                });
              };
              for (const [index2, { id: matchId, routeId }] of matches.entries()) {
                const existingMatch = this.getMatch(matchId), parentMatchId = (_a = matches[index2 - 1]) == null ? void 0 : _a.id, route = this.looseRoutesById[routeId], pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs, shouldPending = !!(onReady && !this.isServer && !resolvePreload(matchId) && (route.options.loader || route.options.beforeLoad) && typeof pendingMs == "number" && pendingMs !== 1 / 0 && (route.options.pendingComponent ?? ((_b = this.options) == null ? void 0 : _b.defaultPendingComponent)));
                let executeBeforeLoad = !0;
                if (
                  // If we are in the middle of a load, either of these will be present
                  // (not to be confused with `loadPromise`, which is always defined)
                  (existingMatch.beforeLoadPromise || existingMatch.loaderPromise) && (shouldPending && setTimeout(() => {
                    try {
                      triggerOnReady();
                    } catch {
                    }
                  }, pendingMs), await existingMatch.beforeLoadPromise, executeBeforeLoad = this.getMatch(matchId).status !== "success"), executeBeforeLoad
                ) {
                  try {
                    updateMatch(matchId, (prev) => {
                      const prevLoadPromise = prev.loadPromise;
                      return {
                        ...prev,
                        loadPromise: createControlledPromise(() => {
                          prevLoadPromise?.resolve();
                        }),
                        beforeLoadPromise: createControlledPromise()
                      };
                    });
                    const abortController = new AbortController();
                    let pendingTimeout;
                    shouldPending && (pendingTimeout = setTimeout(() => {
                      try {
                        triggerOnReady();
                      } catch {
                      }
                    }, pendingMs));
                    const { paramsError, searchError } = this.getMatch(matchId);
                    paramsError && handleSerialError(index2, paramsError, "PARSE_PARAMS"), searchError && handleSerialError(index2, searchError, "VALIDATE_SEARCH");
                    const getParentMatchContext = () => parentMatchId ? this.getMatch(parentMatchId).context : this.options.context ?? {};
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      isFetching: "beforeLoad",
                      fetchCount: prev.fetchCount + 1,
                      abortController,
                      pendingTimeout,
                      context: {
                        ...getParentMatchContext(),
                        ...prev.__routeContext
                      }
                    }));
                    const { search, params, context: context2, cause } = this.getMatch(matchId), preload = resolvePreload(matchId), beforeLoadFnContext = {
                      search,
                      abortController,
                      params,
                      preload,
                      context: context2,
                      location,
                      navigate: (opts) => this.navigate({ ...opts, _fromLocation: location }),
                      buildLocation: this.buildLocation,
                      cause: preload ? "preload" : cause,
                      matches
                    }, beforeLoadContext = await ((_d = (_c = route.options).beforeLoad) == null ? void 0 : _d.call(_c, beforeLoadFnContext)) ?? {};
                    (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) && handleSerialError(index2, beforeLoadContext, "BEFORE_LOAD"), updateMatch(matchId, (prev) => ({
                      ...prev,
                      __beforeLoadContext: beforeLoadContext,
                      context: {
                        ...getParentMatchContext(),
                        ...prev.__routeContext,
                        ...beforeLoadContext
                      },
                      abortController
                    }));
                  } catch (err) {
                    handleSerialError(index2, err, "BEFORE_LOAD");
                  }
                  updateMatch(matchId, (prev) => {
                    var _a2;
                    return (_a2 = prev.beforeLoadPromise) == null || _a2.resolve(), {
                      ...prev,
                      beforeLoadPromise: void 0,
                      isFetching: !1
                    };
                  });
                }
              }
              const validResolvedMatches = matches.slice(0, firstBadMatchIndex), matchPromises = [];
              validResolvedMatches.forEach(({ id: matchId, routeId }, index2) => {
                matchPromises.push(
                  (async () => {
                    const { loaderPromise: prevLoaderPromise } = this.getMatch(matchId);
                    let loaderShouldRunAsync = !1, loaderIsRunningAsync = !1;
                    if (prevLoaderPromise) {
                      await prevLoaderPromise;
                      const match = this.getMatch(matchId);
                      match.error && handleRedirectAndNotFound(match, match.error);
                    } else {
                      const parentMatchPromise = matchPromises[index2 - 1], route = this.looseRoutesById[routeId], getLoaderContext = () => {
                        const {
                          params,
                          loaderDeps,
                          abortController,
                          context: context2,
                          cause
                        } = this.getMatch(matchId), preload2 = resolvePreload(matchId);
                        return {
                          params,
                          deps: loaderDeps,
                          preload: !!preload2,
                          parentMatchPromise,
                          abortController,
                          context: context2,
                          location,
                          navigate: (opts) => this.navigate({ ...opts, _fromLocation: location }),
                          cause: preload2 ? "preload" : cause,
                          route
                        };
                      }, age = Date.now() - this.getMatch(matchId).updatedAt, preload = resolvePreload(matchId), staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0, shouldReloadOption = route.options.shouldReload, shouldReload = typeof shouldReloadOption == "function" ? shouldReloadOption(getLoaderContext()) : shouldReloadOption;
                      updateMatch(matchId, (prev) => ({
                        ...prev,
                        loaderPromise: createControlledPromise(),
                        preload: !!preload && !this.state.matches.find((d2) => d2.id === matchId)
                      }));
                      const runLoader = async () => {
                        var _a2, _b2, _c2, _d2, _e, _f, _g, _h, _i, _j, _k;
                        try {
                          const potentialPendingMinPromise = async () => {
                            const latestMatch = this.getMatch(matchId);
                            latestMatch.minPendingPromise && await latestMatch.minPendingPromise;
                          };
                          try {
                            this.loadRouteChunk(route), updateMatch(matchId, (prev) => ({
                              ...prev,
                              isFetching: "loader"
                            }));
                            const loaderData = await ((_b2 = (_a2 = route.options).loader) == null ? void 0 : _b2.call(_a2, getLoaderContext()));
                            handleRedirectAndNotFound(
                              this.getMatch(matchId),
                              loaderData
                            ), await route._lazyPromise, await potentialPendingMinPromise();
                            const assetContext = {
                              matches,
                              match: this.getMatch(matchId),
                              params: this.getMatch(matchId).params,
                              loaderData
                            }, headFnContent = (_d2 = (_c2 = route.options).head) == null ? void 0 : _d2.call(_c2, assetContext), meta = headFnContent?.meta, links = headFnContent?.links, headScripts = headFnContent?.scripts, scripts = (_f = (_e = route.options).scripts) == null ? void 0 : _f.call(_e, assetContext), headers = (_h = (_g = route.options).headers) == null ? void 0 : _h.call(_g, {
                              loaderData
                            });
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              error: void 0,
                              status: "success",
                              isFetching: !1,
                              updatedAt: Date.now(),
                              loaderData,
                              meta,
                              links,
                              headScripts,
                              headers,
                              scripts
                            }));
                          } catch (e2) {
                            let error = e2;
                            await potentialPendingMinPromise(), handleRedirectAndNotFound(this.getMatch(matchId), e2);
                            try {
                              (_j = (_i = route.options).onError) == null || _j.call(_i, e2);
                            } catch (onErrorError) {
                              error = onErrorError, handleRedirectAndNotFound(
                                this.getMatch(matchId),
                                onErrorError
                              );
                            }
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              error,
                              status: "error",
                              isFetching: !1
                            }));
                          }
                          (_k = this.serverSsr) == null || _k.onMatchSettled({
                            router: this,
                            match: this.getMatch(matchId)
                          }), await route._componentsPromise;
                        } catch (err) {
                          updateMatch(matchId, (prev) => ({
                            ...prev,
                            loaderPromise: void 0
                          })), handleRedirectAndNotFound(this.getMatch(matchId), err);
                        }
                      }, { status, invalid } = this.getMatch(matchId);
                      loaderShouldRunAsync = status === "success" && (invalid || (shouldReload ?? age > staleAge)), preload && route.options.preload === !1 || (loaderShouldRunAsync && !sync ? (loaderIsRunningAsync = !0, (async () => {
                        try {
                          await runLoader();
                          const { loaderPromise, loadPromise } = this.getMatch(matchId);
                          loaderPromise?.resolve(), loadPromise?.resolve(), updateMatch(matchId, (prev) => ({
                            ...prev,
                            loaderPromise: void 0
                          }));
                        } catch (err) {
                          isResolvedRedirect(err) && await this.navigate(err);
                        }
                      })()) : (status !== "success" || loaderShouldRunAsync && sync) && await runLoader());
                    }
                    if (!loaderIsRunningAsync) {
                      const { loaderPromise, loadPromise } = this.getMatch(matchId);
                      loaderPromise?.resolve(), loadPromise?.resolve();
                    }
                    return updateMatch(matchId, (prev) => ({
                      ...prev,
                      isFetching: loaderIsRunningAsync ? prev.isFetching : !1,
                      loaderPromise: loaderIsRunningAsync ? prev.loaderPromise : void 0,
                      invalid: !1
                    })), this.getMatch(matchId);
                  })()
                );
              }), await Promise.all(matchPromises), resolveAll();
            } catch (err) {
              rejectAll(err);
            }
          })();
        }), await triggerOnReady();
      } catch (err) {
        if (isRedirect(err) || isNotFound(err))
          throw isNotFound(err) && !allPreload && await triggerOnReady(), err;
      }
      return matches;
    }, this.invalidate = (opts) => {
      const invalidate = (d2) => {
        var _a;
        return ((_a = opts?.filter) == null ? void 0 : _a.call(opts, d2)) ?? !0 ? {
          ...d2,
          invalid: !0,
          ...d2.status === "error" ? { status: "pending", error: void 0 } : {}
        } : d2;
      };
      return this.__store.setState((s2) => {
        var _a;
        return {
          ...s2,
          matches: s2.matches.map(invalidate),
          cachedMatches: s2.cachedMatches.map(invalidate),
          pendingMatches: (_a = s2.pendingMatches) == null ? void 0 : _a.map(invalidate)
        };
      }), this.load({ sync: opts?.sync });
    }, this.resolveRedirect = (err) => {
      const redirect2 = err;
      return redirect2.href || (redirect2.href = this.buildLocation(redirect2).href), redirect2;
    }, this.clearCache = (opts) => {
      const filter2 = opts?.filter;
      filter2 !== void 0 ? this.__store.setState((s2) => ({
        ...s2,
        cachedMatches: s2.cachedMatches.filter(
          (m2) => !filter2(m2)
        )
      })) : this.__store.setState((s2) => ({
        ...s2,
        cachedMatches: []
      }));
    }, this.clearExpiredCache = () => {
      const filter2 = (d2) => {
        const route = this.looseRoutesById[d2.routeId];
        if (!route.options.loader)
          return !0;
        const gcTime = (d2.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;
        return !(d2.status !== "error" && Date.now() - d2.updatedAt < gcTime);
      };
      this.clearCache({ filter: filter2 });
    }, this.loadRouteChunk = (route) => (route._lazyPromise === void 0 && (route.lazyFn ? route._lazyPromise = route.lazyFn().then((lazyRoute) => {
      const { id: _id, ...options2 } = lazyRoute.options;
      Object.assign(route.options, options2);
    }) : route._lazyPromise = Promise.resolve()), route._componentsPromise === void 0 && (route._componentsPromise = route._lazyPromise.then(
      () => Promise.all(
        componentTypes.map(async (type) => {
          const component = route.options[type];
          component?.preload && await component.preload();
        })
      )
    )), route._componentsPromise), this.preloadRoute = async (opts) => {
      const next = this.buildLocation(opts);
      let matches = this.matchRoutes(next, {
        throwOnError: !0,
        preload: !0,
        dest: opts
      });
      const activeMatchIds = new Set(
        [...this.state.matches, ...this.state.pendingMatches ?? []].map(
          (d2) => d2.id
        )
      ), loadedMatchIds = /* @__PURE__ */ new Set([
        ...activeMatchIds,
        ...this.state.cachedMatches.map((d2) => d2.id)
      ]);
      batch(() => {
        matches.forEach((match) => {
          loadedMatchIds.has(match.id) || this.__store.setState((s2) => ({
            ...s2,
            cachedMatches: [...s2.cachedMatches, match]
          }));
        });
      });
      try {
        return matches = await this.loadMatches({
          matches,
          location: next,
          preload: !0,
          updateMatch: (id2, updater) => {
            activeMatchIds.has(id2) ? matches = matches.map((d2) => d2.id === id2 ? updater(d2) : d2) : this.updateMatch(id2, updater);
          }
        }), matches;
      } catch (err) {
        if (isRedirect(err))
          return err.reloadDocument ? void 0 : await this.preloadRoute({
            ...err,
            _fromLocation: next
          });
        isNotFound(err) || console.error(err);
        return;
      }
    }, this.matchRoute = (location, opts) => {
      const matchLocation = {
        ...location,
        to: location.to ? this.resolvePathWithBase(
          location.from || "",
          location.to
        ) : void 0,
        params: location.params || {},
        leaveParams: !0
      }, next = this.buildLocation(matchLocation);
      if (opts?.pending && this.state.status !== "pending")
        return !1;
      const baseLocation = (opts?.pending === void 0 ? !this.state.isLoading : opts.pending) ? this.latestLocation : this.state.resolvedLocation || this.state.location, match = matchPathname(this.basepath, baseLocation.pathname, {
        ...opts,
        to: next.pathname
      });
      return !match || location.params && !deepEqual$1(match, location.params, { partial: !0 }) ? !1 : match && (opts?.includeSearch ?? !0) ? deepEqual$1(baseLocation.search, next.search, { partial: !0 }) ? match : !1 : match;
    }, this._handleNotFound = (matches, err, {
      updateMatch = this.updateMatch
    } = {}) => {
      var _a;
      const routeCursor = this.routesById[err.routeId ?? ""] ?? this.routeTree, matchesByRouteId = {};
      for (const match of matches)
        matchesByRouteId[match.routeId] = match;
      !routeCursor.options.notFoundComponent && ((_a = this.options) != null && _a.defaultNotFoundComponent) && (routeCursor.options.notFoundComponent = this.options.defaultNotFoundComponent), invariant$1(
        routeCursor.options.notFoundComponent,
        "No notFoundComponent found. Please set a notFoundComponent on your route or provide a defaultNotFoundComponent to the router."
      );
      const matchForRoute = matchesByRouteId[routeCursor.id];
      invariant$1(
        matchForRoute,
        "Could not find match for route: " + routeCursor.id
      ), updateMatch(matchForRoute.id, (prev) => ({
        ...prev,
        status: "notFound",
        error: err,
        isFetching: !1
      })), err.routerCode === "BEFORE_LOAD" && routeCursor.parentRoute && (err.routeId = routeCursor.parentRoute.id, this._handleNotFound(matches, err, {
        updateMatch
      }));
    }, this.hasNotFoundMatch = () => this.__store.state.matches.some(
      (d2) => d2.status === "notFound" || d2.globalNotFound
    ), this.update({
      defaultPreloadDelay: 50,
      defaultPendingMs: 1e3,
      defaultPendingMinMs: 500,
      context: void 0,
      ...options,
      caseSensitive: options.caseSensitive ?? !1,
      notFoundMode: options.notFoundMode ?? "fuzzy",
      stringifySearch: options.stringifySearch ?? defaultStringifySearch,
      parseSearch: options.parseSearch ?? defaultParseSearch
    }), typeof document < "u" && (window.__TSR_ROUTER__ = this);
  }
  get state() {
    return this.__store.state;
  }
  get looseRoutesById() {
    return this.routesById;
  }
  matchRoutesInternal(next, opts) {
    const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(
      next,
      opts?.dest
    );
    let isGlobalNotFound = !1;
    // If we found a route, and it's not an index route and we have left over path
    (foundRoute ? foundRoute.path !== "/" && routeParams["**"] : (
      // Or if we didn't find a route and we have left over path
      trimPathRight(next.pathname)
    )) && (this.options.notFoundRoute ? matchedRoutes.push(this.options.notFoundRoute) : isGlobalNotFound = !0);
    const globalNotFoundRouteId = (() => {
      if (isGlobalNotFound) {
        if (this.options.notFoundMode !== "root")
          for (let i2 = matchedRoutes.length - 1; i2 >= 0; i2--) {
            const route = matchedRoutes[i2];
            if (route.children)
              return route.id;
          }
        return rootRouteId;
      }
    })(), parseErrors = matchedRoutes.map((route) => {
      var _a;
      let parsedParamsError;
      const parseParams = ((_a = route.options.params) == null ? void 0 : _a.parse) ?? route.options.parseParams;
      if (parseParams)
        try {
          const parsedParams = parseParams(routeParams);
          Object.assign(routeParams, parsedParams);
        } catch (err) {
          if (parsedParamsError = new PathParamError(err.message, {
            cause: err
          }), opts?.throwOnError)
            throw parsedParamsError;
          return parsedParamsError;
        }
    }), matches = [], getParentContext = (parentMatch) => parentMatch?.id ? parentMatch.context ?? this.options.context ?? {} : this.options.context ?? {};
    return matchedRoutes.forEach((route, index2) => {
      var _a, _b;
      const parentMatch = matches[index2 - 1], [preMatchSearch, strictMatchSearch, searchError] = (() => {
        const parentSearch = parentMatch?.search ?? next.search, parentStrictSearch = parentMatch?._strictSearch ?? {};
        try {
          const strictSearch = validateSearch(route.options.validateSearch, { ...parentSearch }) ?? {};
          return [
            {
              ...parentSearch,
              ...strictSearch
            },
            { ...parentStrictSearch, ...strictSearch },
            void 0
          ];
        } catch (err) {
          let searchParamError = err;
          if (err instanceof SearchParamError || (searchParamError = new SearchParamError(err.message, {
            cause: err
          })), opts?.throwOnError)
            throw searchParamError;
          return [parentSearch, {}, searchParamError];
        }
      })(), loaderDeps = ((_b = (_a = route.options).loaderDeps) == null ? void 0 : _b.call(_a, {
        search: preMatchSearch
      })) ?? "", loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "", { usedParams, interpolatedPath } = interpolatePath({
        path: route.fullPath,
        params: routeParams,
        decodeCharMap: this.pathParamsDecodeCharMap
      }), matchId = interpolatePath({
        path: route.id,
        params: routeParams,
        leaveWildcards: !0,
        decodeCharMap: this.pathParamsDecodeCharMap
      }).interpolatedPath + loaderDepsHash, existingMatch = this.getMatch(matchId), previousMatch = this.state.matches.find(
        (d2) => d2.routeId === route.id
      ), cause = previousMatch ? "stay" : "enter";
      let match;
      if (existingMatch)
        match = {
          ...existingMatch,
          cause,
          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,
          _strictParams: usedParams,
          search: replaceEqualDeep(previousMatch ? previousMatch.search : existingMatch.search, preMatchSearch),
          _strictSearch: strictMatchSearch
        };
      else {
        const status = route.options.loader || route.options.beforeLoad || route.lazyFn || routeNeedsPreload(route) ? "pending" : "success";
        match = {
          id: matchId,
          index: index2,
          routeId: route.id,
          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,
          _strictParams: usedParams,
          pathname: joinPaths([this.basepath, interpolatedPath]),
          updatedAt: Date.now(),
          search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : preMatchSearch,
          _strictSearch: strictMatchSearch,
          searchError: void 0,
          status,
          isFetching: !1,
          error: void 0,
          paramsError: parseErrors[index2],
          __routeContext: {},
          __beforeLoadContext: {},
          context: {},
          abortController: new AbortController(),
          fetchCount: 0,
          cause,
          loaderDeps: previousMatch ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps) : loaderDeps,
          invalid: !1,
          preload: !1,
          links: void 0,
          scripts: void 0,
          headScripts: void 0,
          meta: void 0,
          staticData: route.options.staticData || {},
          loadPromise: createControlledPromise(),
          fullPath: route.fullPath
        };
      }
      opts?.preload || (match.globalNotFound = globalNotFoundRouteId === route.id), match.searchError = searchError;
      const parentContext = getParentContext(parentMatch);
      match.context = {
        ...parentContext,
        ...match.__routeContext,
        ...match.__beforeLoadContext
      }, matches.push(match);
    }), matches.forEach((match, index2) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const route = this.looseRoutesById[match.routeId];
      if (!this.getMatch(match.id) && opts?._buildLocation !== !0) {
        const parentMatch = matches[index2 - 1], parentContext = getParentContext(parentMatch), contextFnContext = {
          deps: match.loaderDeps,
          params: match.params,
          context: parentContext,
          location: next,
          navigate: (opts2) => this.navigate({ ...opts2, _fromLocation: next }),
          buildLocation: this.buildLocation,
          cause: match.cause,
          abortController: match.abortController,
          preload: !!match.preload,
          matches
        };
        match.__routeContext = ((_b = (_a = route.options).context) == null ? void 0 : _b.call(_a, contextFnContext)) ?? {}, match.context = {
          ...parentContext,
          ...match.__routeContext,
          ...match.__beforeLoadContext
        };
      }
      if (match.status === "success") {
        match.headers = (_d = (_c = route.options).headers) == null ? void 0 : _d.call(_c, {
          loaderData: match.loaderData
        });
        const assetContext = {
          matches,
          match,
          params: match.params,
          loaderData: match.loaderData
        }, headFnContent = (_f = (_e = route.options).head) == null ? void 0 : _f.call(_e, assetContext);
        match.links = headFnContent?.links, match.headScripts = headFnContent?.scripts, match.meta = headFnContent?.meta, match.scripts = (_h = (_g = route.options).scripts) == null ? void 0 : _h.call(_g, assetContext);
      }
    }), matches;
  }
}
class SearchParamError extends Error {
}
class PathParamError extends Error {
}
function getInitialRouterState(location) {
  return {
    loadedAt: 0,
    isLoading: !1,
    isTransitioning: !1,
    status: "idle",
    resolvedLocation: void 0,
    location,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    statusCode: 200
  };
}
function validateSearch(validateSearch2, input2) {
  if (validateSearch2 == null) return {};
  if ("~standard" in validateSearch2) {
    const result = validateSearch2["~standard"].validate(input2);
    if (result instanceof Promise)
      throw new SearchParamError("Async validation not supported");
    if (result.issues)
      throw new SearchParamError(JSON.stringify(result.issues, void 0, 2), {
        cause: result
      });
    return result.value;
  }
  return "parse" in validateSearch2 ? validateSearch2.parse(input2) : typeof validateSearch2 == "function" ? validateSearch2(input2) : {};
}
const componentTypes = [
  "component",
  "errorComponent",
  "pendingComponent",
  "notFoundComponent"
];
function routeNeedsPreload(route) {
  var _a;
  for (const componentType of componentTypes)
    if ((_a = route.options[componentType]) != null && _a.preload)
      return !0;
  return !1;
}
const preloadWarning = "Error preloading route! ";
class BaseRoute {
  constructor(options) {
    if (this.init = (opts) => {
      var _a, _b;
      this.originalIndex = opts.originalIndex;
      const options2 = this.options, isRoot = !options2?.path && !options2?.id;
      if (this.parentRoute = (_b = (_a = this.options).getParentRoute) == null ? void 0 : _b.call(_a), isRoot)
        this._path = rootRouteId;
      else if (!this.parentRoute)
        throw new Error(
          "Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance."
        );
      let path = isRoot ? rootRouteId : options2?.path;
      path && path !== "/" && (path = trimPathLeft(path));
      const customId = options2?.id || path;
      let id2 = isRoot ? rootRouteId : joinPaths([
        this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id,
        customId
      ]);
      path === rootRouteId && (path = "/"), id2 !== rootRouteId && (id2 = joinPaths(["/", id2]));
      const fullPath = id2 === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path]);
      this._path = path, this._id = id2, this._fullPath = fullPath, this._to = fullPath, this._ssr = options2?.ssr ?? opts.defaultSsr ?? !0;
    }, this.addChildren = (children2) => this._addFileChildren(children2), this._addFileChildren = (children2) => (Array.isArray(children2) && (this.children = children2), typeof children2 == "object" && children2 !== null && (this.children = Object.values(children2)), this), this._addFileTypes = () => this, this.updateLoader = (options2) => (Object.assign(this.options, options2), this), this.update = (options2) => (Object.assign(this.options, options2), this), this.lazy = (lazyFn) => (this.lazyFn = lazyFn, this), this.options = options || {}, this.isRoot = !options?.getParentRoute, options?.id && options?.path)
      throw new Error("Route cannot have both an 'id' and a 'path' option.");
  }
  get to() {
    return this._to;
  }
  get id() {
    return this._id;
  }
  get path() {
    return this._path;
  }
  get fullPath() {
    return this._fullPath;
  }
  get ssr() {
    return this._ssr;
  }
}
class BaseRootRoute extends BaseRoute {
  constructor(options) {
    super(options);
  }
}
function CatchBoundary(props) {
  const errorComponent = props.errorComponent ?? ErrorComponent;
  return /* @__PURE__ */ jsx(
    CatchBoundaryImpl,
    {
      getResetKey: props.getResetKey,
      onCatch: props.onCatch,
      children: ({ error, reset }) => error ? React.createElement(errorComponent, {
        error,
        reset
      }) : props.children
    }
  );
}
class CatchBoundaryImpl extends React.Component {
  constructor() {
    super(...arguments), this.state = { error: null };
  }
  static getDerivedStateFromProps(props) {
    return { resetKey: props.getResetKey() };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  reset() {
    this.setState({ error: null });
  }
  componentDidUpdate(prevProps, prevState) {
    prevState.error && prevState.resetKey !== this.state.resetKey && this.reset();
  }
  componentDidCatch(error, errorInfo) {
    this.props.onCatch && this.props.onCatch(error, errorInfo);
  }
  render() {
    return this.props.children({
      error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
      reset: () => {
        this.reset();
      }
    });
  }
}
function ErrorComponent({ error }) {
  const [show, setShow] = React.useState(!1);
  return /* @__PURE__ */ jsxs("div", { style: { padding: ".5rem", maxWidth: "100%" }, children: [
    /* @__PURE__ */ jsxs("div", { style: { display: "flex", alignItems: "center", gap: ".5rem" }, children: [
      /* @__PURE__ */ jsx("strong", { style: { fontSize: "1rem" }, children: "Something went wrong!" }),
      /* @__PURE__ */ jsx(
        "button",
        {
          style: {
            appearance: "none",
            fontSize: ".6em",
            border: "1px solid currentColor",
            padding: ".1rem .2rem",
            fontWeight: "bold",
            borderRadius: ".25rem"
          },
          onClick: () => setShow((d2) => !d2),
          children: show ? "Hide Error" : "Show Error"
        }
      )
    ] }),
    /* @__PURE__ */ jsx("div", { style: { height: ".25rem" } }),
    show ? /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
      "pre",
      {
        style: {
          fontSize: ".7em",
          border: "1px solid red",
          borderRadius: ".25rem",
          padding: ".3rem",
          color: "red",
          overflow: "auto"
        },
        children: error.message ? /* @__PURE__ */ jsx("code", { children: error.message }) : null
      }
    ) }) : null
  ] });
}
var withSelector = { exports: {} }, withSelector_production = {}, shim = { exports: {} }, useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = React__default;
  function is(x2, y2) {
    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is, useState2 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect2 = React2.useLayoutEffect, useDebugValue2 = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState2({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    return useLayoutEffect2(
      function() {
        inst.value = value, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    ), useEffect2(
      function() {
        return checkIfSnapshotChanged(inst) && forceUpdate({ inst }), subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    ), useDebugValue2(value), value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch {
      return !0;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? useSyncExternalStore$1 : useSyncExternalStore$2;
  return useSyncExternalStoreShim_production.useSyncExternalStore = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim2, useSyncExternalStoreShim_production;
}
shim.exports;
var hasRequiredShim;
function requireShim() {
  return hasRequiredShim || (hasRequiredShim = 1, shim.exports = requireUseSyncExternalStoreShim_production()), shim.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = React__default, shim2 = requireShim();
  function is(x2, y2) {
    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is, useSyncExternalStore2 = shim2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue2 = React2.useDebugValue;
  return withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector3, isEqual2) {
    var instRef = useRef2(null);
    if (instRef.current === null) {
      var inst = { hasValue: !1, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo2(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector3(nextSnapshot), isEqual2 !== void 0 && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual2(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector3(nextSnapshot);
          return isEqual2 !== void 0 && isEqual2(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
        }
        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector3, isEqual2]
    );
    var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
    return useEffect2(
      function() {
        inst.hasValue = !0, inst.value = value;
      },
      [value]
    ), useDebugValue2(value), value;
  }, withSelector_production;
}
withSelector.exports;
var hasRequiredWithSelector;
function requireWithSelector() {
  return hasRequiredWithSelector || (hasRequiredWithSelector = 1, withSelector.exports = requireWithSelector_production()), withSelector.exports;
}
var withSelectorExports = requireWithSelector();
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
function useStore$2(store, selector3 = (d2) => d2) {
  return withSelectorExports.useSyncExternalStoreWithSelector(
    store.subscribe,
    () => store.state,
    () => store.state,
    selector3,
    shallow
  );
}
function shallow(objA, objB) {
  if (Object.is(objA, objB))
    return !0;
  if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
    return !1;
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return !1;
    for (const [k2, v] of objA)
      if (!objB.has(k2) || !Object.is(v, objB.get(k2))) return !1;
    return !0;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return !1;
    for (const v of objA)
      if (!objB.has(v)) return !1;
    return !0;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length)
    return !1;
  for (let i2 = 0; i2 < keysA.length; i2++)
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !Object.is(objA[keysA[i2]], objB[keysA[i2]]))
      return !1;
  return !0;
}
const routerContext = React.createContext(null);
function getRouterContext() {
  return typeof document > "u" ? routerContext : window.__TSR_ROUTER_CONTEXT__ ? window.__TSR_ROUTER_CONTEXT__ : (window.__TSR_ROUTER_CONTEXT__ = routerContext, routerContext);
}
function useRouter(opts) {
  const value = React.useContext(getRouterContext());
  return warning(
    !((opts?.warn ?? !0) && !value),
    "useRouter must be used inside a <RouterProvider> component!"
  ), value;
}
function useRouterState(opts) {
  const contextRouter = useRouter({
    warn: opts?.router === void 0
  }), router = opts?.router || contextRouter, previousResult = useRef(void 0);
  return useStore$2(router.__store, (state) => {
    if (opts?.select) {
      if (opts.structuralSharing ?? router.options.defaultStructuralSharing) {
        const newSlice = replaceEqualDeep(
          previousResult.current,
          opts.select(state)
        );
        return previousResult.current = newSlice, newSlice;
      }
      return opts.select(state);
    }
    return state;
  });
}
const matchContext = React.createContext(void 0), dummyMatchContext = React.createContext(
  void 0
);
function useMatch(opts) {
  const nearestMatchId = React.useContext(
    opts.from ? dummyMatchContext : matchContext
  );
  return useRouterState({
    select: (state) => {
      const match = state.matches.find(
        (d2) => opts.from ? opts.from === d2.routeId : d2.id === nearestMatchId
      );
      if (invariant$1(
        !((opts.shouldThrow ?? !0) && !match),
        `Could not find ${opts.from ? `an active match from "${opts.from}"` : "a nearest match!"}`
      ), match !== void 0)
        return opts.select ? opts.select(match) : match;
    },
    structuralSharing: opts.structuralSharing
  });
}
function useLoaderData(opts) {
  return useMatch({
    from: opts.from,
    strict: opts.strict,
    structuralSharing: opts.structuralSharing,
    select: (s2) => opts.select ? opts.select(s2.loaderData) : s2.loaderData
  });
}
function useLoaderDeps(opts) {
  const { select: select2, ...rest } = opts;
  return useMatch({
    ...rest,
    select: (s2) => select2 ? select2(s2.loaderDeps) : s2.loaderDeps
  });
}
function useParams(opts) {
  return useMatch({
    from: opts.from,
    strict: opts.strict,
    shouldThrow: opts.shouldThrow,
    structuralSharing: opts.structuralSharing,
    select: (match) => opts.select ? opts.select(match.params) : match.params
  });
}
function useSearch$1(opts) {
  return useMatch({
    from: opts.from,
    strict: opts.strict,
    shouldThrow: opts.shouldThrow,
    structuralSharing: opts.structuralSharing,
    select: (match) => opts.select ? opts.select(match.search) : match.search
  });
}
function useNavigate(_defaultOpts) {
  const { navigate } = useRouter();
  return React.useCallback(
    (options) => navigate({
      from: _defaultOpts?.from,
      ...options
    }),
    [_defaultOpts?.from, navigate]
  );
}
function Navigate(props) {
  const router = useRouter(), previousPropsRef = React.useRef(null);
  return React.useEffect(() => {
    previousPropsRef.current !== props && (router.navigate({
      ...props
    }), previousPropsRef.current = props);
  }, [router, props]), null;
}
let Route$m = class extends BaseRoute {
  /**
   * @deprecated Use the `createRoute` function instead.
   */
  constructor(options) {
    super(options), this.useMatch = (opts) => useMatch({
      select: opts?.select,
      from: this.id,
      structuralSharing: opts?.structuralSharing
    }), this.useRouteContext = (opts) => useMatch({
      ...opts,
      from: this.id,
      select: (d2) => opts?.select ? opts.select(d2.context) : d2.context
    }), this.useSearch = (opts) => useSearch$1({
      select: opts?.select,
      structuralSharing: opts?.structuralSharing,
      from: this.id
    }), this.useParams = (opts) => useParams({
      select: opts?.select,
      structuralSharing: opts?.structuralSharing,
      from: this.id
    }), this.useLoaderDeps = (opts) => useLoaderDeps({ ...opts, from: this.id }), this.useLoaderData = (opts) => useLoaderData({ ...opts, from: this.id }), this.useNavigate = () => useNavigate({ from: this.fullPath }), this.$$typeof = Symbol.for("react.memo");
  }
};
function createRoute(options) {
  return new Route$m(options);
}
function createRootRouteWithContext() {
  return (options) => createRootRoute(options);
}
class RootRoute extends BaseRootRoute {
  /**
   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
   */
  constructor(options) {
    super(options), this.useMatch = (opts) => useMatch({
      select: opts?.select,
      from: this.id,
      structuralSharing: opts?.structuralSharing
    }), this.useRouteContext = (opts) => useMatch({
      ...opts,
      from: this.id,
      select: (d2) => opts?.select ? opts.select(d2.context) : d2.context
    }), this.useSearch = (opts) => useSearch$1({
      select: opts?.select,
      structuralSharing: opts?.structuralSharing,
      from: this.id
    }), this.useParams = (opts) => useParams({
      select: opts?.select,
      structuralSharing: opts?.structuralSharing,
      from: this.id
    }), this.useLoaderDeps = (opts) => useLoaderDeps({ ...opts, from: this.id }), this.useLoaderData = (opts) => useLoaderData({ ...opts, from: this.id }), this.useNavigate = () => useNavigate({ from: this.fullPath });
  }
}
function createRootRoute(options) {
  return new RootRoute(options);
}
function createFileRoute(path) {
  return new FileRoute(path, {
    silent: !0
  }).createRoute;
}
class FileRoute {
  constructor(path, _opts) {
    this.path = path, this.createRoute = (options) => {
      warning(
        this.silent,
        "FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead."
      );
      const route = createRoute(options);
      return route.isRoot = !1, route;
    }, this.silent = _opts?.silent;
  }
}
function CatchNotFound(props) {
  const resetKey = useRouterState({
    select: (s2) => `not-found-${s2.location.pathname}-${s2.status}`
  });
  return /* @__PURE__ */ jsx(
    CatchBoundary,
    {
      getResetKey: () => resetKey,
      onCatch: (error, errorInfo) => {
        var _a;
        if (isNotFound(error))
          (_a = props.onCatch) == null || _a.call(props, error, errorInfo);
        else
          throw error;
      },
      errorComponent: ({ error }) => {
        var _a;
        if (isNotFound(error))
          return (_a = props.fallback) == null ? void 0 : _a.call(props, error);
        throw error;
      },
      children: props.children
    }
  );
}
function DefaultGlobalNotFound() {
  return /* @__PURE__ */ jsx("p", { children: "Not Found" });
}
function SafeFragment(props) {
  return /* @__PURE__ */ jsx(Fragment$1, { children: props.children });
}
function renderRouteNotFound(router, route, data) {
  return route.options.notFoundComponent ? /* @__PURE__ */ jsx(route.options.notFoundComponent, { data }) : router.options.defaultNotFoundComponent ? /* @__PURE__ */ jsx(router.options.defaultNotFoundComponent, { data }) : /* @__PURE__ */ jsx(DefaultGlobalNotFound, {});
}
var jsesc_1, hasRequiredJsesc;
function requireJsesc() {
  if (hasRequiredJsesc) return jsesc_1;
  hasRequiredJsesc = 1;
  const object = {}, hasOwnProperty2 = object.hasOwnProperty, forOwn = (object2, callback) => {
    for (const key2 in object2)
      hasOwnProperty2.call(object2, key2) && callback(key2, object2[key2]);
  }, extend2 = (destination, source) => (source && forOwn(source, (key2, value) => {
    destination[key2] = value;
  }), destination), forEach = (array2, callback) => {
    const length = array2.length;
    let index2 = -1;
    for (; ++index2 < length; )
      callback(array2[index2]);
  }, fourHexEscape = (hex2) => "\\u" + ("0000" + hex2).slice(-4), hexadecimal = (code, lowercase) => {
    let hexadecimal2 = code.toString(16);
    return lowercase ? hexadecimal2 : hexadecimal2.toUpperCase();
  }, toString2 = object.toString, isArray2 = Array.isArray, isBuffer = (value) => typeof Buffer == "function" && Buffer.isBuffer(value), isObject2 = (value) => toString2.call(value) == "[object Object]", isString = (value) => typeof value == "string" || toString2.call(value) == "[object String]", isNumber2 = (value) => typeof value == "number" || toString2.call(value) == "[object Number]", isBigInt = (value) => typeof value == "bigint", isFunction2 = (value) => typeof value == "function", isMap = (value) => toString2.call(value) == "[object Map]", isSet = (value) => toString2.call(value) == "[object Set]", singleEscapes = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, regexSingleEscape = /[\\\b\f\n\r\t]/, regexDigit = /[0-9]/, regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g, escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, jsesc = (argument, options) => {
    const increaseIndentation = () => {
      oldIndent = indent, ++options.indentLevel, indent = options.indent.repeat(options.indentLevel);
    }, defaults2 = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, json2 = options && options.json;
    json2 && (defaults2.quotes = "double", defaults2.wrap = !0), options = extend2(defaults2, options), options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick" && (options.quotes = "single");
    const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'", compact2 = options.compact, lowercaseHex = options.lowercaseHex;
    let indent = options.indent.repeat(options.indentLevel), oldIndent = "";
    const inline1 = options.__inline1__, inline2 = options.__inline2__, newLine = compact2 ? "" : `
`;
    let result, isEmpty = !0;
    const useBinNumbers = options.numbers == "binary", useOctNumbers = options.numbers == "octal", useDecNumbers = options.numbers == "decimal", useHexNumbers = options.numbers == "hexadecimal";
    if (json2 && argument && isFunction2(argument.toJSON) && (argument = argument.toJSON()), !isString(argument)) {
      if (isMap(argument))
        return argument.size == 0 ? "new Map()" : (compact2 || (options.__inline1__ = !0, options.__inline2__ = !1), "new Map(" + jsesc(Array.from(argument), options) + ")");
      if (isSet(argument))
        return argument.size == 0 ? "new Set()" : "new Set(" + jsesc(Array.from(argument), options) + ")";
      if (isBuffer(argument))
        return argument.length == 0 ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
      if (isArray2(argument))
        return result = [], options.wrap = !0, inline1 && (options.__inline1__ = !1, options.__inline2__ = !0), inline2 || increaseIndentation(), forEach(argument, (value) => {
          isEmpty = !1, inline2 && (options.__inline2__ = !1), result.push(
            (compact2 || inline2 ? "" : indent) + jsesc(value, options)
          );
        }), isEmpty ? "[]" : inline2 ? "[" + result.join(", ") + "]" : "[" + newLine + result.join("," + newLine) + newLine + (compact2 ? "" : oldIndent) + "]";
      if (isNumber2(argument) || isBigInt(argument)) {
        if (json2)
          return JSON.stringify(Number(argument));
        let result2;
        if (useDecNumbers)
          result2 = String(argument);
        else if (useHexNumbers) {
          let hexadecimal2 = argument.toString(16);
          lowercaseHex || (hexadecimal2 = hexadecimal2.toUpperCase()), result2 = "0x" + hexadecimal2;
        } else useBinNumbers ? result2 = "0b" + argument.toString(2) : useOctNumbers && (result2 = "0o" + argument.toString(8));
        return isBigInt(argument) ? result2 + "n" : result2;
      } else return isBigInt(argument) ? json2 ? JSON.stringify(Number(argument)) : argument + "n" : isObject2(argument) ? (result = [], options.wrap = !0, increaseIndentation(), forOwn(argument, (key2, value) => {
        isEmpty = !1, result.push(
          (compact2 ? "" : indent) + jsesc(key2, options) + ":" + (compact2 ? "" : " ") + jsesc(value, options)
        );
      }), isEmpty ? "{}" : "{" + newLine + result.join("," + newLine) + newLine + (compact2 ? "" : oldIndent) + "}") : json2 ? JSON.stringify(argument) || "null" : String(argument);
    }
    const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
    return result = argument.replace(regex, (char, pair, lone, quoteChar, index2, string) => {
      if (pair) {
        if (options.minimal) return pair;
        const first = pair.charCodeAt(0), second = pair.charCodeAt(1);
        if (options.es6) {
          const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
          return "\\u{" + hexadecimal(codePoint, lowercaseHex) + "}";
        }
        return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
      }
      if (lone)
        return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
      if (char == "\0" && !json2 && !regexDigit.test(string.charAt(index2 + 1)))
        return "\\0";
      if (quoteChar)
        return quoteChar == quote || options.escapeEverything ? "\\" + quoteChar : quoteChar;
      if (regexSingleEscape.test(char))
        return singleEscapes[char];
      if (options.minimal && !regexWhitespace.test(char))
        return char;
      const hex2 = hexadecimal(char.charCodeAt(0), lowercaseHex);
      return json2 || hex2.length > 2 ? fourHexEscape(hex2) : "\\x" + ("00" + hex2).slice(-2);
    }), quote == "`" && (result = result.replace(/\$\{/g, "\\${")), options.isScriptContext && (result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--")), options.wrap && (result = quote + result + quote), result;
  };
  return jsesc.version = "3.0.2", jsesc_1 = jsesc, jsesc_1;
}
requireJsesc();
function ScriptOnce({
  children: children2,
  log
}) {
  return typeof document < "u" ? null : /* @__PURE__ */ jsx(
    "script",
    {
      className: "tsr-once",
      dangerouslySetInnerHTML: {
        __html: [
          children2,
          "",
          'if (typeof __TSR_SSR__ !== "undefined") __TSR_SSR__.cleanScripts()'
        ].filter(Boolean).join(`
`)
      }
    }
  );
}
function ScrollRestoration() {
  const router = useRouter(), userKey = (router.options.getScrollRestorationKey || defaultGetScrollRestorationKey)(router.latestLocation), resolvedKey = userKey !== defaultGetScrollRestorationKey(router.latestLocation) ? userKey : null;
  return !router.isScrollRestoring || !router.isServer ? null : /* @__PURE__ */ jsx(
    ScriptOnce,
    {
      children: `(${restoreScroll.toString()})(${JSON.stringify(storageKey)},${JSON.stringify(resolvedKey)}, undefined, true)`,
      log: !1
    }
  );
}
const Match = React.memo(function({
  matchId
}) {
  var _a, _b;
  const router = useRouter(), routeId = useRouterState({
    select: (s2) => {
      var _a2;
      return (_a2 = s2.matches.find((d2) => d2.id === matchId)) == null ? void 0 : _a2.routeId;
    }
  });
  invariant$1(
    routeId,
    `Could not find routeId for matchId "${matchId}". Please file an issue!`
  );
  const route = router.routesById[routeId], PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent, pendingElement = PendingComponent ? /* @__PURE__ */ jsx(PendingComponent, {}) : null, routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent, routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch, routeNotFoundComponent = route.isRoot ? (
    // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
    route.options.notFoundComponent ?? ((_a = router.options.notFoundRoute) == null ? void 0 : _a.options.component)
  ) : route.options.notFoundComponent, ResolvedSuspenseBoundary = (
    // If we're on the root route, allow forcefully wrapping in suspense
    (!route.isRoot || route.options.wrapInSuspense) && (route.options.wrapInSuspense ?? PendingComponent ?? ((_b = route.options.errorComponent) == null ? void 0 : _b.preload)) ? React.Suspense : SafeFragment
  ), ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment, ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment, resetKey = useRouterState({
    select: (s2) => s2.loadedAt
  }), parentRouteId = useRouterState({
    select: (s2) => {
      var _a2;
      const index2 = s2.matches.findIndex((d2) => d2.id === matchId);
      return (_a2 = s2.matches[index2 - 1]) == null ? void 0 : _a2.routeId;
    }
  });
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsx(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ jsx(
      ResolvedCatchBoundary,
      {
        getResetKey: () => resetKey,
        errorComponent: routeErrorComponent || ErrorComponent,
        onCatch: (error, errorInfo) => {
          if (isNotFound(error)) throw error;
          warning(!1, `Error in route match: ${matchId}`), routeOnCatch?.(error, errorInfo);
        },
        children: /* @__PURE__ */ jsx(
          ResolvedNotFoundBoundary,
          {
            fallback: (error) => {
              if (!routeNotFoundComponent || error.routeId && error.routeId !== routeId || !error.routeId && !route.isRoot)
                throw error;
              return React.createElement(routeNotFoundComponent, error);
            },
            children: /* @__PURE__ */ jsx(MatchInner, { matchId })
          }
        )
      }
    ) }) }),
    parentRouteId === rootRouteId && router.options.scrollRestoration ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
      /* @__PURE__ */ jsx(OnRendered, {}),
      /* @__PURE__ */ jsx(ScrollRestoration, {})
    ] }) : null
  ] });
});
function OnRendered() {
  var _a;
  const router = useRouter(), prevLocationRef = React.useRef(
    void 0
  );
  return /* @__PURE__ */ jsx(
    "script",
    {
      suppressHydrationWarning: !0,
      ref: (el) => {
        var _a2;
        el && (prevLocationRef.current === void 0 || prevLocationRef.current.href !== ((_a2 = router.state.resolvedLocation) == null ? void 0 : _a2.href)) && (router.emit({
          type: "onRendered",
          ...getLocationChangeInfo(router.state)
        }), prevLocationRef.current = router.state.resolvedLocation);
      }
    },
    (_a = router.state.resolvedLocation) == null ? void 0 : _a.state.key
  );
}
const MatchInner = React.memo(function({
  matchId
}) {
  var _a, _b, _c;
  const router = useRouter(), { match, key: key2, routeId } = useRouterState({
    select: (s2) => {
      const matchIndex = s2.matches.findIndex((d2) => d2.id === matchId), match2 = s2.matches[matchIndex], routeId2 = match2.routeId, remountFn = router.routesById[routeId2].options.remountDeps ?? router.options.defaultRemountDeps, remountDeps = remountFn?.({
        routeId: routeId2,
        loaderDeps: match2.loaderDeps,
        params: match2._strictParams,
        search: match2._strictSearch
      });
      return {
        key: remountDeps ? JSON.stringify(remountDeps) : void 0,
        routeId: routeId2,
        match: pick(match2, ["id", "status", "error"])
      };
    },
    structuralSharing: !0
  }), route = router.routesById[routeId], out = React.useMemo(() => {
    const Comp = route.options.component ?? router.options.defaultComponent;
    return Comp ? /* @__PURE__ */ jsx(Comp, {}, key2) : /* @__PURE__ */ jsx(Outlet, {});
  }, [key2, route.options.component, router.options.defaultComponent]), RouteErrorComponent = (route.options.errorComponent ?? router.options.defaultErrorComponent) || ErrorComponent;
  if (match.status === "notFound")
    return invariant$1(isNotFound(match.error), "Expected a notFound error"), renderRouteNotFound(router, route, match.error);
  if (match.status === "redirected")
    throw invariant$1(isRedirect(match.error), "Expected a redirect error"), (_a = router.getMatch(match.id)) == null ? void 0 : _a.loadPromise;
  if (match.status === "error") {
    if (router.isServer)
      return /* @__PURE__ */ jsx(
        RouteErrorComponent,
        {
          error: match.error,
          reset: void 0,
          info: {
            componentStack: ""
          }
        }
      );
    throw match.error;
  }
  if (match.status === "pending") {
    const pendingMinMs = route.options.pendingMinMs ?? router.options.defaultPendingMinMs;
    if (pendingMinMs && !((_b = router.getMatch(match.id)) != null && _b.minPendingPromise) && !router.isServer) {
      const minPendingPromise = createControlledPromise();
      Promise.resolve().then(() => {
        router.updateMatch(match.id, (prev) => ({
          ...prev,
          minPendingPromise
        }));
      }), setTimeout(() => {
        minPendingPromise.resolve(), router.updateMatch(match.id, (prev) => ({
          ...prev,
          minPendingPromise: void 0
        }));
      }, pendingMinMs);
    }
    throw (_c = router.getMatch(match.id)) == null ? void 0 : _c.loadPromise;
  }
  return out;
}), Outlet = React.memo(function() {
  const router = useRouter(), matchId = React.useContext(matchContext), routeId = useRouterState({
    select: (s2) => {
      var _a;
      return (_a = s2.matches.find((d2) => d2.id === matchId)) == null ? void 0 : _a.routeId;
    }
  }), route = router.routesById[routeId], parentGlobalNotFound = useRouterState({
    select: (s2) => {
      const parentMatch = s2.matches.find((d2) => d2.id === matchId);
      return invariant$1(
        parentMatch,
        `Could not find parent match for matchId "${matchId}"`
      ), parentMatch.globalNotFound;
    }
  }), childMatchId = useRouterState({
    select: (s2) => {
      var _a;
      const matches = s2.matches, index2 = matches.findIndex((d2) => d2.id === matchId);
      return (_a = matches[index2 + 1]) == null ? void 0 : _a.id;
    }
  });
  if (parentGlobalNotFound)
    return renderRouteNotFound(router, route, void 0);
  if (!childMatchId)
    return null;
  const nextMatch = /* @__PURE__ */ jsx(Match, { matchId: childMatchId }), pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsx(router.options.defaultPendingComponent, {}) : null;
  return matchId === rootRouteId ? /* @__PURE__ */ jsx(React.Suspense, { fallback: pendingElement, children: nextMatch }) : nextMatch;
}), useLayoutEffect = typeof window < "u" ? React.useLayoutEffect : React.useEffect;
function usePrevious(value) {
  const ref = React.useRef({
    value,
    prev: null
  }), current = ref.current.value;
  return value !== current && (ref.current = {
    value,
    prev: current
  }), ref.current.prev;
}
function useIntersectionObserver(ref, callback, intersectionObserverOptions = {}, options = {}) {
  const isIntersectionObserverAvailable = React.useRef(
    typeof IntersectionObserver == "function"
  ), observerRef = React.useRef(null);
  return React.useEffect(() => {
    if (!(!ref.current || !isIntersectionObserverAvailable.current || options.disabled))
      return observerRef.current = new IntersectionObserver(([entry]) => {
        callback(entry);
      }, intersectionObserverOptions), observerRef.current.observe(ref.current), () => {
        var _a;
        (_a = observerRef.current) == null || _a.disconnect();
      };
  }, [callback, intersectionObserverOptions, options.disabled, ref]), observerRef.current;
}
function useForwardedRef(ref) {
  const innerRef = React.useRef(null);
  return React.useImperativeHandle(ref, () => innerRef.current, []), innerRef;
}
function Transitioner() {
  const router = useRouter(), mountLoadForRouter = React.useRef({ router, mounted: !1 }), isLoading = useRouterState({
    select: ({ isLoading: isLoading2 }) => isLoading2
  }), [isTransitioning, setIsTransitioning] = React.useState(!1), hasPendingMatches = useRouterState({
    select: (s2) => s2.matches.some((d2) => d2.status === "pending"),
    structuralSharing: !0
  }), previousIsLoading = usePrevious(isLoading), isAnyPending = isLoading || isTransitioning || hasPendingMatches, previousIsAnyPending = usePrevious(isAnyPending), isPagePending = isLoading || hasPendingMatches, previousIsPagePending = usePrevious(isPagePending);
  return router.isServer || (router.startTransition = (fn) => {
    setIsTransitioning(!0), React.startTransition(() => {
      fn(), setIsTransitioning(!1);
    });
  }), React.useEffect(() => {
    const unsub = router.history.subscribe(router.load), nextLocation = router.buildLocation({
      to: router.latestLocation.pathname,
      search: !0,
      params: !0,
      hash: !0,
      state: !0,
      _includeValidateSearch: !0
    });
    return trimPathRight(router.latestLocation.href) !== trimPathRight(nextLocation.href) && router.commitLocation({ ...nextLocation, replace: !0 }), () => {
      unsub();
    };
  }, [router, router.history]), useLayoutEffect(() => {
    if (typeof window < "u" && router.clientSsr || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted)
      return;
    mountLoadForRouter.current = { router, mounted: !0 }, (async () => {
      try {
        await router.load();
      } catch (err) {
        console.error(err);
      }
    })();
  }, [router]), useLayoutEffect(() => {
    previousIsLoading && !isLoading && router.emit({
      type: "onLoad",
      // When the new URL has committed, when the new matches have been loaded into state.matches
      ...getLocationChangeInfo(router.state)
    });
  }, [previousIsLoading, router, isLoading]), useLayoutEffect(() => {
    previousIsPagePending && !isPagePending && router.emit({
      type: "onBeforeRouteMount",
      ...getLocationChangeInfo(router.state)
    });
  }, [isPagePending, previousIsPagePending, router]), useLayoutEffect(() => {
    previousIsAnyPending && !isAnyPending && (router.emit({
      type: "onResolved",
      ...getLocationChangeInfo(router.state)
    }), router.__store.setState((s2) => ({
      ...s2,
      status: "idle",
      resolvedLocation: s2.location
    })));
  }, [isAnyPending, previousIsAnyPending, router]), null;
}
function Matches() {
  const router = useRouter(), pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsx(router.options.defaultPendingComponent, {}) : null, ResolvedSuspense = router.isServer || typeof document < "u" && router.clientSsr ? SafeFragment : React.Suspense, inner2 = /* @__PURE__ */ jsxs(ResolvedSuspense, { fallback: pendingElement, children: [
    /* @__PURE__ */ jsx(Transitioner, {}),
    /* @__PURE__ */ jsx(MatchesInner, {})
  ] });
  return router.options.InnerWrap ? /* @__PURE__ */ jsx(router.options.InnerWrap, { children: inner2 }) : inner2;
}
function MatchesInner() {
  const matchId = useRouterState({
    select: (s2) => {
      var _a;
      return (_a = s2.matches[0]) == null ? void 0 : _a.id;
    }
  }), resetKey = useRouterState({
    select: (s2) => s2.loadedAt
  });
  return /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsx(
    CatchBoundary,
    {
      getResetKey: () => resetKey,
      errorComponent: ErrorComponent,
      onCatch: (error) => {
        warning(
          !1,
          "The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!"
        ), warning(!1, error.message || error.toString());
      },
      children: matchId ? /* @__PURE__ */ jsx(Match, { matchId }) : null
    }
  ) });
}
function useMatches(opts) {
  return useRouterState({
    select: (state) => {
      const matches = state.matches;
      return opts?.select ? opts.select(matches) : matches;
    },
    structuralSharing: opts?.structuralSharing
  });
}
function useParentMatches(opts) {
  const contextMatchId = React.useContext(matchContext);
  return useMatches({
    select: (matches) => (matches = matches.slice(
      0,
      matches.findIndex((d2) => d2.id === contextMatchId)
    ), matches),
    structuralSharing: void 0
  });
}
function useLinkProps(options, forwardedRef) {
  const router = useRouter(), [isTransitioning, setIsTransitioning] = React.useState(!1), hasRenderFetched = React.useRef(!1), innerRef = useForwardedRef(forwardedRef), {
    // custom props
    activeProps = () => ({ className: "active" }),
    inactiveProps = () => ({}),
    activeOptions,
    to,
    preload: userPreload,
    preloadDelay: userPreloadDelay,
    hashScrollIntoView,
    replace,
    startTransition,
    resetScroll,
    viewTransition,
    // element props
    children: children2,
    target,
    disabled,
    style: style2,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    ignoreBlocker,
    ...rest
  } = options, {
    // prevent these from being returned
    params: _params,
    search: _search,
    hash: _hash,
    state: _state,
    mask: _mask,
    reloadDocument: _reloadDocument,
    ...propsSafeToSpread
  } = rest, type = React.useMemo(() => {
    try {
      return new URL(`${to}`), "external";
    } catch {
    }
    return "internal";
  }, [to]), currentSearch = useRouterState({
    select: (s2) => s2.location.search,
    structuralSharing: !0
  }), from = useMatches({
    select: (matches) => {
      var _a;
      return options.from ?? ((_a = matches[matches.length - 1]) == null ? void 0 : _a.fullPath);
    }
  }), _options = React.useMemo(() => ({ ...options, from }), [options, from]), next = React.useMemo(
    () => router.buildLocation(_options),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [router, _options, currentSearch]
  ), preload = React.useMemo(() => _options.reloadDocument ? !1 : userPreload ?? router.options.defaultPreload, [router.options.defaultPreload, userPreload, _options.reloadDocument]), preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0, isActive = useRouterState({
    select: (s2) => {
      if (activeOptions?.exact) {
        if (!exactPathTest(
          s2.location.pathname,
          next.pathname,
          router.basepath
        ))
          return !1;
      } else {
        const currentPathSplit = removeTrailingSlash(
          s2.location.pathname,
          router.basepath
        ).split("/");
        if (!removeTrailingSlash(
          next.pathname,
          router.basepath
        ).split("/").every(
          (d2, i2) => d2 === currentPathSplit[i2]
        ))
          return !1;
      }
      return (activeOptions?.includeSearch ?? !0) && !deepEqual$1(s2.location.search, next.search, {
        partial: !activeOptions?.exact,
        ignoreUndefined: !activeOptions?.explicitUndefined
      }) ? !1 : activeOptions?.includeHash ? s2.location.hash === next.hash : !0;
    }
  }), doPreload = React.useCallback(() => {
    router.preloadRoute(_options).catch((err) => {
      console.warn(err), console.warn(preloadWarning);
    });
  }, [_options, router]), preloadViewportIoCallback = React.useCallback(
    (entry) => {
      entry?.isIntersecting && doPreload();
    },
    [doPreload]
  );
  if (useIntersectionObserver(
    innerRef,
    preloadViewportIoCallback,
    { rootMargin: "100px" },
    { disabled: !!disabled || preload !== "viewport" }
  ), useLayoutEffect(() => {
    hasRenderFetched.current || !disabled && preload === "render" && (doPreload(), hasRenderFetched.current = !0);
  }, [disabled, doPreload, preload]), type === "external")
    return {
      ...propsSafeToSpread,
      ref: innerRef,
      type,
      href: to,
      ...children2 && { children: children2 },
      ...target && { target },
      ...disabled && { disabled },
      ...style2 && { style: style2 },
      ...className && { className },
      ...onClick && { onClick },
      ...onFocus && { onFocus },
      ...onMouseEnter && { onMouseEnter },
      ...onMouseLeave && { onMouseLeave },
      ...onTouchStart && { onTouchStart }
    };
  const handleClick = (e2) => {
    if (!disabled && !isCtrlEvent(e2) && !e2.defaultPrevented && (!target || target === "_self") && e2.button === 0) {
      e2.preventDefault(), flushSync(() => {
        setIsTransitioning(!0);
      });
      const unsub = router.subscribe("onResolved", () => {
        unsub(), setIsTransitioning(!1);
      });
      return router.navigate({
        ..._options,
        replace,
        resetScroll,
        hashScrollIntoView,
        startTransition,
        viewTransition,
        ignoreBlocker
      });
    }
  }, handleFocus = (_) => {
    disabled || preload && doPreload();
  }, handleTouchStart = handleFocus, handleEnter = (e2) => {
    if (disabled) return;
    const eventTarget = e2.target || {};
    if (preload) {
      if (eventTarget.preloadTimeout)
        return;
      eventTarget.preloadTimeout = setTimeout(() => {
        eventTarget.preloadTimeout = null, doPreload();
      }, preloadDelay);
    }
  }, handleLeave = (e2) => {
    if (disabled) return;
    const eventTarget = e2.target || {};
    eventTarget.preloadTimeout && (clearTimeout(eventTarget.preloadTimeout), eventTarget.preloadTimeout = null);
  }, composeHandlers = (handlers) => (e2) => {
    var _a;
    (_a = e2.persist) == null || _a.call(e2), handlers.filter(Boolean).forEach((handler) => {
      e2.defaultPrevented || handler(e2);
    });
  }, resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {}, resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}), resolvedClassName = [
    className,
    resolvedActiveProps.className,
    resolvedInactiveProps.className
  ].filter(Boolean).join(" "), resolvedStyle = {
    ...style2,
    ...resolvedActiveProps.style,
    ...resolvedInactiveProps.style
  };
  return {
    ...propsSafeToSpread,
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    href: disabled ? void 0 : next.maskedLocation ? router.history.createHref(next.maskedLocation.href) : router.history.createHref(next.href),
    ref: innerRef,
    onClick: composeHandlers([onClick, handleClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
    disabled: !!disabled,
    target,
    ...Object.keys(resolvedStyle).length && { style: resolvedStyle },
    ...resolvedClassName && { className: resolvedClassName },
    ...disabled && {
      role: "link",
      "aria-disabled": !0
    },
    ...isActive && { "data-status": "active", "aria-current": "page" },
    ...isTransitioning && { "data-transitioning": "transitioning" }
  };
}
const Link$1 = React.forwardRef(
  (props, ref) => {
    const { _asChild, ...rest } = props, {
      type: _type,
      ref: innerRef,
      ...linkProps
    } = useLinkProps(rest, ref), children2 = typeof rest.children == "function" ? rest.children({
      isActive: linkProps["data-status"] === "active"
    }) : rest.children;
    return typeof _asChild > "u" && delete linkProps.disabled, React.createElement(
      _asChild || "a",
      {
        ...linkProps,
        ref: innerRef
      },
      children2
    );
  }
);
function isCtrlEvent(e2) {
  return !!(e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey);
}
const createRouter$1 = (options) => new Router(options);
class Router extends RouterCore {
  constructor(options) {
    super(options);
  }
}
function RouterContextProvider({
  router,
  children: children2,
  ...rest
}) {
  router.update({
    ...router.options,
    ...rest,
    context: {
      ...router.options.context,
      ...rest.context
    }
  });
  const routerContext2 = getRouterContext(), provider = /* @__PURE__ */ jsx(routerContext2.Provider, { value: router, children: children2 });
  return router.options.Wrap ? /* @__PURE__ */ jsx(router.options.Wrap, { children: provider }) : provider;
}
function RouterProvider({ router, ...rest }) {
  return /* @__PURE__ */ jsx(RouterContextProvider, { router, ...rest, children: /* @__PURE__ */ jsx(Matches, {}) });
}
function isObject(value) {
  return typeof value == "object" && value != null && !Array.isArray(value);
}
var isObjectOrArray = (obj) => typeof obj == "object" && obj !== null;
function compact(value) {
  return Object.fromEntries(Object.entries(value ?? {}).filter(([_, value2]) => value2 !== void 0));
}
var isBaseCondition = (v) => v === "base";
function filterBaseConditions(c2) {
  return c2.slice().filter((v) => !isBaseCondition(v));
}
function toChar(code) {
  return String.fromCharCode(code + (code > 25 ? 39 : 97));
}
function toName(code) {
  let name = "", x2;
  for (x2 = Math.abs(code); x2 > 52; x2 = x2 / 52 | 0)
    name = toChar(x2 % 52) + name;
  return toChar(x2 % 52) + name;
}
function toPhash(h, x2) {
  let i2 = x2.length;
  for (; i2; )
    h = h * 33 ^ x2.charCodeAt(--i2);
  return h;
}
function toHash(value) {
  return toName(toPhash(5381, value) >>> 0);
}
var importantRegex = /\s*!(important)?/i;
function isImportant(value) {
  return typeof value == "string" ? importantRegex.test(value) : !1;
}
function withoutImportant(value) {
  return typeof value == "string" ? value.replace(importantRegex, "").trim() : value;
}
function withoutSpace(str) {
  return typeof str == "string" ? str.replaceAll(" ", "_") : str;
}
var memo$1 = (fn) => {
  const cache = /* @__PURE__ */ new Map();
  return (...args) => {
    const key2 = JSON.stringify(args);
    if (cache.has(key2))
      return cache.get(key2);
    const result = fn(...args);
    return cache.set(key2, result), result;
  };
}, MERGE_OMIT = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function mergeProps(...sources) {
  return sources.reduce((prev, obj) => (obj && Object.keys(obj).forEach((key2) => {
    if (MERGE_OMIT.has(key2))
      return;
    const prevValue = prev[key2], value = obj[key2];
    isObject(prevValue) && isObject(value) ? prev[key2] = mergeProps(prevValue, value) : prev[key2] = value;
  }), prev), {});
}
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner2(value, path = []) {
    if (isObjectOrArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key2 = getKey?.(prop, child) ?? prop, childPath = [...path, key2];
        if (stop?.(value, childPath))
          return predicate(value, path);
        const next = inner2(child, childPath);
        isNotNullish(next) && (result[key2] = next);
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner2(target);
}
function mapObject(obj, fn) {
  return Array.isArray(obj) ? obj.map((value) => fn(value)) : isObject(obj) ? walkObject(obj, (value) => fn(value)) : fn(obj);
}
function toResponsiveObject(values2, breakpoints) {
  return values2.reduce(
    (acc, current, index2) => {
      const key2 = breakpoints[index2];
      return current != null && (acc[key2] = current), acc;
    },
    {}
  );
}
function normalizeStyleObject(styles, context2, shorthand = !0) {
  const { utility, conditions: conditions2 } = context2, { hasShorthand, resolveShorthand: resolveShorthand2 } = utility;
  return walkObject(
    styles,
    (value) => Array.isArray(value) ? toResponsiveObject(value, conditions2.breakpoints.keys) : value,
    {
      stop: (value) => Array.isArray(value),
      getKey: shorthand ? (prop) => hasShorthand ? resolveShorthand2(prop) : prop : void 0
    }
  );
}
var fallbackCondition = {
  shift: (v) => v,
  finalize: (v) => v,
  breakpoints: { keys: [] }
}, sanitize$1 = (value) => typeof value == "string" ? value.replaceAll(/[\n\s]+/g, " ") : value;
function createCss(context2) {
  const { utility, hash, conditions: conds = fallbackCondition } = context2, formatClassName = (str) => [utility.prefix, str].filter(Boolean).join("-"), hashFn = (conditions2, className) => {
    let result;
    if (hash) {
      const baseArray = [...conds.finalize(conditions2), className];
      result = formatClassName(utility.toHash(baseArray, toHash));
    } else
      result = [...conds.finalize(conditions2), formatClassName(className)].join(":");
    return result;
  };
  return memo$1(({ base, ...styles } = {}) => {
    const styleObject = Object.assign(styles, base), normalizedObject = normalizeStyleObject(styleObject, context2), classNames = /* @__PURE__ */ new Set();
    return walkObject(normalizedObject, (value, paths) => {
      if (value == null)
        return;
      const important = isImportant(value), [prop, ...allConditions] = conds.shift(paths), conditions2 = filterBaseConditions(allConditions), transformed = utility.transform(prop, withoutImportant(sanitize$1(value)));
      let className = hashFn(conditions2, transformed.className);
      important && (className = `${className}!`), classNames.add(className);
    }), Array.from(classNames).join(" ");
  });
}
function compactStyles(...styles) {
  return styles.flat().filter((style2) => isObject(style2) && Object.keys(compact(style2)).length > 0);
}
function createMergeCss(context2) {
  function resolve(styles) {
    const allStyles = compactStyles(...styles);
    return allStyles.length === 1 ? allStyles : allStyles.map((style2) => normalizeStyleObject(style2, context2));
  }
  function mergeCss2(...styles) {
    return mergeProps(...resolve(styles));
  }
  function assignCss(...styles) {
    return Object.assign({}, ...resolve(styles));
  }
  return { mergeCss: memo$1(mergeCss2), assignCss };
}
var wordRegex = /([A-Z])/g, msRegex = /^ms-/, hypenateProperty = memo$1((property) => property.startsWith("--") ? property : property.replace(wordRegex, "-$1").replace(msRegex, "-ms-").toLowerCase()), fns = ["min", "max", "clamp", "calc"], fnRegExp = new RegExp(`^(${fns.join("|")})\\(.*\\)`), isCssFunction = (v) => typeof v == "string" && fnRegExp.test(v), lengthUnits = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%", lengthUnitsPattern = `(?:${lengthUnits.split(",").join("|")})`, lengthRegExp = new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`), isCssUnit = (v) => typeof v == "string" && lengthRegExp.test(v), isCssVar = (v) => typeof v == "string" && /^var\(--.+\)$/.test(v), patternFns = {
  map: mapObject,
  isCssFunction,
  isCssVar,
  isCssUnit
}, getPatternStyles = (pattern, styles) => {
  if (!pattern?.defaultValues)
    return styles;
  const defaults2 = typeof pattern.defaultValues == "function" ? pattern.defaultValues(styles) : pattern.defaultValues;
  return Object.assign({}, defaults2, compact(styles));
}, getSlotRecipes = (recipe = {}) => {
  const init2 = (slot) => ({
    className: [recipe.className, slot].filter(Boolean).join("__"),
    base: recipe.base?.[slot] ?? {},
    variants: {},
    defaultVariants: recipe.defaultVariants ?? {},
    compoundVariants: recipe.compoundVariants ? getSlotCompoundVariant(recipe.compoundVariants, slot) : []
  }), recipeParts = (recipe.slots ?? []).map((slot) => [slot, init2(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(recipe.variants ?? {}))
    for (const [variantKey, variantSpec] of Object.entries(variantsSpec))
      recipeParts.forEach(([slot, slotRecipe]) => {
        slotRecipe.variants[variantsKey] ??= {}, slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
  return Object.fromEntries(recipeParts);
}, getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({ ...compoundVariant, css: compoundVariant.css[slotName] }));
function splitProps(props, ...keys2) {
  const descriptors = Object.getOwnPropertyDescriptors(props), dKeys = Object.keys(descriptors), split = (k2) => {
    const clone = {};
    for (let i2 = 0; i2 < k2.length; i2++) {
      const key2 = k2[i2];
      descriptors[key2] && (Object.defineProperty(clone, key2, descriptors[key2]), delete descriptors[key2]);
    }
    return clone;
  }, fn = (key2) => split(Array.isArray(key2) ? key2 : dKeys.filter(key2));
  return keys2.map(fn).concat(split(dKeys));
}
var uniq = (...items) => {
  const set2 = items.reduce((acc, currItems) => (currItems && currItems.forEach((item) => acc.add(item)), acc), /* @__PURE__ */ new Set([]));
  return Array.from(set2);
}, htmlProps = ["htmlSize", "htmlTranslate", "htmlWidth", "htmlHeight"];
function convert(key2) {
  return htmlProps.includes(key2) ? key2.replace("html", "").toLowerCase() : key2;
}
function normalizeHTMLProps(props) {
  return Object.fromEntries(Object.entries(props).map(([key2, value]) => [convert(key2), value]));
}
normalizeHTMLProps.keys = htmlProps;
const conditionsStr = "_hover,_focus,_focusWithin,_focusVisible,_disabled,_active,_visited,_target,_readOnly,_readWrite,_empty,_checked,_enabled,_expanded,_highlighted,_complete,_incomplete,_dragging,_before,_after,_firstLetter,_firstLine,_marker,_selection,_file,_backdrop,_first,_last,_only,_even,_odd,_firstOfType,_lastOfType,_onlyOfType,_peerFocus,_peerHover,_peerActive,_peerFocusWithin,_peerFocusVisible,_peerDisabled,_peerChecked,_peerInvalid,_peerExpanded,_peerPlaceholderShown,_groupFocus,_groupHover,_groupActive,_groupFocusWithin,_groupFocusVisible,_groupDisabled,_groupChecked,_groupExpanded,_groupInvalid,_indeterminate,_required,_valid,_invalid,_autofill,_inRange,_outOfRange,_placeholder,_placeholderShown,_pressed,_selected,_grabbed,_underValue,_overValue,_atValue,_default,_optional,_open,_closed,_fullscreen,_loading,_hidden,_current,_currentPage,_currentStep,_today,_unavailable,_rangeStart,_rangeEnd,_now,_topmost,_motionReduce,_motionSafe,_print,_landscape,_portrait,_dark,_light,_osDark,_osLight,_highContrast,_lessContrast,_moreContrast,_ltr,_rtl,_scrollbar,_scrollbarThumb,_scrollbarTrack,_horizontal,_vertical,_icon,_starting,_reduceGraphics,_reduceGraphicsOnPan,_noReduceGraphics,_whenPanning,_smallZoom,_compoundTransparent,_edgeActive,_whenHovered,_whenSelected,_whenDimmed,_whenFocused,_shapeSizeXs,_shapeSizeSm,_shapeSizeMd,_shapeSizeLg,_shapeSizeXl,_shapeRectangle,_shapePerson,_shapeBrowser,_shapeMobile,_shapeCylinder,_shapeStorage,_shapeQueue,xs,xsOnly,xsDown,sm,smOnly,smDown,md,mdOnly,mdDown,lg,lgOnly,lgDown,xl,xlOnly,xlDown,xsToSm,xsToMd,xsToLg,xsToXl,smToMd,smToLg,smToXl,mdToLg,mdToXl,lgToXl,base", conditions = new Set(conditionsStr.split(",")), conditionRegex = /^@|&|&$/;
function isCondition(value) {
  return conditions.has(value) || conditionRegex.test(value);
}
const underscoreRegex = /^_/, conditionsSelectorRegex = /&|@/;
function finalizeConditions(paths) {
  return paths.map((path) => conditions.has(path) ? path.replace(underscoreRegex, "") : conditionsSelectorRegex.test(path) ? `[${withoutSpace(path.trim())}]` : path);
}
function sortConditions(paths) {
  return paths.sort((a2, b2) => {
    const aa = isCondition(a2), bb = isCondition(b2);
    return aa && !bb ? 1 : !aa && bb ? -1 : 0;
  });
}
const utilities = "aspectRatio:asp,boxDecorationBreak:bx-db,zIndex:z,boxSizing:bx-s,objectPosition:obj-p,objectFit:obj-f,overscrollBehavior:ovs-b,overscrollBehaviorX:ovs-bx,overscrollBehaviorY:ovs-by,position:pos/1,top:top,left:left,inset:inset,insetInline:inset-x/insetX,insetBlock:inset-y/insetY,insetBlockEnd:inset-be,insetBlockStart:inset-bs,insetInlineEnd:inset-e/insetEnd/end,insetInlineStart:inset-s/insetStart/start,right:right,bottom:bottom,float:float,visibility:vis,display:d,hideFrom:hide,hideBelow:show,flexBasis:flex-b,flex:flex,flexDirection:flex-d/flexDir,flexGrow:flex-g,flexShrink:flex-sh,gridTemplateColumns:grid-tc,gridTemplateRows:grid-tr,gridColumn:grid-c,gridRow:grid-r,gridColumnStart:grid-cs,gridColumnEnd:grid-ce,gridAutoFlow:grid-af,gridAutoColumns:grid-ac,gridAutoRows:grid-ar,gap:gap,gridGap:grid-g,gridRowGap:grid-rg,gridColumnGap:grid-cg,rowGap:rg,columnGap:cg,justifyContent:jc,alignContent:ac,alignItems:ai,alignSelf:as,padding:p/1,paddingLeft:pl/1,paddingRight:pr/1,paddingTop:pt/1,paddingBottom:pb/1,paddingBlock:py/1/paddingY,paddingBlockEnd:pbe,paddingBlockStart:pbs,paddingInline:px/paddingX/1,paddingInlineEnd:pe/1/paddingEnd,paddingInlineStart:ps/1/paddingStart,marginLeft:ml/1,marginRight:mr/1,marginTop:mt/1,marginBottom:mb/1,margin:m/1,marginBlock:my/1/marginY,marginBlockEnd:mbe,marginBlockStart:mbs,marginInline:mx/1/marginX,marginInlineEnd:me/1/marginEnd,marginInlineStart:ms/1/marginStart,spaceX:sx,spaceY:sy,outlineWidth:ring-w/ringWidth,outlineColor:ring-c/ringColor,outline:ring/1,outlineOffset:ring-o/ringOffset,divideX:dvd-x,divideY:dvd-y,divideColor:dvd-c,divideStyle:dvd-s,width:w/1,inlineSize:w-is,minWidth:min-w/minW,minInlineSize:min-w-is,maxWidth:max-w/maxW,maxInlineSize:max-w-is,height:h/1,blockSize:h-bs,minHeight:min-h/minH,minBlockSize:min-h-bs,maxHeight:max-h/maxH,maxBlockSize:max-b,color:c,fontFamily:ff,fontSize:fs,fontSizeAdjust:fs-a,fontPalette:fp,fontKerning:fk,fontFeatureSettings:ff-s,fontWeight:fw,fontSmoothing:fsmt,fontVariant:fv,fontVariantAlternates:fv-alt,fontVariantCaps:fv-caps,fontVariationSettings:fv-s,fontVariantNumeric:fv-num,letterSpacing:ls,lineHeight:lh,textAlign:ta,textDecoration:td,textDecorationColor:td-c,textEmphasisColor:te-c,textDecorationStyle:td-s,textDecorationThickness:td-t,textUnderlineOffset:tu-o,textTransform:tt,textIndent:ti,textShadow:tsh,textShadowColor:tsh-c/textShadowColor,textOverflow:tov,verticalAlign:va,wordBreak:wb,textWrap:tw,truncate:trunc,lineClamp:lc,listStyleType:li-t,listStylePosition:li-pos,listStyleImage:li-img,listStyle:li-s,backgroundPosition:bg-p/bgPosition,backgroundPositionX:bg-p-x/bgPositionX,backgroundPositionY:bg-p-y/bgPositionY,backgroundAttachment:bg-a/bgAttachment,backgroundClip:bg-cp/bgClip,background:bg/1,backgroundColor:bg-c/bgColor,backgroundOrigin:bg-o/bgOrigin,backgroundImage:bg-i/bgImage,backgroundRepeat:bg-r/bgRepeat,backgroundBlendMode:bg-bm/bgBlendMode,backgroundSize:bg-s/bgSize,backgroundGradient:bg-grad/bgGradient,textGradient:txt-grad,gradientFromPosition:grad-from-pos,gradientToPosition:grad-to-pos,gradientFrom:grad-from,gradientTo:grad-to,gradientVia:grad-via,gradientViaPosition:grad-via-pos,borderRadius:bdr/rounded,borderTopLeftRadius:bdr-tl/roundedTopLeft,borderTopRightRadius:bdr-tr/roundedTopRight,borderBottomRightRadius:bdr-br/roundedBottomRight,borderBottomLeftRadius:bdr-bl/roundedBottomLeft,borderTopRadius:bdr-t/roundedTop,borderRightRadius:bdr-r/roundedRight,borderBottomRadius:bdr-b/roundedBottom,borderLeftRadius:bdr-l/roundedLeft,borderStartStartRadius:bdr-ss/roundedStartStart,borderStartEndRadius:bdr-se/roundedStartEnd,borderStartRadius:bdr-s/roundedStart,borderEndStartRadius:bdr-es/roundedEndStart,borderEndEndRadius:bdr-ee/roundedEndEnd,borderEndRadius:bdr-e/roundedEnd,border:bd,borderWidth:bd-w,borderTopWidth:bd-t-w,borderLeftWidth:bd-l-w,borderRightWidth:bd-r-w,borderBottomWidth:bd-b-w,borderColor:bd-c,borderInline:bd-x/borderX,borderInlineWidth:bd-x-w/borderXWidth,borderInlineColor:bd-x-c/borderXColor,borderBlock:bd-y/borderY,borderBlockWidth:bd-y-w/borderYWidth,borderBlockColor:bd-y-c/borderYColor,borderLeft:bd-l,borderLeftColor:bd-l-c,borderInlineStart:bd-s/borderStart,borderInlineStartWidth:bd-s-w/borderStartWidth,borderInlineStartColor:bd-s-c/borderStartColor,borderRight:bd-r,borderRightColor:bd-r-c,borderInlineEnd:bd-e/borderEnd,borderInlineEndWidth:bd-e-w/borderEndWidth,borderInlineEndColor:bd-e-c/borderEndColor,borderTop:bd-t,borderTopColor:bd-t-c,borderBottom:bd-b,borderBottomColor:bd-b-c,borderBlockEnd:bd-be,borderBlockEndColor:bd-be-c,borderBlockStart:bd-bs,borderBlockStartColor:bd-bs-c,opacity:op,boxShadow:bx-sh/shadow,boxShadowColor:bx-sh-c/shadowColor,mixBlendMode:mix-bm,filter:filter,brightness:brightness,contrast:contrast,grayscale:grayscale,hueRotate:hue-rotate,invert:invert,saturate:saturate,sepia:sepia,dropShadow:drop-shadow,blur:blur,backdropFilter:bkdp,backdropBlur:bkdp-blur,backdropBrightness:bkdp-brightness,backdropContrast:bkdp-contrast,backdropGrayscale:bkdp-grayscale,backdropHueRotate:bkdp-hue-rotate,backdropInvert:bkdp-invert,backdropOpacity:bkdp-opacity,backdropSaturate:bkdp-saturate,backdropSepia:bkdp-sepia,borderCollapse:bd-cl,borderSpacing:bd-sp,borderSpacingX:bd-sx,borderSpacingY:bd-sy,tableLayout:tbl,transitionTimingFunction:trs-tmf,transitionDelay:trs-dly,transitionDuration:trs-dur,transitionProperty:trs-prop,transition:transition-fast,animation:anim,animationName:anim-n,animationTimingFunction:anim-tmf,animationDuration:anim-dur,animationDelay:anim-dly,animationPlayState:anim-ps,animationComposition:anim-comp,animationFillMode:anim-fm,animationDirection:anim-dir,animationIterationCount:anim-ic,animationRange:anim-r,animationState:anim-s,animationRangeStart:anim-rs,animationRangeEnd:anim-re,animationTimeline:anim-tl,transformOrigin:trf-o,transformBox:trf-b,transformStyle:trf-s,transform:trf,rotate:rotate,rotateX:rotate-x,rotateY:rotate-y,rotateZ:rotate-z,scale:scale,scaleX:scale-x,scaleY:scale-y,translate:translate,translateX:translate-x/x,translateY:translate-y/y,translateZ:translate-z/z,accentColor:ac-c,caretColor:ca-c,scrollBehavior:scr-bhv,scrollbar:scr-bar,scrollbarColor:scr-bar-c,scrollbarGutter:scr-bar-g,scrollbarWidth:scr-bar-w,scrollMargin:scr-m,scrollMarginLeft:scr-ml,scrollMarginRight:scr-mr,scrollMarginTop:scr-mt,scrollMarginBottom:scr-mb,scrollMarginBlock:scr-my/scrollMarginY,scrollMarginBlockEnd:scr-mbe,scrollMarginBlockStart:scr-mbt,scrollMarginInline:scr-mx/scrollMarginX,scrollMarginInlineEnd:scr-me,scrollMarginInlineStart:scr-ms,scrollPadding:scr-p,scrollPaddingBlock:scr-py/scrollPaddingY,scrollPaddingBlockStart:scr-pbs,scrollPaddingBlockEnd:scr-pbe,scrollPaddingInline:scr-px/scrollPaddingX,scrollPaddingInlineEnd:scr-pe,scrollPaddingInlineStart:scr-ps,scrollPaddingLeft:scr-pl,scrollPaddingRight:scr-pr,scrollPaddingTop:scr-pt,scrollPaddingBottom:scr-pb,scrollSnapAlign:scr-sa,scrollSnapStop:scrs-s,scrollSnapType:scrs-t,scrollSnapStrictness:scrs-strt,scrollSnapMargin:scrs-m,scrollSnapMarginTop:scrs-mt,scrollSnapMarginBottom:scrs-mb,scrollSnapMarginLeft:scrs-ml,scrollSnapMarginRight:scrs-mr,scrollSnapCoordinate:scrs-c,scrollSnapDestination:scrs-d,scrollSnapPointsX:scrs-px,scrollSnapPointsY:scrs-py,scrollSnapTypeX:scrs-tx,scrollSnapTypeY:scrs-ty,scrollTimeline:scrtl,scrollTimelineAxis:scrtl-a,scrollTimelineName:scrtl-n,touchAction:tch-a,userSelect:us,overflow:ov,overflowWrap:ov-wrap,overflowX:ov-x,overflowY:ov-y,overflowAnchor:ov-a,overflowBlock:ov-b,overflowInline:ov-i,overflowClipBox:ovcp-bx,overflowClipMargin:ovcp-m,overscrollBehaviorBlock:ovs-bb,overscrollBehaviorInline:ovs-bi,fill:fill,stroke:stk,strokeWidth:stk-w,strokeDasharray:stk-dsh,strokeDashoffset:stk-do,strokeLinecap:stk-lc,strokeLinejoin:stk-lj,strokeMiterlimit:stk-ml,strokeOpacity:stk-op,srOnly:sr,debug:debug,appearance:ap,backfaceVisibility:bfv,clipPath:cp-path,hyphens:hy,mask:msk,maskImage:msk-i,maskSize:msk-s,textSizeAdjust:txt-adj,container:cq,containerName:cq-n,containerType:cq-t,cursor:cursor,likec4Palette:likec4-palette,likec4RelationPalette:likec4-relation-color,textStyle:textStyle,animationStyle:animationStyle", classNameByProp = /* @__PURE__ */ new Map(), shorthands = /* @__PURE__ */ new Map();
utilities.split(",").forEach((utility) => {
  const [prop, meta] = utility.split(":"), [className, ...shorthandList] = meta.split("/");
  classNameByProp.set(prop, className), shorthandList.length && shorthandList.forEach((shorthand) => {
    shorthands.set(shorthand === "1" ? className : shorthand, prop);
  });
});
const resolveShorthand = (prop) => shorthands.get(prop) || prop, context = {
  conditions: {
    shift: sortConditions,
    finalize: finalizeConditions,
    breakpoints: { keys: ["base", "xs", "sm", "md", "lg", "xl"] }
  },
  utility: {
    transform: (prop, value) => {
      const key2 = resolveShorthand(prop);
      return { className: `${classNameByProp.get(key2) || hypenateProperty(key2)}_${withoutSpace(value)}` };
    },
    hasShorthand: !0,
    toHash: (path, hashFn) => hashFn(path.join(":")),
    resolveShorthand
  }
}, cssFn = createCss(context), css = (...styles) => cssFn(mergeCss(...styles));
css.raw = (...styles) => mergeCss(...styles);
const { mergeCss } = createMergeCss(context);
function cx() {
  let str = "", i2 = 0, arg;
  for (; i2 < arguments.length; )
    (arg = arguments[i2++]) && typeof arg == "string" && (str && (str += " "), str += arg);
  return str;
}
const defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function cva(config) {
  const { base, variants, defaultVariants, compoundVariants } = defaults(config), getVariantProps = (variants2) => ({ ...defaultVariants, ...compact(variants2) });
  function resolve(props = {}) {
    const computedVariants = getVariantProps(props);
    let variantCss = { ...base };
    for (const [key2, value] of Object.entries(computedVariants))
      variants[key2]?.[value] && (variantCss = mergeCss(variantCss, variants[key2][value]));
    const compoundVariantCss = getCompoundVariantCss(compoundVariants, computedVariants);
    return mergeCss(variantCss, compoundVariantCss);
  }
  function merge(__cva) {
    const override = defaults(__cva.config), variantKeys2 = uniq(__cva.variantKeys, Object.keys(variants));
    return cva({
      base: mergeCss(base, override.base),
      variants: Object.fromEntries(
        variantKeys2.map((key2) => [key2, mergeCss(variants[key2], override.variants[key2])])
      ),
      defaultVariants: mergeProps(defaultVariants, override.defaultVariants),
      compoundVariants: [...compoundVariants, ...override.compoundVariants]
    });
  }
  function cvaFn(props) {
    return css(resolve(props));
  }
  const variantKeys = Object.keys(variants);
  function splitVariantProps(props) {
    return splitProps(props, variantKeys);
  }
  const variantMap = Object.fromEntries(Object.entries(variants).map(([key2, value]) => [key2, Object.keys(value)]));
  return Object.assign(memo$1(cvaFn), {
    __cva__: !0,
    variantMap,
    variantKeys,
    raw: resolve,
    config,
    merge,
    splitVariantProps,
    getVariantProps
  });
}
function getCompoundVariantCss(compoundVariants, variantMap) {
  let result = {};
  return compoundVariants.forEach((compoundVariant) => {
    Object.entries(compoundVariant).every(([key2, value]) => key2 === "css" ? !0 : (Array.isArray(value) ? value : [value]).some((value2) => variantMap[key2] === value2)) && (result = mergeCss(result, compoundVariant.css));
  }), result;
}
function assertCompoundVariant(name, compoundVariants, variants, prop) {
  if (compoundVariants.length > 0 && typeof variants?.[prop] == "object")
    throw new Error(`[recipe:${name}:${prop}] Conditions are not supported when using compound variants.`);
}
const slotClass = (className, slot) => className + "__" + slot;
function sva(config) {
  const slots = Object.entries(getSlotRecipes(config)).map(([slot, slotCva]) => [slot, cva(slotCva)]), defaultVariants = config.defaultVariants ?? {};
  function svaFn(props) {
    const result = slots.map(([slot, cvaFn]) => [slot, cx(cvaFn(props), config.className && slotClass(config.className, slot))]);
    return Object.fromEntries(result);
  }
  function raw(props) {
    const result = slots.map(([slot, cvaFn]) => [slot, cvaFn.raw(props)]);
    return Object.fromEntries(result);
  }
  const variants = config.variants ?? {}, variantKeys = Object.keys(variants);
  function splitVariantProps(props) {
    return splitProps(props, variantKeys);
  }
  const getVariantProps = (variants2) => ({ ...defaultVariants || {}, ...compact(variants2) }), variantMap = Object.fromEntries(
    Object.entries(variants).map(([key2, value]) => [key2, Object.keys(value)])
  );
  return Object.assign(memo$1(svaFn), {
    __cva__: !1,
    raw,
    variantMap,
    variantKeys,
    splitVariantProps,
    getVariantProps
  });
}
const content = css({
  paddingTop: 120,
  position: "relative",
  zIndex: "1",
  sm: {
    paddingTop: 220
  }
}), image = css({
  position: "absolute",
  inset: "0",
  opacity: 0.2
}), inner = css({
  position: "relative"
}), root$4 = css({
  paddingTop: "80px",
  paddingBottom: "80px"
}), description$3 = css({
  maxWidth: rem(540),
  margin: "auto",
  marginTop: "xl",
  marginBottom: "calc({spacing.xl}*1.5)"
}), title$5 = css({
  textAlign: "center",
  fontWeight: "900",
  fontSize: rem(38)
});
function NotFound() {
  return /* @__PURE__ */ jsx(Container, { className: root$4, children: /* @__PURE__ */ jsxs("div", { className: inner, children: [
    /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 362 145", className: image, children: /* @__PURE__ */ jsx(
      "path",
      {
        fill: "currentColor",
        d: "M62.6 142c-2.133 0-3.2-1.067-3.2-3.2V118h-56c-2 0-3-1-3-3V92.8c0-1.333.4-2.733 1.2-4.2L58.2 4c.8-1.333 2.067-2 3.8-2h28c2 0 3 1 3 3v85.4h11.2c.933 0 1.733.333 2.4 1 .667.533 1 1.267 1 2.2v21.2c0 .933-.333 1.733-1 2.4-.667.533-1.467.8-2.4.8H93v20.8c0 2.133-1.067 3.2-3.2 3.2H62.6zM33 90.4h26.4V51.2L33 90.4zM181.67 144.6c-7.333 0-14.333-1.333-21-4-6.666-2.667-12.866-6.733-18.6-12.2-5.733-5.467-10.266-13-13.6-22.6-3.333-9.6-5-20.667-5-33.2 0-12.533 1.667-23.6 5-33.2 3.334-9.6 7.867-17.133 13.6-22.6 5.734-5.467 11.934-9.533 18.6-12.2 6.667-2.8 13.667-4.2 21-4.2 7.467 0 14.534 1.4 21.2 4.2 6.667 2.667 12.8 6.733 18.4 12.2 5.734 5.467 10.267 13 13.6 22.6 3.334 9.6 5 20.667 5 33.2 0 12.533-1.666 23.6-5 33.2-3.333 9.6-7.866 17.133-13.6 22.6-5.6 5.467-11.733 9.533-18.4 12.2-6.666 2.667-13.733 4-21.2 4zm0-31c9.067 0 15.6-3.733 19.6-11.2 4.134-7.6 6.2-17.533 6.2-29.8s-2.066-22.2-6.2-29.8c-4.133-7.6-10.666-11.4-19.6-11.4-8.933 0-15.466 3.8-19.6 11.4-4 7.6-6 17.533-6 29.8s2 22.2 6 29.8c4.134 7.467 10.667 11.2 19.6 11.2zM316.116 142c-2.134 0-3.2-1.067-3.2-3.2V118h-56c-2 0-3-1-3-3V92.8c0-1.333.4-2.733 1.2-4.2l56.6-84.6c.8-1.333 2.066-2 3.8-2h28c2 0 3 1 3 3v85.4h11.2c.933 0 1.733.333 2.4 1 .666.533 1 1.267 1 2.2v21.2c0 .933-.334 1.733-1 2.4-.667.533-1.467.8-2.4.8h-11.2v20.8c0 2.133-1.067 3.2-3.2 3.2h-27.2zm-29.6-51.6h26.4V51.2l-26.4 39.2z"
      }
    ) }),
    /* @__PURE__ */ jsxs("div", { className: content, children: [
      /* @__PURE__ */ jsx(Title, { className: title$5, children: "Nothing to see here" }),
      /* @__PURE__ */ jsx(Text, { c: "dimmed", size: "lg", ta: "center", className: description$3, children: "Page you are trying to open does not exist. You may have mistyped the address, or the page has been moved to another URL. If you think this is an error contact support." }),
      /* @__PURE__ */ jsx(Group, { justify: "center", children: /* @__PURE__ */ jsx(Button, { component: Link$1, to: "/", search: !0, startTransition: !0, size: "md", children: "Take me back to home page" }) })
    ] })
  ] }) });
}
const asTheme = (v) => {
  if (typeof v != "string")
    return;
  const vlower = v.toLowerCase();
  if (vlower === "light" || vlower === "dark")
    return vlower;
}, asPadding = (v) => {
  switch (!0) {
    case typeof v == "number":
      return Math.round(v);
    case typeof v == "string":
      return Math.round(parseFloat(v));
  }
}, Route$l = createRootRouteWithContext()({
  // component: RootComponent,
  validateSearch: (search) => ({
    padding: asPadding(search.padding),
    theme: asTheme(search.theme)
  })
}), Route$k = createFileRoute("/projects")({
  component: RouteComponent$3
});
function RouteComponent$3() {
  return useDocumentTitle("LikeC4 Projects"), /* @__PURE__ */ jsx(Container, { size: "xs", py: "lg", children: /* @__PURE__ */ jsxs(Stack, { children: [
    /* @__PURE__ */ jsx(Text, { fz: "lg", children: "Select a project" }),
    projects.map((v) => /* @__PURE__ */ jsx(
      Button,
      {
        variant: "default",
        size: "lg",
        fw: 400,
        renderRoot: (props) => /* @__PURE__ */ jsx(Link$1, { ...props, to: "/project/$projectId/", params: { projectId: v } }),
        styles: {
          inner: {
            justifyContent: "flex-start"
          }
        },
        children: v
      },
      v
    ))
  ] }) });
}
const LayoutGroupContext = createContext({});
function useConstant(init2) {
  const ref = useRef(null);
  return ref.current === null && (ref.current = init2()), ref.current;
}
const isBrowser$1 = typeof window < "u", useIsomorphicLayoutEffect$2 = isBrowser$1 ? useLayoutEffect$1 : useEffect, PresenceContext = /* @__PURE__ */ createContext(null), MotionConfigContext = createContext({
  transformPagePoint: (p2) => p2,
  isStatic: !1,
  reducedMotion: "never"
});
class PopChildMeasure extends React.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const parent = element.offsetParent, parentWidth = parent instanceof HTMLElement && parent.offsetWidth || 0, size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0, size2.width = element.offsetWidth || 0, size2.top = element.offsetTop, size2.left = element.offsetLeft, size2.right = parentWidth - size2.width - size2.left;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children: children2, isPresent, anchorX }) {
  const id2 = useId$2(), ref = useRef(null), size2 = useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0
  }), { nonce } = useContext(MotionConfigContext);
  return useInsertionEffect$1(() => {
    const { width, height, top, left, right } = size2.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
    ref.current.dataset.motionPopId = id2;
    const style2 = document.createElement("style");
    return nonce && (style2.nonce = nonce), document.head.appendChild(style2), style2.sheet && style2.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x2}px !important;
            top: ${top}px !important;
          }
        `), () => {
      document.head.removeChild(style2);
    };
  }, [isPresent]), jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: React.cloneElement(children2, { ref }) });
}
const PresenceChild = ({ children: children2, initial, isPresent, onExitComplete, custom: custom5, presenceAffectsLayout, mode, anchorX }) => {
  const presenceChildren = useConstant(newChildrenMap), id2 = useId$2();
  let isReusedContext = !0, context2 = useMemo(() => (isReusedContext = !1, {
    id: id2,
    initial,
    isPresent,
    custom: custom5,
    onExitComplete: (childId) => {
      presenceChildren.set(childId, !0);
      for (const isComplete of presenceChildren.values())
        if (!isComplete)
          return;
      onExitComplete && onExitComplete();
    },
    register: (childId) => (presenceChildren.set(childId, !1), () => presenceChildren.delete(childId))
  }), [isPresent, presenceChildren, onExitComplete]);
  return presenceAffectsLayout && isReusedContext && (context2 = { ...context2 }), useMemo(() => {
    presenceChildren.forEach((_, key2) => presenceChildren.set(key2, !1));
  }, [isPresent]), React.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]), mode === "popLayout" && (children2 = jsx(PopChild, { isPresent, anchorX, children: children2 })), jsx(PresenceContext.Provider, { value: context2, children: children2 });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function usePresence(subscribe = !0) {
  const context2 = useContext(PresenceContext);
  if (context2 === null)
    return [!0, null];
  const { isPresent, onExitComplete, register } = context2, id2 = useId$2();
  useEffect(() => {
    if (subscribe)
      return register(id2);
  }, [subscribe]);
  const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [!1, safeToRemove] : [!0];
}
const getChildKey = (child) => child.key || "";
function onlyElements(children2) {
  const filtered = [];
  return Children.forEach(children2, (child) => {
    isValidElement(child) && filtered.push(child);
  }), filtered;
}
const AnimatePresence = ({ children: children2, custom: custom5, initial = !0, onExitComplete, presenceAffectsLayout = !0, mode = "sync", propagate = !1, anchorX = "left" }) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate), presentChildren = useMemo(() => onlyElements(children2), [children2]), presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey), isInitialRender = useRef(!0), pendingPresentChildren = useRef(presentChildren), exitComplete = useConstant(() => /* @__PURE__ */ new Map()), [diffedChildren, setDiffedChildren] = useState(presentChildren), [renderedChildren, setRenderedChildren] = useState(presentChildren);
  useIsomorphicLayoutEffect$2(() => {
    isInitialRender.current = !1, pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key2 = getChildKey(renderedChildren[i2]);
      presentKeys.includes(key2) ? exitComplete.delete(key2) : exitComplete.get(key2) !== !0 && exitComplete.set(key2, !1);
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2], key2 = getChildKey(child);
      presentKeys.includes(key2) || (nextChildren.splice(i2, 0, child), exitingChildren.push(child));
    }
    return mode === "wait" && exitingChildren.length && (nextChildren = exitingChildren), setRenderedChildren(onlyElements(nextChildren)), setDiffedChildren(presentChildren), null;
  }
  const { forceRender } = useContext(LayoutGroupContext);
  return jsx(Fragment$1, { children: renderedChildren.map((child) => {
    const key2 = getChildKey(child), isPresent = propagate && !isParentPresent ? !1 : presentChildren === renderedChildren || presentKeys.includes(key2), onExit = () => {
      if (exitComplete.has(key2))
        exitComplete.set(key2, !0);
      else
        return;
      let isEveryExitComplete = !0;
      exitComplete.forEach((isExitComplete) => {
        isExitComplete || (isEveryExitComplete = !1);
      }), isEveryExitComplete && (forceRender?.(), setRenderedChildren(pendingPresentChildren.current), propagate && safeToRemove?.(), onExitComplete && onExitComplete());
    };
    return jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : !1, custom: custom5, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key2);
  }) });
}, DeprecatedLayoutGroupContext = createContext(null);
function useIsMounted() {
  const isMounted = useRef(!1);
  return useIsomorphicLayoutEffect$2(() => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), []), isMounted;
}
const stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set(), nextFrame = /* @__PURE__ */ new Set(), isProcessing = !1, flushNextFrame = !1;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function triggerCallback(callback) {
    toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame()), callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = !1, immediate = !1) => {
      const queue = immediate && isProcessing ? thisFrame : nextFrame;
      return keepAlive && toKeepAlive.add(callback), queue.has(callback) || queue.add(callback), callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback), toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (latestFrameData = frameData2, isProcessing) {
        flushNextFrame = !0;
        return;
      }
      isProcessing = !0, [thisFrame, nextFrame] = [nextFrame, thisFrame], thisFrame.forEach(triggerCallback), thisFrame.clear(), isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData2));
    }
  };
  return step;
}
const MotionGlobalConfig = {
  useManualTiming: !1
}, maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = !1, useDefaultElapsed = !0;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, flagRunNextFrame = () => runNextFrame = !0, steps = stepsOrder.reduce((acc, key2) => (acc[key2] = createRenderStep(flagRunNextFrame), acc), {}), { read, resolveKeyframes, update, preRender, render, postRender } = steps, processBatch = () => {
    const timestamp = performance.now();
    runNextFrame = !1, state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1), state.timestamp = timestamp, state.isProcessing = !0, read.process(state), resolveKeyframes.process(state), update.process(state), preRender.process(state), render.process(state), postRender.process(state), state.isProcessing = !1, runNextFrame && allowKeepAlive && (useDefaultElapsed = !1, scheduleNextBatch(processBatch));
  }, wake2 = () => {
    runNextFrame = !0, useDefaultElapsed = !0, state.isProcessing || scheduleNextBatch(processBatch);
  };
  return { schedule: stepsOrder.reduce((acc, key2) => {
    const step = steps[key2];
    return acc[key2] = (process2, keepAlive = !1, immediate = !1) => (runNextFrame || wake2(), step.schedule(process2, keepAlive, immediate)), acc;
  }, {}), cancel: (process2) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++)
      steps[stepsOrder[i2]].cancel(process2);
  }, state, steps };
}
const noop$3 = /* @__NO_SIDE_EFFECTS__ */ (any) => any, { schedule: frame$1, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$3, !0);
function useForceUpdate() {
  const isMounted = useIsMounted(), [forcedRenderCount, setForcedRenderCount] = useState(0), forceRender = useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  return [useCallback(() => frame$1.postRender(forceRender), [forceRender]), forcedRenderCount];
}
const notify = (node2) => !node2.isLayoutDirty && node2.willUpdate(!1);
function nodeGroup() {
  const nodes = /* @__PURE__ */ new Set(), subscriptions = /* @__PURE__ */ new WeakMap(), dirtyAll = () => nodes.forEach(notify);
  return {
    add: (node2) => {
      nodes.add(node2), subscriptions.set(node2, node2.addEventListener("willUpdate", dirtyAll));
    },
    remove: (node2) => {
      nodes.delete(node2);
      const unsubscribe = subscriptions.get(node2);
      unsubscribe && (unsubscribe(), subscriptions.delete(node2)), dirtyAll();
    },
    dirty: dirtyAll
  };
}
const shouldInheritGroup = (inherit2) => inherit2 === !0, shouldInheritId = (inherit2) => shouldInheritGroup(inherit2 === !0) || inherit2 === "id", LayoutGroup = ({ children: children2, id: id2, inherit: inherit2 = !0 }) => {
  const layoutGroupContext = useContext(LayoutGroupContext), deprecatedLayoutGroupContext = useContext(DeprecatedLayoutGroupContext), [forceRender, key2] = useForceUpdate(), context2 = useRef(null), upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  context2.current === null && (shouldInheritId(inherit2) && upstreamId && (id2 = id2 ? upstreamId + "-" + id2 : upstreamId), context2.current = {
    id: id2,
    group: shouldInheritGroup(inherit2) && layoutGroupContext.group || nodeGroup()
  });
  const memoizedContext = useMemo(() => ({ ...context2.current, forceRender }), [key2]);
  return jsx(LayoutGroupContext.Provider, { value: memoizedContext, children: children2 });
}, LazyContext = createContext({ strict: !1 }), featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (const key2 in featureProps)
  featureDefinitions[key2] = {
    isEnabled: (props) => featureProps[key2].some((name) => !!props[name])
  };
function loadFeatures(features) {
  for (const key2 in features)
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features[key2]
    };
}
function LazyMotion({ children: children2, features, strict = !1 }) {
  const [, setIsLoaded] = useState(!isLazyBundle(features)), loadedRenderer = useRef(void 0);
  if (!isLazyBundle(features)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer, loadFeatures(loadedFeatures);
  }
  return useEffect(() => {
    isLazyBundle(features) && features().then(({ renderer, ...loadedFeatures }) => {
      loadFeatures(loadedFeatures), loadedRenderer.current = renderer, setIsLoaded(!0);
    });
  }, []), jsx(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children: children2 });
}
function isLazyBundle(features) {
  return typeof features == "function";
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || key2.startsWith("onLayout") || validMotionProps.has(key2);
}
let shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  isValidProp && (shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2));
}
try {
  loadExternalIsValidProp((void 0).default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props)
    key2 === "values" && typeof props.values == "object" || (shouldForward(key2) || forwardMotionProps === !0 && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props.draggable && key2.startsWith("onDrag")) && (filteredProps[key2] = props[key2]);
  return filteredProps;
}
function MotionConfig({ children: children2, isValidProp, ...config }) {
  isValidProp && loadExternalIsValidProp(isValidProp), config = { ...useContext(MotionConfigContext), ...config }, config.isStatic = useConstant(() => config.isStatic);
  const context2 = useMemo(() => config, [
    JSON.stringify(config.transition),
    config.transformPagePoint,
    config.reducedMotion
  ]);
  return jsx(MotionConfigContext.Provider, { value: context2, children: children2 });
}
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy > "u")
    return componentFactory;
  const componentCache = /* @__PURE__ */ new Map(), deprecatedFactoryFunction = (...args) => componentFactory(...args);
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => key2 === "create" ? componentFactory : (componentCache.has(key2) || componentCache.set(key2, componentFactory(key2)), componentCache.get(key2))
  });
}
const MotionContext = /* @__PURE__ */ createContext({});
function isAnimationControls(v) {
  return v !== null && typeof v == "object" && typeof v.start == "function";
}
function isVariantLabel(v) {
  return typeof v == "string" || Array.isArray(v);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return !!(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context2) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === !1 || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== !1 ? context2 : {};
}
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, useContext(MotionContext));
  return useMemo(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(ref) {
  return ref && typeof ref == "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return useCallback(
    (instance) => {
      instance && visualState.onMount && visualState.onMount(instance), visualElement && (instance ? visualElement.mount(instance) : visualElement.unmount()), externalRef && (typeof externalRef == "function" ? externalRef(instance) : isRefObject(externalRef) && (externalRef.current = instance));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId), SwitchLayoutGroupContext = createContext({}), { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, !1);
function useVisualElement(Component2, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  const { visualElement: parent } = useContext(MotionContext), lazyContext = useContext(LazyContext), presenceContext = useContext(PresenceContext), reducedMotionConfig = useContext(MotionConfigContext).reducedMotion, visualElementRef = useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer, !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component2, {
    visualState,
    parent,
    props,
    presenceContext,
    blockInitialAnimation: presenceContext ? presenceContext.initial === !1 : !1,
    reducedMotionConfig
  }));
  const visualElement = visualElementRef.current, initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);
  visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg") && createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  const isMounted = useRef(!1);
  useInsertionEffect$1(() => {
    visualElement && isMounted.current && visualElement.update(props, presenceContext);
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute], wantsHandoff = useRef(!!optimisedAppearId && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
  return useIsomorphicLayoutEffect$2(() => {
    visualElement && (isMounted.current = !0, window.MotionIsMounted = !0, visualElement.updateFeatures(), microtask.render(visualElement.render), wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges());
  }), useEffect(() => {
    visualElement && (!wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges(), wantsHandoff.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
    }), wantsHandoff.current = !1));
  }), visualElement;
}
function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent)), visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: !!drag2 || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 == "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (visualElement)
    return visualElement.options.allowProjection !== !1 ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
let invariant = () => {
};
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component: Component2 }) {
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    }, { isStatic } = configAndProps, context2 = useCreateMotionContext(props), visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$1) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout, context2.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxs(MotionContext.Provider, { value: context2, children: [MeasureLayout2 && context2.visualElement ? jsx(MeasureLayout2, { visualElement: context2.visualElement, ...configAndProps }) : null, useRender(Component2, props, useMotionRef(visualState, context2.visualElement, externalRef), visualState, isStatic, context2.visualElement)] });
  }
  MotionComponent.displayName = `motion.${typeof Component2 == "string" ? Component2 : `create(${Component2.displayName ?? Component2.name ?? ""})`}`;
  const ForwardRefMotionComponent = forwardRef(MotionComponent);
  return ForwardRefMotionComponent[motionComponentSymbol] = Component2, ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
const checkStringStartsWith = (token) => (key2) => typeof key2 == "string" && key2.startsWith(token), isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--"), startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--"), isCSSVariableToken = (value) => startsAsVariableToken(value) ? singleCssVariableRegex.test(value.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, scaleCorrectors = {};
function addScaleCorrector(correctors) {
  for (const key2 in correctors)
    scaleCorrectors[key2] = correctors[key2], isCSSVariableName(key2) && (scaleCorrectors[key2].isCSSVariable = !0);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}
const isMotionValue = (value) => !!(value && value.getVelocity), getValueAsType = (value, type) => type && typeof value == "number" ? type.transform(value) : value, clamp$1 = (min2, max2, v) => v > max2 ? max2 : v < min2 ? min2 : v, number = {
  test: (v) => typeof v == "number",
  parse: parseFloat,
  transform: (v) => v
}, alpha = {
  ...number,
  transform: (v) => clamp$1(0, 1, v)
}, scale = {
  ...number,
  default: 1
}, createUnitType = (unit) => ({
  test: (v) => typeof v == "string" && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
}), degrees$1 = /* @__PURE__ */ createUnitType("deg"), percent = /* @__PURE__ */ createUnitType("%"), px = /* @__PURE__ */ createUnitType("px"), vh = /* @__PURE__ */ createUnitType("vh"), vw = /* @__PURE__ */ createUnitType("vw"), progressPercentage = {
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100)
}, browserNumberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px
}, transformValueTypes = {
  rotate: degrees$1,
  rotateX: degrees$1,
  rotateY: degrees$1,
  rotateZ: degrees$1,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees$1,
  skewX: degrees$1,
  skewY: degrees$1,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
}, int = {
  ...number,
  transform: Math.round
}, numberValueTypes = {
  ...browserNumberValueTypes,
  ...transformValueTypes,
  zIndex: int,
  size: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
}, translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform2, transformTemplate) {
  let transformString = "", transformIsDefault = !0;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key2 = transformPropOrder[i2], value = latestValues[key2];
    if (value === void 0)
      continue;
    let valueIsDefault = !0;
    if (typeof value == "number" ? valueIsDefault = value === (key2.startsWith("scale") ? 1 : 0) : valueIsDefault = parseFloat(value) === 0, !valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key2]);
      if (!valueIsDefault) {
        transformIsDefault = !1;
        const transformName = translateAlias[key2] || key2;
        transformString += `${transformName}(${valueAsType}) `;
      }
      transformTemplate && (transform2[key2] = valueAsType);
    }
  }
  return transformString = transformString.trim(), transformTemplate ? transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString) : transformIsDefault && (transformString = "none"), transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style: style2, vars, transformOrigin } = state;
  let hasTransform2 = !1, hasTransformOrigin = !1;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (transformProps.has(key2)) {
      hasTransform2 = !0;
      continue;
    } else if (isCSSVariableName(key2)) {
      vars[key2] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key2]);
      key2.startsWith("origin") ? (hasTransformOrigin = !0, transformOrigin[key2] = valueAsType) : style2[key2] = valueAsType;
    }
  }
  if (latestValues.transform || (hasTransform2 || transformTemplate ? style2.transform = buildTransform(latestValues, state.transform, transformTemplate) : style2.transform && (style2.transform = "none")), hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style2.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key2 in source)
    !isMotionValue(source[key2]) && !isForcedMotionValue(key2, props) && (target[key2] = source[key2]);
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return useMemo(() => {
    const state = createHtmlRenderState();
    return buildHTMLStyles(state, visualState, transformTemplate), Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {}, style2 = {};
  return copyRawValuesOnly(style2, styleProp, props), Object.assign(style2, useInitialMotionValues(props, visualState)), style2;
}
function useHTMLProps(props, visualState) {
  const htmlProps2 = {}, style2 = useStyle(props, visualState);
  return props.drag && props.dragListener !== !1 && (htmlProps2.draggable = !1, style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none", style2.touchAction = props.drag === !0 ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`), props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap) && (htmlProps2.tabIndex = 0), htmlProps2.style = style2, htmlProps2;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(lowercaseSVGElements.indexOf(Component2) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component2))
    )
  );
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = !0) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset2);
  const pathLength = px.transform(length), pathSpacing = px.transform(spacing);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}
function calcOrigin$1(origin, offset2, size2) {
  return typeof origin == "string" ? origin : px.transform(offset2 + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width), pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  if (buildHTMLStyles(state, latest, transformTemplate), isSVGTag2) {
    state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);
    return;
  }
  state.attrs = state.style, state.style = {};
  const { attrs, style: style2, dimensions } = state;
  attrs.transform && (dimensions && (style2.transform = attrs.transform), delete attrs.transform), dimensions && (originX !== void 0 || originY !== void 0 || style2.transform) && (style2.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5)), attrX !== void 0 && (attrs.x = attrX), attrY !== void 0 && (attrs.y = attrY), attrScale !== void 0 && (attrs.scale = attrScale), pathLength !== void 0 && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
}), isSVGTag = (tag) => typeof tag == "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component2) {
  const visualProps = useMemo(() => {
    const state = createSvgRenderState();
    return buildSVGAttrs(state, visualState, isSVGTag(Component2), props.transformTemplate), {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props), visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = !1) {
  return (Component2, props, ref, { latestValues }, isStatic) => {
    const visualProps = (isSVGComponent(Component2) ? useSVGProps : useHTMLProps)(props, latestValues, isStatic, Component2), filteredProps = filterProps(props, typeof Component2 == "string", forwardMotionProps), elementProps = Component2 !== Fragment ? { ...filteredProps, ...visualProps, ref } : {}, { children: children2 } = props, renderedChildren = useMemo(() => isMotionValue(children2) ? children2.get() : children2, [children2]);
    return createElement(Component2, {
      ...elementProps,
      children: renderedChildren
    });
  };
}
function getValueState(visualElement) {
  const state = [{}, {}];
  return visualElement?.values.forEach((value, key2) => {
    state[0][key2] = value.get(), state[1][key2] = value.getVelocity();
  }), state;
}
function resolveVariantFromProps(props, definition, custom5, visualElement) {
  if (typeof definition == "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props.custom, current, velocity);
  }
  if (typeof definition == "string" && (definition = props.variants && props.variants[definition]), typeof definition == "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props.custom, current, velocity);
  }
  return definition;
}
const isKeyframesTarget = (v) => Array.isArray(v), isCustomValue = (v) => !!(v && typeof v == "object" && v.mix && v.toValue), resolveFinalValueInKeyframes = (v) => isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onUpdate }, props, context2, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context2, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  return onUpdate && (state.onMount = (instance) => onUpdate({ props, current: instance, ...state }), state.onUpdate = (visualElement) => onUpdate(visualElement)), state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context2 = useContext(MotionContext), presenceContext = useContext(PresenceContext), make = () => makeState(config, props, context2, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context2, presenceContext, scrapeMotionValues) {
  const values2 = {}, motionValues = scrapeMotionValues(props, {});
  for (const key2 in motionValues)
    values2[key2] = resolveMotionValue(motionValues[key2]);
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props), isVariantNode$1 = isVariantNode(props);
  context2 && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== !1 && (initial === void 0 && (initial = context2.initial), animate2 === void 0 && (animate2 = context2.animate));
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === !1 : !1;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === !1;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet != "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list2.length; i2++) {
      const resolved = resolveVariantFromProps(props, list2[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key2 in target) {
          let valueTarget = target[key2];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          valueTarget !== null && (values2[key2] = valueTarget);
        }
        for (const key2 in transitionEnd)
          values2[key2] = transitionEnd[key2];
      }
    }
  }
  return values2;
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  const { style: style2 } = props, newValues = {};
  for (const key2 in style2)
    (isMotionValue(style2[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props) || visualElement?.getValue(key2)?.liveStyle !== void 0) && (newValues[key2] = style2[key2]);
  return newValues;
}
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function updateSVGDimensions(instance, renderState) {
  try {
    renderState.dimensions = typeof instance.getBBox == "function" ? instance.getBBox() : instance.getBoundingClientRect();
  } catch {
    renderState.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
function renderHTML(element, { style: style2, vars }, styleProp, projection) {
  Object.assign(element.style, style2, projection && projection.getProjectionStyles(styleProp));
  for (const key2 in vars)
    element.style.setProperty(key2, vars[key2]);
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs)
    element.setAttribute(camelCaseAttributes.has(key2) ? key2 : camelToDash(key2), renderState.attrs[key2]);
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key2 in props)
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = transformPropOrder.indexOf(key2) !== -1 ? "attr" + key2.charAt(0).toUpperCase() + key2.substring(1) : key2;
      newValues[targetKey] = props[key2];
    }
  return newValues;
}
const layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"], svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onUpdate: ({ props, prevProps, current, renderState, latestValues }) => {
      if (!current)
        return;
      let hasTransform2 = !!props.drag;
      if (!hasTransform2) {
        for (const key2 in latestValues)
          if (transformProps.has(key2)) {
            hasTransform2 = !0;
            break;
          }
      }
      if (!hasTransform2)
        return;
      let needsMeasure = !prevProps;
      if (prevProps)
        for (let i2 = 0; i2 < layoutProps.length; i2++) {
          const key2 = layoutProps[i2];
          props[key2] !== prevProps[key2] && (needsMeasure = !0);
        }
      needsMeasure && frame$1.read(() => {
        updateSVGDimensions(current, renderState), frame$1.render(() => {
          buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate), renderSVG(current, renderState);
        });
      });
    }
  })
};
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function(Component2, { forwardMotionProps } = { forwardMotionProps: !1 }) {
    const config = {
      ...isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component: Component2
    };
    return createRendererMotionComponent(config);
  };
}
const createMinimalMotionComponent = /* @__PURE__ */ createMotionComponentFactory(), m$2 = /* @__PURE__ */ createDOMMotionComponentProxy(createMinimalMotionComponent);
function resolveVariant(visualElement, definition, custom5) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom5 !== void 0 ? custom5 : props.custom, visualElement);
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);
let now$1;
function clearTime() {
  now$1 = void 0;
}
const time = {
  now: () => (now$1 === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now$1),
  set: (newTime) => {
    now$1 = newTime, queueMicrotask(clearTime);
  }
};
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  index2 > -1 && arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    return addUniqueItem(this.subscriptions, handler), () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (numSubscriptions)
      if (numSubscriptions === 1)
        this.subscriptions[0](a2, b2, c2);
      else
        for (let i2 = 0; i2 < numSubscriptions; i2++) {
          const handler = this.subscriptions[i2];
          handler && handler(a2, b2, c2);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const MAX_VELOCITY_DELTA = 30, isFloat = (value) => !isNaN(parseFloat(value));
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init2, options = {}) {
    this.version = "12.7.4", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (v, render = !0) => {
      const currentTime = time.now();
      this.updatedAt !== currentTime && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(v), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), render && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(init2), this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current, this.updatedAt = time.now(), this.canTrackVelocity === null && current !== void 0 && (this.canTrackVelocity = isFloat(this.current));
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
    const unsubscribe = this.events[eventName].add(callback);
    return eventName === "change" ? () => {
      unsubscribe(), frame$1.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events)
      this.events[eventManagers].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect, this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render = !0) {
    !render || !this.passiveEffect ? this.updateAndNotify(v, render) : this.passiveEffect(v, this.updateAndNotify);
  }
  setWithVelocity(prev, current, delta) {
    this.set(current), this.prev = void 0, this.prevFrameValue = prev, this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = !0) {
    this.updateAndNotify(v), this.prev = v, this.prevUpdatedAt = this.prevFrameValue = void 0, endAnimation && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA)
      return 0;
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    return this.stop(), new Promise((resolve) => {
      this.hasAnimated = !0, this.animation = startAnimation(resolve), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}
function setMotionValue(visualElement, key2, value) {
  visualElement.hasValue(key2) ? visualElement.getValue(key2).set(value) : visualElement.addValue(key2, motionValue(value));
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key2 in target) {
    const value = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value);
  }
}
function isWillChangeMotionValue(value) {
  return !!(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key2) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange))
    return willChange.add(key2);
  if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange), newWillChange.add(key2);
  }
}
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX, currentT, i2 = 0;
  do
    currentT = lowerBound + (upperBound - lowerBound) / 2, currentX = calcBezier(currentT, mX1, mX2) - x2, currentX > 0 ? upperBound = currentT : lowerBound = currentT;
  while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$3;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2, reverseEasing = (easing) => (p2) => 1 - easing(1 - p2), backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = /* @__PURE__ */ reverseEasing(backOut), backInOut = /* @__PURE__ */ mirrorEasing(backIn), anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1))), circIn = (p2) => 1 - Math.sin(Math.acos(p2)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
function isNone(value) {
  return typeof value == "number" ? value === 0 : value !== null ? value === "none" || value === "0" || isZeroValueString(value) : !0;
}
const sanitize = (v) => Math.round(v * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v) {
  return v == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, isColorString = (type, testProp) => (v) => !!(typeof v == "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp)), splitColor = (aName, bName, cName) => (v) => {
  if (typeof v != "string")
    return v;
  const [a2, b2, c2, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
}, clampRgbUnit = (v) => clamp$1(0, 255, v), rgbUnit = {
  ...number,
  transform: (v) => Math.round(clampRgbUnit(v))
}, rgba$1 = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$12 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
};
function parseHex(v) {
  let r2 = "", g = "", b2 = "", a2 = "";
  return v.length > 5 ? (r2 = v.substring(1, 3), g = v.substring(3, 5), b2 = v.substring(5, 7), a2 = v.substring(7, 9)) : (r2 = v.substring(1, 2), g = v.substring(2, 3), b2 = v.substring(3, 4), a2 = v.substring(4, 5), r2 += r2, g += g, b2 += b2, a2 += a2), {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex$1 = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba$1.transform
}, hsla$1 = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$12 = 1 }) => "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
}, color$1 = {
  test: (v) => rgba$1.test(v) || hex$1.test(v) || hsla$1.test(v),
  parse: (v) => rgba$1.test(v) ? rgba$1.parse(v) : hsla$1.test(v) ? hsla$1.parse(v) : hex$1.parse(v),
  transform: (v) => typeof v == "string" ? v : v.hasOwnProperty("red") ? rgba$1.transform(v) : hsla$1.transform(v)
}, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v) {
  return isNaN(v) && typeof v == "string" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;
}
const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString(), values2 = [], indexes = {
    color: [],
    number: [],
    var: []
  }, types = [];
  let i2 = 0;
  const split = originalValue.replace(complexRegex, (parsedValue) => (color$1.test(parsedValue) ? (indexes.color.push(i2), types.push(COLOR_TOKEN), values2.push(color$1.parse(parsedValue))) : parsedValue.startsWith(VAR_FUNCTION_TOKEN) ? (indexes.var.push(i2), types.push(VAR_TOKEN), values2.push(parsedValue)) : (indexes.number.push(i2), types.push(NUMBER_TOKEN), values2.push(parseFloat(parsedValue))), ++i2, SPLIT_TOKEN)).split(SPLIT_TOKEN);
  return { values: values2, split, indexes, types };
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source), numSections = split.length;
  return (v) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++)
      if (output += split[i2], v[i2] !== void 0) {
        const type = types[i2];
        type === NUMBER_TOKEN ? output += sanitize(v[i2]) : type === COLOR_TOKEN ? output += color$1.transform(v[i2]) : output += v[i2];
      }
    return output;
  };
}
const convertNumbersToZero = (v) => typeof v == "number" ? 0 : v;
function getAnimatableNone$1(v) {
  const parsed = parseComplexValue(v);
  return createTransformer(v)(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
}, maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  return number2 !== value && (defaultValue *= 100), name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter$1 = {
  ...complex,
  getAnimatableNone: (v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }
}, defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color: color$1,
  backgroundColor: color$1,
  outlineColor: color$1,
  fill: color$1,
  stroke: color$1,
  // Border props
  borderColor: color$1,
  borderTopColor: color$1,
  borderRightColor: color$1,
  borderBottomColor: color$1,
  borderLeftColor: color$1,
  filter: filter$1,
  WebkitFilter: filter$1
}, getDefaultValueType = (key2) => defaultValueTypes[key2];
function getAnimatableNone(key2, value) {
  let defaultValueType = getDefaultValueType(key2);
  return defaultValueType !== filter$1 && (defaultValueType = complex), defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0, animatableTemplate;
  for (; i2 < unresolvedKeyframes.length && !animatableTemplate; ) {
    const keyframe = unresolvedKeyframes[i2];
    typeof keyframe == "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length && (animatableTemplate = unresolvedKeyframes[i2]), i2++;
  }
  if (animatableTemplate && name)
    for (const noneIndex of noneKeyframeIndexes)
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
}
const radToDeg = (rad) => rad * 180 / Math.PI, rotate = (v) => {
  const angle = radToDeg(Math.atan2(v[1], v[0]));
  return rebaseAngle(angle);
}, matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v) => radToDeg(Math.atan(v[1])),
  skewY: (v) => radToDeg(Math.atan(v[2])),
  skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
}, rebaseAngle = (angle) => (angle = angle % 360, angle < 0 && (angle += 360), angle), rotateZ = rotate, scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]), scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]), matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v) => (scaleX(v) + scaleY(v)) / 2,
  rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
  rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v) => radToDeg(Math.atan(v[4])),
  skewY: (v) => radToDeg(Math.atan(v[1])),
  skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform2, name) {
  if (!transform2 || transform2 === "none")
    return defaultTransformValue(name);
  const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers, match;
  if (matrix3dMatch)
    parsers = matrix3dParsers, match = matrix3dMatch;
  else {
    const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers, match = matrix2dMatch;
  }
  if (!match)
    return defaultTransformValue(name);
  const valueParser = parsers[name], values2 = match[1].split(",").map(convertTransformToNumber);
  return typeof valueParser == "function" ? valueParser(values2) : values2[valueParser];
}
const readTransformValue = (instance, name) => {
  const { transform: transform2 = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform2, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const isNumOrPxType = (v) => v === number || v === px, transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  return nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    value !== void 0 && (removedTransforms.push([key2, value.get()]), value.set(key2.startsWith("scale") ? 1 : 0));
  }), removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
  y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = !1, anyNeedsMeasurement = !1;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement), elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element)), transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      removedTransforms.length && (transformsToRestore.set(element, removedTransforms), element.render());
    }), resolversToMeasure.forEach((resolver) => resolver.measureInitialState()), elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      restore && restore.forEach(([key2, value]) => {
        element.getValue(key2)?.set(value);
      });
    }), resolversToMeasure.forEach((resolver) => resolver.measureEndState()), resolversToMeasure.forEach((resolver) => {
      resolver.suspendedScrollY !== void 0 && window.scrollTo(0, resolver.suspendedScrollY);
    });
  }
  anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach((resolver) => resolver.complete()), toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes(), resolver.needsMeasurement && (anyNeedsMeasurement = !0);
  });
}
function flushKeyframeResolvers() {
  readAllKeyframes(), measureAllKeyframes();
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...unresolvedKeyframes], this.onComplete = onComplete, this.name = name, this.motionValue = motionValue2, this.element = element, this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame$1.read(readAllKeyframes), frame$1.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++)
      if (unresolvedKeyframes[i2] === null)
        if (i2 === 0) {
          const currentValue = motionValue2?.get(), finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0)
            unresolvedKeyframes[0] = currentValue;
          else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            valueAsRead != null && (unresolvedKeyframes[0] = valueAsRead);
          }
          unresolvedKeyframes[0] === void 0 && (unresolvedKeyframes[0] = finalKeyframe), motionValue2 && currentValue === void 0 && motionValue2.set(unresolvedKeyframes[0]);
        } else
          unresolvedKeyframes[i2] = unresolvedKeyframes[i2 - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), toResolve.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, toResolve.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v), splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
const testValueType = (v) => (type) => type.test(v), auto = {
  test: (v) => v === "auto",
  parse: (v) => v
}, dimensionValueTypes = [number, px, percent, degrees$1, vw, vh, auto], findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe == "string" && (keyframe = keyframe.trim(), isCSSVariableToken(keyframe))) {
        const resolved = getVariableValue(keyframe, element.current);
        resolved !== void 0 && (unresolvedKeyframes[i2] = resolved), i2 === unresolvedKeyframes.length - 1 && (this.finalKeyframe = keyframe);
      }
    }
    if (this.resolveNoneKeyframes(), !positionalKeys.has(name) || unresolvedKeyframes.length !== 2)
      return;
    const [origin, target] = unresolvedKeyframes, originType = findDimensionValueType(origin), targetType = findDimensionValueType(target);
    if (originType !== targetType)
      if (isNumOrPxType(originType) && isNumOrPxType(targetType))
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          const value = unresolvedKeyframes[i2];
          typeof value == "string" && (unresolvedKeyframes[i2] = parseFloat(value));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this, noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++)
      isNone(unresolvedKeyframes[i2]) && noneKeyframeIndexes.push(i2);
    noneKeyframeIndexes.length && makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    name === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    measureKeyframe !== void 0 && element.getValue(name, measureKeyframe).jump(measureKeyframe, !1);
  }
  measureEndState() {
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, !1);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1, finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), finalKeyframe !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = finalKeyframe), this.removedTransforms?.length && this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
      element.getValue(unsetTransformName).set(unsetTransformValue);
    }), this.resolveNoneKeyframes();
  }
}
const isAnimatable = (value, name) => name === "zIndex" ? !1 : !!(typeof value == "number" || Array.isArray(value) || typeof value == "string" && // It's animatable if we have a string
(complex.test(value) || value === "0") && // And it contains numbers and/or colors
!value.startsWith("url("));
function isGenerator(type) {
  return typeof type == "function" && "applyToOptions" in type;
}
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return !0;
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    if (keyframes2[i2] !== current)
      return !0;
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return !1;
  if (name === "display" || name === "visibility")
    return !0;
  const targetKeyframe = keyframes2[keyframes2.length - 1], isOriginAnimatable = isAnimatable(originKeyframe, name), isTargetAnimatable = isAnimatable(targetKeyframe, name);
  return !isOriginAnimatable || !isTargetAnimatable ? !1 : hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull), index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
  constructor({ autoplay = !0, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = time.now(), this.options = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes2, finalKeyframe) {
    this.resolvedAt = time.now(), this.hasAttemptedResolve = !0;
    const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator: isGenerator2 } = this.options;
    if (!isGenerator2 && !canAnimate(keyframes2, name, type, velocity))
      if (delay2)
        this.options.duration = 0;
      else {
        onUpdate && onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onComplete && onComplete(), this.resolveFinishedPromise();
        return;
      }
    const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
    resolvedAnimation !== !1 && (this._resolved = {
      keyframes: keyframes2,
      finalKeyframe,
      ...resolvedAnimation
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  flatten() {
    this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear");
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((resolve) => {
      this.resolveFinishedPromise = resolve;
    });
  }
}
const mixNumber$1 = (from, to, progress2) => from + (to - from) * progress2;
function hueToRgb(p2, q, t2) {
  return t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p2 + (q - p2) * 6 * t2 : t2 < 1 / 2 ? q : t2 < 2 / 3 ? p2 + (q - p2) * (2 / 3 - t2) * 6 : p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360, saturation /= 100, lightness /= 100;
  let red = 0, green = 0, blue = 0;
  if (!saturation)
    red = green = blue = lightness;
  else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p2 = 2 * lightness - q;
    red = hueToRgb(p2, q, hue + 1 / 3), green = hueToRgb(p2, q, hue), blue = hueToRgb(p2, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
function mixImmediate(a2, b2) {
  return (p2) => p2 > 0 ? b2 : a2;
}
const mixLinearColor = (from, to, v) => {
  const fromExpo = from * from, expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
}, colorTypes = [hex$1, rgba$1, hsla$1], getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color2) {
  const type = getColorType(color2);
  if (!type)
    return !1;
  let model = type.parse(color2);
  return type === hsla$1 && (model = hslaToRgba(model)), model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from), toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA)
    return mixImmediate(from, to);
  const blended = { ...fromRGBA };
  return (v) => (blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v), blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v), blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v), blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v), rgba$1.transform(blended));
}, combineFunctions = (a2, b2) => (v) => b2(a2(v)), pipe = (...transformers) => transformers.reduce(combineFunctions), invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  return invisibleValues.has(origin) ? (p2) => p2 <= 0 ? origin : target : (p2) => p2 >= 1 ? target : origin;
}
function mixNumber(a2, b2) {
  return (p2) => mixNumber$1(a2, b2, p2);
}
function getMixer(a2) {
  return typeof a2 == "number" ? mixNumber : typeof a2 == "string" ? isCSSVariableToken(a2) ? mixImmediate : color$1.test(a2) ? mixColor : mixComplex : Array.isArray(a2) ? mixArray : typeof a2 == "object" ? color$1.test(a2) ? mixColor : mixObject : mixImmediate;
}
function mixArray(a2, b2) {
  const output = [...a2], numValues = output.length, blendValue = a2.map((v, i2) => getMixer(v)(v, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++)
      output[i2] = blendValue[i2](p2);
    return output;
  };
}
function mixObject(a2, b2) {
  const output = { ...a2, ...b2 }, blendValue = {};
  for (const key2 in output)
    a2[key2] !== void 0 && b2[key2] !== void 0 && (blendValue[key2] = getMixer(a2[key2])(a2[key2], b2[key2]));
  return (v) => {
    for (const key2 in blendValue)
      output[key2] = blendValue[key2](v);
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [], pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type = target.types[i2], originIndex = origin.indexes[type][pointers[type]], originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i2] = originValue, pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target), originStats = analyseComplexValue(origin), targetStats = analyseComplexValue(target);
  return originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length ? invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length ? mixVisibility(origin, target) : pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template) : mixImmediate(origin, target);
};
function mix(from, to, p2) {
  return typeof from == "number" && typeof to == "number" && typeof p2 == "number" ? mixNumber$1(from, to, p2) : getMixer(from)(from, to);
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3, millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3, safeMin = 1e-3;
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope, derivative, dampingRatio = 1 - bounce;
  dampingRatio = clamp$1(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio), duration = clamp$1(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration)), dampingRatio < 1 ? (envelope = (undampedFreq2) => {
    const exponentialDecay = undampedFreq2 * dampingRatio, delta = exponentialDecay * duration, a2 = exponentialDecay - velocity, b2 = calcAngularFreq(undampedFreq2, dampingRatio), c2 = Math.exp(-delta);
    return safeMin - a2 / b2 * c2;
  }, derivative = (undampedFreq2) => {
    const delta = undampedFreq2 * dampingRatio * duration, d2 = delta * velocity + velocity, e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration, f2 = Math.exp(-delta), g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
    return (-envelope(undampedFreq2) + safeMin > 0 ? -1 : 1) * ((d2 - e2) * f2) / g;
  }) : (envelope = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration), b2 = (undampedFreq2 - velocity) * duration + 1;
    return -1e-3 + a2 * b2;
  }, derivative = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration), b2 = (velocity - undampedFreq2) * (duration * duration);
    return a2 * b2;
  });
  const initialGuess = 5 / duration, undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  if (duration = /* @__PURE__ */ secondsToMilliseconds(duration), isNaN(undampedFreq))
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++)
    result = result - envelope(result) / derivative(result);
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  for (; !state.done && duration < maxGeneratorDuration; )
    duration += timeStep, state = generator.next(duration);
  return duration >= maxGeneratorDuration ? 1 / 0 : duration;
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] }), duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => generator.next(duration * progress2).value / scale2,
    duration: /* @__PURE__ */ millisecondsToSeconds(duration)
  };
}
const supportsFlags = {};
// @__NO_SIDE_EFFECTS__
function memo(callback) {
  let result;
  return () => (result === void 0 && (result = callback()), result);
}
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), generateLinearEasing = (easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++)
    points += easing(i2 / (numPoints - 1)) + ", ";
  return `linear(${points.substring(0, points.length - 2)})`;
}, durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key2) => options[key2] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: !1,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys))
    if (options.visualDuration) {
      const visualDuration = options.visualDuration, root2 = 2 * Math.PI / (visualDuration * 1.2), stiffness = root2 * root2, damping = 2 * clamp$1(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      }, springOptions.isResolvedFromDuration = !0;
    }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration != "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0], target = options.keyframes[options.keyframes.length - 1], state = { done: !1, value: origin }, { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)
  }), initialVelocity = velocity || 0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target - origin, undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass)), isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default), restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1)
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2), freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration && duration || null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (isResolvedFromDuration)
        state.done = t2 >= duration;
      else {
        let currentVelocity = 0;
        dampingRatio < 1 && (currentVelocity = t2 === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current));
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed, isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      }
      return state.value = state.done ? target : current, state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration), easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  return options.ease = supportsLinearEasing() ? generatorOptions.ease : "easeOut", options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration), options.type = "keyframes", options;
};
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0], state = {
    done: !1,
    value: origin
  }, isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2, nearestBoundary = (v) => min2 === void 0 ? max2 : max2 === void 0 || Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  let amplitude = power * velocity;
  const ideal = origin + amplitude, target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  target !== ideal && (amplitude = target - origin);
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant), calcLatest = (t2) => target + calcDelta(t2), applyFriction = (t2) => {
    const delta = calcDelta(t2), latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta, state.value = state.done ? target : latest;
  };
  let timeReachedBoundary, spring$1;
  const checkCatchBoundary = (t2) => {
    isOutOfBounds(state.value) && (timeReachedBoundary = t2, spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    }));
  };
  return checkCatchBoundary(0), {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = !1;
      return !spring$1 && timeReachedBoundary === void 0 && (hasUpdatedFrame = !0, applyFriction(t2), checkCatchBoundary(t2)), timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary ? spring$1.next(t2 - timeReachedBoundary) : (!hasUpdatedFrame && applyFriction(t2), state);
    }
  };
}
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1), easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1), easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1), isEasingArray = (ease2) => Array.isArray(ease2) && typeof ease2[0] != "number", isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] == "number", easingLookup = {
  linear: noop$3,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
}, easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition == "string")
    return easingLookup[definition];
  return definition;
}, progress = /* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
function createMixers(output, ease2, customMixer) {
  const mixers = [], mixerFactory = customMixer || mix, numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$3 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate$1(input2, output, { clamp: isClamp = !0, ease: ease2, mixer } = {}) {
  const inputLength = input2.length;
  if (invariant(inputLength === output.length), inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input2[0] === input2[1];
  input2[0] > input2[inputLength - 1] && (input2 = [...input2].reverse(), output = [...output].reverse());
  const mixers = createMixers(output, ease2, mixer), numMixers = mixers.length, interpolator = (v) => {
    if (isZeroDeltaRange && v < input2[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1)
      for (; i2 < input2.length - 2 && !(v < input2[i2 + 1]); i2++)
        ;
    const progressInRange = /* @__PURE__ */ progress(input2[i2], input2[i2 + 1], v);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v) => interpolator(clamp$1(input2[0], input2[inputLength - 1], v)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i2);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  return fillOffset(offset2, arr.length - 1), offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o2) => o2 * duration);
}
function defaultEasing(values2, easing) {
  return values2.map(() => easing || easeInOut).splice(0, values2.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2), state = {
    done: !1,
    value: keyframeValues[0]
  }, absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  ), mapTimeToKeyframe = interpolate$1(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => (state.value = mapTimeToKeyframe(t2), state.done = t2 >= duration, state)
  };
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame$1.update(passTimestamp, !0),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
}, generators = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
}, percentToProgress = (percent2) => percent2 / 100;
class MainThreadAnimation extends BaseAnimation {
  constructor(options) {
    super(options), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options, KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver, onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
    this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2, element), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(keyframes$1) {
    const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options, generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;
    let mapPercentToKeyframes, mirroredGenerator;
    generatorFactory !== keyframes && typeof keyframes$1[0] != "number" && (mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1])), keyframes$1 = [0, 100]);
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
    repeatType === "mirror" && (mirroredGenerator = generatorFactory({
      ...this.options,
      keyframes: [...keyframes$1].reverse(),
      velocity: -velocity
    })), generator.calculatedDuration === null && (generator.calculatedDuration = calcGeneratorDuration(generator));
    const { calculatedDuration } = generator, resolvedDuration = calculatedDuration + repeatDelay, totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !autoplay ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(timestamp, sample = !1) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes3 } = this.options;
      return { done: !0, value: keyframes3[keyframes3.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, timestamp) : this.speed < 0 && (this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime)), sample ? this.currentTime = timestamp : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1), isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = totalDuration);
    let elapsed = this.currentTime, frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2), iterationProgress = progress2 % 1;
      !iterationProgress && progress2 >= 1 && (iterationProgress = 1), iterationProgress === 1 && currentIteration--, currentIteration = Math.min(currentIteration, repeat + 1), !!(currentIteration % 2) && (repeatType === "reverse" ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : repeatType === "mirror" && (frameGenerator = mirroredGenerator)), elapsed = clamp$1(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: !1, value: keyframes2[0] } : frameGenerator.next(elapsed);
    mapPercentToKeyframes && (state.value = mapPercentToKeyframes(state.value));
    let { done } = state;
    !isInDelayPhase && calculatedDuration !== null && (done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0);
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    return isAnimationFinished && finalKeyframe !== void 0 && (state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onUpdate && onUpdate(state.value), isAnimationFinished && this.finish(), state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? /* @__PURE__ */ millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime), this.currentTime = newTime, this.holdTime !== null || this.speed === 0 ? this.holdTime = newTime : this.driver && (this.startTime = this.driver.now() - newTime / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed, hasChanged && (this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay, startTime } = this.options;
    this.driver || (this.driver = driver((timestamp) => this.tick(timestamp))), onPlay && onPlay();
    const now2 = this.driver.now();
    this.holdTime !== null ? this.startTime = now2 - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = now2) : this.startTime = startTime ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = this.currentTime ?? 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(time2) {
    return this.startTime = 0, this.tick(time2, !0);
  }
  get finished() {
    return this.currentFinishedPromise;
  }
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")), cubicBezierAsString = ([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`, supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (easing)
    return typeof easing == "function" && supportsLinearEasing() ? generateLinearEasing(easing, duration) : isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[easing];
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeInOut", times } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  times && (keyframeOptions.offset = times);
  const easing = mapEasingToNativeEasing(ease2, duration);
  return Array.isArray(easing) && (keyframeOptions.easing = easing), element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: Array.isArray(easing) ? "linear" : easing,
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal",
    pseudoElement
  });
}
function attachTimeline(animation, timeline) {
  animation.timeline = timeline, animation.onfinish = null;
}
function isWaapiSupportedEasing(easing) {
  return !!(typeof easing == "function" && supportsLinearEasing() || !easing || typeof easing == "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const sampleDelta = 10, maxDuration = 2e4;
function requiresPregeneratedKeyframes(options) {
  return isGenerator(options.type) || options.type === "spring" || !isWaapiSupportedEasing(options.ease);
}
function pregenerateKeyframes(keyframes2, options) {
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes: keyframes2,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let state = { done: !1, value: keyframes2[0] };
  const pregeneratedKeyframes = [];
  let t2 = 0;
  for (; !state.done && t2 < maxDuration; )
    state = sampleAnimation.sample(t2), pregeneratedKeyframes.push(state.value), t2 += sampleDelta;
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t2 - sampleDelta,
    ease: "linear"
  };
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key2) {
  return key2 in unsupportedEasingFunctions;
}
class AcceleratedAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2, element), this.resolver.scheduleResolve();
  }
  initPlayback(keyframes2, finalKeyframe) {
    let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name, startTime } = this.options;
    if (!motionValue2.owner || !motionValue2.owner.current)
      return !1;
    if (typeof ease2 == "string" && supportsLinearEasing() && isUnsupportedEase(ease2) && (ease2 = unsupportedEasingFunctions[ease2]), requiresPregeneratedKeyframes(this.options)) {
      const { onComplete, onUpdate, motionValue: motionValue3, element, ...options } = this.options, pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);
      keyframes2 = pregeneratedAnimation.keyframes, keyframes2.length === 1 && (keyframes2[1] = keyframes2[0]), duration = pregeneratedAnimation.duration, times = pregeneratedAnimation.times, ease2 = pregeneratedAnimation.ease, type = "keyframes";
    }
    const animation = startWaapiAnimation(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });
    return animation.startTime = startTime ?? this.calcStartTime(), this.pendingTimeline ? (attachTimeline(animation, this.pendingTimeline), this.pendingTimeline = void 0) : animation.onfinish = () => {
      const { onComplete } = this.options;
      motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe)), onComplete && onComplete(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation,
      duration,
      times,
      type,
      ease: ease2,
      keyframes: keyframes2
    };
  }
  get duration() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { duration } = resolved;
    return /* @__PURE__ */ millisecondsToSeconds(duration);
  }
  get time() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { animation } = resolved;
    return /* @__PURE__ */ millisecondsToSeconds(animation.currentTime || 0);
  }
  set time(newTime) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  get speed() {
    const { resolved } = this;
    if (!resolved)
      return 1;
    const { animation } = resolved;
    return animation.playbackRate;
  }
  get finished() {
    return this.resolved.animation.finished;
  }
  set speed(newSpeed) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playbackRate = newSpeed;
  }
  get state() {
    const { resolved } = this;
    if (!resolved)
      return "idle";
    const { animation } = resolved;
    return animation.playState;
  }
  get startTime() {
    const { resolved } = this;
    if (!resolved)
      return null;
    const { animation } = resolved;
    return animation.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved)
      this.pendingTimeline = timeline;
    else {
      const { resolved } = this;
      if (!resolved)
        return noop$3;
      const { animation } = resolved;
      attachTimeline(animation, timeline);
    }
    return noop$3;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playState === "finished" && this.updateFinishedPromise(), animation.play();
  }
  pause() {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation, keyframes: keyframes2, duration, type, ease: ease2, times } = resolved;
    if (animation.playState === "idle" || animation.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options, sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes: keyframes2,
        duration,
        type,
        ease: ease2,
        times,
        isGenerator: !0
      }), sampleTime = /* @__PURE__ */ secondsToMilliseconds(this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    const { onStop } = this.options;
    onStop && onStop(), this.cancel();
  }
  complete() {
    const { resolved } = this;
    resolved && resolved.animation.finish();
  }
  cancel() {
    const { resolved } = this;
    resolved && resolved.animation.cancel();
  }
  static supports(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    if (!motionValue2 || !motionValue2.owner || !(motionValue2.owner.current instanceof HTMLElement))
      return !1;
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), keyframesTransition = {
  type: "keyframes",
  duration: 0.8
}, ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => keyframes2.length > 2 ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring : ease;
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function getValueTransition$1(transition, key2) {
  return transition?.[key2] ?? transition?.default ?? transition;
}
const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0);
class GroupAnimation {
  constructor(animations2) {
    this.stop = () => this.runAll("stop"), this.animations = animations2.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((animation) => animation.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i2 = 0; i2 < this.animations.length; i2++)
      this.animations[i2][propName] = newValue;
  }
  attachTimeline(timeline, fallback) {
    const subscriptions = this.animations.map((animation) => {
      if (supportsScrollTimeline() && animation.attachTimeline)
        return animation.attachTimeline(timeline);
      if (typeof fallback == "function")
        return fallback(animation);
    });
    return () => {
      subscriptions.forEach((cancel, i2) => {
        cancel && cancel(), this.animations[i2].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let max2 = 0;
    for (let i2 = 0; i2 < this.animations.length; i2++)
      max2 = Math.max(max2, this.animations[i2].duration);
    return max2;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class GroupAnimationWithThen extends GroupAnimation {
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition$1(transition, name) || {}, delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v) => {
      value.set(v), valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete(), valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  isTransitionDefined(valueTransition) || (options = {
    ...options,
    ...getDefaultTransition(name, options)
  }), options.duration && (options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration)), options.repeatDelay && (options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay)), options.from !== void 0 && (options.keyframes[0] = options.from);
  let shouldSkip = !1;
  if ((options.type === !1 || options.duration === 0 && !options.repeatDelay) && (options.duration = 0, options.delay === 0 && (shouldSkip = !0)), options.allowFlatten = !valueTransition.type && !valueTransition.ease, shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0)
      return frame$1.update(() => {
        options.onUpdate(finalKeyframe), options.onComplete();
      }), new GroupAnimationWithThen([]);
  }
  return !isHandoff && AcceleratedAnimation.supports(options) ? new AcceleratedAnimation(options) : new MainThreadAnimation(options);
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== !0;
  return needsAnimating[key2] = !1, shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  transitionOverride && (transition = transitionOverride);
  const animations2 = [], animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key2 in target) {
    const value = visualElement.getValue(key2, visualElement.latestValues[key2] ?? null), valueTarget = target[key2];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2))
      continue;
    const valueTransition = {
      delay: delay2,
      ...getValueTransition$1(transition || {}, key2)
    };
    let isHandoff = !1;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key2, frame$1);
        startTime !== null && (valueTransition.startTime = startTime, isHandoff = !0);
      }
    }
    addValueToWillChange(visualElement, key2), value.start(animateMotionValue(key2, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key2) ? { type: !1 } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    animation && animations2.push(animation);
  }
  return transitionEnd && Promise.all(animations2).then(() => {
    frame$1.update(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }), animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  options.transitionOverride && (transition = options.transitionOverride);
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve(), getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve(), { when } = transition;
  if (when) {
    const [first, last2] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last2());
  } else
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [], maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren, generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  return Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant), animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  }), Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition == "string")
    animation = animateVariant(visualElement, definition, options);
  else {
    const resolvedDefinition = typeof definition == "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return !1;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return !1;
  for (let i2 = 0; i2 < prevLength; i2++)
    if (prev[i2] !== next[i2])
      return !1;
  return !0;
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return;
  if (!visualElement.isControllingVariants) {
    const context3 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    return visualElement.props.initial !== void 0 && (context3.initial = visualElement.props.initial), context3;
  }
  const context2 = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2], prop = visualElement.props[name];
    (isVariantLabel(prop) || prop === !1) && (context2[name] = prop);
  }
  return context2;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement), state = createState(), isInitialRender = !0;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement, context2 = getVariantContext(visualElement.parent) || {}, animations2 = [], removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {}, removedVariantIndex = 1 / 0;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2], typeState = state[type], prop = props[type] !== void 0 ? props[type] : context2[type], propIsVariant = isVariantLabel(prop), activeDelta = type === changedActiveType ? typeState.isActive : null;
      activeDelta === !1 && (removedVariantIndex = i2);
      let isInherited = prop === context2[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1), typeState.protectedKeys = { ...encounteredKeys }, // If it isn't active and hasn't *just* been set as inactive
      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
      isAnimationControls(prop) || typeof prop == "boolean")
        continue;
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant, handledRemovedValues = !1;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      activeDelta === !1 && (resolvedValues = {});
      const { prevResolvedValues = {} } = typeState, allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      }, markToAnimate = (key2) => {
        shouldAnimateType = !0, removedKeys.has(key2) && (handledRemovedValues = !0, removedKeys.delete(key2)), typeState.needsAnimating[key2] = !0;
        const motionValue2 = visualElement.getValue(key2);
        motionValue2 && (motionValue2.liveStyle = !1);
      };
      for (const key2 in allKeys) {
        const next = resolvedValues[key2], prev = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        let valueHasChanged = !1;
        isKeyframesTarget(next) && isKeyframesTarget(prev) ? valueHasChanged = !shallowCompare(next, prev) : valueHasChanged = next !== prev, valueHasChanged ? next != null ? markToAnimate(key2) : removedKeys.add(key2) : next !== void 0 && removedKeys.has(key2) ? markToAnimate(key2) : typeState.protectedKeys[key2] = !0;
      }
      typeState.prevProp = prop, typeState.prevResolvedValues = resolvedValues, typeState.isActive && (encounteredKeys = { ...encounteredKeys, ...resolvedValues }), isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1), shouldAnimateType && (!(isInherited && variantDidChange) || handledRemovedValues) && animations2.push(...definitionList.map((animation) => ({
        animation,
        options: { type }
      })));
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial != "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        initialTransition && initialTransition.transition && (fallbackAnimation.transition = initialTransition.transition);
      }
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2), motionValue2 = visualElement.getValue(key2);
        motionValue2 && (motionValue2.liveStyle = !0), fallbackAnimation[key2] = fallbackTarget ?? null;
      }), animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = !!animations2.length;
    return isInitialRender && (props.initial === !1 || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount && (shouldAnimate = !1), isInitialRender = !1, shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    if (state[type].isActive === isActive)
      return Promise.resolve();
    visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive)), state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key2 in state)
      state[key2].protectedKeys = {};
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState(), isInitialRender = !0;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  return typeof next == "string" ? next !== prev : Array.isArray(next) ? !shallowCompare(next, prev) : !1;
}
function createTypeState(isActive = !1) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node2) {
    this.isMounted = !1, this.node = node2;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2), node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate: animate2 } = this.node.getProps();
    isAnimationControls(animate2) && (this.unmountControls = animate2.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: animate2 } = this.node.getProps(), { animate: prevAnimate } = this.node.prevProps || {};
    animate2 !== prevAnimate && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let id$2 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments), this.id = id$2++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext, { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent)
      return;
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    onExitComplete && !isPresent && exitAnimation.then(() => {
      onExitComplete(this.id);
    });
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    onExitComplete && onExitComplete(this.id), register && (this.unmount = register(this.id));
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
function addDomEvent(target, eventName, handler, options = { passive: !0 }) {
  return target.addEventListener(eventName, handler, options), () => target.removeEventListener(eventName, handler);
}
const isPrimaryPointer = (event) => event.pointerType === "mouse" ? typeof event.button != "number" || event.button <= 0 : event.isPrimary !== !1;
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top }), bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
const SCALE_PRECISION = 1e-4, SCALE_MIN = 1 - SCALE_PRECISION, SCALE_MAX = 1 + SCALE_PRECISION, TRANSLATE_PRECISION = 0.01, TRANSLATE_MIN = 0 - TRANSLATE_PRECISION, TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin, delta.originPoint = mixNumber$1(source.min, source.max, delta.origin), delta.scale = calcLength(target) / calcLength(source), delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint, (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) && (delta.scale = 1), (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) && (delta.translate = 0);
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0), calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min, target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x), calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min, target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x), calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values2) {
  return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY || values2.skewX || values2.skewY;
}
function has2DTranslate(values2) {
  return is2DTranslate(values2.x) || is2DTranslate(values2.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint, scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate2, scale2, originPoint, boxScale) {
  return boxScale !== void 0 && (point2 = scalePoint(point2, boxScale, originPoint)), scalePoint(point2, scale2, originPoint) + translate2;
}
function applyAxisDelta(axis, translate2 = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate2, scale2, originPoint, boxScale), axis.max = applyPointDelta(axis.max, translate2, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint), applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999, TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2, delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2], delta = node2.projectionDelta;
    const { visualElement } = node2.options;
    visualElement && visualElement.props.style && visualElement.props.style.display === "contents" || (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(box, {
      x: -node2.scroll.offset.x,
      y: -node2.scroll.offset.y
    }), delta && (treeScale.x *= delta.x.scale, treeScale.y *= delta.y.scale, applyBoxDelta(box, delta)), isSharedTransition && hasTransform(node2.latestValues) && transformBox(box, node2.latestValues));
  }
  treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN && (treeScale.x = 1), treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN && (treeScale.y = 1);
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2, axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform2) {
  transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX), transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint), { scroll } = rootProjectionNode2;
  return scroll && (translateAxis(viewportBox.x, scroll.offset.x), translateAxis(viewportBox.y, scroll.offset.y)), viewportBox;
}
const getContextWindow = ({ current }) => current ? current.ownerDocument.defaultView : null, distance$1 = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance$1(a2.x, b2.x), yDelta = distance$1(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = this.startEvent !== null, isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2, { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      isPanStarted || (onStart && onStart(this.lastMoveEvent, info2), this.startEvent = this.lastMoveEvent), onMove && onMove(this.lastMoveEvent, info2);
    }, this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2, this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint), frame$1.update(this.updatePoint, !0);
    }, this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin && resumeAnimation && resumeAnimation(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      this.startEvent && onEnd && onEnd(event2, panInfo), onSessionEnd && onSessionEnd(event2, panInfo);
    }, !isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin, this.handlers = handlers, this.transformPagePoint = transformPagePoint, this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event), initialInfo = transformPoint(info, this.transformPagePoint), { point: point2 } = initialInfo, { timestamp } = frameData;
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point: point2 }, history) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history)),
    offset: subtractPoint(point2, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i2 = history.length - 1, timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  for (; i2 >= 0 && (timestampedPoint = history[i2], !(lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta))); )
    i2--;
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time2 = /* @__PURE__ */ millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  return currentVelocity.x === 1 / 0 && (currentVelocity.x = 0), currentVelocity.y === 1 / 0 && (currentVelocity.y = 0), currentVelocity;
}
function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
  return min2 !== void 0 && point2 < min2 ? point2 = elastic ? mixNumber$1(min2, point2, elastic.min) : Math.max(point2, min2) : max2 !== void 0 && point2 > max2 && (point2 = elastic ? mixNumber$1(max2, point2, elastic.max) : Math.min(point2, max2)), point2;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min, max2 = constraintsAxis.max - layoutAxis.max;
  return constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min2, max2] = [max2, min2]), { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source), targetLength = calcLength(target);
  return targetLength > sourceLength ? origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min) : sourceLength > targetLength && (origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min)), clamp$1(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  return constraints.min !== void 0 && (relativeConstraints.min = constraints.min - layout2.min), constraints.max !== void 0 && (relativeConstraints.max = constraints.max - layout2.min), relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  return dragElastic === !1 ? dragElastic = 0 : dragElastic === !0 && (dragElastic = defaultElastic), {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label2) {
  return typeof dragElastic == "number" ? dragElastic : dragElastic[label2] || 0;
}
const isDragging = {
  x: !1,
  y: !1
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function setDragLock(axis) {
  return axis === "x" || axis === "y" ? isDragging[axis] ? null : (isDragging[axis] = !0, () => {
    isDragging[axis] = !1;
  }) : isDragging.x || isDragging.y ? null : (isDragging.x = isDragging.y = !0, () => {
    isDragging.x = isDragging.y = !1;
  });
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = !1 } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === !1)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation(), snapToCursor && this.snapToCursor(extractEventInfo(event).point);
    }, onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation && (this.openDragLock && this.openDragLock(), this.openDragLock = setDragLock(drag2), !this.openDragLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            measuredAxis && (current = calcLength(measuredAxis) * (parseFloat(current) / 100));
          }
        }
        this.originPoint[axis] = current;
      }), onDragStart && frame$1.postRender(() => onDragStart(event, info)), addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", !0);
    }, onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2), this.currentDirection !== null && onDirectionLock && onDirectionLock(this.currentDirection);
        return;
      }
      this.updateAxis("x", info.point, offset2), this.updateAxis("y", info.point, offset2), this.visualElement.render(), onDrag && onDrag(event, info);
    }, onSessionEnd = (event, info) => this.stop(event, info), resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play()), { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging2 = this.isDragging;
    if (this.cancel(), !isDragging2)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd && frame$1.postRender(() => onDragEnd(event, info));
  }
  cancel() {
    this.isDragging = !1;
    const { projection, animationState } = this.visualElement;
    projection && (projection.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    !dragPropagation && this.openDragLock && (this.openDragLock(), this.openDragLock = null), animationState && animationState.setActive("whileDrag", !1);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    this.constraints && this.constraints[axis] && (next = applyConstraints(next, this.constraints[axis], this.elastic[axis])), axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps(), layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, prevConstraints = this.constraints;
    dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : dragConstraints && layout2 ? this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints) : this.constraints = !1, this.elastic = resolveDragElastic(dragElastic), prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints && eachAxis((axis) => {
      this.constraints !== !1 && this.getAxisMotionValue(axis) && (this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return !1;
    const constraintsElement = constraints.current, { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return !1;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints, userConstraints && (measuredConstraints = convertBoundingBoxToBox(userConstraints));
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      let transition = constraints && constraints[axis] || {};
      dragSnapToOrigin && (transition = { min: 0, max: 0 });
      const bounceStiffness = dragElastic ? 200 : 1e6, bounceDamping = dragElastic ? 40 : 1e7, inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return addValueToWillChange(this.visualElement, axis), axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, !1));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
  }
  getAnimationState(axis) {
    return this.getAxisMotionValue(axis).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`, props = this.visualElement.getProps(), externalMotionValue = props[dragKey];
    return externalMotionValue || this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement, axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps(), { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== !1) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none", projection.root && projection.root.updateScroll(), projection.updateLayout(), this.resolveConstraints(), eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis), { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current, stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = !0 } = this.getProps();
      drag2 && dragListener && this.start(event);
    }), measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      isRefObject(dragConstraints) && dragConstraints.current && (this.constraints = this.resolveRefConstraints());
    }, { projection } = this.visualElement, stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout()), frame$1.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      this.isDragging && hasLayoutChanged && (eachAxis((axis) => {
        const motionValue2 = this.getAxisMotionValue(axis);
        motionValue2 && (this.originPoint[axis] += delta[axis].translate, motionValue2.set(motionValue2.get() + delta[axis].translate));
      }), this.visualElement.render());
    });
    return () => {
      stopResizeListener(), stopPointerListener(), stopMeasureLayoutListener(), stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps(), { drag: drag2 = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = defaultElastic, dragMomentum = !0 } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === !0 || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  return Math.abs(offset2.y) > lockThreshold ? direction = "y" : Math.abs(offset2.x) > lockThreshold && (direction = "x"), direction;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2), this.removeGroupControls = noop$3, this.removeListeners = noop$3, this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop$3;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  handler && frame$1.postRender(() => handler(event, info));
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments), this.removePointerDownListener = noop$3;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session, onPanEnd && frame$1.postRender(() => onPanEnd(event, info));
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function pixelsToPercent(pixels, axis) {
  return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest == "string")
      if (px.test(latest))
        latest = parseFloat(latest);
      else
        return latest;
    const x2 = pixelsToPercent(latest, node2.target.x), y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
}, correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest, shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest), offset2 = typeof shadow[0] != "number" ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x, yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale, shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    return typeof shadow[2 + offset2] == "number" && (shadow[2 + offset2] /= averageScale), typeof shadow[3 + offset2] == "number" && (shadow[3 + offset2] /= averageScale), template(shadow);
  }
};
class MeasureLayoutWithContext extends Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props, { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors), projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), projection.root.didUpdate(), projection.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), projection.setOptions({
      ...projection.options,
      onExitComplete: () => this.safeToRemove()
    })), globalProjectionState.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props, projection = visualElement.projection;
    return projection && (projection.isPresent = isPresent, drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent ? projection.willUpdate() : this.safeToRemove(), prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || frame$1.postRender(() => {
      const stack = projection.getStack();
      (!stack || !stack.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    projection && (projection.root.didUpdate(), microtask.postRender(() => {
      !projection.currentAnimation && projection.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props, { projection } = visualElement;
    projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence(), layoutGroup = useContext(LayoutGroupContext);
  return jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  return motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options)), motionValue$1.animation;
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(child) {
    addUniqueItem(this.children, child), this.isDirty = !0;
  }
  remove(child) {
    removeItem(this.children, child), this.isDirty = !0;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(callback);
  }
}
function delay(callback, timeout2) {
  const start2 = time.now(), checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start2;
    elapsed >= timeout2 && (cancelFrame(checkElapsed), callback(elapsed - timeout2));
  };
  return frame$1.read(checkElapsed, !0), () => cancelFrame(checkElapsed);
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = (value) => typeof value == "string" ? parseFloat(value) : value, isPx = (value) => typeof value == "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  shouldCrossfadeOpacity ? (target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2)), target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2))) : isOnlyMember && (target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2));
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel), leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0), leadRadius || (leadRadius = 0), followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius) ? (target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0), (percent.test(leadRadius) || percent.test(followRadius)) && (target[borderLabel] += "%")) : target[borderLabel] = leadRadius;
  }
  (follow.rotate || lead.rotate) && (target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2));
}
function getRadius(values2, radiusName) {
  return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut), easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$3);
function compress(min2, max2, easing) {
  return (p2) => p2 < min2 ? 0 : p2 > max2 ? 1 : easing(/* @__PURE__ */ progress(min2, max2, p2));
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min, axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x), copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate, delta.scale = originDelta.scale, delta.originPoint = originDelta.originPoint, delta.origin = originDelta.origin;
}
function removePointDelta(point2, translate2, scale2, originPoint, boxScale) {
  return point2 -= translate2, point2 = scalePoint(point2, 1 / scale2, originPoint), boxScale !== void 0 && (point2 = scalePoint(point2, 1 / boxScale, originPoint)), point2;
}
function removeAxisDelta(axis, translate2 = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate2) && (translate2 = parseFloat(translate2), translate2 = mixNumber$1(sourceAxis.min, sourceAxis.max, translate2 / 100) - sourceAxis.min), typeof translate2 != "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  axis === originAxis && (originPoint -= translate2), axis.min = removePointDelta(axis.min, translate2, scale2, originPoint, boxScale), axis.max = removePointDelta(axis.max, translate2, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key2, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key2], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0), removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
function boxEquals(a2, b2) {
  return axisEquals(a2.x, b2.x) && axisEquals(a2.y, b2.y);
}
function axisEqualsRounded(a2, b2) {
  return Math.round(a2.min) === Math.round(b2.min) && Math.round(a2.max) === Math.round(b2.max);
}
function boxEqualsRounded(a2, b2) {
  return axisEqualsRounded(a2.x, b2.x) && axisEqualsRounded(a2.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a2, b2) {
  return a2.translate === b2.translate && a2.scale === b2.scale && a2.originPoint === b2.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2), node2.scheduleRender();
  }
  remove(node2) {
    if (removeItem(this.members, node2), node2 === this.prevLead && (this.prevLead = void 0), node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      prevLead && this.promote(prevLead);
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return !1;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== !1) {
        prevLead = member;
        break;
      }
    }
    return prevLead ? (this.promote(prevLead), !0) : !1;
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 !== prevLead && (this.prevLead = prevLead, this.lead = node2, node2.show(), prevLead)) {
      prevLead.instance && prevLead.scheduleRender(), node2.scheduleRender(), node2.resumeFrom = prevLead, preserveFollowOpacity && (node2.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node2.snapshot = prevLead.snapshot, node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node2.root && node2.root.isUpdating && (node2.isLayoutDirty = !0);
      const { crossfade } = node2.options;
      crossfade === !1 && prevLead.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete(), resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x, yTranslate = delta.y.translate / treeScale.y, zTranslate = latestTransform?.z || 0;
  if ((xTranslate || yTranslate || zTranslate) && (transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `), (treeScale.x !== 1 || treeScale.y !== 1) && (transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `), latestTransform) {
    const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
    transformPerspective && (transform2 = `perspective(${transformPerspective}px) ${transform2}`), rotate2 && (transform2 += `rotate(${rotate2}deg) `), rotateX && (transform2 += `rotateX(${rotateX}deg) `), rotateY && (transform2 += `rotateY(${rotateY}deg) `), skewX && (transform2 += `skewX(${skewX}deg) `), skewY && (transform2 += `skewY(${skewY}deg) `);
  }
  const elementScaleX = delta.x.scale * treeScale.x, elementScaleY = delta.y.scale * treeScale.y;
  return (elementScaleX !== 1 || elementScaleY !== 1) && (transform2 += `scale(${elementScaleX}, ${elementScaleY})`), transform2 || "none";
}
const transformAxes = ["", "X", "Y", "Z"], hiddenVisibility = { visibility: "hidden" }, animationTarget = 1e3;
let id$1 = 0;
function resetDistortingTransform(key2, visualElement, values2, sharedAnimationValues) {
  const { latestValues } = visualElement;
  latestValues[key2] && (values2[key2] = latestValues[key2], visualElement.setStaticValue(key2, 0), sharedAnimationValues && (sharedAnimationValues[key2] = 0));
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  if (projectionNode.hasCheckedOptimisedAppear = !0, projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame$1, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  parent && !parent.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(parent);
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class {
    constructor(latestValues = {}, parent = defaultParent?.()) {
      this.id = id$1++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = latestValues, this.root = parent ? parent.root || parent : this, this.path = parent ? [...parent.path, parent] : [], this.parent = parent, this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++)
        this.path[i2].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(name, handler) {
      return this.eventHandlers.has(name) || this.eventHandlers.set(name, new SubscriptionManager()), this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance), this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current && visualElement.mount(instance), this.root.nodes.add(this), this.parent && this.parent.children.add(this), isLayoutDirty && (layout2 || layoutId) && (this.isLayoutDirty = !0), attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = !0, cancelDelay && cancelDelay(), cancelDelay = delay(resizeUnblockUpdate, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation));
        });
      }
      layoutId && this.root.registerSharedNode(layoutId, this), this.options.animate !== !1 && visualElement && (layoutId || layout2) && this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps(), hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout), hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
        if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          const animationOptions = {
            ...getValueTransition$1(layoutTransition, "layout"),
            onPlay: onLayoutAnimationStart,
            onComplete: onLayoutAnimationComplete
          };
          (visualElement.shouldReduceMotion || this.options.layoutRoot) && (animationOptions.delay = 0, animationOptions.type = !1), this.startAnimation(animationOptions);
        } else
          hasLayoutChanged || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = newLayout;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        node2.shouldResetTransform = !0, node2.updateScroll("snapshot"), node2.options.layoutRoot && node2.willUpdate(!1);
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        return;
      }
      this.isUpdating || this.nodes.forEach(clearIsLayoutDirty), this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp$1(0, 1e3 / 60, now2 - frameData.timestamp), frameData.timestamp = now2, frameData.isProcessing = !0, frameSteps.update.process(frameData), frameSteps.preRender.process(frameData), frameSteps.render.process(frameData), frameData.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame$1.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame$1.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let i2 = 0; i2 < this.path.length; i2++)
          this.path[i2].updateScroll();
      const prevLayout = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1), needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta), transformTemplate = this.getTransformTemplate(), transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplateValue), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(removeTransform = !0) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      return removeTransform && (layoutBox = this.removeTransform(layoutBox)), roundBox(layoutBox), {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot))) {
        const { scroll } = this.root;
        scroll && (translateAxis(box.x, scroll.offset.x), translateAxis(box.y, scroll.offset.y));
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      if (copyBoxInto(boxWithoutScroll, box), this.scroll?.wasRoot)
        return boxWithoutScroll;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2], { scroll, options } = node2;
        node2 !== this.root && scroll && options.layoutScroll && (scroll.wasRoot && copyBoxInto(boxWithoutScroll, box), translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y));
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = !1) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        !transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(withTransforms, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        }), hasTransform(node2.latestValues) && transformBox(withTransforms, node2.latestValues);
      }
      return hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues), withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!node2.instance || !hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox(), nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox), removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      return hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues), boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(forceRecalculation = !1) {
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = !!this.resumingFrom || this !== lead;
      if (!(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!(!this.layout || !(layout2 || layoutId))) {
        if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          relativeParent && relativeParent.layout && this.animationProgress !== 1 ? (this.relativeParent = relativeParent, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const relativeParent = this.getClosestProjectingParent();
          relativeParent && !!relativeParent.resumingFrom == !!this.resumingFrom && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1 ? (this.relativeParent = relativeParent, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      const lead = this.getLead(), isShared = !!this.resumingFrom || this !== lead;
      let canSkip = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (canSkip = !1), isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1), canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x, prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared), lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (lead.target = lead.layout.layoutBox, lead.targetWithTransforms = createBox());
      const { target } = lead;
      if (!target) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues), (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", target));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(notifyAll = !0) {
      if (this.options.visualElement?.scheduleRender(), notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = !1) {
      const snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = { ...this.latestValues }, targetDelta = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox(), snapshotSource = snapshot ? snapshot.source : void 0, layoutSource = this.layout ? this.layout.source : void 0, isSharedLayoutAnimation = snapshotSource !== layoutSource, stack = this.getStack(), isOnlyMember = !stack || stack.members.length <= 1, shouldCrossfadeOpacity = !!(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2), mixAxisDelta(targetDelta.y, delta.y, progress2), this.setTargetDelta(targetDelta), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2), prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget) && (this.isProjectionDirty = !1), prevRelativeTarget || (prevRelativeTarget = createBox()), copyBoxInto(prevRelativeTarget, this.relativeTarget)), isSharedLayoutAnimation && (this.animationValues = mixedValues, mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = progress2;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame$1.update(() => {
        globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest), options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {
          },
          onComplete: () => {
            options.onComplete && options.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const stack = this.getStack();
      stack && stack.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!(!targetWithTransforms || !target || !layout2)) {
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min, target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min, target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target), transformBox(targetWithTransforms, latestValues), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
    }
    registerSharedNode(layoutId, node2) {
      this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack()), this.sharedNodes.get(layoutId).add(node2);
      const config = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : !0;
    }
    getLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      stack && stack.promote(this, preserveFollowOpacity), needsReset && (this.projectionDelta = void 0, this.needsReset = !0), transition && this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      return stack ? stack.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = !1;
      const { latestValues } = visualElement;
      if ((latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) && (hasDistortingTransform = !0), !hasDistortingTransform)
        return;
      const resetValues = {};
      latestValues.z && resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      for (let i2 = 0; i2 < transformAxes.length; i2++)
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues), resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      visualElement.render();
      for (const key2 in resetValues)
        visualElement.setStaticValue(key2, resetValues[key2]), this.animationValues && (this.animationValues[key2] = resetValues[key2]);
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return hiddenVisibility;
      const styles = {
        visibility: ""
      }, transformTemplate = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, styles.opacity = "", styles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "", styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none", styles;
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        return this.options.layoutId && (emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, emptyStyles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none", this.hasProjected = !1), emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget(), styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender), transformTemplate && (styles.transform = transformTemplate(valuesToRender, styles.transform));
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`, lead.animationValues ? styles.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key2], corrected = styles.transform === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++)
            styles[applyTo[i2]] = corrected;
        } else
          isCSSVariable ? this.options.visualElement.renderState.vars[key2] = corrected : styles[key2] = corrected;
      }
      return this.options.layoutId && (styles.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none"), styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => node2.currentAnimation?.stop()), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  const snapshot = node2.resumeFrom?.snapshot || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout, { animationType } = node2.options, isShared = snapshot.source !== node2.layout.source;
    animationType === "size" ? eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(axisSnapshot);
      axisSnapshot.min = layout2[axis].min, axisSnapshot.max = axisSnapshot.min + length;
    }) : shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2) && eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(layout2[axis]);
      axisSnapshot.max = axisSnapshot.min + length, node2.relativeTarget && !node2.currentAnimation && (node2.isProjectionDirty = !0, node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length);
    });
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    isShared ? calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = !1;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox), boxEqualsRounded(relativeSnapshot, relativeLayout) || (hasRelativeLayoutChanged = !0), relativeParent.options.layoutRoot && (node2.relativeTarget = relativeLayout, node2.relativeTargetOrigin = relativeSnapshot, node2.relativeParent = relativeParent);
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  node2.parent && (node2.isProjecting() || (node2.isProjectionDirty = node2.parent.isProjectionDirty), node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = !!(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty)), node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty));
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = !1;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = !1;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify("BeforeLayoutMeasure"), node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation(), node2.targetDelta = node2.relativeTarget = node2.target = void 0, node2.isProjectionDirty = !0;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetSkewAndRotation(node2) {
  node2.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2), output.scale = mixNumber$1(delta.scale, 1, p2), output.origin = delta.origin, output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p2) {
  output.min = mixNumber$1(from.min, to.min, p2), output.max = mixNumber$1(from.max, to.max, p2);
}
function mixBox(output, from, to, p2) {
  mixAxis(output.x, from.x, to.x, p2), mixAxis(output.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, userAgentContains = (string) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$3;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min), axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x), roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node2) {
  return node2 !== node2.root && node2.scroll?.wasRoot;
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), rootProjectionNode = {
  current: void 0
}, HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window), documentNode.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => window.getComputedStyle(instance).position === "fixed"
}), drag$1 = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector instanceof EventTarget)
    return [elementOrSelector];
  if (typeof elementOrSelector == "string") {
    let root2 = document;
    const elements = selectorCache?.[elementOrSelector] ?? root2.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector), gestureAbortController = new AbortController(), eventOptions = {
    passive: !0,
    ...options,
    signal: gestureAbortController.signal
  };
  return [elements, eventOptions, () => gestureAbortController.abort()];
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options), onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent, onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd != "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      isValidHover(leaveEvent) && (onHoverEnd(leaveEvent), target.removeEventListener("pointerleave", onPointerLeave));
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  return elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  }), cancel;
}
function handleHoverEvent(node2, event, lifecycle) {
  const { props } = node2;
  node2.animationState && props.whileHover && node2.animationState.setActive("whileHover", lifecycle === "Start");
  const eventName = "onHover" + lifecycle, callback = props[eventName];
  callback && frame$1.postRender(() => callback(event, extractEventInfo(event)));
}
class HoverGesture extends Feature {
  mount() {
    const { current } = this.node;
    current && (this.unmount = hover(current, (_element, startEvent) => (handleHoverEvent(this.node, startEvent, "Start"), (endEvent) => handleHoverEvent(this.node, endEvent, "End"))));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let isFocusVisible = !1;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch {
      isFocusVisible = !0;
    }
    !isFocusVisible || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => child ? parent === child ? !0 : isNodeOrChild(parent, child.parentElement) : !1, focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    event.key === "Enter" && callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: !0, bubbles: !0 }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    }), handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions), element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions), element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options), startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent) || isPressing.has(target))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent), onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp), window.removeEventListener("pointercancel", onPointerCancel), !(!isValidPressEvent(endEvent) || !isPressing.has(target)) && (isPressing.delete(target), typeof onPressEnd == "function" && onPressEnd(endEvent, { success }));
    }, onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    }, onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, !1);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions), window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  return targets.forEach((target) => {
    (options.useGlobalTarget ? window : target).addEventListener("pointerdown", startPress, eventOptions), target instanceof HTMLElement && (target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions)), !isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex") && (target.tabIndex = 0));
  }), cancelEvents;
}
function handlePressEvent(node2, event, lifecycle) {
  const { props } = node2;
  if (node2.current instanceof HTMLButtonElement && node2.current.disabled)
    return;
  node2.animationState && props.whileTap && node2.animationState.setActive("whileTap", lifecycle === "Start");
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle), callback = props[eventName];
  callback && frame$1.postRender(() => callback(event, extractEventInfo(event)));
}
class PressGesture extends Feature {
  mount() {
    const { current } = this.node;
    current && (this.unmount = press(current, (_element, startEvent) => (handlePressEvent(this.node, startEvent, "Start"), (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap(), observers = /* @__PURE__ */ new WeakMap(), fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  observers.has(lookupRoot) || observers.set(lookupRoot, {});
  const rootObservers = observers.get(lookupRoot), key2 = JSON.stringify(options);
  return rootObservers[key2] || (rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options })), rootObservers[key2];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  return observerCallbacks.set(element, callback), rootInteresectionObserver.observe(element), () => {
    observerCallbacks.delete(element), rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps(), { root: root2, margin: rootMargin, amount = "some", once } = viewport, options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount == "number" ? amount : thresholdNames[amount]
    }, onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting || (this.isInView = isIntersecting, once && !isIntersecting && this.hasEnteredView))
        return;
      isIntersecting && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", isIntersecting);
      const { onViewportEnter, onViewportLeave } = this.node.getProps(), callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props, prevProps } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps)) && this.startObserver();
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
}, layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
}, prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (hasReducedMotionListener.current = !0, !!isBrowser$1)
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)"), setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addListener(setReducedMotionPreferences), setReducedMotionPreferences();
    } else
      prefersReducedMotion.current = !1;
}
const valueTypes = [...dimensionValueTypes, color$1, complex], findValueType = (v) => valueTypes.find(testValueType(v)), visualElementStore = /* @__PURE__ */ new WeakMap();
function updateMotionValuesFromProps(element, next, prev) {
  for (const key2 in next) {
    const nextValue = next[key2], prevValue = prev[key2];
    if (isMotionValue(nextValue))
      element.addValue(key2, nextValue);
    else if (isMotionValue(prevValue))
      element.addValue(key2, motionValue(nextValue, { owner: element }));
    else if (prevValue !== nextValue)
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        existingValue.liveStyle === !0 ? existingValue.jump(nextValue) : existingValue.hasAnimated || existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
  }
  for (const key2 in prev)
    next[key2] === void 0 && element.removeValue(key2);
  return next;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const now2 = time.now();
      this.renderScheduledAt < now2 && (this.renderScheduledAt = now2, frame$1.render(this.render, !1, !0));
    };
    const { latestValues, renderState, onUpdate } = visualState;
    this.onUpdate = onUpdate, this.latestValues = latestValues, this.baseTarget = { ...latestValues }, this.initialValues = props.initial ? { ...latestValues } : {}, this.renderState = renderState, this.parent = parent, this.props = props, this.presenceContext = presenceContext, this.depth = parent ? parent.depth + 1 : 0, this.reducedMotionConfig = reducedMotionConfig, this.options = options, this.blockInitialAnimation = !!blockInitialAnimation, this.isControllingVariants = isControllingVariants(props), this.isVariantNode = isVariantNode(props), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      latestValues[key2] !== void 0 && isMotionValue(value) && value.set(latestValues[key2], !1);
    }
  }
  mount(instance) {
    this.current = instance, visualElementStore.set(instance, this), this.projection && !this.projection.instance && this.projection.mount(instance), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((value, key2) => this.bindToMotionValue(key2, value)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach((remove2) => remove2()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const key2 in this.events)
      this.events[key2].clear();
    for (const key2 in this.features) {
      const feature = this.features[key2];
      feature && (feature.unmount(), feature.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(key2, value) {
    this.valueSubscriptions.has(key2) && this.valueSubscriptions.get(key2)();
    const valueIsTransform = transformProps.has(key2);
    valueIsTransform && this.onBindTransform && this.onBindTransform();
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue, this.props.onUpdate && frame$1.preRender(this.notifyUpdate), valueIsTransform && this.projection && (this.projection.isTransformDirty = !0);
    }), removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    window.MotionCheckAppearSync && (removeSyncCheck = window.MotionCheckAppearSync(this, key2, value)), this.valueSubscriptions.set(key2, () => {
      removeOnChange(), removeOnRenderRequest(), removeSyncCheck && removeSyncCheck(), value.owner && value.stop();
    });
  }
  sortNodePosition(other) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== other.type ? 0 : this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key2 = "animation";
    for (key2 in featureDefinitions) {
      const featureDefinition = featureDefinitions[key2];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key2] && FeatureConstructor && isEnabled(this.props) && (this.features[key2] = new FeatureConstructor(this)), this.features[key2]) {
        const feature = this.features[key2];
        feature.isMounted ? feature.update() : (feature.mount(), feature.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    (props.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = props, this.prevPresenceContext = this.presenceContext, this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key2 = propEventHandlers[i2];
      this.propEventSubscriptions[key2] && (this.propEventSubscriptions[key2](), delete this.propEventSubscriptions[key2]);
      const listenerName = "on" + key2, listener = props[listenerName];
      listener && (this.propEventSubscriptions[key2] = this.on(key2, listener));
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode)
      return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    const existingValue = this.values.get(key2);
    value !== existingValue && (existingValue && this.removeValue(key2), this.bindToMotionValue(key2, value), this.values.set(key2, value), this.latestValues[key2] = value.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    this.values.delete(key2);
    const unsubscribe = this.valueSubscriptions.get(key2);
    unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key2)), delete this.latestValues[key2], this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2])
      return this.props.values[key2];
    let value = this.values.get(key2);
    return value === void 0 && defaultValue !== void 0 && (value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this }), this.addValue(key2, value)), value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2, target) {
    let value = this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : this.getBaseTargetFromProps(this.props, key2) ?? this.readValueFromInstance(this.current, key2, this.options);
    return value != null && (typeof value == "string" && (isNumericalString(value) || isZeroValueString(value)) ? value = parseFloat(value) : !findValueType(value) && complex.test(target) && (value = getAnimatableNone(key2, target)), this.setBaseTarget(key2, isMotionValue(value) ? value.get() : value)), isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial == "string" || typeof initial == "object") {
      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
      variant && (valueFromInitial = variant[key2]);
    }
    if (initial && valueFromInitial !== void 0)
      return valueFromInitial;
    const target = this.getBaseTargetFromProps(this.props, key2);
    return target !== void 0 && !isMotionValue(target) ? target : this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    return this.events[eventName] || (this.events[eventName] = new SubscriptionManager()), this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    this.events[eventName] && this.events[eventName].notify(...args);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    return props.style ? props.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars, style: style2 }) {
    delete vars[key2], delete style2[key2];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: children2 } = this.props;
    isMotionValue(children2) && (this.childSubscription = children2.on("change", (latest) => {
      this.current && (this.current.textContent = `${latest}`);
    }));
  }
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2))
      return readTransformValue(instance, key2);
    {
      const computedStyle = getComputedStyle$1(instance), value = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value == "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox, this.updateDimensions = () => {
      this.current && !this.renderState.dimensions && updateSVGDimensions(this.current, this.renderState);
    };
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType && defaultType.default || 0;
    }
    return key2 = camelCaseAttributes.has(key2) ? key2 : camelToDash(key2), instance.getAttribute(key2);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  onBindTransform() {
    this.current && !this.renderState.dimensions && frame$1.postRender(this.updateDimensions);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName), super.mount(instance);
  }
}
const createDomVisualElement = (Component2, options) => isSVGComponent(Component2) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
  allowProjection: Component2 !== Fragment
}), domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
}, domMax = {
  ...domAnimation,
  ...drag$1,
  ...layout
};
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial)), { isStatic } = useContext(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = useState(initial);
    useEffect(() => value.on("change", setLatest), []);
  }
  return value;
}
function useReducedMotion() {
  !hasReducedMotionListener.current && initPrefersReducedMotion();
  const [shouldReduceMotion] = useState(prefersReducedMotion.current);
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  const reducedMotionPreference = useReducedMotion(), { reducedMotion } = useContext(MotionConfigContext);
  return reducedMotion === "never" ? !1 : reducedMotion === "always" ? !0 : reducedMotionPreference;
}
const wrap = (min2, max2, v) => {
  const rangeSize = max2 - min2;
  return ((v - min2) % rangeSize + rangeSize) % rangeSize + min2;
};
function getEasingForSegment(easing, i2) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i2)] : easing;
}
function isDOMKeyframes(keyframes2) {
  return typeof keyframes2 == "object" && !Array.isArray(keyframes2);
}
function resolveSubjects(subject, keyframes2, scope, selectorCache) {
  return typeof subject == "string" && isDOMKeyframes(keyframes2) ? resolveElements(subject, scope, selectorCache) : subject instanceof NodeList ? Array.from(subject) : Array.isArray(subject) ? subject : [subject];
}
function calculateRepeatDuration(duration, repeat, _repeatDelay) {
  return duration * (repeat + 1);
}
function calcNextTime(current, next, prev, labels) {
  return typeof next == "number" ? next : next.startsWith("-") || next.startsWith("+") ? Math.max(0, current + parseFloat(next)) : next === "<" ? prev : labels.get(next) ?? current;
}
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const keyframe = sequence[i2];
    keyframe.at > startTime && keyframe.at < endTime && (removeItem(sequence, keyframe), i2--);
  }
}
function addKeyframes(sequence, keyframes2, easing, offset2, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    sequence.push({
      value: keyframes2[i2],
      at: mixNumber$1(startTime, endTime, offset2[i2]),
      easing: getEasingForSegment(easing, i2)
    });
}
function normalizeTimes(times, repeat) {
  for (let i2 = 0; i2 < times.length; i2++)
    times[i2] = times[i2] / (repeat + 1);
}
function compareByTime(a2, b2) {
  return a2.at === b2.at ? a2.value === null ? 1 : b2.value === null ? -1 : 0 : a2.at - b2.at;
}
const defaultSegmentEasing = "easeInOut";
function createAnimationsFromSequence(sequence, { defaultTransition: defaultTransition2 = {}, ...sequenceTransition } = {}, scope, generators2) {
  const defaultDuration = defaultTransition2.duration || 0.3, animationDefinitions = /* @__PURE__ */ new Map(), sequences = /* @__PURE__ */ new Map(), elementCache = {}, timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0, currentTime = 0, totalDuration = 0;
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const segment = sequence[i2];
    if (typeof segment == "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes2, transition = {}] = segment;
    transition.at !== void 0 && (currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels));
    let maxDuration2 = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes), { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition2.ease || "easeOut", duration } = valueTransition;
      const calculatedDelay = typeof delay2 == "function" ? delay2(elementIndex, numSubjects) : delay2, numKeyframes = valueKeyframesAsList.length, createGenerator = isGenerator(type) ? type : generators2?.[type];
      if (numKeyframes <= 2 && createGenerator) {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = { ...remainingTransition };
        duration !== void 0 && (springTransition.duration = /* @__PURE__ */ secondsToMilliseconds(duration));
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
        ease2 = springEasing.ease, duration = springEasing.duration;
      }
      duration ?? (duration = defaultDuration);
      const startTime = currentTime + calculatedDelay;
      times.length === 1 && times[0] === 0 && (times[1] = 1);
      const remainder = times.length - valueKeyframesAsList.length;
      if (remainder > 0 && fillOffset(times, remainder), valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null), repeat) {
        duration = calculateRepeatDuration(duration, repeat);
        const originalKeyframes = [...valueKeyframesAsList], originalTimes = [...times];
        ease2 = Array.isArray(ease2) ? [...ease2] : [ease2];
        const originalEase = [...ease2];
        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
          valueKeyframesAsList.push(...originalKeyframes);
          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++)
            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1)), ease2.push(keyframeIndex === 0 ? "linear" : getEasingForSegment(originalEase, keyframeIndex - 1));
        }
        normalizeTimes(times, repeat);
      }
      const targetTime = startTime + duration;
      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime), maxDuration2 = Math.max(calculatedDelay + duration, maxDuration2), totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
    } else {
      const subjects = resolveSubjects(subject, keyframes2, scope, elementCache), numSubjects = subjects.length;
      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
        keyframes2 = keyframes2, transition = transition;
        const thisSubject = subjects[subjectIndex], subjectSequence = getSubjectSequence(thisSubject, sequences);
        for (const key2 in keyframes2)
          resolveValueSequence(keyframes2[key2], getValueTransition(transition, key2), getValueSequence(key2, subjectSequence), subjectIndex, numSubjects);
      }
    }
    prevTime = currentTime, currentTime += maxDuration2;
  }
  return sequences.forEach((valueSequences, element) => {
    for (const key2 in valueSequences) {
      const valueSequence = valueSequences[key2];
      valueSequence.sort(compareByTime);
      const keyframes2 = [], valueOffset = [], valueEasing = [];
      for (let i2 = 0; i2 < valueSequence.length; i2++) {
        const { at, value, easing } = valueSequence[i2];
        keyframes2.push(value), valueOffset.push(/* @__PURE__ */ progress(0, totalDuration, at)), valueEasing.push(easing || "easeOut");
      }
      valueOffset[0] !== 0 && (valueOffset.unshift(0), keyframes2.unshift(keyframes2[0]), valueEasing.unshift(defaultSegmentEasing)), valueOffset[valueOffset.length - 1] !== 1 && (valueOffset.push(1), keyframes2.push(null)), animationDefinitions.has(element) || animationDefinitions.set(element, {
        keyframes: {},
        transition: {}
      });
      const definition = animationDefinitions.get(element);
      definition.keyframes[key2] = keyframes2, definition.transition[key2] = {
        ...defaultTransition2,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  }), animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  return !sequences.has(subject) && sequences.set(subject, {}), sequences.get(subject);
}
function getValueSequence(name, sequences) {
  return sequences[name] || (sequences[name] = []), sequences[name];
}
function keyframesAsList(keyframes2) {
  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
}
function getValueTransition(transition, key2) {
  return transition && transition[key2] ? {
    ...transition,
    ...transition[key2]
  } : { ...transition };
}
const isNumber = (keyframe) => typeof keyframe == "number", isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber);
function isObjectKey(key2, object) {
  return key2 in object;
}
class ObjectVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(instance, key2) {
    if (isObjectKey(key2, instance)) {
      const value = instance[key2];
      if (typeof value == "string" || typeof value == "number")
        return value;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(key2, renderState) {
    delete renderState.output[key2];
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  build(renderState, latestValues) {
    Object.assign(renderState.output, latestValues);
  }
  renderInstance(instance, { output }) {
    Object.assign(instance, output);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function createDOMVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, node2 = isSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node2.mount(element), visualElementStore.set(element, node2);
}
function createObjectVisualElement(subject) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, node2 = new ObjectVisualElement(options);
  node2.mount(subject), visualElementStore.set(subject, node2);
}
function isSingleValue(subject, keyframes2) {
  return isMotionValue(subject) || typeof subject == "number" || typeof subject == "string" && !isDOMKeyframes(keyframes2);
}
function animateSubject(subject, keyframes2, options, scope) {
  const animations2 = [];
  if (isSingleValue(subject, keyframes2))
    animations2.push(animateSingleValue(subject, isDOMKeyframes(keyframes2) && keyframes2.default || keyframes2, options && (options.default || options)));
  else {
    const subjects = resolveSubjects(subject, keyframes2, scope), numSubjects = subjects.length;
    for (let i2 = 0; i2 < numSubjects; i2++) {
      const thisSubject = subjects[i2], createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      visualElementStore.has(thisSubject) || createVisualElement(thisSubject);
      const visualElement = visualElementStore.get(thisSubject), transition = { ...options };
      "delay" in transition && typeof transition.delay == "function" && (transition.delay = transition.delay(i2, numSubjects)), animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
    }
  }
  return animations2;
}
function animateSequence(sequence, options, scope) {
  const animations2 = [];
  return createAnimationsFromSequence(sequence, options, scope, { spring }).forEach(({ keyframes: keyframes2, transition }, subject) => {
    animations2.push(...animateSubject(subject, keyframes2, transition));
  }), animations2;
}
function isSequence(value) {
  return Array.isArray(value) && value.some(Array.isArray);
}
function createScopedAnimate(scope) {
  function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
    let animations2 = [];
    return isSequence(subjectOrSequence) ? animations2 = animateSequence(subjectOrSequence, optionsOrKeyframes, scope) : animations2 = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope), new GroupAnimationWithThen(animations2);
  }
  return scopedAnimate;
}
const animate = createScopedAnimate();
class DragControls {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls) {
    return this.componentControls.add(controls), () => this.componentControls.delete(controls);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options) {
    this.componentControls.forEach((controls) => {
      controls.start(event.nativeEvent || event, options);
    });
  }
}
const createDragControls = () => new DragControls();
function useDragControls() {
  return useConstant(createDragControls);
}
const FramerMotionConfig = ({
  reducedMotion = "user",
  children: children2
}) => {
  const nonce = useMantineStyleNonce()?.();
  return /* @__PURE__ */ jsx(LazyMotion, { features: domMax, strict: !0, children: /* @__PURE__ */ jsx(MotionConfig, { reducedMotion, ...nonce && { nonce }, children: children2 }) });
};
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  outline: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  },
  filled: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "none"
  }
};
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createReactComponent = (type, iconName, iconNamePascal, iconNode) => {
  const Component2 = forwardRef(
    ({ color: color2 = "currentColor", size: size2 = 24, stroke = 2, title: title2, className, children: children2, ...rest }, ref) => createElement(
      "svg",
      {
        ref,
        ...defaultAttributes[type],
        width: size2,
        height: size2,
        className: ["tabler-icon", `tabler-icon-${iconName}`, className].join(" "),
        ...type === "filled" ? {
          fill: color2
        } : {
          strokeWidth: stroke,
          stroke: color2
        },
        ...rest
      },
      [
        title2 && createElement("title", { key: "svg-title" }, title2),
        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
        ...Array.isArray(children2) ? children2 : [children2]
      ]
    )
  );
  return Component2.displayName = `${iconNamePascal}`, Component2;
};
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconAlertTriangle = createReactComponent("outline", "alert-triangle", "IconAlertTriangle", [["path", { d: "M12 9v4", key: "svg-0" }], ["path", { d: "M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z", key: "svg-1" }], ["path", { d: "M12 16h.01", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconArrowDownRight = createReactComponent("outline", "arrow-down-right", "IconArrowDownRight", [["path", { d: "M7 7l10 10", key: "svg-0" }], ["path", { d: "M17 8l0 9l-9 0", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconArrowLeft = createReactComponent("outline", "arrow-left", "IconArrowLeft", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M5 12l6 6", key: "svg-1" }], ["path", { d: "M5 12l6 -6", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconArrowRight = createReactComponent("outline", "arrow-right", "IconArrowRight", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M13 18l6 -6", key: "svg-1" }], ["path", { d: "M13 6l6 6", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconBrowser = createReactComponent("outline", "browser", "IconBrowser", [["path", { d: "M4 8h16", key: "svg-0" }], ["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-1" }], ["path", { d: "M8 4v4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconCheck = createReactComponent("outline", "check", "IconCheck", [["path", { d: "M5 12l5 5l10 -10", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronDown = createReactComponent("outline", "chevron-down", "IconChevronDown", [["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronLeft = createReactComponent("outline", "chevron-left", "IconChevronLeft", [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconChevronRight = createReactComponent("outline", "chevron-right", "IconChevronRight", [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconCopy = createReactComponent("outline", "copy", "IconCopy", [["path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-0" }], ["path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconCylinder = createReactComponent("outline", "cylinder", "IconCylinder", [["path", { d: "M12 6m-7 0a7 3 0 1 0 14 0a7 3 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M5 6v12c0 1.657 3.134 3 7 3s7 -1.343 7 -3v-12", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconDeviceMobile = createReactComponent("outline", "device-mobile", "IconDeviceMobile", [["path", { d: "M6 5a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2v-14z", key: "svg-0" }], ["path", { d: "M11 4h2", key: "svg-1" }], ["path", { d: "M12 17v.01", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconExternalLink = createReactComponent("outline", "external-link", "IconExternalLink", [["path", { d: "M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6", key: "svg-0" }], ["path", { d: "M11 13l9 -9", key: "svg-1" }], ["path", { d: "M15 4h5v5", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFileCode = createReactComponent("outline", "file-code", "IconFileCode", [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M10 13l-1 2l1 2", key: "svg-2" }], ["path", { d: "M14 13l1 2l-1 2", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFileSymlink = createReactComponent("outline", "file-symlink", "IconFileSymlink", [["path", { d: "M4 21v-4a3 3 0 0 1 3 -3h5", key: "svg-0" }], ["path", { d: "M9 17l3 -3l-3 -3", key: "svg-1" }], ["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-2" }], ["path", { d: "M5 11v-6a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2h-9.5", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFocusCentered = createReactComponent("outline", "focus-centered", "IconFocusCentered", [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-1" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-2" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-3" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFolderOpen = createReactComponent("outline", "folder-open", "IconFolderOpen", [["path", { d: "M5 19l2.757 -7.351a1 1 0 0 1 .936 -.649h12.307a1 1 0 0 1 .986 1.164l-.996 5.211a2 2 0 0 1 -1.964 1.625h-14.026a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2h4l3 3h7a2 2 0 0 1 2 2v2", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconHelpCircle = createReactComponent("outline", "help-circle", "IconHelpCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 16v.01", key: "svg-1" }], ["path", { d: "M12 13a2 2 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconId = createReactComponent("outline", "id", "IconId", [["path", { d: "M3 4m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v10a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3z", key: "svg-0" }], ["path", { d: "M9 10m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M15 8l2 0", key: "svg-2" }], ["path", { d: "M15 12l2 0", key: "svg-3" }], ["path", { d: "M7 16l10 0", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconInfoCircle = createReactComponent("outline", "info-circle", "IconInfoCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 9h.01", key: "svg-1" }], ["path", { d: "M11 12h1v4h1", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignBottom = createReactComponent("outline", "layout-align-bottom", "IconLayoutAlignBottom", [["path", { d: "M4 20l16 0", key: "svg-0" }], ["path", { d: "M9 4m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignCenter = createReactComponent("outline", "layout-align-center", "IconLayoutAlignCenter", [["path", { d: "M12 4l0 5", key: "svg-0" }], ["path", { d: "M12 15l0 5", key: "svg-1" }], ["path", { d: "M6 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignLeft = createReactComponent("outline", "layout-align-left", "IconLayoutAlignLeft", [["path", { d: "M4 4l0 16", key: "svg-0" }], ["path", { d: "M8 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignMiddle = createReactComponent("outline", "layout-align-middle", "IconLayoutAlignMiddle", [["path", { d: "M4 12l5 0", key: "svg-0" }], ["path", { d: "M15 12l5 0", key: "svg-1" }], ["path", { d: "M9 6m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignRight = createReactComponent("outline", "layout-align-right", "IconLayoutAlignRight", [["path", { d: "M20 4l0 16", key: "svg-0" }], ["path", { d: "M4 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutAlignTop = createReactComponent("outline", "layout-align-top", "IconLayoutAlignTop", [["path", { d: "M4 4l16 0", key: "svg-0" }], ["path", { d: "M9 8m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutBoardSplit = createReactComponent("outline", "layout-board-split", "IconLayoutBoardSplit", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M4 12h8", key: "svg-1" }], ["path", { d: "M12 15h8", key: "svg-2" }], ["path", { d: "M12 9h8", key: "svg-3" }], ["path", { d: "M12 4v16", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutCollage = createReactComponent("outline", "layout-collage", "IconLayoutCollage", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M10 4l4 16", key: "svg-1" }], ["path", { d: "M12 12l-8 2", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLayoutDashboard = createReactComponent("outline", "layout-dashboard", "IconLayoutDashboard", [["path", { d: "M5 4h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-0" }], ["path", { d: "M5 16h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-1" }], ["path", { d: "M15 12h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-2" }], ["path", { d: "M15 4h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLockOpen2 = createReactComponent("outline", "lock-open-2", "IconLockOpen2", [["path", { d: "M3 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M9 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }], ["path", { d: "M13 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconLock = createReactComponent("outline", "lock", "IconLock", [["path", { d: "M5 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6z", key: "svg-0" }], ["path", { d: "M11 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }], ["path", { d: "M8 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconMenu2 = createReactComponent("outline", "menu-2", "IconMenu2", [["path", { d: "M4 6l16 0", key: "svg-0" }], ["path", { d: "M4 12l16 0", key: "svg-1" }], ["path", { d: "M4 18l16 0", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconMenu = createReactComponent("outline", "menu", "IconMenu", [["path", { d: "M4 8l16 0", key: "svg-0" }], ["path", { d: "M4 16l16 0", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconMoonStars = createReactComponent("outline", "moon-stars", "IconMoonStars", [["path", { d: "M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z", key: "svg-0" }], ["path", { d: "M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2", key: "svg-1" }], ["path", { d: "M19 11h2m-1 -1v2", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconRectangularPrism = createReactComponent("outline", "rectangular-prism", "IconRectangularPrism", [["path", { d: "M21 14.008v-5.018a1.98 1.98 0 0 0 -1 -1.717l-4 -2.008a2.016 2.016 0 0 0 -2 0l-10 5.008c-.619 .355 -1 1.01 -1 1.718v5.018c0 .709 .381 1.363 1 1.717l4 2.008a2.016 2.016 0 0 0 2 0l10 -5.008c.619 -.355 1 -1.01 1 -1.718z", key: "svg-0" }], ["path", { d: "M9 21v-7.5", key: "svg-1" }], ["path", { d: "M9 13.5l11.5 -5.5", key: "svg-2" }], ["path", { d: "M3.5 11l5.5 2.5", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconReorder = createReactComponent("outline", "reorder", "IconReorder", [["path", { d: "M3 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-0" }], ["path", { d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-1" }], ["path", { d: "M17 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-2" }], ["path", { d: "M5 11v-3a3 3 0 0 1 3 -3h8a3 3 0 0 1 3 3v3", key: "svg-3" }], ["path", { d: "M16.5 8.5l2.5 2.5l2.5 -2.5", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconRouteOff = createReactComponent("outline", "route-off", "IconRouteOff", [["path", { d: "M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-0" }], ["path", { d: "M18 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M12 19h4.5c.71 0 1.372 -.212 1.924 -.576m1.545 -2.459a3.5 3.5 0 0 0 -3.469 -3.965h-.499m-4 0h-3.501a3.5 3.5 0 0 1 -2.477 -5.972m2.477 -1.028h3.5", key: "svg-2" }], ["path", { d: "M3 3l18 18", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconSearch = createReactComponent("outline", "search", "IconSearch", [["path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M21 21l-6 -6", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconSelector = createReactComponent("outline", "selector", "IconSelector", [["path", { d: "M8 9l4 -4l4 4", key: "svg-0" }], ["path", { d: "M16 15l-4 4l-4 -4", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconShare = createReactComponent("outline", "share", "IconShare", [["path", { d: "M6 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-0" }], ["path", { d: "M18 6m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-1" }], ["path", { d: "M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-2" }], ["path", { d: "M8.7 10.7l6.6 -3.4", key: "svg-3" }], ["path", { d: "M8.7 13.3l6.6 3.4", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconStack2 = createReactComponent("outline", "stack-2", "IconStack2", [["path", { d: "M12 4l-8 4l8 4l8 -4l-8 -4", key: "svg-0" }], ["path", { d: "M4 12l8 4l8 -4", key: "svg-1" }], ["path", { d: "M4 16l8 4l8 -4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconSun = createReactComponent("outline", "sun", "IconSun", [["path", { d: "M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0", key: "svg-0" }], ["path", { d: "M3 12h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconTarget = createReactComponent("outline", "target", "IconTarget", [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M12 12m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0", key: "svg-1" }], ["path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconTransform = createReactComponent("outline", "transform", "IconTransform", [["path", { d: "M3 6a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-0" }], ["path", { d: "M21 11v-3a2 2 0 0 0 -2 -2h-6l3 3m0 -6l-3 3", key: "svg-1" }], ["path", { d: "M3 13v3a2 2 0 0 0 2 2h6l-3 -3m0 6l3 -3", key: "svg-2" }], ["path", { d: "M15 18a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconUser = createReactComponent("outline", "user", "IconUser", [["path", { d: "M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0", key: "svg-0" }], ["path", { d: "M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconX = createReactComponent("outline", "x", "IconX", [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconZoomScan = createReactComponent("outline", "zoom-scan", "IconZoomScan", [["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-0" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-1" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-2" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-3" }], ["path", { d: "M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-4" }], ["path", { d: "M16 16l-2.5 -2.5", key: "svg-5" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconFolderFilled = createReactComponent("filled", "folder-filled", "IconFolderFilled", [["path", { d: "M9 3a1 1 0 0 1 .608 .206l.1 .087l2.706 2.707h6.586a3 3 0 0 1 2.995 2.824l.005 .176v8a3 3 0 0 1 -2.824 2.995l-.176 .005h-14a3 3 0 0 1 -2.995 -2.824l-.005 -.176v-11a3 3 0 0 1 2.824 -2.995l.176 -.005h4z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconPlayerPlayFilled = createReactComponent("filled", "player-play-filled", "IconPlayerPlayFilled", [["path", { d: "M6 4v16a1 1 0 0 0 1.524 .852l13 -8a1 1 0 0 0 0 -1.704l-13 -8a1 1 0 0 0 -1.524 .852z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconPlayerSkipBackFilled = createReactComponent("filled", "player-skip-back-filled", "IconPlayerSkipBackFilled", [["path", { d: "M19.496 4.136l-12 7a1 1 0 0 0 0 1.728l12 7a1 1 0 0 0 1.504 -.864v-14a1 1 0 0 0 -1.504 -.864z", key: "svg-0" }], ["path", { d: "M4 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconPlayerSkipForwardFilled = createReactComponent("filled", "player-skip-forward-filled", "IconPlayerSkipForwardFilled", [["path", { d: "M3 5v14a1 1 0 0 0 1.504 .864l12 -7a1 1 0 0 0 0 -1.728l-12 -7a1 1 0 0 0 -1.504 .864z", key: "svg-0" }], ["path", { d: "M20 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconPlayerStopFilled = createReactComponent("filled", "player-stop-filled", "IconPlayerStopFilled", [["path", { d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.31.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var IconStarFilled = createReactComponent("filled", "star-filled", "IconStarFilled", [["path", { d: "M8.243 7.34l-6.38 .925l-.113 .023a1 1 0 0 0 -.44 1.684l4.622 4.499l-1.09 6.355l-.013 .11a1 1 0 0 0 1.464 .944l5.706 -3l5.693 3l.1 .046a1 1 0 0 0 1.352 -1.1l-1.091 -6.355l4.624 -4.5l.078 -.085a1 1 0 0 0 -.633 -1.62l-6.38 -.926l-2.852 -5.78a1 1 0 0 0 -1.794 0l-2.853 5.78z", key: "svg-0" }]]);
const IconRendererContext = createContext(null);
function IconRendererProvider({
  value,
  children: children2
}) {
  return useContext(IconRendererContext) ? /* @__PURE__ */ jsx(Fragment$1, { children: children2 }) : /* @__PURE__ */ jsx(IconRendererContext.Provider, { value, children: children2 });
}
function IconRenderer({
  element,
  className
}) {
  const RenderIcon = useContext(IconRendererContext);
  if (!element || !element.icon || element.icon === "none")
    return null;
  let icon2;
  return element.icon.startsWith("http://") || element.icon.startsWith("https://") ? icon2 = /* @__PURE__ */ jsx("img", { src: element.icon, alt: element.title }) : RenderIcon && (icon2 = /* @__PURE__ */ jsx(RenderIcon, { node: element })), icon2 ? /* @__PURE__ */ jsx(
    "div",
    {
      className: clsx(
        className,
        "likec4-element-icon"
      ),
      "data-likec4-icon": element.icon,
      children: icon2
    }
  ) : null;
}
const ShapeIcons = {
  browser: IconBrowser,
  cylinder: IconCylinder,
  mobile: IconDeviceMobile,
  person: IconUser,
  queue: IconReorder,
  rectangle: IconRectangularPrism,
  storage: IconCylinder
};
function IconOrShapeRenderer({
  element,
  className
}) {
  const icon2 = IconRenderer({
    element,
    className
  });
  if (icon2)
    return icon2;
  const ShapeIcon = ShapeIcons[element.shape];
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: clsx(
        className,
        "likec4-shape-icon"
      ),
      children: /* @__PURE__ */ jsx(ShapeIcon, {})
    }
  );
}
function cc(names) {
  if (typeof names == "string" || typeof names == "number") return "" + names;
  let out = "";
  if (Array.isArray(names))
    for (let i2 = 0, tmp; i2 < names.length; i2++)
      (tmp = cc(names[i2])) !== "" && (out += (out && " ") + tmp);
  else
    for (let k2 in names)
      names[k2] && (out += (out && " ") + k2);
  return out;
}
var noop$2 = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _ = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _ || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
    _[t2] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0 && (name = t2.slice(i2 + 1), t2 = t2.slice(0, i2)), t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T2 = parseTypenames$1(typename + "", _), t2, i2 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      for (; ++i2 < n2; ) if ((t2 = (typename = T2[i2]).type) && (t2 = get$1(_[t2], typename.name))) return t2;
      return;
    }
    if (callback != null && typeof callback != "function") throw new Error("invalid callback: " + callback);
    for (; ++i2 < n2; )
      if (t2 = (typename = T2[i2]).type) _[t2] = set$1(_[t2], typename.name, callback);
      else if (callback == null) for (t2 in _) _[t2] = set$1(_[t2], typename.name, null);
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t2 in _) copy[t2] = _[t2].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  }
};
function get$1(type, name) {
  for (var i2 = 0, n2 = type.length, c2; i2 < n2; ++i2)
    if ((c2 = type[i2]).name === name)
      return c2.value;
}
function set$1(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2)
    if (type[i2].name === name) {
      type[i2] = noop$2, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  return callback != null && type.push({ name, value: callback }), type;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix2 = name += "", i2 = prefix2.indexOf(":");
  return i2 >= 0 && (prefix2 = name.slice(0, i2)) !== "xmlns" && (name = name.slice(i2 + 1)), namespaces.hasOwnProperty(prefix2) ? { space: namespaces[prefix2], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector$p(selector3) {
  return selector3 == null ? none : function() {
    return this.querySelector(selector3);
  };
}
function selection_select(select2) {
  typeof select2 != "function" && (select2 = selector$p(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subnode = select2.call(node2, node2.__data__, i2, group)) && ("__data__" in node2 && (subnode.__data__ = node2.__data__), subgroup[i2] = subnode);
  return new Selection$1(subgroups, this._parents);
}
function array$1(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector3) {
  return selector3 == null ? empty : function() {
    return this.querySelectorAll(selector3);
  };
}
function arrayAll(select2) {
  return function() {
    return array$1(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  typeof select2 == "function" ? select2 = arrayAll(select2) : select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subgroups.push(select2.call(node2, node2.__data__, i2, group)), parents.push(node2));
  return new Selection$1(subgroups, parents);
}
function matcher(selector3) {
  return function() {
    return this.matches(selector3);
  };
}
function childMatcher(selector3) {
  return function(node2) {
    return node2.matches(selector3);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match == "function" ? match : childMatcher(match)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match == "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  typeof match != "function" && (match = matcher(match));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && match.call(node2, node2.__data__, i2, group) && subgroup.push(node2);
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument, this.namespaceURI = parent.namespaceURI, this._next = null, this._parent = parent, this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector3) {
    return this._parent.querySelector(selector3);
  },
  querySelectorAll: function(selector3) {
    return this._parent.querySelectorAll(selector3);
  }
};
function constant$4(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  for (var i2 = 0, node2, groupLength = group.length, dataLength = data.length; i2 < dataLength; ++i2)
    (node2 = group[i2]) ? (node2.__data__ = data[i2], update[i2] = node2) : enter[i2] = new EnterNode(parent, data[i2]);
  for (; i2 < groupLength; ++i2)
    (node2 = group[i2]) && (exit[i2] = node2);
}
function bindKey(parent, group, enter, update, exit, data, key2) {
  var i2, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2)
    (node2 = group[i2]) && (keyValues[i2] = keyValue = key2.call(node2, node2.__data__, i2, group) + "", nodeByKeyValue.has(keyValue) ? exit[i2] = node2 : nodeByKeyValue.set(keyValue, node2));
  for (i2 = 0; i2 < dataLength; ++i2)
    keyValue = key2.call(parent, data[i2], i2, data) + "", (node2 = nodeByKeyValue.get(keyValue)) ? (update[i2] = node2, node2.__data__ = data[i2], nodeByKeyValue.delete(keyValue)) : enter[i2] = new EnterNode(parent, data[i2]);
  for (i2 = 0; i2 < groupLength; ++i2)
    (node2 = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node2 && (exit[i2] = node2);
}
function datum(node2) {
  return node2.__data__;
}
function selection_data(value, key2) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  typeof value != "function" && (value = constant$4(value));
  for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    var parent = parents[j2], group = groups[j2], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key2);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0)
      if (previous = enterGroup[i0]) {
        for (i0 >= i1 && (i1 = i0 + 1); !(next = updateGroup[i1]) && ++i1 < dataLength; ) ;
        previous._next = next || null;
      }
  }
  return update = new Selection$1(update, parents), update._enter = enter, update._exit = exit, update;
}
function arraylike(data) {
  return typeof data == "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  return typeof onenter == "function" ? (enter = onenter(enter), enter && (enter = enter.selection())) : enter = enter.append(onenter + ""), onupdate != null && (update = onupdate(update), update && (update = update.selection())), onexit == null ? exit.remove() : onexit(exit), enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context2) {
  for (var selection2 = context2.selection ? context2.selection() : context2, groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2)
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge = merges[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group0[i2] || group1[i2]) && (merge[i2] = node2);
  for (; j2 < m0; ++j2)
    merges[j2] = groups0[j2];
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j2 = -1, m2 = groups.length; ++j2 < m2; )
    for (var group = groups[j2], i2 = group.length - 1, next = group[i2], node2; --i2 >= 0; )
      (node2 = group[i2]) && (next && node2.compareDocumentPosition(next) ^ 4 && next.parentNode.insertBefore(node2, next), next = node2);
  return this;
}
function selection_sort(compare) {
  compare || (compare = ascending);
  function compareNode(a2, b2) {
    return a2 && b2 ? compare(a2.__data__, b2.__data__) : !a2 - !b2;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, sortgroup = sortgroups[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (sortgroup[i2] = node2);
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  return arguments[0] = this, callback.apply(null, arguments), this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
      var node2 = group[i2];
      if (node2) return node2;
    }
  return null;
}
function selection_size() {
  let size2 = 0;
  for (const node2 of this) ++size2;
  return size2;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length, node2; i2 < n2; ++i2)
      (node2 = group[i2]) && callback.call(node2, node2.__data__, i2, group);
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    v == null ? this.removeAttribute(name) : this.setAttribute(name, v);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    v == null ? this.removeAttributeNS(fullname.space, fullname.local) : this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value == "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    v == null ? this.style.removeProperty(name) : this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value == "function" ? styleFunction$1 : styleConstant$1)(name, value, priority ?? "")) : styleValue(this.node(), name);
}
function styleValue(node2, name) {
  return node2.style.getPropertyValue(name) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    v == null ? delete this[name] : this[name] = v;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value == "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2, this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i2 = this._names.indexOf(name);
    i2 < 0 && (this._names.push(name), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(name) {
    var i2 = this._names.indexOf(name);
    i2 >= 0 && (this._names.splice(i2, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node2, names) {
  for (var list2 = classList(node2), i2 = -1, n2 = names.length; ++i2 < n2; ) list2.add(names[i2]);
}
function classedRemove(node2, names) {
  for (var list2 = classList(node2), i2 = -1, n2 = names.length; ++i2 < n2; ) list2.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    for (var list2 = classList(this.node()), i2 = -1, n2 = names.length; ++i2 < n2; ) if (!list2.contains(names[i2])) return !1;
    return !0;
  }
  return this.each((typeof value == "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v ?? "";
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value == "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v ?? "";
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value == "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name == "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name == "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before == "function" ? before : selector$p(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  parent && parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(!1), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(!0), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    return i2 >= 0 && (name = t2.slice(i2 + 1), t2 = t2.slice(0, i2)), { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (on2) {
      for (var j2 = 0, i2 = -1, m2 = on2.length, o2; j2 < m2; ++j2)
        o2 = on2[j2], (!typename.type || o2.type === typename.type) && o2.name === typename.name ? this.removeEventListener(o2.type, o2.listener, o2.options) : on2[++i2] = o2;
      ++i2 ? on2.length = i2 : delete this.__on;
    }
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on2 = this.__on, o2, listener = contextListener(value);
    if (on2) {
      for (var j2 = 0, m2 = on2.length; j2 < m2; ++j2)
        if ((o2 = on2[j2]).type === typename.type && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options), this.addEventListener(o2.type, o2.listener = listener, o2.options = options), o2.value = value;
          return;
        }
    }
    this.addEventListener(typename.type, listener, options), o2 = { type: typename.type, name: typename.name, value, listener, options }, on2 ? on2.push(o2) : this.__on = [o2];
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i2, n2 = typenames.length, t2;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2) {
      for (var j2 = 0, m2 = on2.length, o2; j2 < m2; ++j2)
        for (i2 = 0, o2 = on2[j2]; i2 < n2; ++i2)
          if ((t2 = typenames[i2]).type === o2.type && t2.name === o2.name)
            return o2.value;
    }
    return;
  }
  for (on2 = value ? onAdd : onRemove, i2 = 0; i2 < n2; ++i2) this.each(on2(typenames[i2], value, options));
  return this;
}
function dispatchEvent(node2, type, params) {
  var window2 = defaultView(node2), event = window2.CustomEvent;
  typeof event == "function" ? event = new event(type, params) : (event = window2.document.createEvent("Event"), params ? (event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail) : event.initEvent(type, !1, !1)), node2.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params == "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length, node2; i2 < n2; ++i2)
      (node2 = group[i2]) && (yield node2);
}
var root$3 = [null];
function Selection$1(groups, parents) {
  this._groups = groups, this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root$3);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select$1(selector3) {
  return typeof selector3 == "string" ? new Selection$1([[document.querySelector(selector3)]], [document.documentElement]) : new Selection$1([[selector3]], root$3);
}
function sourceEvent(event) {
  let sourceEvent2;
  for (; sourceEvent2 = event.sourceEvent; ) event = sourceEvent2;
  return event;
}
function pointer(event, node2) {
  if (event = sourceEvent(event), node2 === void 0 && (node2 = event.currentTarget), node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      return point2.x = event.clientX, point2.y = event.clientY, point2 = point2.matrixTransform(node2.getScreenCTM().inverse()), [point2.x, point2.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const nonpassive = { passive: !1 }, nonpassivecapture = { capture: !0, passive: !1 };
function nopropagation$1(event) {
  event.stopImmediatePropagation();
}
function noevent$1(event) {
  event.preventDefault(), event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select$1(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  "onselectstart" in root2 ? selection2.on("selectstart.drag", noevent$1, nonpassivecapture) : (root2.__noselect = root2.style.MozUserSelect, root2.style.MozUserSelect = "none");
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select$1(view).on("dragstart.drag", null);
  noclick && (selection2.on("click.drag", noevent$1, nonpassivecapture), setTimeout(function() {
    selection2.on("click.drag", null);
  }, 0)), "onselectstart" in root2 ? selection2.on("selectstart.drag", null) : (root2.style.MozUserSelect = root2.__noselect, delete root2.__noselect);
}
const constant$3 = (x2) => () => x2;
function DragEvent(type, {
  sourceEvent: sourceEvent2,
  subject,
  target,
  identifier,
  active,
  x: x2,
  y: y2,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: !0, configurable: !0 },
    sourceEvent: { value: sourceEvent2, enumerable: !0, configurable: !0 },
    subject: { value: subject, enumerable: !0, configurable: !0 },
    target: { value: target, enumerable: !0, configurable: !0 },
    identifier: { value: identifier, enumerable: !0, configurable: !0 },
    active: { value: active, enumerable: !0, configurable: !0 },
    x: { value: x2, enumerable: !0, configurable: !0 },
    y: { value: y2, enumerable: !0, configurable: !0 },
    dx: { value: dx, enumerable: !0, configurable: !0 },
    dy: { value: dy, enumerable: !0, configurable: !0 },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter$1(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d2) {
  return d2 ?? { x: event.x, y: event.y };
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag() {
  var filter2 = defaultFilter$1, container2 = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$1, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d2) {
    if (!(touchending || !filter2.call(this, event, d2))) {
      var gesture = beforestart(this, container2.call(this, event, d2), event, d2, "mouse");
      gesture && (select$1(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture), dragDisable(event.view), nopropagation$1(event), mousemoving = !1, mousedownx = event.clientX, mousedowny = event.clientY, gesture("start", event));
    }
  }
  function mousemoved(event) {
    if (noevent$1(event), !mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select$1(event.view).on("mousemove.drag mouseup.drag", null), yesdrag(event.view, mousemoving), noevent$1(event), gestures.mouse("end", event);
  }
  function touchstarted(event, d2) {
    if (filter2.call(this, event, d2)) {
      var touches = event.changedTouches, c2 = container2.call(this, event, d2), n2 = touches.length, i2, gesture;
      for (i2 = 0; i2 < n2; ++i2)
        (gesture = beforestart(this, c2, event, d2, touches[i2].identifier, touches[i2])) && (nopropagation$1(event), gesture("start", event, touches[i2]));
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2)
      (gesture = gestures[touches[i2].identifier]) && (noevent$1(event), gesture("drag", event, touches[i2]));
  }
  function touchended(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (touchending && clearTimeout(touchending), touchending = setTimeout(function() {
      touchending = null;
    }, 500), i2 = 0; i2 < n2; ++i2)
      (gesture = gestures[touches[i2].identifier]) && (nopropagation$1(event), gesture("end", event, touches[i2]));
  }
  function beforestart(that, container3, event, d2, identifier, touch) {
    var dispatch2 = listeners.copy(), p2 = pointer(touch || event, container3), dx, dy, s2;
    if ((s2 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p2[0],
      y: p2[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d2)) != null)
      return dx = s2.x - p2[0] || 0, dy = s2.y - p2[1] || 0, function gesture(type, event2, touch2) {
        var p0 = p2, n2;
        switch (type) {
          case "start":
            gestures[identifier] = gesture, n2 = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          // falls through
          case "drag":
            p2 = pointer(touch2 || event2, container3), n2 = active;
            break;
        }
        dispatch2.call(
          type,
          that,
          new DragEvent(type, {
            sourceEvent: event2,
            subject: s2,
            target: drag2,
            identifier,
            active: n2,
            x: p2[0] + dx,
            y: p2[1] + dy,
            dx: p2[0] - p0[0],
            dy: p2[1] - p0[1],
            dispatch: dispatch2
          }),
          d2
        );
      };
  }
  return drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ == "function" ? _ : constant$3(!!_), drag2) : filter2;
  }, drag2.container = function(_) {
    return arguments.length ? (container2 = typeof _ == "function" ? _ : constant$3(_), drag2) : container2;
  }, drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ == "function" ? _ : constant$3(_), drag2) : subject;
  }, drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ == "function" ? _ : constant$3(!!_), drag2) : touchable;
  }, drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  }, drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  }, drag2;
}
function define(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype, prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key2 in definition) prototype[key2] = definition[key2];
  return prototype;
}
function Color() {
}
var darker = 0.7, brighter = 1 / darker, reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`), named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m2, l2;
  return format = (format + "").trim().toLowerCase(), (m2 = reHex.exec(format)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g, b2, a2) {
  return a2 <= 0 && (r2 = g = b2 = NaN), new Rgb(r2, g, b2, a2);
}
function rgbConvert(o2) {
  return o2 instanceof Color || (o2 = color(o2)), o2 ? (o2 = o2.rgb(), new Rgb(o2.r, o2.g, o2.b, o2.opacity)) : new Rgb();
}
function rgb(r2, g, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b2, opacity ?? 1);
}
function Rgb(r2, g, b2, opacity) {
  this.r = +r2, this.g = +g, this.b = +b2, this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter(k2) {
    return k2 = k2 == null ? brighter : Math.pow(brighter, k2), new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    return k2 = k2 == null ? darker : Math.pow(darker, k2), new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  return value = clampi(value), (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l2, a2) {
  return a2 <= 0 ? h = s2 = l2 = NaN : l2 <= 0 || l2 >= 1 ? h = s2 = NaN : s2 <= 0 && (h = NaN), new Hsl(h, s2, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (o2 instanceof Color || (o2 = color(o2)), !o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g = o2.g / 255, b2 = o2.b / 255, min2 = Math.min(r2, g, b2), max2 = Math.max(r2, g, b2), h = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  return s2 ? (r2 === max2 ? h = (g - b2) / s2 + (g < b2) * 6 : g === max2 ? h = (b2 - r2) / s2 + 2 : h = (r2 - g) / s2 + 4, s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2, h *= 60) : s2 = l2 > 0 && l2 < 1 ? 0 : h, new Hsl(h, s2, l2, o2.opacity);
}
function hsl(h, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l2, opacity ?? 1);
}
function Hsl(h, s2, l2, opacity) {
  this.h = +h, this.s = +s2, this.l = +l2, this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    return k2 = k2 == null ? brighter : Math.pow(brighter, k2), new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    return k2 = k2 == null ? darker : Math.pow(darker, k2), new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  return value = (value || 0) % 360, value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
const constant$2 = (x2) => () => x2;
function linear(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) == 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant$2(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear(a2, d2) : constant$2(isNaN(a2) ? b2 : a2);
}
const interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end) {
    var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b2 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t2) {
      return start2.r = r2(t2), start2.g = g(t2), start2.b = b2(t2), start2.opacity = opacity(t2), start2 + "";
    };
  }
  return rgb$1.gamma = rgbGamma, rgb$1;
}(1);
function interpolateNumber(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function interpolateString(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q = [];
  for (a2 = a2 + "", b2 = b2 + ""; (am = reA.exec(a2)) && (bm = reB.exec(b2)); )
    (bs = bm.index) > bi && (bs = b2.slice(bi, bs), s2[i2] ? s2[i2] += bs : s2[++i2] = bs), (am = am[0]) === (bm = bm[0]) ? s2[i2] ? s2[i2] += bm : s2[++i2] = bm : (s2[++i2] = null, q.push({ i: i2, x: interpolateNumber(am, bm) })), bi = reB.lastIndex;
  return bi < b2.length && (bs = b2.slice(bi), s2[i2] ? s2[i2] += bs : s2[++i2] = bs), s2.length < 2 ? q[0] ? one(q[0].x) : zero(b2) : (b2 = q.length, function(t2) {
    for (var i3 = 0, o2; i3 < b2; ++i3) s2[(o2 = q[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}
var degrees = 180 / Math.PI, identity$2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b2, c2, d2, e2, f2) {
  var scaleX2, scaleY2, skewX;
  return (scaleX2 = Math.sqrt(a2 * a2 + b2 * b2)) && (a2 /= scaleX2, b2 /= scaleX2), (skewX = a2 * c2 + b2 * d2) && (c2 -= a2 * skewX, d2 -= b2 * skewX), (scaleY2 = Math.sqrt(c2 * c2 + d2 * d2)) && (c2 /= scaleY2, d2 /= scaleY2, skewX /= scaleY2), a2 * d2 < b2 * c2 && (a2 = -a2, b2 = -b2, skewX = -skewX, scaleX2 = -scaleX2), {
    translateX: e2,
    translateY: f2,
    rotate: Math.atan2(b2, a2) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX2,
    scaleY: scaleY2
  };
}
var svgNode;
function parseCss(value) {
  const m2 = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m2.isIdentity ? identity$2 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value) {
  return value == null || (svgNode || (svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g")), svgNode.setAttribute("transform", value), !(value = svgNode.transform.baseVal.consolidate())) ? identity$2 : (value = value.matrix, decompose(value.a, value.b, value.c, value.d, value.e, value.f));
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else (xb || yb) && s2.push("translate(" + xb + pxComma + yb + pxParen);
  }
  function rotate2(a2, b2, s2, q) {
    a2 !== b2 ? (a2 - b2 > 180 ? b2 += 360 : b2 - a2 > 180 && (a2 += 360), q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b2) })) : b2 && s2.push(pop(s2) + "rotate(" + b2 + degParen);
  }
  function skewX(a2, b2, s2, q) {
    a2 !== b2 ? q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b2) }) : b2 && s2.push(pop(s2) + "skewX(" + b2 + degParen);
  }
  function scale2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else (xb !== 1 || yb !== 1) && s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
  }
  return function(a2, b2) {
    var s2 = [], q = [];
    return a2 = parse2(a2), b2 = parse2(b2), translate2(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s2, q), rotate2(a2.rotate, b2.rotate, s2, q), skewX(a2.skewX, b2.skewX, s2, q), scale2(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s2, q), a2 = b2 = null, function(t2) {
      for (var i2 = -1, n2 = q.length, o2; ++i2 < n2; ) s2[(o2 = q[i2]).i] = o2.x(t2);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)"), interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")"), epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const interpolateZoom = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S;
    if (d2 < epsilon2)
      S = Math.log(w1 / w0) / rho, i2 = function(t2) {
        return [
          ux0 + t2 * dx,
          uy0 + t2 * dy,
          w0 * Math.exp(rho * t2 * S)
        ];
      };
    else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho, i2 = function(t2) {
        var s2 = t2 * S, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u2 * dx,
          uy0 + u2 * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    return i2.duration = S * 1e3 * rho / Math.SQRT2, i2;
  }
  return zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  }, zoom2;
}(Math.SQRT2, 2, 4);
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance == "object" && performance.now ? performance : Date, setFrame = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay2, time2) {
    if (typeof callback != "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay2 == null ? 0 : +delay2), !this._next && taskTail !== this && (taskTail ? taskTail._next = this : taskHead = this, taskTail = this), this._call = callback, this._time = time2, sleep();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, sleep());
  }
};
function timer(callback, delay2, time2) {
  var t2 = new Timer();
  return t2.restart(callback, delay2, time2), t2;
}
function timerFlush() {
  now(), ++frame;
  for (var t2 = taskHead, e2; t2; )
    (e2 = clockNow - t2._time) >= 0 && t2._call.call(void 0, e2), t2 = t2._next;
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew, frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0, nap(), clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay2 = now2 - clockLast;
  delay2 > pokeDelay && (clockSkew -= delay2, clockLast = now2);
}
function nap() {
  for (var t0, t1 = taskHead, t2, time2 = 1 / 0; t1; )
    t1._call ? (time2 > t1._time && (time2 = t1._time), t0 = t1, t1 = t1._next) : (t2 = t1._next, t1._next = null, t1 = t0 ? t0._next = t2 : taskHead = t2);
  taskTail = t0, sleep(time2);
}
function sleep(time2) {
  if (!frame) {
    timeout$1 && (timeout$1 = clearTimeout(timeout$1));
    var delay2 = time2 - clockNow;
    delay2 > 24 ? (time2 < 1 / 0 && (timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew)), interval && (interval = clearInterval(interval))) : (interval || (clockLast = clock.now(), interval = setInterval(poke, pokeDelay)), frame = 1, setFrame(wake));
  }
}
function timeout(callback, delay2, time2) {
  var t2 = new Timer();
  return delay2 = delay2 == null ? 0 : +delay2, t2.restart((elapsed) => {
    t2.stop(), callback(elapsed + delay2);
  }, delay2, time2), t2;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt"), emptyTween = [], CREATED = 0, SCHEDULED = 1, STARTING = 2, STARTED = 3, RUNNING = 4, ENDING = 5, ENDED = 6;
function schedule(node2, name, id2, index2, group, timing) {
  var schedules = node2.__transition;
  if (!schedules) node2.__transition = {};
  else if (id2 in schedules) return;
  create(node2, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node2, id2) {
  var schedule2 = get(node2, id2);
  if (schedule2.state > CREATED) throw new Error("too late; already scheduled");
  return schedule2;
}
function set(node2, id2) {
  var schedule2 = get(node2, id2);
  if (schedule2.state > STARTED) throw new Error("too late; already running");
  return schedule2;
}
function get(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2])) throw new Error("transition not found");
  return schedule2;
}
function create(node2, id2, self2) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self2, self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED, self2.timer.restart(start2, self2.delay, self2.time), self2.delay <= elapsed && start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j2, n2, o2;
    if (self2.state !== SCHEDULED) return stop();
    for (i2 in schedules)
      if (o2 = schedules[i2], o2.name === self2.name) {
        if (o2.state === STARTED) return timeout(start2);
        o2.state === RUNNING ? (o2.state = ENDED, o2.timer.stop(), o2.on.call("interrupt", node2, node2.__data__, o2.index, o2.group), delete schedules[i2]) : +i2 < id2 && (o2.state = ENDED, o2.timer.stop(), o2.on.call("cancel", node2, node2.__data__, o2.index, o2.group), delete schedules[i2]);
      }
    if (timeout(function() {
      self2.state === STARTED && (self2.state = RUNNING, self2.timer.restart(tick, self2.delay, self2.time), tick(elapsed));
    }), self2.state = STARTING, self2.on.call("start", node2, node2.__data__, self2.index, self2.group), self2.state === STARTING) {
      for (self2.state = STARTED, tween = new Array(n2 = self2.tween.length), i2 = 0, j2 = -1; i2 < n2; ++i2)
        (o2 = self2.tween[i2].value.call(node2, node2.__data__, self2.index, self2.group)) && (tween[++j2] = o2);
      tween.length = j2 + 1;
    }
  }
  function tick(elapsed) {
    for (var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length; ++i2 < n2; )
      tween[i2].call(node2, t2);
    self2.state === ENDING && (self2.on.call("end", node2, node2.__data__, self2.index, self2.group), stop());
  }
  function stop() {
    self2.state = ENDED, self2.timer.stop(), delete schedules[id2];
    for (var i2 in schedules) return;
    delete node2.__transition;
  }
}
function interrupt(node2, name) {
  var schedules = node2.__transition, schedule2, active, empty2 = !0, i2;
  if (schedules) {
    name = name == null ? null : name + "";
    for (i2 in schedules) {
      if ((schedule2 = schedules[i2]).name !== name) {
        empty2 = !1;
        continue;
      }
      active = schedule2.state > STARTING && schedule2.state < ENDING, schedule2.state = ENDED, schedule2.timer.stop(), schedule2.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group), delete schedules[i2];
    }
    empty2 && delete node2.__transition;
  }
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2)
        if (tween1[i2].name === name) {
          tween1 = tween1.slice(), tween1.splice(i2, 1);
          break;
        }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value != "function") throw new Error();
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2)
        if (tween1[i2].name === name) {
          tween1[i2] = t2;
          break;
        }
      i2 === n2 && tween1.push(t2);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  if (name += "", arguments.length < 2) {
    for (var tween = get(this.node(), id2).tween, i2 = 0, n2 = tween.length, t2; i2 < n2; ++i2)
      if ((t2 = tween[i2]).name === name)
        return t2.value;
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition, name, value) {
  var id2 = transition._id;
  return transition.each(function() {
    var schedule2 = set(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  }), function(node2) {
    return get(node2, id2).value[name];
  };
}
function interpolate(a2, b2) {
  var c2;
  return (typeof b2 == "number" ? interpolateNumber : b2 instanceof color ? interpolateRgb : (c2 = color(b2)) ? (b2 = c2, interpolateRgb) : interpolateString)(a2, b2);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    return value1 == null ? void this.removeAttribute(name) : (string0 = this.getAttribute(name), string1 = value1 + "", string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1)));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    return value1 == null ? void this.removeAttributeNS(fullname.space, fullname.local) : (string0 = this.getAttributeNS(fullname.space, fullname.local), string1 = value1 + "", string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1)));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value == "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i2, value));
}
function attrInterpolate(name, i2) {
  return function(t2) {
    this.setAttribute(name, i2.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && attrInterpolateNS(fullname, i2)), t0;
  }
  return tween._value = value, tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && attrInterpolate(name, i2)), t0;
  }
  return tween._value = value, tween;
}
function transition_attrTween(name, value) {
  var key2 = "attr." + name;
  if (arguments.length < 2) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value != "function") throw new Error();
  var fullname = namespace(name);
  return this.tween(key2, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value == "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value == "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value != "function") throw new Error();
  return function() {
    set(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v != "function") throw new Error();
    set(this, id2).ease = v;
  };
}
function transition_easeVarying(value) {
  if (typeof value != "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  typeof match != "function" && (match = matcher(match));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && match.call(node2, node2.__data__, i2, group) && subgroup.push(node2);
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2)
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge = merges[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group0[i2] || group1[i2]) && (merge[i2] = node2);
  for (; j2 < m0; ++j2)
    merges[j2] = groups0[j2];
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i2 = t2.indexOf(".");
    return i2 >= 0 && (t2 = t2.slice(0, i2)), !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule2 = sit(this, id2), on2 = schedule2.on;
    on2 !== on0 && (on1 = (on0 = on2).copy()).on(name, listener), schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i2 in this.__transition) if (+i2 !== id2) return;
    parent && parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  typeof select2 != "function" && (select2 = selector$p(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subnode = select2.call(node2, node2.__data__, i2, group)) && ("__data__" in node2 && (subnode.__data__ = node2.__data__), subgroup[i2] = subnode, schedule(subgroup[i2], name, id2, i2, subgroup, get(node2, id2)));
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  typeof select2 != "function" && (select2 = selectorAll(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      if (node2 = group[i2]) {
        for (var children2 = select2.call(node2, node2.__data__, i2, group), child, inherit2 = get(node2, id2), k2 = 0, l2 = children2.length; k2 < l2; ++k2)
          (child = children2[k2]) && schedule(child, name, id2, k2, children2, inherit2);
        subgroups.push(children2), parents.push(node2);
      }
  return new Transition(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    return value1 == null && (string1 = value1 = (this.style.removeProperty(name), styleValue(this, name))), string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key2 = "style." + name, event = "end." + key2, remove2;
  return function() {
    var schedule2 = set(this, id2), on2 = schedule2.on, listener = schedule2.value[key2] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    (on2 !== on0 || listener0 !== listener) && (on1 = (on0 = on2).copy()).on(event, listener0 = listener), schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i2 = (name += "") == "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove(name)) : typeof value == "function" ? this.styleTween(name, styleFunction(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i2, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i2, priority) {
  return function(t2) {
    this.style.setProperty(name, i2.call(this, t2), priority);
  };
}
function styleTween(name, value, priority) {
  var t2, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t2 = (i0 = i2) && styleInterpolate(name, i2, priority)), t2;
  }
  return tween._value = value, tween;
}
function transition_styleTween(name, value, priority) {
  var key2 = "style." + (name += "");
  if (arguments.length < 2) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value != "function") throw new Error();
  return this.tween(key2, styleTween(name, value, priority ?? ""));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 ?? "";
  };
}
function transition_text(value) {
  return this.tween("text", typeof value == "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i2) {
  return function(t2) {
    this.textContent = i2.call(this, t2);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && textInterpolate(i2)), t0;
  }
  return tween._value = value, tween;
}
function transition_textTween(value) {
  var key2 = "text";
  if (arguments.length < 1) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value != "function") throw new Error();
  return this.tween(key2, textTween(value));
}
function transition_transition() {
  for (var name = this._name, id0 = this._id, id1 = newId(), groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      if (node2 = group[i2]) {
        var inherit2 = get(node2, id0);
        schedule(node2, name, id1, i2, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size2 = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      --size2 === 0 && resolve();
    } };
    that.each(function() {
      var schedule2 = set(this, id2), on2 = schedule2.on;
      on2 !== on0 && (on1 = (on0 = on2).copy(), on1._.cancel.push(cancel), on1._.interrupt.push(cancel), on1._.end.push(end)), schedule2.on = on1;
    }), size2 === 0 && resolve();
  });
}
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups, this._parents = parents, this._name = name, this._id = id2;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node2, id2) {
  for (var timing; !(timing = node2.__transition) || !(timing = timing[id2]); )
    if (!(node2 = node2.parentNode))
      throw new Error(`transition ${id2} not found`);
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  name instanceof Transition ? (id2 = name._id, name = name._name) : (id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "");
  for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && schedule(node2, name, id2, i2, group, timing || inherit(node2, id2));
  return new Transition(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
const constant$1 = (x2) => () => x2;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: !0, configurable: !0 },
    sourceEvent: { value: sourceEvent2, enumerable: !0, configurable: !0 },
    target: { value: target, enumerable: !0, configurable: !0 },
    transform: { value: transform2, enumerable: !0, configurable: !0 },
    _: { value: dispatch2 }
  });
}
function Transform(k2, x2, y2) {
  this.k = k2, this.x = x2, this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k2) {
    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity$1 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node2) {
  for (; !node2.__zoom; ) if (!(node2 = node2.parentNode)) return identity$1;
  return node2.__zoom;
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault(), event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e2 = this;
  return e2 instanceof SVGElement ? (e2 = e2.ownerSVGElement || e2, e2.hasAttribute("viewBox") ? (e2 = e2.viewBox.baseVal, [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]]) : [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]]) : [[0, 0], [e2.clientWidth, e2.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity$1;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, 1 / 0], translateExtent = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: !1 }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point2, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform), collection !== selection2 ? schedule2(collection, transform2, point2, event) : selection2.interrupt().each(function() {
      gesture(this, arguments).event(event).start().zoom(null, typeof transform2 == "function" ? transform2.apply(this, arguments) : transform2).end();
    });
  }, zoom2.scaleBy = function(selection2, k2, p2, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 == "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p2, event);
  }, zoom2.scaleTo = function(selection2, k2, p2, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 == "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k2 == "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate2(scale2(t0, k1), p0, p1), e2, translateExtent);
    }, p2, event);
  }, zoom2.translateBy = function(selection2, x2, y2, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 == "function" ? x2.apply(this, arguments) : x2,
        typeof y2 == "function" ? y2.apply(this, arguments) : y2
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  }, zoom2.translateTo = function(selection2, x2, y2, p2, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 == "function" ? p2.apply(this, arguments) : p2;
      return constrain(identity$1.translate(p0[0], p0[1]).scale(t2.k).translate(
        typeof x2 == "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 == "function" ? -y2.apply(this, arguments) : -y2
      ), e2, translateExtent);
    }, p2, event);
  };
  function scale2(transform2, k2) {
    return k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2)), k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
  }
  function translate2(transform2, p0, p1) {
    var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform2, point2, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e2 = extent.apply(that, args), p2 = point2 == null ? centroid(e2) : typeof point2 == "function" ? point2.apply(that, args) : point2, w = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a2 = that.__zoom, b2 = typeof transform2 == "function" ? transform2.apply(that, args) : transform2, i2 = interpolate2(a2.invert(p2).concat(w / a2.k), b2.invert(p2).concat(w / b2.k));
      return function(t2) {
        if (t2 === 1) t2 = b2;
        else {
          var l2 = i2(t2), k2 = w / l2[2];
          t2 = new Transform(k2, p2[0] - l2[0] * k2, p2[1] - l2[1] * k2);
        }
        g.zoom(null, t2);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that, this.args = args, this.active = 0, this.sourceEvent = null, this.extent = extent.apply(that, args), this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      return event && (this.sourceEvent = event), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(key2, transform2) {
      return this.mouse && key2 !== "mouse" && (this.mouse[1] = transform2.invert(this.mouse[0])), this.touch0 && key2 !== "touch" && (this.touch0[1] = transform2.invert(this.touch0[0])), this.touch1 && key2 !== "touch" && (this.touch1[1] = transform2.invert(this.touch1[0])), this.that.__zoom = transform2, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(type) {
      var d2 = select$1(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d2
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g = gesture(this, args).event(event), t2 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p2 = pointer(event);
    if (g.wheel)
      (g.mouse[0][0] !== p2[0] || g.mouse[0][1] !== p2[1]) && (g.mouse[1] = t2.invert(g.mouse[0] = p2)), clearTimeout(g.wheel);
    else {
      if (t2.k === k2) return;
      g.mouse = [p2, t2.invert(p2)], interrupt(this), g.start();
    }
    noevent(event), g.wheel = setTimeout(wheelidled, wheelDelay), g.zoom("mouse", constrain(translate2(scale2(t2, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null, g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g = gesture(this, args, !0).event(event), v = select$1(event.view).on("mousemove.zoom", mousemoved, !0).on("mouseup.zoom", mouseupped, !0), p2 = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view), nopropagation(event), g.mouse = [p2, this.__zoom.invert(p2)], interrupt(this), g.start();
    function mousemoved(event2) {
      if (noevent(event2), !g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate2(g.that.__zoom, g.mouse[0] = pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null), yesdrag(event2.view, g.moved), noevent(event2), g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (filter2.apply(this, arguments)) {
      var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate2(scale2(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
      noevent(event), duration > 0 ? select$1(this).transition().duration(duration).call(schedule2, t1, p0, event) : select$1(this).call(zoom2.transform, t1, p0, event);
    }
  }
  function touchstarted(event, ...args) {
    if (filter2.apply(this, arguments)) {
      var touches = event.touches, n2 = touches.length, g = gesture(this, args, event.changedTouches.length === n2).event(event), started, i2, t2, p2;
      for (nopropagation(event), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], p2 = pointer(t2, this), p2 = [p2, this.__zoom.invert(p2), t2.identifier], g.touch0 ? !g.touch1 && g.touch0[2] !== p2[2] && (g.touch1 = p2, g.taps = 0) : (g.touch0 = p2, started = !0, g.taps = 1 + !!touchstarting);
      touchstarting && (touchstarting = clearTimeout(touchstarting)), started && (g.taps < 2 && (touchfirst = p2[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay)), interrupt(this), g.start());
    }
  }
  function touchmoved(event, ...args) {
    if (this.__zooming) {
      var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2, p2, l2;
      for (noevent(event), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], p2 = pointer(t2, this), g.touch0 && g.touch0[2] === t2.identifier ? g.touch0[0] = p2 : g.touch1 && g.touch1[2] === t2.identifier && (g.touch1[0] = p2);
      if (t2 = g.that.__zoom, g.touch1) {
        var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t2 = scale2(t2, Math.sqrt(dp / dl)), p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2], l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g.touch0) p2 = g.touch0[0], l2 = g.touch0[1];
      else return;
      g.zoom("touch", constrain(translate2(t2, p2, l2), g.extent, translateExtent));
    }
  }
  function touchended(event, ...args) {
    if (this.__zooming) {
      var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2;
      for (nopropagation(event), touchending && clearTimeout(touchending), touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], g.touch0 && g.touch0[2] === t2.identifier ? delete g.touch0 : g.touch1 && g.touch1[2] === t2.identifier && delete g.touch1;
      if (g.touch1 && !g.touch0 && (g.touch0 = g.touch1, delete g.touch1), g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
      else if (g.end(), g.taps === 2 && (t2 = pointer(t2, this), Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance)) {
        var p2 = select$1(this).on("dblclick.zoom");
        p2 && p2.apply(this, arguments);
      }
    }
  }
  return zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta2 = typeof _ == "function" ? _ : constant$1(+_), zoom2) : wheelDelta2;
  }, zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ == "function" ? _ : constant$1(!!_), zoom2) : filter2;
  }, zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ == "function" ? _ : constant$1(!!_), zoom2) : touchable;
  }, zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ == "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  }, zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  }, zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  }, zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  }, zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  }, zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, zoom2) : interpolate2;
  }, zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  }, zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  }, zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  }, zoom2;
}
const errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id2) => `The old edge with id=${id2} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id: id2, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${handleType === "source" ? sourceHandle : targetHandle}", edge id: ${id2}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (lib2 = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib2}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], elementSelectionKeys = ["Enter", " ", "Escape"];
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2.Strict = "strict", ConnectionMode2.Loose = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2.Free = "free", PanOnScrollMode2.Vertical = "vertical", PanOnScrollMode2.Horizontal = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2.Partial = "partial", SelectionMode2.Full = "full";
})(SelectionMode || (SelectionMode = {}));
const initialConnection = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2.Bezier = "default", ConnectionLineType2.Straight = "straight", ConnectionLineType2.Step = "step", ConnectionLineType2.SmoothStep = "smoothstep", ConnectionLineType2.SimpleBezier = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2.Arrow = "arrow", MarkerType2.ArrowClosed = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2.Left = "left", Position2.Top = "top", Position2.Right = "right", Position2.Bottom = "bottom";
})(Position || (Position = {}));
const oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? "valid" : "invalid";
}
const isEdgeBase = (element) => "id" in element && "source" in element && "target" in element, isNodeBase = (element) => "id" in element && "position" in element && !("source" in element) && !("target" in element), isInternalNodeBase = (element) => "id" in element && "internals" in element && !("source" in element) && !("target" in element), getNodePositionWithOrigin = (node2, nodeOrigin = [0, 0]) => {
  const { width, height } = getNodeDimensions(node2), origin = node2.origin ?? nodeOrigin, offsetX = width * origin[0], offsetY = height * origin[1];
  return {
    x: node2.position.x - offsetX,
    y: node2.position.y - offsetY
  };
}, getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {
  if (nodes.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const box = nodes.reduce((currBox, nodeOrId) => {
    const isId = typeof nodeOrId == "string";
    let currentNode = !params.nodeLookup && !isId ? nodeOrId : void 0;
    params.nodeLookup && (currentNode = isId ? params.nodeLookup.get(nodeOrId) : isInternalNodeBase(nodeOrId) ? nodeOrId : params.nodeLookup.get(nodeOrId.id));
    const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return getBoundsOfBoxes(currBox, nodeBox);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return boxToRect(box);
}, getInternalNodesBounds = (nodeLookup, params = {}) => {
  if (nodeLookup.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let box = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return nodeLookup.forEach((node2) => {
    if (params.filter === void 0 || params.filter(node2)) {
      const nodeBox = nodeToBox(node2);
      box = getBoundsOfBoxes(box, nodeBox);
    }
  }), boxToRect(box);
}, getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = !1, excludeNonSelectableNodes = !1) => {
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  }, visibleNodes = [];
  for (const node2 of nodes.values()) {
    const { measured, selectable = !0, hidden: hidden2 = !1 } = node2;
    if (excludeNonSelectableNodes && !selectable || hidden2)
      continue;
    const width = measured.width ?? node2.width ?? node2.initialWidth ?? null, height = measured.height ?? node2.height ?? node2.initialHeight ?? null, overlappingArea = getOverlappingArea(paneRect, nodeToRect(node2)), area = (width ?? 0) * (height ?? 0), partiallyVisible = partially && overlappingArea > 0;
    (!node2.internals.handleBounds || partiallyVisible || overlappingArea >= area || node2.dragging) && visibleNodes.push(node2);
  }
  return visibleNodes;
}, getConnectedEdges = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  return nodes.forEach((node2) => {
    nodeIds.add(node2.id);
  }), edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function getFitViewNodes(nodeLookup, options) {
  const fitViewNodes = /* @__PURE__ */ new Map(), optionNodeIds = options?.nodes ? new Set(options.nodes.map((node2) => node2.id)) : null;
  return nodeLookup.forEach((n2) => {
    n2.measured.width && n2.measured.height && (options?.includeHiddenNodes || !n2.hidden) && (!optionNodeIds || optionNodeIds.has(n2.id)) && fitViewNodes.set(n2.id, n2);
  }), fitViewNodes;
}
async function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {
  if (nodes.size === 0)
    return Promise.resolve(!0);
  const nodesToFit = getFitViewNodes(nodes, options), bounds = getInternalNodesBounds(nodesToFit), viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);
  return await panZoom.setViewport(viewport, { duration: options?.duration }), Promise.resolve(!0);
}
function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError }) {
  const node2 = nodeLookup.get(nodeId), parentNode = node2.parentId ? nodeLookup.get(node2.parentId) : void 0, { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 }, origin = node2.origin ?? nodeOrigin;
  let extent = nodeExtent;
  if (node2.extent === "parent" && !node2.expandParent)
    if (!parentNode)
      onError?.("005", errorMessages.error005());
    else {
      const parentWidth = parentNode.measured.width, parentHeight = parentNode.measured.height;
      parentWidth && parentHeight && (extent = [
        [parentX, parentY],
        [parentX + parentWidth, parentY + parentHeight]
      ]);
    }
  else parentNode && isCoordinateExtent(node2.extent) && (extent = [
    [node2.extent[0][0] + parentX, node2.extent[0][1] + parentY],
    [node2.extent[1][0] + parentX, node2.extent[1][1] + parentY]
  ]);
  const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node2.measured) : nextPosition;
  return (node2.measured.width === void 0 || node2.measured.height === void 0) && onError?.("015", errorMessages.error015()), {
    position: {
      x: positionAbsolute.x - parentX + (node2.measured.width ?? 0) * origin[0],
      y: positionAbsolute.y - parentY + (node2.measured.height ?? 0) * origin[1]
    },
    positionAbsolute
  };
}
async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {
  const nodeIds = new Set(nodesToRemove.map((node2) => node2.id)), matchingNodes = [];
  for (const node2 of nodes) {
    if (node2.deletable === !1)
      continue;
    const isIncluded = nodeIds.has(node2.id), parentHit = !isIncluded && node2.parentId && matchingNodes.find((n2) => n2.id === node2.parentId);
    (isIncluded || parentHit) && matchingNodes.push(node2);
  }
  const edgeIds = new Set(edgesToRemove.map((edge) => edge.id)), deletableEdges = edges.filter((edge) => edge.deletable !== !1), matchingEdges = getConnectedEdges(matchingNodes, deletableEdges);
  for (const edge of deletableEdges)
    edgeIds.has(edge.id) && !matchingEdges.find((e2) => e2.id === edge.id) && matchingEdges.push(edge);
  if (!onBeforeDelete)
    return {
      edges: matchingEdges,
      nodes: matchingNodes
    };
  const onBeforeDeleteResult = await onBeforeDelete({
    nodes: matchingNodes,
    edges: matchingEdges
  });
  return typeof onBeforeDeleteResult == "boolean" ? onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] } : onBeforeDeleteResult;
}
const clamp = (val, min2 = 0, max2 = 1) => Math.min(Math.max(val, min2), max2), clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({
  x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),
  y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0))
});
function clampPositionToParent(childPosition, childDimensions, parent) {
  const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent), { x: parentX, y: parentY } = parent.internals.positionAbsolute;
  return clampPosition(childPosition, [
    [parentX, parentY],
    [parentX + parentWidth, parentY + parentHeight]
  ], childDimensions);
}
const calcAutoPanVelocity = (value, min2, max2) => value < min2 ? clamp(Math.abs(value - min2), 1, min2) / min2 : value > max2 ? -clamp(Math.abs(value - max2), 1, min2) / min2 : 0, calcAutoPan = (pos, bounds, speed = 15, distance2 = 40) => {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed, yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
}, getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
}), rectToBox = ({ x: x2, y: y2, width, height }) => ({
  x: x2,
  y: y2,
  x2: x2 + width,
  y2: y2 + height
}), boxToRect = ({ x: x2, y: y2, x2: x22, y2: y22 }) => ({
  x: x2,
  y: y2,
  width: x22 - x2,
  height: y22 - y2
}), nodeToRect = (node2, nodeOrigin = [0, 0]) => {
  const { x: x2, y: y2 } = isInternalNodeBase(node2) ? node2.internals.positionAbsolute : getNodePositionWithOrigin(node2, nodeOrigin);
  return {
    x: x2,
    y: y2,
    width: node2.measured?.width ?? node2.width ?? node2.initialWidth ?? 0,
    height: node2.measured?.height ?? node2.height ?? node2.initialHeight ?? 0
  };
}, nodeToBox = (node2, nodeOrigin = [0, 0]) => {
  const { x: x2, y: y2 } = isInternalNodeBase(node2) ? node2.internals.positionAbsolute : getNodePositionWithOrigin(node2, nodeOrigin);
  return {
    x: x2,
    y: y2,
    x2: x2 + (node2.measured?.width ?? node2.width ?? node2.initialWidth ?? 0),
    y2: y2 + (node2.measured?.height ?? node2.height ?? node2.initialHeight ?? 0)
  };
}, getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2))), getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x)), yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
}, isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y), isNumeric = (n2) => !isNaN(n2) && isFinite(n2), devWarn = (id2, message) => {
}, snapPosition = (position, snapGrid = [1, 1]) => ({
  x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
  y: snapGrid[1] * Math.round(position.y / snapGrid[1])
}), pointToRendererPoint = ({ x: x2, y: y2 }, [tx, ty, tScale], snapToGrid = !1, snapGrid = [1, 1]) => {
  const position = {
    x: (x2 - tx) / tScale,
    y: (y2 - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
}, rendererPointToPoint = ({ x: x2, y: y2 }, [tx, ty, tScale]) => ({
  x: x2 * tScale + tx,
  y: y2 * tScale + ty
});
function parsePadding(padding, viewport) {
  if (typeof padding == "number")
    return Math.floor(viewport - viewport / (1 + padding));
  if (typeof padding == "string" && padding.endsWith("px")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue))
      return Math.floor(paddingValue);
  }
  if (typeof padding == "string" && padding.endsWith("%")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue))
      return Math.floor(viewport * paddingValue * 0.01);
  }
  return console.error(`[React Flow] The padding value "${padding}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function parsePaddings(padding, width, height) {
  if (typeof padding == "string" || typeof padding == "number") {
    const paddingY = parsePadding(padding, height), paddingX = parsePadding(padding, width);
    return {
      top: paddingY,
      right: paddingX,
      bottom: paddingY,
      left: paddingX,
      x: paddingX * 2,
      y: paddingY * 2
    };
  }
  if (typeof padding == "object") {
    const top = parsePadding(padding.top ?? padding.y ?? 0, height), bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height), left = parsePadding(padding.left ?? padding.x ?? 0, width), right = parsePadding(padding.right ?? padding.x ?? 0, width);
    return { top, right, bottom, left, x: left + right, y: top + bottom };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function calculateAppliedPaddings(bounds, x2, y2, zoom2, width, height) {
  const { x: left, y: top } = rendererPointToPoint(bounds, [x2, y2, zoom2]), { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x2, y2, zoom2]), right = width - boundRight, bottom = height - boundBottom;
  return {
    left: Math.floor(left),
    top: Math.floor(top),
    right: Math.floor(right),
    bottom: Math.floor(bottom)
  };
}
const getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {
  const p2 = parsePaddings(padding, width, height), xZoom = (width - p2.x) / bounds.width, yZoom = (height - p2.y) / bounds.height, zoom2 = Math.min(xZoom, yZoom), clampedZoom = clamp(zoom2, minZoom, maxZoom), boundsCenterX = bounds.x + bounds.width / 2, boundsCenterY = bounds.y + bounds.height / 2, x2 = width / 2 - boundsCenterX * clampedZoom, y2 = height / 2 - boundsCenterY * clampedZoom, newPadding = calculateAppliedPaddings(bounds, x2, y2, clampedZoom, width, height), offset2 = {
    left: Math.min(newPadding.left - p2.left, 0),
    top: Math.min(newPadding.top - p2.top, 0),
    right: Math.min(newPadding.right - p2.right, 0),
    bottom: Math.min(newPadding.bottom - p2.bottom, 0)
  };
  return {
    x: x2 - offset2.left + offset2.right,
    y: y2 - offset2.top + offset2.bottom,
    zoom: clampedZoom
  };
}, isMacOs = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function isCoordinateExtent(extent) {
  return extent !== void 0 && extent !== "parent";
}
function getNodeDimensions(node2) {
  return {
    width: node2.measured?.width ?? node2.width ?? node2.initialWidth ?? 0,
    height: node2.measured?.height ?? node2.height ?? node2.initialHeight ?? 0
  };
}
function nodeHasDimensions(node2) {
  return (node2.measured?.width ?? node2.width ?? node2.initialWidth) !== void 0 && (node2.measured?.height ?? node2.height ?? node2.initialHeight) !== void 0;
}
function evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {
  const positionAbsolute = { ...position }, parent = nodeLookup.get(parentId);
  if (parent) {
    const origin = parent.origin || nodeOrigin;
    positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0], positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];
  }
  return positionAbsolute;
}
function areSetsEqual$1(a2, b2) {
  if (a2.size !== b2.size)
    return !1;
  for (const item of a2)
    if (!b2.has(item))
      return !1;
  return !0;
}
function getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = !1, transform: transform2, containerBounds }) {
  const { x: x2, y: y2 } = getEventPosition(event), pointerPos = pointToRendererPoint({ x: x2 - (containerBounds?.left ?? 0), y: y2 - (containerBounds?.top ?? 0) }, transform2), { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
const getDimensions = (node2) => ({
  width: node2.offsetWidth,
  height: node2.offsetHeight
}), getHostForElement = (element) => element?.getRootNode?.() || window?.document, inputTags = ["INPUT", "SELECT", "TEXTAREA"];
function isInputDOMNode(event) {
  const target = event.composedPath?.()?.[0] || event.target;
  return target?.nodeType !== 1 ? !1 : inputTags.includes(target.nodeName) || target.hasAttribute("contenteditable") || !!target.closest(".nokey");
}
const isMouseEvent = (event) => "clientX" in event, getEventPosition = (event, bounds) => {
  const isMouse = isMouseEvent(event), evtX = isMouse ? event.clientX : event.touches?.[0].clientX, evtY = isMouse ? event.clientY : event.touches?.[0].clientY;
  return {
    x: evtX - (bounds?.left ?? 0),
    y: evtY - (bounds?.top ?? 0)
  };
}, getHandleBounds = (type, nodeElement, nodeBounds, zoom2, nodeId) => {
  const handles = nodeElement.querySelectorAll(`.${type}`);
  return !handles || !handles.length ? null : Array.from(handles).map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      type,
      nodeId,
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125, centerY2 = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125, offsetX = Math.abs(centerX - sourceX), offsetY = Math.abs(centerY2 - sourceY);
  return [centerX, centerY2, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  return distance2 >= 0 ? 0.5 * distance2 : curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c: c2 }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c2), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c2), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c2)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c2)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  }), [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  }), [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2, centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset, yOffset = Math.abs(targetY - sourceY) / 2, centerY2 = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY2, xOffset, yOffset];
}
function getElevatedEdgeZIndex({ sourceNode, targetNode, selected: selected2 = !1, zIndex = 0, elevateOnSelect = !1 }) {
  if (!elevateOnSelect)
    return zIndex;
  const edgeOrConnectedNodeSelected = selected2 || targetNode.selected || sourceNode.selected, selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1e3);
  return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
}
function isEdgeVisible({ sourceNode, targetNode, width, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  edgeBox.x === edgeBox.x2 && (edgeBox.x2 += 1), edgeBox.y === edgeBox.y2 && (edgeBox.y2 += 1);
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
const getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ""}-${target}${targetHandle || ""}`, connectionExists = (edge, edges) => edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle)), addEdge = (edgeParams, edges) => {
  if (!edgeParams.source || !edgeParams.target)
    return edges;
  let edge;
  return isEdgeBase(edgeParams) ? edge = { ...edgeParams } : edge = {
    ...edgeParams,
    id: getEdgeId(edgeParams)
  }, connectionExists(edge, edges) ? edges : (edge.sourceHandle === null && delete edge.sourceHandle, edge.targetHandle === null && delete edge.targetHandle, edges.concat(edge));
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
const handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
}, getDirection = ({ source, sourcePosition = Position.Bottom, target }) => sourcePosition === Position.Left || sourcePosition === Position.Right ? source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, distance = (a2, b2) => Math.sqrt(Math.pow(b2.x - a2.x, 2) + Math.pow(b2.y - a2.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset: offset2 }) {
  const sourceDir = handleDirections[sourcePosition], targetDir = handleDirections[targetPosition], sourceGapped = { x: source.x + sourceDir.x * offset2, y: source.y + sourceDir.y * offset2 }, targetGapped = { x: target.x + targetDir.x * offset2, y: target.y + targetDir.y * offset2 }, dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  }), dirAccessor = dir.x !== 0 ? "x" : "y", currDir = dir[dirAccessor];
  let points = [], centerX, centerY2;
  const sourceGapOffset = { x: 0, y: 0 }, targetGapOffset = { x: 0, y: 0 }, [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    centerX = center.x ?? defaultCenterX, centerY2 = center.y ?? defaultCenterY;
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ], horizontalSplit = [
      { x: sourceGapped.x, y: centerY2 },
      { x: targetGapped.x, y: centerY2 }
    ];
    sourceDir[dirAccessor] === currDir ? points = dirAccessor === "x" ? verticalSplit : horizontalSplit : points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }], targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x" ? points = sourceDir.x === currDir ? targetSource : sourceTarget : points = sourceDir.y === currDir ? sourceTarget : targetSource, sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset2) {
        const gapOffset = Math.min(offset2 - 1, offset2 - diff);
        sourceDir[dirAccessor] === currDir ? sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset : targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x", isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite], sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite], sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      (sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo)) && (points = dirAccessor === "x" ? sourceTarget : targetSource);
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y }, targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y }, maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x)), maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    maxXDistance >= maxYDistance ? (centerX = (sourceGapPoint.x + targetGapPoint.x) / 2, centerY2 = points[0].y) : (centerX = points[0].x, centerY2 = (sourceGapPoint.y + targetGapPoint.y) / 2);
  }
  return [[
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ], centerX, centerY2, defaultOffsetX, defaultOffsetY];
}
function getBend(a2, b2, c2, size2) {
  const bendSize = Math.min(distance(a2, b2) / 2, distance(b2, c2) / 2, size2), { x: x2, y: y2 } = b2;
  if (a2.x === x2 && x2 === c2.x || a2.y === y2 && y2 === c2.y)
    return `L${x2} ${y2}`;
  if (a2.y === y2) {
    const xDir2 = a2.x < c2.x ? -1 : 1, yDir2 = a2.y < c2.y ? 1 : -1;
    return `L ${x2 + bendSize * xDir2},${y2}Q ${x2},${y2} ${x2},${y2 + bendSize * yDir2}`;
  }
  const xDir = a2.x < c2.x ? 1 : -1, yDir = a2.y < c2.y ? -1 : 1;
  return `L ${x2},${y2 + bendSize * yDir}Q ${x2},${y2} ${x2 + bendSize * xDir},${y2}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius: borderRadius2 = 5, centerX, centerY: centerY2, offset: offset2 = 20 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY2 },
    offset: offset2
  });
  return [points.reduce((res, p2, i2) => {
    let segment = "";
    return i2 > 0 && i2 < points.length - 1 ? segment = getBend(points[i2 - 1], p2, points[i2 + 1], borderRadius2) : segment = `${i2 === 0 ? "M" : "L"}${p2.x} ${p2.y}`, res += segment, res;
  }, ""), labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node2) {
  return node2 && !!(node2.internals.handleBounds || node2.handles?.length) && !!(node2.measured.width || node2.width || node2.initialWidth);
}
function getEdgePosition(params) {
  const { sourceNode, targetNode } = params;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode))
    return null;
  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles), targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles), sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle), targetHandle = getHandle$1(
    // when connection type is loose we can define all handles as sources and connect source -> source
    params.connectionMode === ConnectionMode.Strict ? targetHandleBounds?.target ?? [] : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []),
    params.targetHandle
  );
  if (!sourceHandle || !targetHandle)
    return params.onError?.("008", errorMessages.error008(sourceHandle ? "target" : "source", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    })), null;
  const sourcePosition = sourceHandle?.position || Position.Bottom, targetPosition = targetHandle?.position || Position.Top, source = getHandlePosition(sourceNode, sourceHandle, sourcePosition), target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles)
    return null;
  const source = [], target = [];
  for (const handle of handles)
    handle.width = handle.width ?? 1, handle.height = handle.height ?? 1, handle.type === "source" ? source.push(handle) : handle.type === "target" && target.push(handle);
  return {
    source,
    target
  };
}
function getHandlePosition(node2, handle, fallbackPosition = Position.Left, center = !1) {
  const x2 = (handle?.x ?? 0) + node2.internals.positionAbsolute.x, y2 = (handle?.y ?? 0) + node2.internals.positionAbsolute.y, { width, height } = handle ?? getNodeDimensions(node2);
  if (center)
    return { x: x2 + width / 2, y: y2 + height / 2 };
  switch (handle?.position ?? fallbackPosition) {
    case Position.Top:
      return { x: x2 + width / 2, y: y2 };
    case Position.Right:
      return { x: x2 + width, y: y2 + height / 2 };
    case Position.Bottom:
      return { x: x2 + width / 2, y: y2 + height };
    case Position.Left:
      return { x: x2, y: y2 + height / 2 };
  }
}
function getHandle$1(bounds, handleId) {
  return bounds && (handleId ? bounds.find((d2) => d2.id === handleId) : bounds[0]) || null;
}
function getMarkerId(marker, id2) {
  return marker ? typeof marker == "string" ? marker : `${id2 ? `${id2}__` : ""}${Object.keys(marker).sort().map((key2) => `${key2}=${marker[key2]}`).join("&")}` : "";
}
function createMarkerIds(edges, { id: id2, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {
  const ids = /* @__PURE__ */ new Set();
  return edges.reduce((markers, edge) => ([edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {
    if (marker && typeof marker == "object") {
      const markerId = getMarkerId(marker, id2);
      ids.has(markerId) || (markers.push({ id: markerId, color: marker.color || defaultColor, ...marker }), ids.add(markerId));
    }
  }), markers), []).sort((a2, b2) => a2.id.localeCompare(b2.id));
}
function getNodeToolbarTransform(nodeRect, viewport, position, offset2, align) {
  let alignmentOffset = 0.5;
  align === "start" ? alignmentOffset = 0 : align === "end" && (alignmentOffset = 1);
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,
    nodeRect.y * viewport.zoom + viewport.y - offset2
  ], shift2 = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset2,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ], shift2 = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset2, shift2[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * viewport.zoom + viewport.x - offset2,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ], shift2 = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift2[0]}%, ${shift2[1]}%)`;
}
const defaultOptions = {
  nodeOrigin: [0, 0],
  nodeExtent: infiniteExtent,
  elevateNodesOnSelect: !0,
  defaults: {}
}, adoptUserNodesDefaultOptions = {
  ...defaultOptions,
  checkEquality: !0
};
function mergeObjects(base, incoming) {
  const result = { ...base };
  for (const key2 in incoming)
    incoming[key2] !== void 0 && (result[key2] = incoming[key2]);
  return result;
}
function updateAbsolutePositions(nodeLookup, parentLookup, options) {
  const _options = mergeObjects(defaultOptions, options);
  for (const node2 of nodeLookup.values())
    if (node2.parentId)
      updateChildNode(node2, nodeLookup, parentLookup, _options);
    else {
      const positionWithOrigin = getNodePositionWithOrigin(node2, _options.nodeOrigin), extent = isCoordinateExtent(node2.extent) ? node2.extent : _options.nodeExtent, clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node2));
      node2.internals.positionAbsolute = clampedPosition;
    }
}
function adoptUserNodes(nodes, nodeLookup, parentLookup, options) {
  const _options = mergeObjects(adoptUserNodesDefaultOptions, options);
  let nodesInitialized = !0;
  const tmpLookup = new Map(nodeLookup), selectedNodeZ = _options?.elevateNodesOnSelect ? 1e3 : 0;
  nodeLookup.clear(), parentLookup.clear();
  for (const userNode of nodes) {
    let internalNode = tmpLookup.get(userNode.id);
    if (_options.checkEquality && userNode === internalNode?.internals.userNode)
      nodeLookup.set(userNode.id, internalNode);
    else {
      const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin), extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent, clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));
      internalNode = {
        ..._options.defaults,
        ...userNode,
        measured: {
          width: userNode.measured?.width,
          height: userNode.measured?.height
        },
        internals: {
          positionAbsolute: clampedPosition,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: userNode.measured ? internalNode?.internals.handleBounds : void 0,
          z: calculateZ(userNode, selectedNodeZ),
          userNode
        }
      }, nodeLookup.set(userNode.id, internalNode);
    }
    (!internalNode.measured || !internalNode.measured.width || !internalNode.measured.height) && !internalNode.hidden && (nodesInitialized = !1), userNode.parentId && updateChildNode(internalNode, nodeLookup, parentLookup, options);
  }
  return nodesInitialized;
}
function updateParentLookup(node2, parentLookup) {
  if (!node2.parentId)
    return;
  const childNodes = parentLookup.get(node2.parentId);
  childNodes ? childNodes.set(node2.id, node2) : parentLookup.set(node2.parentId, /* @__PURE__ */ new Map([[node2.id, node2]]));
}
function updateChildNode(node2, nodeLookup, parentLookup, options) {
  const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options), parentId = node2.parentId, parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  updateParentLookup(node2, parentLookup);
  const selectedNodeZ = elevateNodesOnSelect ? 1e3 : 0, { x: x2, y: y2, z } = calculateChildXYZ(node2, parentNode, nodeOrigin, nodeExtent, selectedNodeZ), { positionAbsolute } = node2.internals, positionChanged = x2 !== positionAbsolute.x || y2 !== positionAbsolute.y;
  (positionChanged || z !== node2.internals.z) && nodeLookup.set(node2.id, {
    ...node2,
    internals: {
      ...node2.internals,
      positionAbsolute: positionChanged ? { x: x2, y: y2 } : positionAbsolute,
      z
    }
  });
}
function calculateZ(node2, selectedNodeZ) {
  return (isNumeric(node2.zIndex) ? node2.zIndex : 0) + (node2.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {
  const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute, childDimensions = getNodeDimensions(childNode), positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin), clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;
  let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);
  childNode.extent === "parent" && (absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode));
  const childZ = calculateZ(childNode, selectedNodeZ), parentZ = parentNode.internals.z ?? 0;
  return {
    x: absolutePosition.x,
    y: absolutePosition.y,
    z: parentZ > childZ ? parentZ : childZ
  };
}
function handleExpandParent(children2, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {
  const changes = [], parentExpansions = /* @__PURE__ */ new Map();
  for (const child of children2) {
    const parent = nodeLookup.get(child.parentId);
    if (!parent)
      continue;
    const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent), expandedRect = getBoundsOfRects(parentRect, child.rect);
    parentExpansions.set(child.parentId, { expandedRect, parent });
  }
  return parentExpansions.size > 0 && parentExpansions.forEach(({ expandedRect, parent }, parentId) => {
    const positionAbsolute = parent.internals.positionAbsolute, dimensions = getNodeDimensions(parent), origin = parent.origin ?? nodeOrigin, xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0, yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0, newWidth = Math.max(dimensions.width, Math.round(expandedRect.width)), newHeight = Math.max(dimensions.height, Math.round(expandedRect.height)), widthChange = (newWidth - dimensions.width) * origin[0], heightChange = (newHeight - dimensions.height) * origin[1];
    (xChange > 0 || yChange > 0 || widthChange || heightChange) && (changes.push({
      id: parentId,
      type: "position",
      position: {
        x: parent.position.x - xChange + widthChange,
        y: parent.position.y - yChange + heightChange
      }
    }), parentLookup.get(parentId)?.forEach((childNode) => {
      children2.some((child) => child.id === childNode.id) || changes.push({
        id: childNode.id,
        type: "position",
        position: {
          x: childNode.position.x + xChange,
          y: childNode.position.y + yChange
        }
      });
    })), (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) && changes.push({
      id: parentId,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
      }
    });
  }), changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {
  const viewportNode = domNode?.querySelector(".xyflow__viewport");
  let updatedInternals = !1;
  if (!viewportNode)
    return { changes: [], updatedInternals };
  const changes = [], style2 = window.getComputedStyle(viewportNode), { m22: zoom2 } = new window.DOMMatrixReadOnly(style2.transform), parentExpandChildren = [];
  for (const update of updates.values()) {
    const node2 = nodeLookup.get(update.id);
    if (!node2)
      continue;
    if (node2.hidden) {
      nodeLookup.set(node2.id, {
        ...node2,
        internals: {
          ...node2.internals,
          handleBounds: void 0
        }
      }), updatedInternals = !0;
      continue;
    }
    const dimensions = getDimensions(update.nodeElement), dimensionChanged = node2.measured.width !== dimensions.width || node2.measured.height !== dimensions.height;
    if (!!(dimensions.width && dimensions.height && (dimensionChanged || !node2.internals.handleBounds || update.force))) {
      const nodeBounds = update.nodeElement.getBoundingClientRect(), extent = isCoordinateExtent(node2.extent) ? node2.extent : nodeExtent;
      let { positionAbsolute } = node2.internals;
      node2.parentId && node2.extent === "parent" ? positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node2.parentId)) : extent && (positionAbsolute = clampPosition(positionAbsolute, extent, dimensions));
      const newNode = {
        ...node2,
        measured: dimensions,
        internals: {
          ...node2.internals,
          positionAbsolute,
          handleBounds: {
            source: getHandleBounds("source", update.nodeElement, nodeBounds, zoom2, node2.id),
            target: getHandleBounds("target", update.nodeElement, nodeBounds, zoom2, node2.id)
          }
        }
      };
      nodeLookup.set(node2.id, newNode), node2.parentId && updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin }), updatedInternals = !0, dimensionChanged && (changes.push({
        id: node2.id,
        type: "dimensions",
        dimensions
      }), node2.expandParent && node2.parentId && parentExpandChildren.push({
        id: node2.id,
        parentId: node2.parentId,
        rect: nodeToRect(newNode, nodeOrigin)
      }));
    }
  }
  if (parentExpandChildren.length > 0) {
    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push(...parentExpandChanges);
  }
  return { changes, updatedInternals };
}
async function panBy({ delta, panZoom, transform: transform2, translateExtent, width, height }) {
  if (!panZoom || !delta.x && !delta.y)
    return Promise.resolve(!1);
  const nextViewport = await panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width, height]
  ], translateExtent), transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return Promise.resolve(transformChanged);
}
function addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {
  let key2 = nodeId;
  const nodeMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
  connectionLookup.set(key2, nodeMap.set(connectionKey, connection)), key2 = `${nodeId}-${type}`;
  const typeMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
  if (connectionLookup.set(key2, typeMap.set(connectionKey, connection)), handleId) {
    key2 = `${nodeId}-${type}-${handleId}`;
    const handleMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
    connectionLookup.set(key2, handleMap.set(connectionKey, connection));
  }
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear(), edgeLookup.clear();
  for (const edge of edges) {
    const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge, connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle }, sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`, targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;
    addConnectionToLookup("source", connection, targetKey, connectionLookup, sourceNode, sourceHandle), addConnectionToLookup("target", connection, sourceKey, connectionLookup, targetNode, targetHandle), edgeLookup.set(edge.id, edge);
  }
}
function isParentSelected(node2, nodeLookup) {
  if (!node2.parentId)
    return !1;
  const parentNode = nodeLookup.get(node2.parentId);
  return parentNode ? parentNode.selected ? !0 : isParentSelected(parentNode, nodeLookup) : !1;
}
function hasSelector(target, selector3, domNode) {
  let current = target;
  do {
    if (current?.matches?.(selector3))
      return !0;
    if (current === domNode)
      return !1;
    current = current?.parentElement;
  } while (current);
  return !1;
}
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  const dragItems = /* @__PURE__ */ new Map();
  for (const [id2, node2] of nodeLookup)
    if ((node2.selected || node2.id === nodeId) && (!node2.parentId || !isParentSelected(node2, nodeLookup)) && (node2.draggable || nodesDraggable && typeof node2.draggable > "u")) {
      const internalNode = nodeLookup.get(id2);
      internalNode && dragItems.set(id2, {
        id: id2,
        position: internalNode.position || { x: 0, y: 0 },
        distance: {
          x: mousePos.x - internalNode.internals.positionAbsolute.x,
          y: mousePos.y - internalNode.internals.positionAbsolute.y
        },
        extent: internalNode.extent,
        parentId: internalNode.parentId,
        origin: internalNode.origin,
        expandParent: internalNode.expandParent,
        internals: {
          positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: internalNode.measured.width ?? 0,
          height: internalNode.measured.height ?? 0
        }
      });
    }
  return dragItems;
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = !0 }) {
  const nodesFromDragItems = [];
  for (const [id2, dragItem] of dragItems) {
    const node22 = nodeLookup.get(id2)?.internals.userNode;
    node22 && nodesFromDragItems.push({
      ...node22,
      position: dragItem.position,
      dragging
    });
  }
  if (!nodeId)
    return [nodesFromDragItems[0], nodesFromDragItems];
  const node2 = nodeLookup.get(nodeId)?.internals.userNode;
  return [
    node2 ? {
      ...node2,
      position: dragItems.get(nodeId)?.position || node2.position,
      dragging
    } : nodesFromDragItems[0],
    nodesFromDragItems
  ];
}
function XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null }, autoPanId = 0, dragItems = /* @__PURE__ */ new Map(), autoPanStarted = !1, mousePosition = { x: 0, y: 0 }, containerBounds = null, dragStarted = !1, d3Selection = null, abortDrag = !1;
  function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {
    d3Selection = select$1(domNode);
    function updateNodes2({ x: x2, y: y2 }, dragEvent) {
      const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x: x2, y: y2 };
      let hasChange = !1, nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };
      if (dragItems.size > 1 && nodeExtent) {
        const rect = getInternalNodesBounds(dragItems);
        nodesBox = rectToBox(rect);
      }
      for (const [id2, dragItem] of dragItems) {
        if (!nodeLookup.has(id2))
          continue;
        let nextPosition = { x: x2 - dragItem.distance.x, y: y2 - dragItem.distance.y };
        snapToGrid && (nextPosition = snapPosition(nextPosition, snapGrid));
        let adjustedNodeExtent = [
          [nodeExtent[0][0], nodeExtent[0][1]],
          [nodeExtent[1][0], nodeExtent[1][1]]
        ];
        if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {
          const { positionAbsolute: positionAbsolute2 } = dragItem.internals, x1 = positionAbsolute2.x - nodesBox.x + nodeExtent[0][0], x22 = positionAbsolute2.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0], y1 = positionAbsolute2.y - nodesBox.y + nodeExtent[0][1], y22 = positionAbsolute2.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
          adjustedNodeExtent = [
            [x1, y1],
            [x22, y22]
          ];
        }
        const { position, positionAbsolute } = calculateNodePosition({
          nodeId: id2,
          nextPosition,
          nodeLookup,
          nodeExtent: adjustedNodeExtent,
          nodeOrigin,
          onError
        });
        hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y, dragItem.position = position, dragItem.internals.positionAbsolute = positionAbsolute;
      }
      if (hasChange && (updateNodePositions(dragItems, !0), dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag))) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag?.(dragEvent, dragItems, currentNode, currentNodes), onNodeDrag?.(dragEvent, currentNode, currentNodes), nodeId || onSelectionDrag?.(dragEvent, currentNodes);
      }
    }
    async function autoPan() {
      if (!containerBounds)
        return;
      const { transform: transform2, panBy: panBy2, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();
      if (!autoPanOnNodeDrag) {
        autoPanStarted = !1, cancelAnimationFrame(autoPanId);
        return;
      }
      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);
      (xMovement !== 0 || yMovement !== 0) && (lastPos.x = (lastPos.x ?? 0) - xMovement / transform2[2], lastPos.y = (lastPos.y ?? 0) - yMovement / transform2[2], await panBy2({ x: xMovement, y: yMovement }) && updateNodes2(lastPos, null)), autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event) {
      const { nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = !0, (!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId && (nodeLookup.get(nodeId)?.selected || unselectNodesAndEdges()), isSelectable && selectNodesOnDrag && nodeId && onNodeMouseDown?.(nodeId);
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      if (lastPos = pointerPos, dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId), dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes), onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes), nodeId || onSelectionDragStart?.(event.sourceEvent, currentNodes);
      }
    }
    const d3DragInstance = drag().clickDistance(nodeClickDistance).on("start", (event) => {
      const { domNode: domNode2, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      containerBounds = domNode2?.getBoundingClientRect() || null, abortDrag = !1, nodeDragThreshold === 0 && startDrag(event), lastPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds }), mousePosition = getEventPosition(event.sourceEvent, containerBounds);
    }).on("drag", (event) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems(), pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      if ((event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      nodeId && !nodeLookup.has(nodeId)) && (abortDrag = !0), !abortDrag) {
        if (!autoPanStarted && autoPanOnNodeDrag && dragStarted && (autoPanStarted = !0, autoPan()), !dragStarted) {
          const x2 = pointerPos.xSnapped - (lastPos.x ?? 0), y2 = pointerPos.ySnapped - (lastPos.y ?? 0);
          Math.sqrt(x2 * x2 + y2 * y2) > nodeDragThreshold && startDrag(event);
        }
        (lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted && (mousePosition = getEventPosition(event.sourceEvent, containerBounds), updateNodes2(pointerPos, event.sourceEvent));
      }
    }).on("end", (event) => {
      if (!(!dragStarted || abortDrag) && (autoPanStarted = !1, dragStarted = !1, cancelAnimationFrame(autoPanId), dragItems.size > 0)) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        if (updateNodePositions(dragItems, !1), onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup,
            dragging: !1
          });
          onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes), onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes), nodeId || onSelectionDragStop?.(event.sourceEvent, currentNodes);
        }
      }
    }).filter((event) => {
      const target = event.target;
      return !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection?.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getNodesWithinDistance(position, nodeLookup, distance2) {
  const nodes = [], rect = {
    x: position.x - distance2,
    y: position.y - distance2,
    width: distance2 * 2,
    height: distance2 * 2
  };
  for (const node2 of nodeLookup.values())
    getOverlappingArea(rect, nodeToRect(node2)) > 0 && nodes.push(node2);
  return nodes;
}
const ADDITIONAL_DISTANCE = 250;
function getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {
  let closestHandles = [], minDistance = 1 / 0;
  const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);
  for (const node2 of closeNodes) {
    const allHandles = [...node2.internals.handleBounds?.source ?? [], ...node2.internals.handleBounds?.target ?? []];
    for (const handle of allHandles) {
      if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id)
        continue;
      const { x: x2, y: y2 } = getHandlePosition(node2, handle, handle.position, !0), distance2 = Math.sqrt(Math.pow(x2 - position.x, 2) + Math.pow(y2 - position.y, 2));
      distance2 > connectionRadius || (distance2 < minDistance ? (closestHandles = [{ ...handle, x: x2, y: y2 }], minDistance = distance2) : distance2 === minDistance && closestHandles.push({ ...handle, x: x2, y: y2 }));
    }
  }
  if (!closestHandles.length)
    return null;
  if (closestHandles.length > 1) {
    const oppositeHandleType = fromHandle.type === "source" ? "target" : "source";
    return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];
  }
  return closestHandles[0];
}
function getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = !1) {
  const node2 = nodeLookup.get(nodeId);
  if (!node2)
    return null;
  const handles = connectionMode === "strict" ? node2.internals.handleBounds?.[handleType] : [...node2.internals.handleBounds?.source ?? [], ...node2.internals.handleBounds?.target ?? []], handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;
  return handle && withAbsolutePosition ? { ...handle, ...getHandlePosition(node2, handle, handle.position, !0) } : handle;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  return edgeUpdaterType || (handleDomNode?.classList.contains("target") ? "target" : handleDomNode?.classList.contains("source") ? "source" : null);
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  let isValid = null;
  return isHandleValid ? isValid = !0 : isInsideConnectionRadius && !isHandleValid && (isValid = !1), isValid;
}
const alwaysValid = () => !0;
function onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib: lib2, autoPanOnConnect, flowId, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed }) {
  const doc = getHostForElement(event.target);
  let autoPanId = 0, closestHandle;
  const { x: x2, y: y2 } = getEventPosition(event), clickedHandle = doc?.elementFromPoint(x2, y2), handleType = getHandleType(edgeUpdaterType, clickedHandle), containerBounds = domNode?.getBoundingClientRect();
  if (!containerBounds || !handleType)
    return;
  const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);
  if (!fromHandleInternal)
    return;
  let position = getEventPosition(event, containerBounds), autoPanStarted = !1, connection = null, isValid = !1, handleDomNode = null;
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds)
      return;
    const [x22, y22] = calcAutoPan(position, containerBounds, autoPanSpeed);
    panBy2({ x: x22, y: y22 }), autoPanId = requestAnimationFrame(autoPan);
  }
  const fromHandle = {
    ...fromHandleInternal,
    nodeId,
    type: handleType,
    position: fromHandleInternal.position
  }, fromNodeInternal = nodeLookup.get(nodeId), newConnection = {
    inProgress: !0,
    isValid: null,
    from: getHandlePosition(fromNodeInternal, fromHandle, Position.Left, !0),
    fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromNodeInternal,
    to: position,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null
  };
  updateConnection(newConnection);
  let previousConnection = newConnection;
  onConnectStart?.(event, { nodeId, handleId, handleType });
  function onPointerMove(event2) {
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event2);
      return;
    }
    const transform2 = getTransform();
    position = getEventPosition(event2, containerBounds), closestHandle = getClosestHandle(pointToRendererPoint(position, transform2, !1, [1, 1]), connectionRadius, nodeLookup, fromHandle), autoPanStarted || (autoPan(), autoPanStarted = !0);
    const result = isValidHandle(event2, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib: lib2,
      flowId,
      nodeLookup
    });
    handleDomNode = result.handleDomNode, connection = result.connection, isValid = isConnectionValid(!!closestHandle, result.isValid);
    const newConnection2 = {
      // from stays the same
      ...previousConnection,
      isValid,
      to: closestHandle && isValid ? rendererPointToPoint({ x: closestHandle.x, y: closestHandle.y }, transform2) : position,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null
    };
    isValid && closestHandle && previousConnection.toHandle && newConnection2.toHandle && previousConnection.toHandle.type === newConnection2.toHandle.type && previousConnection.toHandle.nodeId === newConnection2.toHandle.nodeId && previousConnection.toHandle.id === newConnection2.toHandle.id && previousConnection.to.x === newConnection2.to.x && previousConnection.to.y === newConnection2.to.y || (updateConnection(newConnection2), previousConnection = newConnection2);
  }
  function onPointerUp(event2) {
    (closestHandle || handleDomNode) && connection && isValid && onConnect?.(connection);
    const { inProgress, ...connectionState } = previousConnection, finalConnectionState = {
      ...connectionState,
      toPosition: previousConnection.toHandle ? previousConnection.toPosition : null
    };
    onConnectEnd?.(event2, finalConnectionState), edgeUpdaterType && onReconnectEnd?.(event2, finalConnectionState), cancelConnection(), cancelAnimationFrame(autoPanId), autoPanStarted = !1, isValid = !1, connection = null, handleDomNode = null, doc.removeEventListener("mousemove", onPointerMove), doc.removeEventListener("mouseup", onPointerUp), doc.removeEventListener("touchmove", onPointerMove), doc.removeEventListener("touchend", onPointerUp);
  }
  doc.addEventListener("mousemove", onPointerMove), doc.addEventListener("mouseup", onPointerUp), doc.addEventListener("touchmove", onPointerMove), doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib: lib2, flowId, isValidConnection = alwaysValid, nodeLookup }) {
  const isTarget = fromType === "target", handleDomNode = handle ? doc.querySelector(`.${lib2}-flow__handle[data-id="${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}"]`) : null, { x: x2, y: y2 } = getEventPosition(event), handleBelow = doc.elementFromPoint(x2, y2), handleToCheck = handleBelow?.classList.contains(`${lib2}-flow__handle`) ? handleBelow : handleDomNode, result = {
    handleDomNode: handleToCheck,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck), handleNodeId = handleToCheck.getAttribute("data-nodeid"), handleId = handleToCheck.getAttribute("data-handleid"), connectable = handleToCheck.classList.contains("connectable"), connectableEnd = handleToCheck.classList.contains("connectableend");
    if (!handleNodeId || !handleType)
      return result;
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isValid = connectable && connectableEnd && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection), result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, !1);
  }
  return result;
}
const XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection2 = select$1(domNode);
  function update({ translateExtent, width, height, zoomStep = 10, pannable = !0, zoomable = !0, inversePan = !1 }) {
    const zoomHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "wheel" || !panZoom)
        return;
      const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep, nextZoom = transform2[2] * Math.pow(2, pinchDelta);
      panZoom.scaleTo(nextZoom);
    };
    let panStart = [0, 0];
    const panStartHandler = (event) => {
      (event.sourceEvent.type === "mousedown" || event.sourceEvent.type === "touchstart") && (panStart = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ]);
    }, panHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "mousemove" && event.sourceEvent.type !== "touchmove" || !panZoom)
        return;
      const panCurrent = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ], panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      const moveScale = getViewScale() * Math.max(transform2[2], Math.log(transform2[2])) * (inversePan ? -1 : 1), position = {
        x: transform2[0] - panDelta[0] * moveScale,
        y: transform2[1] - panDelta[1] * moveScale
      }, extent = [
        [0, 0],
        [width, height]
      ];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    }, zoomAndPanHandler = zoom().on("start", panStartHandler).on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection2.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection2.on("zoom", null);
  }
  return {
    update,
    destroy,
    pointer
  };
}
const viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k, transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
}), viewportToTransform = ({ x: x2, y: y2, zoom: zoom2 }) => identity$1.translate(x2, y2).scale(zoom2), isWrappedWithClass = (event, className) => event.target.closest(`.${className}`), isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2), getD3Transition = (selection2, duration = 0, onEnd = () => {
}) => {
  const hasDuration = typeof duration == "number" && duration > 0;
  return hasDuration || onEnd(), hasDuration ? selection2.transition().duration(duration).on("end", onEnd) : selection2;
}, wheelDelta = (event) => {
  const factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event) => {
    if (isWrappedWithClass(event, noWheelClassName))
      return !1;
    event.preventDefault(), event.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    if (event.ctrlKey && zoomOnPinch) {
      const point2 = pointer(event), pinchDelta = wheelDelta(event), zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point2, event);
      return;
    }
    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize, deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
    !isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical && (deltaX = event.deltaY * deltaNormalize, deltaY = 0), d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: !0 }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout), zoomPanValues.isPanScrolling || (zoomPanValues.isPanScrolling = !0, onPanZoomStart?.(event, nextViewport)), zoomPanValues.isPanScrolling && (onPanZoom?.(event, nextViewport), zoomPanValues.panScrollTimeout = setTimeout(() => {
      onPanZoomEnd?.(event, nextViewport), zoomPanValues.isPanScrolling = !1;
    }, 150));
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event, d2) {
    const isWheel = event.type === "wheel", preventZoom = !preventScrolling && isWheel && !event.ctrlKey, hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);
    if (event.ctrlKey && isWheel && hasNoWheelClass && event.preventDefault(), preventZoom || hasNoWheelClass)
      return null;
    event.preventDefault(), d3ZoomHandler.call(this, event, d2);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event) => {
    if (event.sourceEvent?.internal)
      return;
    const viewport = transformToViewport(event.transform);
    zoomPanValues.mouseButton = event.sourceEvent?.button || 0, zoomPanValues.isZoomingOrPanning = !0, zoomPanValues.prevViewport = viewport, event.sourceEvent?.type === "mousedown" && onDraggingChange(!0), onPanZoomStart && onPanZoomStart?.(event.sourceEvent, viewport);
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event) => {
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0)), event.sourceEvent?.sync || onTransformChange([event.transform.x, event.transform.y, event.transform.k]), onPanZoom && !event.sourceEvent?.internal && onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event) => {
    if (!event.sourceEvent?.internal && (zoomPanValues.isZoomingOrPanning = !1, onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent && onPaneContextMenu(event.sourceEvent), zoomPanValues.usedRightMouseButton = !1, onDraggingChange(!1), onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform))) {
      const viewport = transformToViewport(event.transform);
      zoomPanValues.prevViewport = viewport, clearTimeout(zoomPanValues.timerId), zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd?.(event.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib: lib2 }) {
  return (event) => {
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll, pinchZoom = zoomOnPinch && event.ctrlKey;
    if (event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, `${lib2}-flow__node`) || isWrappedWithClass(event, `${lib2}-flow__edge`)))
      return !0;
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch || userSelectionActive || isWrappedWithClass(event, noWheelClassName) && event.type === "wheel" || isWrappedWithClass(event, noPanClassName) && (event.type !== "wheel" || panOnScroll && event.type === "wheel" && !zoomActivationKeyPressed) || !zoomOnPinch && event.ctrlKey && event.type === "wheel")
      return !1;
    if (!zoomOnPinch && event.type === "touchstart" && event.touches?.length > 1)
      return event.preventDefault(), !1;
    if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === "wheel" || !panOnDrag && (event.type === "mousedown" || event.type === "touchstart") || Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === "mousedown")
      return !1;
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
    return (!event.ctrlKey || event.type === "wheel") && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, bbox = domNode.getBoundingClientRect(), d3ZoomInstance = zoom().clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance).scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent), d3Selection = select$1(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom"), d3DblClickZoomHandler = d3Selection.on("dblclick.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.transform(getD3Transition(d3Selection, options?.duration, () => resolve(!0)), transform2);
    }) : Promise.resolve(!1);
  }
  function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib: lib2, onTransformChange }) {
    userSelectionActive && !zoomPanValues.isZoomingOrPanning && destroy();
    const wheelHandler = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    if (d3Selection.on("wheel.zoom", wheelHandler, { passive: !1 }), !userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter2 = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib: lib2
    });
    d3ZoomInstance.filter(filter2), zoomOnDoubleClick ? d3Selection.on("dblclick.zoom", d3DblClickZoomHandler) : d3Selection.on("dblclick.zoom", null);
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  async function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2), contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent2);
    return contrainedTransform && await setTransform(contrainedTransform), new Promise((resolve) => resolve(contrainedTransform));
  }
  async function setViewport(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    return await setTransform(nextTransform, options), new Promise((resolve) => resolve(nextTransform));
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2), currentTransform = d3Selection.property("__zoom");
      (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) && d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: !0 });
    }
  }
  function getViewport() {
    const transform$1 = d3Selection ? transform(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform$1.x, y: transform$1.y, zoom: transform$1.k };
  }
  function scaleTo(zoom2, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.scaleTo(getD3Transition(d3Selection, options?.duration, () => resolve(!0)), zoom2);
    }) : Promise.resolve(!1);
  }
  function scaleBy(factor, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.scaleBy(getD3Transition(d3Selection, options?.duration, () => resolve(!0)), factor);
    }) : Promise.resolve(!1);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance?.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance?.translateExtent(translateExtent2);
  }
  function setClickDistance(distance2) {
    const validDistance = !isNumeric(distance2) || distance2 < 0 ? 0 : distance2;
    d3ZoomInstance?.clickDistance(validDistance);
  }
  return {
    update,
    destroy,
    setViewport,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport,
    setClickDistance
  };
}
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2.Line = "line", ResizeControlVariant2.Handle = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
function getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY }) {
  const deltaWidth = width - prevWidth, deltaHeight = height - prevHeight, direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  return deltaWidth && affectsX && (direction[0] = direction[0] * -1), deltaHeight && affectsY && (direction[1] = direction[1] * -1), direction;
}
function getControlDirection(controlPosition) {
  const isHorizontal = controlPosition.includes("right") || controlPosition.includes("left"), isVertical = controlPosition.includes("bottom") || controlPosition.includes("top"), affectsX = controlPosition.includes("left"), affectsY = controlPosition.includes("top");
  return {
    isHorizontal,
    isVertical,
    affectsX,
    affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size2, minSize, maxSize) {
  return Math.max(0, minSize - size2, size2 - maxSize);
}
function xor(a2, b2) {
  return a2 ? !b2 : b2;
}
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  let { affectsX, affectsY } = controlDirection;
  const { isHorizontal, isVertical } = controlDirection, isDiagonal = isHorizontal && isVertical, { xSnapped, ySnapped } = pointerPosition, { minWidth, maxWidth, minHeight, maxHeight } = boundaries, { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio: aspectRatio2 } = startValues;
  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0), distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  const newWidth = startWidth + (affectsX ? -distX : distX), newHeight = startHeight + (affectsY ? -distY : distY), originOffsetX = -nodeOrigin[0] * startWidth, originOffsetY = -nodeOrigin[1] * startHeight;
  let clampX = getSizeClamp(newWidth, minWidth, maxWidth), clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  if (extent) {
    let xExtentClamp = 0, yExtentClamp = 0;
    affectsX && distX < 0 ? xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]) : !affectsX && distX > 0 && (xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0])), affectsY && distY < 0 ? yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]) : !affectsY && distY > 0 && (yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1])), clampX = Math.max(clampX, xExtentClamp), clampY = Math.max(clampY, yExtentClamp);
  }
  if (childExtent) {
    let xExtentClamp = 0, yExtentClamp = 0;
    affectsX && distX > 0 ? xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]) : !affectsX && distX < 0 && (xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0])), affectsY && distY > 0 ? yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]) : !affectsY && distY < 0 && (yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1])), clampX = Math.max(clampX, xExtentClamp), clampY = Math.max(clampY, yExtentClamp);
  }
  if (keepAspectRatio) {
    if (isHorizontal) {
      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio2, minHeight, maxHeight) * aspectRatio2;
      if (clampX = Math.max(clampX, aspectHeightClamp), extent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsX && !affectsY && isDiagonal ? aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio2, extent[1][1]) * aspectRatio2 : aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio2, extent[0][1]) * aspectRatio2, clampX = Math.max(clampX, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsX && !affectsY && isDiagonal ? aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio2, childExtent[1][1]) * aspectRatio2 : aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio2, childExtent[0][1]) * aspectRatio2, clampX = Math.max(clampX, aspectExtentClamp);
      }
    }
    if (isVertical) {
      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio2, minWidth, maxWidth) / aspectRatio2;
      if (clampY = Math.max(clampY, aspectWidthClamp), extent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsY && !affectsX && isDiagonal ? aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio2 + originOffsetX, extent[1][0]) / aspectRatio2 : aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio2 + originOffsetX, extent[0][0]) / aspectRatio2, clampY = Math.max(clampY, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsY && !affectsX && isDiagonal ? aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio2, childExtent[1][0]) / aspectRatio2 : aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio2, childExtent[0][0]) / aspectRatio2, clampY = Math.max(clampY, aspectExtentClamp);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY), distX = distX + (distX < 0 ? clampX : -clampX), keepAspectRatio && (isDiagonal ? newWidth > newHeight * aspectRatio2 ? distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio2 : distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio2 : isHorizontal ? (distY = distX / aspectRatio2, affectsY = affectsX) : (distX = distY * aspectRatio2, affectsX = affectsY));
  const x2 = affectsX ? startX + distX : startX, y2 = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (affectsX ? -1 : 1) + x2,
    y: nodeOrigin[1] * distY * (affectsY ? -1 : 1) + y2
  };
}
const initPrevValues$1 = { width: 0, height: 0, x: 0, y: 0 }, initStartValues = {
  ...initPrevValues$1,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function nodeToParentExtent(node2) {
  return [
    [0, 0],
    [node2.measured.width, node2.measured.height]
  ];
}
function nodeToChildExtent(child, parent, nodeOrigin) {
  const x2 = parent.position.x + child.position.x, y2 = parent.position.y + child.position.y, width = child.measured.width ?? 0, height = child.measured.height ?? 0, originOffsetX = nodeOrigin[0] * width, originOffsetY = nodeOrigin[1] * height;
  return [
    [x2 - originOffsetX, y2 - originOffsetY],
    [x2 + width - originOffsetX, y2 + height - originOffsetY]
  ];
}
function XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {
  const selection2 = select$1(domNode);
  function update({ controlPosition, boundaries, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize }) {
    let prevValues = { ...initPrevValues$1 }, startValues = { ...initStartValues };
    const controlDirection = getControlDirection(controlPosition);
    let node2, containerBounds = null, childNodes = [], parentNode, parentExtent, childExtent;
    const dragHandler = drag().on("start", (event) => {
      const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();
      if (node2 = nodeLookup.get(nodeId), !node2)
        return;
      containerBounds = paneDomNode?.getBoundingClientRect() ?? null;
      const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      });
      prevValues = {
        width: node2.measured.width ?? 0,
        height: node2.measured.height ?? 0,
        x: node2.position.x ?? 0,
        y: node2.position.y ?? 0
      }, startValues = {
        ...prevValues,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      }, parentNode = void 0, node2.parentId && (node2.extent === "parent" || node2.expandParent) && (parentNode = nodeLookup.get(node2.parentId), parentExtent = parentNode && node2.extent === "parent" ? nodeToParentExtent(parentNode) : void 0), childNodes = [], childExtent = void 0;
      for (const [childId, child] of nodeLookup)
        if (child.parentId === nodeId && (childNodes.push({
          id: childId,
          position: { ...child.position },
          extent: child.extent
        }), child.extent === "parent" || child.expandParent)) {
          const extent = nodeToChildExtent(child, node2, child.origin ?? nodeOrigin);
          childExtent ? childExtent = [
            [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],
            [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]
          ] : childExtent = extent;
        }
      onResizeStart?.(event, { ...prevValues });
    }).on("drag", (event) => {
      const { transform: transform2, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems(), pointerPosition = getPointerPosition(event.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      }), childChanges = [];
      if (!node2)
        return;
      const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues, change = {}, nodeOrigin = node2.origin ?? storeNodeOrigin, { width, height, x: x2, y: y2 } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent), isWidthChange = width !== prevWidth, isHeightChange = height !== prevHeight, isXPosChange = x2 !== prevX && isWidthChange, isYPosChange = y2 !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange)
        return;
      if ((isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) && (change.x = isXPosChange ? x2 : prevValues.x, change.y = isYPosChange ? y2 : prevValues.y, prevValues.x = change.x, prevValues.y = change.y, childNodes.length > 0)) {
        const xChange = x2 - prevX, yChange = y2 - prevY;
        for (const childNode of childNodes)
          childNode.position = {
            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),
            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
          }, childChanges.push(childNode);
      }
      if ((isWidthChange || isHeightChange) && (change.width = isWidthChange ? width : prevValues.width, change.height = isHeightChange ? height : prevValues.height, prevValues.width = change.width, prevValues.height = change.height), parentNode && node2.expandParent) {
        const xLimit = nodeOrigin[0] * (change.width ?? 0);
        change.x && change.x < xLimit && (prevValues.x = xLimit, startValues.x = startValues.x - (change.x - xLimit));
        const yLimit = nodeOrigin[1] * (change.height ?? 0);
        change.y && change.y < yLimit && (prevValues.y = yLimit, startValues.y = startValues.y - (change.y - yLimit));
      }
      const direction = getResizeDirection({
        width: prevValues.width,
        prevWidth,
        height: prevValues.height,
        prevHeight,
        affectsX: controlDirection.affectsX,
        affectsY: controlDirection.affectsY
      }), nextValues = { ...prevValues, direction };
      shouldResize?.(event, nextValues) !== !1 && (onResize?.(event, nextValues), onChange(change, childChanges));
    }).on("end", (event) => {
      onResizeEnd?.(event, { ...prevValues }), onEnd?.({ ...prevValues });
    });
    selection2.call(dragHandler);
  }
  function destroy() {
    selection2.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
const __vite_import_meta_env__ = {}, createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set(), setState = (partial, replace) => {
    const nextState = typeof partial == "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = replace ?? (typeof nextState != "object" || nextState === null) ? nextState : Object.assign({}, state, nextState), listeners.forEach((listener) => listener(state, previousState));
    }
  }, getState = () => state, api = { setState, getState, getInitialState: () => initialState, subscribe: (listener) => (listeners.add(listener), () => listeners.delete(listener)), destroy: () => {
    (__vite_import_meta_env__ ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), listeners.clear();
  } }, initialState = state = createState2(setState, getState, api);
  return api;
}, createStore$1 = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl, { useDebugValue } = React__default, { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports, identity = (arg) => arg;
function useStoreWithEqualityFn(api, selector3 = identity, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector3,
    equalityFn
  );
  return useDebugValue(slice), slice;
}
const createWithEqualityFnImpl = (createState2, defaultEqualityFn) => {
  const api = createStore$1(createState2), useBoundStoreWithEqualityFn = (selector3, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector3, equalityFn);
  return Object.assign(useBoundStoreWithEqualityFn, api), useBoundStoreWithEqualityFn;
}, createWithEqualityFn = (createState2, defaultEqualityFn) => createState2 ? createWithEqualityFnImpl(createState2, defaultEqualityFn) : createWithEqualityFnImpl;
function shallow$1(objA, objB) {
  if (Object.is(objA, objB))
    return !0;
  if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
    return !1;
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return !1;
    for (const [key2, value] of objA)
      if (!Object.is(value, objB.get(key2)))
        return !1;
    return !0;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return !1;
    for (const value of objA)
      if (!objB.has(value))
        return !1;
    return !0;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length)
    return !1;
  for (const keyA of keysA)
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA]))
      return !1;
  return !0;
}
const StoreContext = createContext(null), Provider$1 = StoreContext.Provider, zustandErrorMessage = errorMessages.error001();
function useStore$1(selector22, equalityFn) {
  const store = useContext(StoreContext);
  if (store === null)
    throw new Error(zustandErrorMessage);
  return useStoreWithEqualityFn(store, selector22, equalityFn);
}
function useStoreApi() {
  const store = useContext(StoreContext);
  if (store === null)
    throw new Error(zustandErrorMessage);
  return useMemo(() => ({
    getState: store.getState,
    setState: store.setState,
    subscribe: store.subscribe
  }), [store]);
}
const style$1 = { display: "none" }, ariaLiveStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, ARIA_NODE_DESC_KEY = "react-flow__node-desc", ARIA_EDGE_DESC_KEY = "react-flow__edge-desc", ARIA_LIVE_MESSAGE = "react-flow__aria-live", selector$o = (s2) => s2.ariaLiveMessage;
function AriaLiveMessage({ rfId }) {
  const ariaLiveMessage = useStore$1(selector$o);
  return jsx("div", { id: `${ARIA_LIVE_MESSAGE}-${rfId}`, "aria-live": "assertive", "aria-atomic": "true", style: ariaLiveStyle, children: ariaLiveMessage });
}
function A11yDescriptions({ rfId, disableKeyboardA11y }) {
  return jsxs(Fragment$1, { children: [jsxs("div", { id: `${ARIA_NODE_DESC_KEY}-${rfId}`, style: style$1, children: ["Press enter or space to select a node.", !disableKeyboardA11y && "You can then use the arrow keys to move the node around.", " Press delete to remove it and escape to cancel.", " "] }), jsx("div", { id: `${ARIA_EDGE_DESC_KEY}-${rfId}`, style: style$1, children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel." }), !disableKeyboardA11y && jsx(AriaLiveMessage, { rfId })] });
}
const selector$n = (s2) => s2.userSelectionActive ? "none" : "all", Panel = forwardRef(({ position = "top-left", children: children2, className, style: style2, ...rest }, ref) => {
  const pointerEvents = useStore$1(selector$n), positionClasses = `${position}`.split("-");
  return jsx("div", { className: cc(["react-flow__panel", className, ...positionClasses]), style: { ...style2, pointerEvents }, ref, ...rest, children: children2 });
});
Panel.displayName = "Panel";
function Attribution({ proOptions, position = "bottom-right" }) {
  return proOptions?.hideAttribution ? null : jsx(Panel, { position, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const selector$m = (s2) => {
  const selectedNodes = [], selectedEdges = [];
  for (const [, node2] of s2.nodeLookup)
    node2.selected && selectedNodes.push(node2.internals.userNode);
  for (const [, edge] of s2.edgeLookup)
    edge.selected && selectedEdges.push(edge);
  return { selectedNodes, selectedEdges };
}, selectId = (obj) => obj.id;
function areEqual(a2, b2) {
  return shallow$1(a2.selectedNodes.map(selectId), b2.selectedNodes.map(selectId)) && shallow$1(a2.selectedEdges.map(selectId), b2.selectedEdges.map(selectId));
}
function SelectionListenerInner({ onSelectionChange }) {
  const store = useStoreApi(), { selectedNodes, selectedEdges } = useStore$1(selector$m, areEqual);
  return useEffect(() => {
    const params = { nodes: selectedNodes, edges: selectedEdges };
    onSelectionChange?.(params), store.getState().onSelectionChangeHandlers.forEach((fn) => fn(params));
  }, [selectedNodes, selectedEdges, onSelectionChange]), null;
}
const changeSelector = (s2) => !!s2.onSelectionChangeHandlers;
function SelectionListener({ onSelectionChange }) {
  const storeHasSelectionChangeHandlers = useStore$1(changeSelector);
  return onSelectionChange || storeHasSelectionChangeHandlers ? jsx(SelectionListenerInner, { onSelectionChange }) : null;
}
const defaultNodeOrigin = [0, 0], defaultViewport = { x: 0, y: 0, zoom: 1 }, reactFlowFieldsToTrack = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance"
], fieldsToTrack = [...reactFlowFieldsToTrack, "rfId"], selector$l = (s2) => ({
  setNodes: s2.setNodes,
  setEdges: s2.setEdges,
  setMinZoom: s2.setMinZoom,
  setMaxZoom: s2.setMaxZoom,
  setTranslateExtent: s2.setTranslateExtent,
  setNodeExtent: s2.setNodeExtent,
  reset: s2.reset,
  setDefaultNodesAndEdges: s2.setDefaultNodesAndEdges,
  setPaneClickDistance: s2.setPaneClickDistance
}), initPrevValues = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: infiniteExtent,
  nodeOrigin: defaultNodeOrigin,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function StoreUpdater(props) {
  const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore$1(selector$l, shallow$1), store = useStoreApi();
  useEffect(() => (setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges), () => {
    previousFields.current = initPrevValues, reset();
  }), []);
  const previousFields = useRef(initPrevValues);
  return useEffect(
    () => {
      for (const fieldName of fieldsToTrack) {
        const fieldValue = props[fieldName], previousFieldValue = previousFields.current[fieldName];
        fieldValue !== previousFieldValue && (typeof props[fieldName] > "u" || (fieldName === "nodes" ? setNodes(fieldValue) : fieldName === "edges" ? setEdges(fieldValue) : fieldName === "minZoom" ? setMinZoom(fieldValue) : fieldName === "maxZoom" ? setMaxZoom(fieldValue) : fieldName === "translateExtent" ? setTranslateExtent(fieldValue) : fieldName === "nodeExtent" ? setNodeExtent(fieldValue) : fieldName === "paneClickDistance" ? setPaneClickDistance(fieldValue) : fieldName === "fitView" ? store.setState({ fitViewQueued: fieldValue }) : fieldName === "fitViewOptions" ? store.setState({ fitViewOptions: fieldValue }) : store.setState({ [fieldName]: fieldValue })));
      }
      previousFields.current = props;
    },
    // Only re-run the effect if one of the fields we track changes
    fieldsToTrack.map((fieldName) => props[fieldName])
  ), null;
}
function getMediaQuery() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function useColorModeClass(colorMode) {
  const [colorModeClass, setColorModeClass] = useState(colorMode === "system" ? null : colorMode);
  return useEffect(() => {
    if (colorMode !== "system") {
      setColorModeClass(colorMode);
      return;
    }
    const mediaQuery = getMediaQuery(), updateColorModeClass = () => setColorModeClass(mediaQuery?.matches ? "dark" : "light");
    return updateColorModeClass(), mediaQuery?.addEventListener("change", updateColorModeClass), () => {
      mediaQuery?.removeEventListener("change", updateColorModeClass);
    };
  }, [colorMode]), colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? "dark" : "light";
}
const defaultDoc = typeof document < "u" ? document : null;
function useKeyPress(keyCode = null, options = { target: defaultDoc, actInsideInputWithModifier: !0 }) {
  const [keyPressed, setKeyPressed] = useState(!1), modifierPressed = useRef(!1), pressedKeys = useRef(/* @__PURE__ */ new Set([])), [keyCodes, keysToWatch] = useMemo(() => {
    if (keyCode !== null) {
      const keys2 = (Array.isArray(keyCode) ? keyCode : [keyCode]).filter((kc) => typeof kc == "string").map((kc) => kc.replace("+", `
`).replace(`

`, `
+`).split(`
`)), keysFlat = keys2.reduce((res, item) => res.concat(...item), []);
      return [keys2, keysFlat];
    }
    return [[], []];
  }, [keyCode]);
  return useEffect(() => {
    const target = options?.target || defaultDoc;
    if (keyCode !== null) {
      const downHandler = (event) => {
        if (modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey, (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event))
          return !1;
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        if (pressedKeys.current.add(event[keyOrCode]), isMatchingKey(keyCodes, pressedKeys.current, !1)) {
          const target2 = event.composedPath?.()?.[0] || event.target, isInteractiveElement = target2?.nodeName === "BUTTON" || target2?.nodeName === "A";
          options.preventDefault !== !1 && (modifierPressed.current || !isInteractiveElement) && event.preventDefault(), setKeyPressed(!0);
        }
      }, upHandler = (event) => {
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        isMatchingKey(keyCodes, pressedKeys.current, !0) ? (setKeyPressed(!1), pressedKeys.current.clear()) : pressedKeys.current.delete(event[keyOrCode]), event.key === "Meta" && pressedKeys.current.clear(), modifierPressed.current = !1;
      }, resetHandler = () => {
        pressedKeys.current.clear(), setKeyPressed(!1);
      };
      return target?.addEventListener("keydown", downHandler), target?.addEventListener("keyup", upHandler), window.addEventListener("blur", resetHandler), window.addEventListener("contextmenu", resetHandler), () => {
        target?.removeEventListener("keydown", downHandler), target?.removeEventListener("keyup", upHandler), window.removeEventListener("blur", resetHandler), window.removeEventListener("contextmenu", resetHandler);
      };
    }
  }, [keyCode, setKeyPressed]), keyPressed;
}
function isMatchingKey(keyCodes, pressedKeys, isUp) {
  return keyCodes.filter((keys2) => isUp || keys2.length === pressedKeys.size).some((keys2) => keys2.every((k2) => pressedKeys.has(k2)));
}
function useKeyOrCode(eventCode, keysToWatch) {
  return keysToWatch.includes(eventCode) ? "code" : "key";
}
const useViewportHelper = () => {
  const store = useStoreApi();
  return useMemo(() => ({
    zoomIn: (options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleBy(1.2, { duration: options?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleBy(1 / 1.2, { duration: options?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (zoomLevel, options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleTo(zoomLevel, { duration: options?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => store.getState().transform[2],
    setViewport: async (viewport, options) => {
      const { transform: [tX, tY, tZoom], panZoom } = store.getState();
      return panZoom ? (await panZoom.setViewport({
        x: viewport.x ?? tX,
        y: viewport.y ?? tY,
        zoom: viewport.zoom ?? tZoom
      }, { duration: options?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [x2, y2, zoom2] = store.getState().transform;
      return { x: x2, y: y2, zoom: zoom2 };
    },
    setCenter: async (x2, y2, options) => {
      const { width, height, maxZoom, panZoom } = store.getState(), nextZoom = typeof options?.zoom < "u" ? options.zoom : maxZoom, centerX = width / 2 - x2 * nextZoom, centerY2 = height / 2 - y2 * nextZoom;
      return panZoom ? (await panZoom.setViewport({
        x: centerX,
        y: centerY2,
        zoom: nextZoom
      }, { duration: options?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    fitBounds: async (bounds, options) => {
      const { width, height, minZoom, maxZoom, panZoom } = store.getState(), viewport = getViewportForBounds(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);
      return panZoom ? (await panZoom.setViewport(viewport, { duration: options?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (clientPosition, options = {}) => {
      const { transform: transform2, snapGrid, snapToGrid, domNode } = store.getState();
      if (!domNode)
        return clientPosition;
      const { x: domX, y: domY } = domNode.getBoundingClientRect(), correctedPosition = {
        x: clientPosition.x - domX,
        y: clientPosition.y - domY
      }, _snapGrid = options.snapGrid ?? snapGrid, _snapToGrid = options.snapToGrid ?? snapToGrid;
      return pointToRendererPoint(correctedPosition, transform2, _snapToGrid, _snapGrid);
    },
    flowToScreenPosition: (flowPosition) => {
      const { transform: transform2, domNode } = store.getState();
      if (!domNode)
        return flowPosition;
      const { x: domX, y: domY } = domNode.getBoundingClientRect(), rendererPosition = rendererPointToPoint(flowPosition, transform2);
      return {
        x: rendererPosition.x + domX,
        y: rendererPosition.y + domY
      };
    }
  }), []);
};
function applyChanges(changes, elements) {
  const updatedElements = [], changesMap = /* @__PURE__ */ new Map(), addItemChanges = [];
  for (const change of changes)
    if (change.type === "add") {
      addItemChanges.push(change);
      continue;
    } else if (change.type === "remove" || change.type === "replace")
      changesMap.set(change.id, [change]);
    else {
      const elementChanges = changesMap.get(change.id);
      elementChanges ? elementChanges.push(change) : changesMap.set(change.id, [change]);
    }
  for (const element of elements) {
    const changes2 = changesMap.get(element.id);
    if (!changes2) {
      updatedElements.push(element);
      continue;
    }
    if (changes2[0].type === "remove")
      continue;
    if (changes2[0].type === "replace") {
      updatedElements.push({ ...changes2[0].item });
      continue;
    }
    const updatedElement = { ...element };
    for (const change of changes2)
      applyChange(change, updatedElement);
    updatedElements.push(updatedElement);
  }
  return addItemChanges.length && addItemChanges.forEach((change) => {
    change.index !== void 0 ? updatedElements.splice(change.index, 0, { ...change.item }) : updatedElements.push({ ...change.item });
  }), updatedElements;
}
function applyChange(change, element) {
  switch (change.type) {
    case "select": {
      element.selected = change.selected;
      break;
    }
    case "position": {
      typeof change.position < "u" && (element.position = change.position), typeof change.dragging < "u" && (element.dragging = change.dragging);
      break;
    }
    case "dimensions": {
      typeof change.dimensions < "u" && (element.measured ??= {}, element.measured.width = change.dimensions.width, element.measured.height = change.dimensions.height, change.setAttributes && (element.width = change.dimensions.width, element.height = change.dimensions.height)), typeof change.resizing == "boolean" && (element.resizing = change.resizing);
      break;
    }
  }
}
function applyNodeChanges(changes, nodes) {
  return applyChanges(changes, nodes);
}
function applyEdgeChanges(changes, edges) {
  return applyChanges(changes, edges);
}
function createSelectionChange(id2, selected2) {
  return {
    id: id2,
    type: "select",
    selected: selected2
  };
}
function getSelectionChanges(items, selectedIds = /* @__PURE__ */ new Set(), mutateItem = !1) {
  const changes = [];
  for (const [id2, item] of items) {
    const willBeSelected = selectedIds.has(id2);
    !(item.selected === void 0 && !willBeSelected) && item.selected !== willBeSelected && (mutateItem && (item.selected = willBeSelected), changes.push(createSelectionChange(item.id, willBeSelected)));
  }
  return changes;
}
function getElementsDiffChanges({ items = [], lookup }) {
  const changes = [], itemsLookup = new Map(items.map((item) => [item.id, item]));
  for (const [index2, item] of items.entries()) {
    const lookupItem = lookup.get(item.id), storeItem = lookupItem?.internals?.userNode ?? lookupItem;
    storeItem !== void 0 && storeItem !== item && changes.push({ id: item.id, item, type: "replace" }), storeItem === void 0 && changes.push({ item, type: "add", index: index2 });
  }
  for (const [id2] of lookup)
    itemsLookup.get(id2) === void 0 && changes.push({ id: id2, type: "remove" });
  return changes;
}
function elementToRemoveChange(item) {
  return {
    id: item.id,
    type: "remove"
  };
}
const isNode = (element) => isNodeBase(element), isEdge = (element) => isEdgeBase(element);
function fixedForwardRef(render) {
  return forwardRef(render);
}
const useIsomorphicLayoutEffect$1 = typeof window < "u" ? useLayoutEffect$1 : useEffect;
function useQueue(runQueue) {
  const [serial, setSerial] = useState(BigInt(0)), [queue] = useState(() => createQueue(() => setSerial((n2) => n2 + BigInt(1))));
  return useIsomorphicLayoutEffect$1(() => {
    const queueItems = queue.get();
    queueItems.length && (runQueue(queueItems), queue.reset());
  }, [serial]), queue;
}
function createQueue(cb) {
  let queue = [];
  return {
    get: () => queue,
    reset: () => {
      queue = [];
    },
    push: (item) => {
      queue.push(item), cb();
    }
  };
}
const BatchContext = createContext(null);
function BatchProvider({ children: children2 }) {
  const store = useStoreApi(), nodeQueueHandler = useCallback((queueItems) => {
    const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued } = store.getState();
    let next = nodes;
    for (const payload of queueItems)
      next = typeof payload == "function" ? payload(next) : payload;
    if (hasDefaultNodes)
      setNodes(next);
    else {
      const changes = getElementsDiffChanges({
        items: next,
        lookup: nodeLookup
      });
      changes.length > 0 ? onNodesChange?.(changes) : fitViewQueued && window.requestAnimationFrame(() => {
        const { fitViewQueued: fitViewQueued2, nodes: nodes2, setNodes: setNodes2 } = store.getState();
        fitViewQueued2 && setNodes2(nodes2);
      });
    }
  }, []), nodeQueue = useQueue(nodeQueueHandler), edgeQueueHandler = useCallback((queueItems) => {
    const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();
    let next = edges;
    for (const payload of queueItems)
      next = typeof payload == "function" ? payload(next) : payload;
    hasDefaultEdges ? setEdges(next) : onEdgesChange && onEdgesChange(getElementsDiffChanges({
      items: next,
      lookup: edgeLookup
    }));
  }, []), edgeQueue = useQueue(edgeQueueHandler), value = useMemo(() => ({ nodeQueue, edgeQueue }), []);
  return jsx(BatchContext.Provider, { value, children: children2 });
}
function useBatchContext() {
  const batchContext = useContext(BatchContext);
  if (!batchContext)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return batchContext;
}
const selector$k = (s2) => !!s2.panZoom;
function useReactFlow() {
  const viewportHelper = useViewportHelper(), store = useStoreApi(), batchContext = useBatchContext(), viewportInitialized = useStore$1(selector$k), generalHelper = useMemo(() => {
    const getInternalNode = (id2) => store.getState().nodeLookup.get(id2), setNodes = (payload) => {
      batchContext.nodeQueue.push(payload);
    }, setEdges = (payload) => {
      batchContext.edgeQueue.push(payload);
    }, getNodeRect = (node2) => {
      const { nodeLookup, nodeOrigin } = store.getState(), nodeToUse = isNode(node2) ? node2 : nodeLookup.get(node2.id), position = nodeToUse.parentId ? evaluateAbsolutePosition(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position, nodeWithPosition = {
        ...nodeToUse,
        position,
        width: nodeToUse.measured?.width ?? nodeToUse.width,
        height: nodeToUse.measured?.height ?? nodeToUse.height
      };
      return nodeToRect(nodeWithPosition);
    }, updateNode = (id2, nodeUpdate, options = { replace: !1 }) => {
      setNodes((prevNodes) => prevNodes.map((node2) => {
        if (node2.id === id2) {
          const nextNode = typeof nodeUpdate == "function" ? nodeUpdate(node2) : nodeUpdate;
          return options.replace && isNode(nextNode) ? nextNode : { ...node2, ...nextNode };
        }
        return node2;
      }));
    }, updateEdge = (id2, edgeUpdate, options = { replace: !1 }) => {
      setEdges((prevEdges) => prevEdges.map((edge) => {
        if (edge.id === id2) {
          const nextEdge = typeof edgeUpdate == "function" ? edgeUpdate(edge) : edgeUpdate;
          return options.replace && isEdge(nextEdge) ? nextEdge : { ...edge, ...nextEdge };
        }
        return edge;
      }));
    };
    return {
      getNodes: () => store.getState().nodes.map((n2) => ({ ...n2 })),
      getNode: (id2) => getInternalNode(id2)?.internals.userNode,
      getInternalNode,
      getEdges: () => {
        const { edges = [] } = store.getState();
        return edges.map((e2) => ({ ...e2 }));
      },
      getEdge: (id2) => store.getState().edgeLookup.get(id2),
      setNodes,
      setEdges,
      addNodes: (payload) => {
        const newNodes = Array.isArray(payload) ? payload : [payload];
        batchContext.nodeQueue.push((nodes) => [...nodes, ...newNodes]);
      },
      addEdges: (payload) => {
        const newEdges = Array.isArray(payload) ? payload : [payload];
        batchContext.edgeQueue.push((edges) => [...edges, ...newEdges]);
      },
      toObject: () => {
        const { nodes = [], edges = [], transform: transform2 } = store.getState(), [x2, y2, zoom2] = transform2;
        return {
          nodes: nodes.map((n2) => ({ ...n2 })),
          edges: edges.map((e2) => ({ ...e2 })),
          viewport: {
            x: x2,
            y: y2,
            zoom: zoom2
          }
        };
      },
      deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] }) => {
        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState(), { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
          nodesToRemove,
          edgesToRemove,
          nodes,
          edges,
          onBeforeDelete
        }), hasMatchingEdges = matchingEdges.length > 0, hasMatchingNodes = matchingNodes.length > 0;
        if (hasMatchingEdges) {
          const edgeChanges = matchingEdges.map(elementToRemoveChange);
          onEdgesDelete?.(matchingEdges), triggerEdgeChanges(edgeChanges);
        }
        if (hasMatchingNodes) {
          const nodeChanges = matchingNodes.map(elementToRemoveChange);
          onNodesDelete?.(matchingNodes), triggerNodeChanges(nodeChanges);
        }
        return (hasMatchingNodes || hasMatchingEdges) && onDelete?.({ nodes: matchingNodes, edges: matchingEdges }), { deletedNodes: matchingNodes, deletedEdges: matchingEdges };
      },
      getIntersectingNodes: (nodeOrRect, partially = !0, nodes) => {
        const isRect = isRectObject(nodeOrRect), nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect), hasNodesOption = nodes !== void 0;
        return nodeRect ? (nodes || store.getState().nodes).filter((n2) => {
          const internalNode = store.getState().nodeLookup.get(n2.id);
          if (internalNode && !isRect && (n2.id === nodeOrRect.id || !internalNode.internals.positionAbsolute))
            return !1;
          const currNodeRect = nodeToRect(hasNodesOption ? n2 : internalNode), overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
          return partially && overlappingArea > 0 || overlappingArea >= nodeRect.width * nodeRect.height;
        }) : [];
      },
      isNodeIntersecting: (nodeOrRect, area, partially = !0) => {
        const nodeRect = isRectObject(nodeOrRect) ? nodeOrRect : getNodeRect(nodeOrRect);
        if (!nodeRect)
          return !1;
        const overlappingArea = getOverlappingArea(nodeRect, area);
        return partially && overlappingArea > 0 || overlappingArea >= nodeRect.width * nodeRect.height;
      },
      updateNode,
      updateNodeData: (id2, dataUpdate, options = { replace: !1 }) => {
        updateNode(id2, (node2) => {
          const nextData = typeof dataUpdate == "function" ? dataUpdate(node2) : dataUpdate;
          return options.replace ? { ...node2, data: nextData } : { ...node2, data: { ...node2.data, ...nextData } };
        }, options);
      },
      updateEdge,
      updateEdgeData: (id2, dataUpdate, options = { replace: !1 }) => {
        updateEdge(id2, (edge) => {
          const nextData = typeof dataUpdate == "function" ? dataUpdate(edge) : dataUpdate;
          return options.replace ? { ...edge, data: nextData } : { ...edge, data: { ...edge.data, ...nextData } };
        }, options);
      },
      getNodesBounds: (nodes) => {
        const { nodeLookup, nodeOrigin } = store.getState();
        return getNodesBounds(nodes, { nodeLookup, nodeOrigin });
      },
      getHandleConnections: ({ type, id: id2, nodeId }) => Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id2 ? `-${id2}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type, handleId, nodeId }) => Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ""}`)?.values() ?? []),
      fitView: async (options) => {
        const fitViewResolver = store.getState().fitViewResolver ?? Promise.withResolvers();
        return store.setState({ fitViewQueued: !0, fitViewOptions: options, fitViewResolver }), batchContext.nodeQueue.push((nodes) => [...nodes]), fitViewResolver.promise;
      }
    };
  }, []);
  return useMemo(() => ({
    ...generalHelper,
    ...viewportHelper,
    viewportInitialized
  }), [viewportInitialized]);
}
const selected = (item) => item.selected, deleteKeyOptions = { actInsideInputWithModifier: !1 }, win$1 = typeof window < "u" ? window : void 0;
function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {
  const store = useStoreApi(), { deleteElements } = useReactFlow(), deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions), multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, { target: win$1 });
  useEffect(() => {
    if (deleteKeyPressed) {
      const { edges, nodes } = store.getState();
      deleteElements({ nodes: nodes.filter(selected), edges: edges.filter(selected) }), store.setState({ nodesSelectionActive: !1 });
    }
  }, [deleteKeyPressed]), useEffect(() => {
    store.setState({ multiSelectionActive: multiSelectionKeyPressed });
  }, [multiSelectionKeyPressed]);
}
function useResizeHandler(domNode) {
  const store = useStoreApi();
  useEffect(() => {
    const updateDimensions = () => {
      if (!domNode.current)
        return !1;
      const size2 = getDimensions(domNode.current);
      (size2.height === 0 || size2.width === 0) && store.getState().onError?.("004", errorMessages.error004()), store.setState({ width: size2.width || 500, height: size2.height || 500 });
    };
    if (domNode.current) {
      updateDimensions(), window.addEventListener("resize", updateDimensions);
      const resizeObserver = new ResizeObserver(() => updateDimensions());
      return resizeObserver.observe(domNode.current), () => {
        window.removeEventListener("resize", updateDimensions), resizeObserver && domNode.current && resizeObserver.unobserve(domNode.current);
      };
    }
  }, []);
}
const containerStyle = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, selector$j = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  lib: s2.lib
});
function ZoomPane({ onPaneContextMenu, zoomOnScroll = !0, zoomOnPinch = !0, panOnScroll = !1, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = !0, panOnDrag = !0, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = !0, children: children2, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {
  const store = useStoreApi(), zoomPane = useRef(null), { userSelectionActive, lib: lib2 } = useStore$1(selector$j, shallow$1), zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode), panZoom = useRef();
  useResizeHandler(zoomPane);
  const onTransformChange = useCallback((transform2) => {
    onViewportChange?.({ x: transform2[0], y: transform2[1], zoom: transform2[2] }), isControlledViewport || store.setState({ transform: transform2 });
  }, [onViewportChange, isControlledViewport]);
  return useEffect(() => {
    if (zoomPane.current) {
      panZoom.current = XYPanZoom({
        domNode: zoomPane.current,
        minZoom,
        maxZoom,
        translateExtent,
        viewport: defaultViewport2,
        paneClickDistance,
        onDraggingChange: (paneDragging) => store.setState({ paneDragging }),
        onPanZoomStart: (event, vp) => {
          const { onViewportChangeStart, onMoveStart } = store.getState();
          onMoveStart?.(event, vp), onViewportChangeStart?.(vp);
        },
        onPanZoom: (event, vp) => {
          const { onViewportChange: onViewportChange2, onMove } = store.getState();
          onMove?.(event, vp), onViewportChange2?.(vp);
        },
        onPanZoomEnd: (event, vp) => {
          const { onViewportChangeEnd, onMoveEnd } = store.getState();
          onMoveEnd?.(event, vp), onViewportChangeEnd?.(vp);
        }
      });
      const { x: x2, y: y2, zoom: zoom2 } = panZoom.current.getViewport();
      return store.setState({
        panZoom: panZoom.current,
        transform: [x2, y2, zoom2],
        domNode: zoomPane.current.closest(".react-flow")
      }), () => {
        panZoom.current?.destroy();
      };
    }
  }, []), useEffect(() => {
    panZoom.current?.update({
      onPaneContextMenu,
      zoomOnScroll,
      zoomOnPinch,
      panOnScroll,
      panOnScrollSpeed,
      panOnScrollMode,
      zoomOnDoubleClick,
      panOnDrag,
      zoomActivationKeyPressed,
      preventScrolling,
      noPanClassName,
      userSelectionActive,
      noWheelClassName,
      lib: lib2,
      onTransformChange
    });
  }, [
    onPaneContextMenu,
    zoomOnScroll,
    zoomOnPinch,
    panOnScroll,
    panOnScrollSpeed,
    panOnScrollMode,
    zoomOnDoubleClick,
    panOnDrag,
    zoomActivationKeyPressed,
    preventScrolling,
    noPanClassName,
    userSelectionActive,
    noWheelClassName,
    lib2,
    onTransformChange
  ]), jsx("div", { className: "react-flow__renderer", ref: zoomPane, style: containerStyle, children: children2 });
}
const selector$i = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  userSelectionRect: s2.userSelectionRect
});
function UserSelection() {
  const { userSelectionActive, userSelectionRect } = useStore$1(selector$i, shallow$1);
  return userSelectionActive && userSelectionRect ? jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: userSelectionRect.width,
    height: userSelectionRect.height,
    transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`
  } }) : null;
}
const wrapHandler = (handler, containerRef) => (event) => {
  event.target === containerRef.current && handler?.(event);
}, selector$h = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  elementsSelectable: s2.elementsSelectable,
  connectionInProgress: s2.connection.inProgress,
  dragging: s2.paneDragging
});
function Pane({ isSelecting, selectionKeyPressed, selectionMode = SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children: children2 }) {
  const store = useStoreApi(), { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore$1(selector$h, shallow$1), hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive), container2 = useRef(null), containerBounds = useRef(), selectedNodeIds = useRef(/* @__PURE__ */ new Set()), selectedEdgeIds = useRef(/* @__PURE__ */ new Set()), selectionInProgress = useRef(!1), selectionStarted = useRef(!1), onClick = (event) => {
    if (selectionInProgress.current || connectionInProgress) {
      selectionInProgress.current = !1;
      return;
    }
    onPaneClick?.(event), store.getState().resetSelectedElements(), store.setState({ nodesSelectionActive: !1 });
  }, onContextMenu = (event) => {
    if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {
      event.preventDefault();
      return;
    }
    onPaneContextMenu?.(event);
  }, onWheel = onPaneScroll ? (event) => onPaneScroll(event) : void 0, onPointerDown2 = (event) => {
    const { resetSelectedElements, domNode } = store.getState();
    if (containerBounds.current = domNode?.getBoundingClientRect(), !elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container2.current || !containerBounds.current)
      return;
    event.target?.setPointerCapture?.(event.pointerId), selectionStarted.current = !0, selectionInProgress.current = !1;
    const { x: x2, y: y2 } = getEventPosition(event.nativeEvent, containerBounds.current);
    resetSelectedElements(), store.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: x2,
        startY: y2,
        x: x2,
        y: y2
      }
    }), onSelectionStart?.(event);
  }, onPointerMove = (event) => {
    const { userSelectionRect, transform: transform2, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();
    if (!containerBounds.current || !userSelectionRect)
      return;
    selectionInProgress.current = !0;
    const { x: mouseX, y: mouseY } = getEventPosition(event.nativeEvent, containerBounds.current), { startX, startY } = userSelectionRect, nextUserSelectRect = {
      startX,
      startY,
      x: mouseX < startX ? mouseX : startX,
      y: mouseY < startY ? mouseY : startY,
      width: Math.abs(mouseX - startX),
      height: Math.abs(mouseY - startY)
    }, prevSelectedNodeIds = selectedNodeIds.current, prevSelectedEdgeIds = selectedEdgeIds.current;
    selectedNodeIds.current = new Set(getNodesInside(nodeLookup, nextUserSelectRect, transform2, selectionMode === SelectionMode.Partial, !0).map((node2) => node2.id)), selectedEdgeIds.current = /* @__PURE__ */ new Set();
    const edgesSelectable = defaultEdgeOptions?.selectable ?? !0;
    for (const nodeId of selectedNodeIds.current) {
      const connections = connectionLookup.get(nodeId);
      if (connections)
        for (const { edgeId } of connections.values()) {
          const edge = edgeLookup.get(edgeId);
          edge && (edge.selectable ?? edgesSelectable) && selectedEdgeIds.current.add(edgeId);
        }
    }
    if (!areSetsEqual$1(prevSelectedNodeIds, selectedNodeIds.current)) {
      const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, !0);
      triggerNodeChanges(changes);
    }
    if (!areSetsEqual$1(prevSelectedEdgeIds, selectedEdgeIds.current)) {
      const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);
      triggerEdgeChanges(changes);
    }
    store.setState({
      userSelectionRect: nextUserSelectRect,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, onPointerUp = (event) => {
    if (event.button !== 0 || !selectionStarted.current)
      return;
    event.target?.releasePointerCapture?.(event.pointerId);
    const { userSelectionRect } = store.getState();
    !userSelectionActive && userSelectionRect && event.target === container2.current && onClick?.(event), store.setState({
      userSelectionActive: !1,
      userSelectionRect: null,
      nodesSelectionActive: selectedNodeIds.current.size > 0
    }), onSelectionEnd?.(event), (selectionKeyPressed || selectionOnDrag) && (selectionInProgress.current = !1), selectionStarted.current = !1;
  }, draggable = panOnDrag === !0 || Array.isArray(panOnDrag) && panOnDrag.includes(0);
  return jsxs("div", { className: cc(["react-flow__pane", { draggable, dragging, selection: isSelecting }]), onClick: hasActiveSelection ? void 0 : wrapHandler(onClick, container2), onContextMenu: wrapHandler(onContextMenu, container2), onWheel: wrapHandler(onWheel, container2), onPointerEnter: hasActiveSelection ? void 0 : onPaneMouseEnter, onPointerDown: hasActiveSelection ? onPointerDown2 : onPaneMouseMove, onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove, onPointerUp: hasActiveSelection ? onPointerUp : void 0, onPointerLeave: onPaneMouseLeave, ref: container2, style: containerStyle, children: [children2, jsx(UserSelection, {})] });
}
function handleNodeClick({ id: id2, store, unselect = !1, nodeRef: nodeRef2 }) {
  const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState(), node2 = nodeLookup.get(id2);
  if (!node2) {
    onError?.("012", errorMessages.error012(id2));
    return;
  }
  store.setState({ nodesSelectionActive: !1 }), node2.selected ? (unselect || node2.selected && multiSelectionActive) && (unselectNodesAndEdges({ nodes: [node2], edges: [] }), requestAnimationFrame(() => nodeRef2?.current?.blur())) : addSelectedNodes([id2]);
}
function useDrag({ nodeRef: nodeRef2, disabled = !1, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {
  const store = useStoreApi(), [dragging, setDragging] = useState(!1), xyDrag = useRef();
  return useEffect(() => {
    xyDrag.current = XYDrag({
      getStoreItems: () => store.getState(),
      onNodeMouseDown: (id2) => {
        handleNodeClick({
          id: id2,
          store,
          nodeRef: nodeRef2
        });
      },
      onDragStart: () => {
        setDragging(!0);
      },
      onDragStop: () => {
        setDragging(!1);
      }
    });
  }, []), useEffect(() => {
    if (disabled)
      xyDrag.current?.destroy();
    else if (nodeRef2.current)
      return xyDrag.current?.update({
        noDragClassName,
        handleSelector,
        domNode: nodeRef2.current,
        isSelectable,
        nodeId,
        nodeClickDistance
      }), () => {
        xyDrag.current?.destroy();
      };
  }, [noDragClassName, handleSelector, disabled, isSelectable, nodeRef2, nodeId]), dragging;
}
const selectedAndDraggable = (nodesDraggable) => (n2) => n2.selected && (n2.draggable || nodesDraggable && typeof n2.draggable > "u");
function useMoveSelectedNodes() {
  const store = useStoreApi();
  return useCallback((params) => {
    const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState(), nodeUpdates = /* @__PURE__ */ new Map(), isSelected2 = selectedAndDraggable(nodesDraggable), xVelo = snapToGrid ? snapGrid[0] : 5, yVelo = snapToGrid ? snapGrid[1] : 5, xDiff = params.direction.x * xVelo * params.factor, yDiff = params.direction.y * yVelo * params.factor;
    for (const [, node2] of nodeLookup) {
      if (!isSelected2(node2))
        continue;
      let nextPosition = {
        x: node2.internals.positionAbsolute.x + xDiff,
        y: node2.internals.positionAbsolute.y + yDiff
      };
      snapToGrid && (nextPosition = snapPosition(nextPosition, snapGrid));
      const { position, positionAbsolute } = calculateNodePosition({
        nodeId: node2.id,
        nextPosition,
        nodeLookup,
        nodeExtent,
        nodeOrigin,
        onError
      });
      node2.position = position, node2.internals.positionAbsolute = positionAbsolute, nodeUpdates.set(node2.id, node2);
    }
    updateNodePositions(nodeUpdates);
  }, []);
}
const NodeIdContext = createContext(null), Provider = NodeIdContext.Provider;
NodeIdContext.Consumer;
const useNodeId = () => useContext(NodeIdContext), selector$g = (s2) => ({
  connectOnClick: s2.connectOnClick,
  noPanClassName: s2.noPanClassName,
  rfId: s2.rfId
}), connectingSelector = (nodeId, handleId, type) => (state) => {
  const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state, { fromHandle, toHandle, isValid } = connection, connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;
  return {
    connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,
    connectingTo,
    clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,
    isPossibleEndHandle: connectionMode === ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,
    connectionInProcess: !!fromHandle,
    clickConnectionInProcess: !!clickHandle,
    valid: connectingTo && isValid
  };
};
function HandleComponent({ type = "source", position = Position.Top, isValidConnection, isConnectable = !0, isConnectableStart = !0, isConnectableEnd = !0, id: id2, onConnect, children: children2, className, onMouseDown, onTouchStart, ...rest }, ref) {
  const handleId = id2 || null, isTarget = type === "target", store = useStoreApi(), nodeId = useNodeId(), { connectOnClick, noPanClassName, rfId } = useStore$1(selector$g, shallow$1), { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore$1(connectingSelector(nodeId, handleId, type), shallow$1);
  nodeId || store.getState().onError?.("010", errorMessages.error010());
  const onConnectExtended = (params) => {
    const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState(), edgeParams = {
      ...defaultEdgeOptions,
      ...params
    };
    if (hasDefaultEdges) {
      const { edges, setEdges } = store.getState();
      setEdges(addEdge(edgeParams, edges));
    }
    onConnectAction?.(edgeParams), onConnect?.(edgeParams);
  }, onPointerDown2 = (event) => {
    if (!nodeId)
      return;
    const isMouseTriggered = isMouseEvent(event.nativeEvent);
    if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {
      const currentStore = store.getState();
      XYHandle.onPointerDown(event.nativeEvent, {
        autoPanOnConnect: currentStore.autoPanOnConnect,
        connectionMode: currentStore.connectionMode,
        connectionRadius: currentStore.connectionRadius,
        domNode: currentStore.domNode,
        nodeLookup: currentStore.nodeLookup,
        lib: currentStore.lib,
        isTarget,
        handleId,
        nodeId,
        flowId: currentStore.rfId,
        panBy: currentStore.panBy,
        cancelConnection: currentStore.cancelConnection,
        onConnectStart: currentStore.onConnectStart,
        onConnectEnd: currentStore.onConnectEnd,
        updateConnection: currentStore.updateConnection,
        onConnect: onConnectExtended,
        isValidConnection: isValidConnection || currentStore.isValidConnection,
        getTransform: () => store.getState().transform,
        getFromHandle: () => store.getState().connection.fromHandle,
        autoPanSpeed: currentStore.autoPanSpeed
      });
    }
    isMouseTriggered ? onMouseDown?.(event) : onTouchStart?.(event);
  }, onClick = (event) => {
    const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib: lib2, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();
    if (!nodeId || !connectionClickStartHandle && !isConnectableStart)
      return;
    if (!connectionClickStartHandle) {
      onClickConnectStart?.(event.nativeEvent, { nodeId, handleId, handleType: type }), store.setState({ connectionClickStartHandle: { nodeId, type, id: handleId } });
      return;
    }
    const doc = getHostForElement(event.target), isValidConnectionHandler = isValidConnection || isValidConnectionStore, { connection, isValid } = XYHandle.isValid(event.nativeEvent, {
      handle: {
        nodeId,
        id: handleId,
        type
      },
      connectionMode,
      fromNodeId: connectionClickStartHandle.nodeId,
      fromHandleId: connectionClickStartHandle.id || null,
      fromType: connectionClickStartHandle.type,
      isValidConnection: isValidConnectionHandler,
      flowId,
      doc,
      lib: lib2,
      nodeLookup
    });
    isValid && connection && onConnectExtended(connection);
    const connectionClone = structuredClone(connectionState);
    delete connectionClone.inProgress, connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null, onClickConnectEnd?.(event, connectionClone), store.setState({ connectionClickStartHandle: null });
  };
  return jsx("div", { "data-handleid": handleId, "data-nodeid": nodeId, "data-handlepos": position, "data-id": `${rfId}-${nodeId}-${handleId}-${type}`, className: cc([
    "react-flow__handle",
    `react-flow__handle-${position}`,
    "nodrag",
    noPanClassName,
    className,
    {
      source: !isTarget,
      target: isTarget,
      connectable: isConnectable,
      connectablestart: isConnectableStart,
      connectableend: isConnectableEnd,
      clickconnecting: clickConnecting,
      connectingfrom: connectingFrom,
      connectingto: connectingTo,
      valid,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)
    }
  ]), onMouseDown: onPointerDown2, onTouchStart: onPointerDown2, onClick: connectOnClick ? onClick : void 0, ref, ...rest, children: children2 });
}
const Handle = memo$2(fixedForwardRef(HandleComponent));
function InputNode({ data, isConnectable, sourcePosition = Position.Bottom }) {
  return jsxs(Fragment$1, { children: [data?.label, jsx(Handle, { type: "source", position: sourcePosition, isConnectable })] });
}
function DefaultNode({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom }) {
  return jsxs(Fragment$1, { children: [jsx(Handle, { type: "target", position: targetPosition, isConnectable }), data?.label, jsx(Handle, { type: "source", position: sourcePosition, isConnectable })] });
}
function GroupNode() {
  return null;
}
function OutputNode({ data, isConnectable, targetPosition = Position.Top }) {
  return jsxs(Fragment$1, { children: [jsx(Handle, { type: "target", position: targetPosition, isConnectable }), data?.label] });
}
const arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, builtinNodeTypes = {
  input: InputNode,
  default: DefaultNode,
  output: OutputNode,
  group: GroupNode
};
function getNodeInlineStyleDimensions(node2) {
  return node2.internals.handleBounds === void 0 ? {
    width: node2.width ?? node2.initialWidth ?? node2.style?.width,
    height: node2.height ?? node2.initialHeight ?? node2.style?.height
  } : {
    width: node2.width ?? node2.style?.width,
    height: node2.height ?? node2.style?.height
  };
}
const selector$f = (s2) => {
  const { width, height, x: x2, y: y2 } = getInternalNodesBounds(s2.nodeLookup, {
    filter: (node2) => !!node2.selected
  });
  return {
    width: isNumeric(width) ? width : null,
    height: isNumeric(height) ? height : null,
    userSelectionActive: s2.userSelectionActive,
    transformString: `translate(${s2.transform[0]}px,${s2.transform[1]}px) scale(${s2.transform[2]}) translate(${x2}px,${y2}px)`
  };
};
function NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {
  const store = useStoreApi(), { width, height, transformString, userSelectionActive } = useStore$1(selector$f, shallow$1), moveSelectedNodes = useMoveSelectedNodes(), nodeRef2 = useRef(null);
  if (useEffect(() => {
    disableKeyboardA11y || nodeRef2.current?.focus({
      preventScroll: !0
    });
  }, [disableKeyboardA11y]), useDrag({
    nodeRef: nodeRef2
  }), userSelectionActive || !width || !height)
    return null;
  const onContextMenu = onSelectionContextMenu ? (event) => {
    const selectedNodes = store.getState().nodes.filter((n2) => n2.selected);
    onSelectionContextMenu(event, selectedNodes);
  } : void 0, onKeyDown = (event) => {
    Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key) && (event.preventDefault(), moveSelectedNodes({
      direction: arrowKeyDiffs[event.key],
      factor: event.shiftKey ? 4 : 1
    }));
  };
  return jsx("div", { className: cc(["react-flow__nodesselection", "react-flow__container", noPanClassName]), style: {
    transform: transformString
  }, children: jsx("div", { ref: nodeRef2, className: "react-flow__nodesselection-rect", onContextMenu, tabIndex: disableKeyboardA11y ? void 0 : -1, onKeyDown: disableKeyboardA11y ? void 0 : onKeyDown, style: {
    width,
    height
  } }) });
}
const win = typeof window < "u" ? window : void 0, selector$e = (s2) => ({ nodesSelectionActive: s2.nodesSelectionActive, userSelectionActive: s2.userSelectionActive });
function FlowRendererComponent({ children: children2, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {
  const { nodesSelectionActive, userSelectionActive } = useStore$1(selector$e), selectionKeyPressed = useKeyPress(selectionKeyCode, { target: win }), panActivationKeyPressed = useKeyPress(panActivationKeyCode, { target: win }), panOnDrag = panActivationKeyPressed || _panOnDrag, panOnScroll = panActivationKeyPressed || _panOnScroll, _selectionOnDrag = selectionOnDrag && panOnDrag !== !0, isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;
  return useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }), jsx(ZoomPane, { onPaneContextMenu, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: !selectionKeyPressed && panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance, children: jsxs(Pane, { onSelectionStart, onSelectionEnd, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, panOnDrag, isSelecting: !!isSelecting, selectionMode, selectionKeyPressed, selectionOnDrag: _selectionOnDrag, children: [children2, nodesSelectionActive && jsx(NodesSelection, { onSelectionContextMenu, noPanClassName, disableKeyboardA11y })] }) });
}
FlowRendererComponent.displayName = "FlowRenderer";
const FlowRenderer = memo$2(FlowRendererComponent), selector$d = (onlyRenderVisible) => (s2) => onlyRenderVisible ? getNodesInside(s2.nodeLookup, { x: 0, y: 0, width: s2.width, height: s2.height }, s2.transform, !0).map((node2) => node2.id) : Array.from(s2.nodeLookup.keys());
function useVisibleNodeIds(onlyRenderVisible) {
  return useStore$1(useCallback(selector$d(onlyRenderVisible), [onlyRenderVisible]), shallow$1);
}
const selector$c = (s2) => s2.updateNodeInternals;
function useResizeObserver() {
  const updateNodeInternals2 = useStore$1(selector$c), [resizeObserver] = useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id2 = entry.target.getAttribute("data-id");
      updates.set(id2, {
        id: id2,
        nodeElement: entry.target,
        force: !0
      });
    }), updateNodeInternals2(updates);
  }));
  return useEffect(() => () => {
    resizeObserver?.disconnect();
  }, [resizeObserver]), resizeObserver;
}
function useNodeObserver({ node: node2, nodeType, hasDimensions, resizeObserver }) {
  const store = useStoreApi(), nodeRef2 = useRef(null), observedNode = useRef(null), prevSourcePosition = useRef(node2.sourcePosition), prevTargetPosition = useRef(node2.targetPosition), prevType = useRef(nodeType), isInitialized = hasDimensions && !!node2.internals.handleBounds;
  return useEffect(() => {
    nodeRef2.current && !node2.hidden && (!isInitialized || observedNode.current !== nodeRef2.current) && (observedNode.current && resizeObserver?.unobserve(observedNode.current), resizeObserver?.observe(nodeRef2.current), observedNode.current = nodeRef2.current);
  }, [isInitialized, node2.hidden]), useEffect(() => () => {
    observedNode.current && (resizeObserver?.unobserve(observedNode.current), observedNode.current = null);
  }, []), useEffect(() => {
    if (nodeRef2.current) {
      const typeChanged = prevType.current !== nodeType, sourcePosChanged = prevSourcePosition.current !== node2.sourcePosition, targetPosChanged = prevTargetPosition.current !== node2.targetPosition;
      (typeChanged || sourcePosChanged || targetPosChanged) && (prevType.current = nodeType, prevSourcePosition.current = node2.sourcePosition, prevTargetPosition.current = node2.targetPosition, store.getState().updateNodeInternals(/* @__PURE__ */ new Map([[node2.id, { id: node2.id, nodeElement: nodeRef2.current, force: !0 }]])));
    }
  }, [node2.id, nodeType, node2.sourcePosition, node2.targetPosition]), nodeRef2;
}
function NodeWrapper({ id: id2, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes: nodeTypes2, nodeClickDistance, onError }) {
  const { node: node2, internals, isParent: isParent2 } = useStore$1((s2) => {
    const node22 = s2.nodeLookup.get(id2), isParent22 = s2.parentLookup.has(id2);
    return {
      node: node22,
      internals: node22.internals,
      isParent: isParent22
    };
  }, shallow$1);
  let nodeType = node2.type || "default", NodeComponent = nodeTypes2?.[nodeType] || builtinNodeTypes[nodeType];
  NodeComponent === void 0 && (onError?.("003", errorMessages.error003(nodeType)), nodeType = "default", NodeComponent = builtinNodeTypes.default);
  const isDraggable = !!(node2.draggable || nodesDraggable && typeof node2.draggable > "u"), isSelectable = !!(node2.selectable || elementsSelectable && typeof node2.selectable > "u"), isConnectable = !!(node2.connectable || nodesConnectable && typeof node2.connectable > "u"), isFocusable = !!(node2.focusable || nodesFocusable && typeof node2.focusable > "u"), store = useStoreApi(), hasDimensions = nodeHasDimensions(node2), nodeRef2 = useNodeObserver({ node: node2, nodeType, hasDimensions, resizeObserver }), dragging = useDrag({
    nodeRef: nodeRef2,
    disabled: node2.hidden || !isDraggable,
    noDragClassName,
    handleSelector: node2.dragHandle,
    nodeId: id2,
    isSelectable,
    nodeClickDistance
  }), moveSelectedNodes = useMoveSelectedNodes();
  if (node2.hidden)
    return null;
  const nodeDimensions = getNodeDimensions(node2), inlineDimensions = getNodeInlineStyleDimensions(node2), hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave, onMouseEnterHandler = onMouseEnter ? (event) => onMouseEnter(event, { ...internals.userNode }) : void 0, onMouseMoveHandler = onMouseMove ? (event) => onMouseMove(event, { ...internals.userNode }) : void 0, onMouseLeaveHandler = onMouseLeave ? (event) => onMouseLeave(event, { ...internals.userNode }) : void 0, onContextMenuHandler = onContextMenu ? (event) => onContextMenu(event, { ...internals.userNode }) : void 0, onDoubleClickHandler = onDoubleClick ? (event) => onDoubleClick(event, { ...internals.userNode }) : void 0, onSelectNodeHandler = (event) => {
    const { selectNodesOnDrag, nodeDragThreshold } = store.getState();
    isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0) && handleNodeClick({
      id: id2,
      store,
      nodeRef: nodeRef2
    }), onClick && onClick(event, { ...internals.userNode });
  }, onKeyDown = (event) => {
    if (!(isInputDOMNode(event.nativeEvent) || disableKeyboardA11y))
      if (elementSelectionKeys.includes(event.key) && isSelectable) {
        const unselect = event.key === "Escape";
        handleNodeClick({
          id: id2,
          store,
          unselect,
          nodeRef: nodeRef2
        });
      } else isDraggable && node2.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key) && (event.preventDefault(), store.setState({
        ariaLiveMessage: `Moved selected node ${event.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~internals.positionAbsolute.x}, y: ${~~internals.positionAbsolute.y}`
      }), moveSelectedNodes({
        direction: arrowKeyDiffs[event.key],
        factor: event.shiftKey ? 4 : 1
      }));
  };
  return jsx("div", { className: cc([
    "react-flow__node",
    `react-flow__node-${nodeType}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [noPanClassName]: isDraggable
    },
    node2.className,
    {
      selected: node2.selected,
      selectable: isSelectable,
      parent: isParent2,
      draggable: isDraggable,
      dragging
    }
  ]), ref: nodeRef2, style: {
    zIndex: internals.z,
    transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,
    pointerEvents: hasPointerEvents ? "all" : "none",
    visibility: hasDimensions ? "visible" : "hidden",
    ...node2.style,
    ...inlineDimensions
  }, "data-id": id2, "data-testid": `rf__node-${id2}`, onMouseEnter: onMouseEnterHandler, onMouseMove: onMouseMoveHandler, onMouseLeave: onMouseLeaveHandler, onContextMenu: onContextMenuHandler, onClick: onSelectNodeHandler, onDoubleClick: onDoubleClickHandler, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: isFocusable ? "button" : void 0, "aria-describedby": disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${rfId}`, "aria-label": node2.ariaLabel, children: jsx(Provider, { value: id2, children: jsx(NodeComponent, { id: id2, data: node2.data, type: nodeType, positionAbsoluteX: internals.positionAbsolute.x, positionAbsoluteY: internals.positionAbsolute.y, selected: node2.selected ?? !1, selectable: isSelectable, draggable: isDraggable, deletable: node2.deletable ?? !0, isConnectable, sourcePosition: node2.sourcePosition, targetPosition: node2.targetPosition, dragging, dragHandle: node2.dragHandle, zIndex: internals.z, parentId: node2.parentId, ...nodeDimensions }) }) });
}
const selector$b = (s2) => ({
  nodesDraggable: s2.nodesDraggable,
  nodesConnectable: s2.nodesConnectable,
  nodesFocusable: s2.nodesFocusable,
  elementsSelectable: s2.elementsSelectable,
  onError: s2.onError
});
function NodeRendererComponent(props) {
  const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore$1(selector$b, shallow$1), nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements), resizeObserver = useResizeObserver();
  return jsx("div", { className: "react-flow__nodes", style: containerStyle, children: nodeIds.map((nodeId) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    jsx(NodeWrapper, { id: nodeId, nodeTypes: props.nodeTypes, nodeExtent: props.nodeExtent, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onDoubleClick: props.onNodeDoubleClick, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName, rfId: props.rfId, disableKeyboardA11y: props.disableKeyboardA11y, resizeObserver, nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, nodeClickDistance: props.nodeClickDistance, onError }, nodeId)
  )) });
}
NodeRendererComponent.displayName = "NodeRenderer";
const NodeRenderer = memo$2(NodeRendererComponent);
function useVisibleEdgeIds(onlyRenderVisible) {
  return useStore$1(useCallback((s2) => {
    if (!onlyRenderVisible)
      return s2.edges.map((edge) => edge.id);
    const visibleEdgeIds = [];
    if (s2.width && s2.height)
      for (const edge of s2.edges) {
        const sourceNode = s2.nodeLookup.get(edge.source), targetNode = s2.nodeLookup.get(edge.target);
        sourceNode && targetNode && isEdgeVisible({
          sourceNode,
          targetNode,
          width: s2.width,
          height: s2.height,
          transform: s2.transform
        }) && visibleEdgeIds.push(edge.id);
      }
    return visibleEdgeIds;
  }, [onlyRenderVisible]), shallow$1);
}
const ArrowSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => jsx("polyline", { style: {
  stroke: color2,
  strokeWidth
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), ArrowClosedSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => jsx("polyline", { style: {
  stroke: color2,
  fill: color2,
  strokeWidth
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), MarkerSymbols = {
  [MarkerType.Arrow]: ArrowSymbol,
  [MarkerType.ArrowClosed]: ArrowClosedSymbol
};
function useMarkerSymbol(type) {
  const store = useStoreApi();
  return useMemo(() => Object.prototype.hasOwnProperty.call(MarkerSymbols, type) ? MarkerSymbols[type] : (store.getState().onError?.("009", errorMessages.error009(type)), null), [type]);
}
const Marker = ({ id: id2, type, color: color2, width = 12.5, height = 12.5, markerUnits = "strokeWidth", strokeWidth, orient = "auto-start-reverse" }) => {
  const Symbol2 = useMarkerSymbol(type);
  return Symbol2 ? jsx("marker", { className: "react-flow__arrowhead", id: id2, markerWidth: `${width}`, markerHeight: `${height}`, viewBox: "-10 -10 20 20", markerUnits, orient, refX: "0", refY: "0", children: jsx(Symbol2, { color: color2, strokeWidth }) }) : null;
}, MarkerDefinitions = ({ defaultColor, rfId }) => {
  const edges = useStore$1((s2) => s2.edges), defaultEdgeOptions = useStore$1((s2) => s2.defaultEdgeOptions), markers = useMemo(() => createMarkerIds(edges, {
    id: rfId,
    defaultColor,
    defaultMarkerStart: defaultEdgeOptions?.markerStart,
    defaultMarkerEnd: defaultEdgeOptions?.markerEnd
  }), [edges, defaultEdgeOptions, rfId, defaultColor]);
  return markers.length ? jsx("svg", { className: "react-flow__marker", children: jsx("defs", { children: markers.map((marker) => jsx(Marker, { id: marker.id, type: marker.type, color: marker.color, width: marker.width, height: marker.height, markerUnits: marker.markerUnits, strokeWidth: marker.strokeWidth, orient: marker.orient }, marker.id)) }) }) : null;
};
MarkerDefinitions.displayName = "MarkerDefinitions";
var MarkerDefinitions$1 = memo$2(MarkerDefinitions);
function EdgeTextComponent({ x: x2, y: y2, label: label2, labelStyle, labelShowBg = !0, labelBgStyle, labelBgPadding = [2, 4], labelBgBorderRadius = 2, children: children2, className, ...rest }) {
  const [edgeTextBbox, setEdgeTextBbox] = useState({ x: 1, y: 0, width: 0, height: 0 }), edgeTextClasses = cc(["react-flow__edge-textwrapper", className]), edgeTextRef = useRef(null);
  return useEffect(() => {
    if (edgeTextRef.current) {
      const textBbox = edgeTextRef.current.getBBox();
      setEdgeTextBbox({
        x: textBbox.x,
        y: textBbox.y,
        width: textBbox.width,
        height: textBbox.height
      });
    }
  }, [label2]), label2 ? jsxs("g", { transform: `translate(${x2 - edgeTextBbox.width / 2} ${y2 - edgeTextBbox.height / 2})`, className: edgeTextClasses, visibility: edgeTextBbox.width ? "visible" : "hidden", ...rest, children: [labelShowBg && jsx("rect", { width: edgeTextBbox.width + 2 * labelBgPadding[0], x: -labelBgPadding[0], y: -labelBgPadding[1], height: edgeTextBbox.height + 2 * labelBgPadding[1], className: "react-flow__edge-textbg", style: labelBgStyle, rx: labelBgBorderRadius, ry: labelBgBorderRadius }), jsx("text", { className: "react-flow__edge-text", y: edgeTextBbox.height / 2, dy: "0.3em", ref: edgeTextRef, style: labelStyle, children: label2 }), children2] }) : null;
}
EdgeTextComponent.displayName = "EdgeText";
const EdgeText = memo$2(EdgeTextComponent);
function BaseEdge({ path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {
  return jsxs(Fragment$1, { children: [jsx("path", { ...props, d: path, fill: "none", className: cc(["react-flow__edge-path", props.className]) }), interactionWidth && jsx("path", { d: path, fill: "none", strokeOpacity: 0, strokeWidth: interactionWidth, className: "react-flow__edge-interaction" }), label2 && isNumeric(labelX) && isNumeric(labelY) ? jsx(EdgeText, { x: labelX, y: labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius }) : null] });
}
function getControl({ pos, x1, y1, x2, y2 }) {
  return pos === Position.Left || pos === Position.Right ? [0.5 * (x1 + x2), y1] : [x1, 0.5 * (y1 + y2)];
}
function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top }) {
  const [sourceControlX, sourceControlY] = getControl({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY
  }), [targetControlX, targetControlY] = getControl({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY
  }), [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function createSimpleBezierEdge(params) {
  return memo$2(({ id: id2, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getSimpleBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const SimpleBezierEdge = createSimpleBezierEdge({ isInternal: !1 }), SimpleBezierEdgeInternal = createSimpleBezierEdge({ isInternal: !0 });
SimpleBezierEdge.displayName = "SimpleBezierEdge";
SimpleBezierEdgeInternal.displayName = "SimpleBezierEdgeInternal";
function createSmoothStepEdge(params) {
  return memo$2(({ id: id2, sourceX, sourceY, targetX, targetY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getSmoothStepPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      borderRadius: pathOptions?.borderRadius,
      offset: pathOptions?.offset
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const SmoothStepEdge = createSmoothStepEdge({ isInternal: !1 }), SmoothStepEdgeInternal = createSmoothStepEdge({ isInternal: !0 });
SmoothStepEdge.displayName = "SmoothStepEdge";
SmoothStepEdgeInternal.displayName = "SmoothStepEdgeInternal";
function createStepEdge(params) {
  return memo$2(({ id: id2, ...props }) => {
    const _id = params.isInternal ? void 0 : id2;
    return jsx(SmoothStepEdge, { ...props, id: _id, pathOptions: useMemo(() => ({ borderRadius: 0, offset: props.pathOptions?.offset }), [props.pathOptions?.offset]) });
  });
}
const StepEdge = createStepEdge({ isInternal: !1 }), StepEdgeInternal = createStepEdge({ isInternal: !0 });
StepEdge.displayName = "StepEdge";
StepEdgeInternal.displayName = "StepEdgeInternal";
function createStraightEdge(params) {
  return memo$2(({ id: id2, sourceX, sourceY, targetX, targetY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const StraightEdge = createStraightEdge({ isInternal: !1 }), StraightEdgeInternal = createStraightEdge({ isInternal: !0 });
StraightEdge.displayName = "StraightEdge";
StraightEdgeInternal.displayName = "StraightEdgeInternal";
function createBezierEdge(params) {
  return memo$2(({ id: id2, sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      curvature: pathOptions?.curvature
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const BezierEdge = createBezierEdge({ isInternal: !1 }), BezierEdgeInternal = createBezierEdge({ isInternal: !0 });
BezierEdge.displayName = "BezierEdge";
BezierEdgeInternal.displayName = "BezierEdgeInternal";
const builtinEdgeTypes = {
  default: BezierEdgeInternal,
  straight: StraightEdgeInternal,
  step: StepEdgeInternal,
  smoothstep: SmoothStepEdgeInternal,
  simplebezier: SimpleBezierEdgeInternal
}, nullPosition = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, shiftX = (x2, shift2, position) => position === Position.Left ? x2 - shift2 : position === Position.Right ? x2 + shift2 : x2, shiftY = (y2, shift2, position) => position === Position.Top ? y2 - shift2 : position === Position.Bottom ? y2 + shift2 : y2, EdgeUpdaterClassName = "react-flow__edgeupdater";
function EdgeAnchor({ position, centerX, centerY: centerY2, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {
  return jsx("circle", { onMouseDown, onMouseEnter, onMouseOut, className: cc([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${type}`]), cx: shiftX(centerX, radius, position), cy: shiftY(centerY2, radius, position), r: radius, stroke: "transparent", fill: "transparent" });
}
function EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {
  const store = useStoreApi(), handleEdgeUpdater = (event, oppositeHandle) => {
    if (event.button !== 0)
      return;
    const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib: lib2, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy: panBy2, updateConnection } = store.getState(), isTarget = oppositeHandle.type === "target";
    setReconnecting(!0), onReconnectStart?.(event, edge, oppositeHandle.type);
    const _onReconnectEnd = (evt, connectionState) => {
      setReconnecting(!1), onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);
    }, onConnectEdge = (connection) => onReconnect?.(edge, connection);
    XYHandle.onPointerDown(event.nativeEvent, {
      autoPanOnConnect,
      connectionMode,
      connectionRadius,
      domNode,
      handleId: oppositeHandle.id,
      nodeId: oppositeHandle.nodeId,
      nodeLookup,
      isTarget,
      edgeUpdaterType: oppositeHandle.type,
      lib: lib2,
      flowId,
      cancelConnection,
      panBy: panBy2,
      isValidConnection,
      onConnect: onConnectEdge,
      onConnectStart,
      onConnectEnd,
      onReconnectEnd: _onReconnectEnd,
      updateConnection,
      getTransform: () => store.getState().transform,
      getFromHandle: () => store.getState().connection.fromHandle
    });
  }, onReconnectSourceMouseDown = (event) => handleEdgeUpdater(event, { nodeId: edge.target, id: edge.targetHandle ?? null, type: "target" }), onReconnectTargetMouseDown = (event) => handleEdgeUpdater(event, { nodeId: edge.source, id: edge.sourceHandle ?? null, type: "source" }), onReconnectMouseEnter = () => setUpdateHover(!0), onReconnectMouseOut = () => setUpdateHover(!1);
  return jsxs(Fragment$1, { children: [(isReconnectable === !0 || isReconnectable === "source") && jsx(EdgeAnchor, { position: sourcePosition, centerX: sourceX, centerY: sourceY, radius: reconnectRadius, onMouseDown: onReconnectSourceMouseDown, onMouseEnter: onReconnectMouseEnter, onMouseOut: onReconnectMouseOut, type: "source" }), (isReconnectable === !0 || isReconnectable === "target") && jsx(EdgeAnchor, { position: targetPosition, centerX: targetX, centerY: targetY, radius: reconnectRadius, onMouseDown: onReconnectTargetMouseDown, onMouseEnter: onReconnectMouseEnter, onMouseOut: onReconnectMouseOut, type: "target" })] });
}
function EdgeWrapper({ id: id2, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes: edgeTypes2, noPanClassName, onError, disableKeyboardA11y }) {
  let edge = useStore$1((s2) => s2.edgeLookup.get(id2));
  const defaultEdgeOptions = useStore$1((s2) => s2.defaultEdgeOptions);
  edge = defaultEdgeOptions ? { ...defaultEdgeOptions, ...edge } : edge;
  let edgeType = edge.type || "default", EdgeComponent = edgeTypes2?.[edgeType] || builtinEdgeTypes[edgeType];
  EdgeComponent === void 0 && (onError?.("011", errorMessages.error011(edgeType)), edgeType = "default", EdgeComponent = builtinEdgeTypes.default);
  const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable > "u"), isReconnectable = typeof onReconnect < "u" && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable > "u"), isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable > "u"), edgeRef = useRef(null), [updateHover, setUpdateHover] = useState(!1), [reconnecting, setReconnecting] = useState(!1), store = useStoreApi(), { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore$1(useCallback((store2) => {
    const sourceNode = store2.nodeLookup.get(edge.source), targetNode = store2.nodeLookup.get(edge.target);
    if (!sourceNode || !targetNode)
      return {
        zIndex: edge.zIndex,
        ...nullPosition
      };
    const edgePosition = getEdgePosition({
      id: id2,
      sourceNode,
      targetNode,
      sourceHandle: edge.sourceHandle || null,
      targetHandle: edge.targetHandle || null,
      connectionMode: store2.connectionMode,
      onError
    });
    return {
      zIndex: getElevatedEdgeZIndex({
        selected: edge.selected,
        zIndex: edge.zIndex,
        sourceNode,
        targetNode,
        elevateOnSelect: store2.elevateEdgesOnSelect
      }),
      ...edgePosition || nullPosition
    };
  }, [edge.source, edge.target, edge.sourceHandle, edge.targetHandle, edge.selected, edge.zIndex]), shallow$1), markerStartUrl = useMemo(() => edge.markerStart ? `url('#${getMarkerId(edge.markerStart, rfId)}')` : void 0, [edge.markerStart, rfId]), markerEndUrl = useMemo(() => edge.markerEnd ? `url('#${getMarkerId(edge.markerEnd, rfId)}')` : void 0, [edge.markerEnd, rfId]);
  if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null)
    return null;
  const onEdgeClick = (event) => {
    const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();
    isSelectable && (store.setState({ nodesSelectionActive: !1 }), edge.selected && multiSelectionActive ? (unselectNodesAndEdges({ nodes: [], edges: [edge] }), edgeRef.current?.blur()) : addSelectedEdges([id2])), onClick && onClick(event, edge);
  }, onEdgeDoubleClick = onDoubleClick ? (event) => {
    onDoubleClick(event, { ...edge });
  } : void 0, onEdgeContextMenu = onContextMenu ? (event) => {
    onContextMenu(event, { ...edge });
  } : void 0, onEdgeMouseEnter = onMouseEnter ? (event) => {
    onMouseEnter(event, { ...edge });
  } : void 0, onEdgeMouseMove = onMouseMove ? (event) => {
    onMouseMove(event, { ...edge });
  } : void 0, onEdgeMouseLeave = onMouseLeave ? (event) => {
    onMouseLeave(event, { ...edge });
  } : void 0, onKeyDown = (event) => {
    if (!disableKeyboardA11y && elementSelectionKeys.includes(event.key) && isSelectable) {
      const { unselectNodesAndEdges, addSelectedEdges } = store.getState();
      event.key === "Escape" ? (edgeRef.current?.blur(), unselectNodesAndEdges({ edges: [edge] })) : addSelectedEdges([id2]);
    }
  };
  return jsx("svg", { style: { zIndex }, children: jsxs("g", { className: cc([
    "react-flow__edge",
    `react-flow__edge-${edgeType}`,
    edge.className,
    noPanClassName,
    {
      selected: edge.selected,
      animated: edge.animated,
      inactive: !isSelectable && !onClick,
      updating: updateHover,
      selectable: isSelectable
    }
  ]), onClick: onEdgeClick, onDoubleClick: onEdgeDoubleClick, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: isFocusable ? "button" : "img", "data-id": id2, "data-testid": `rf__edge-${id2}`, "aria-label": edge.ariaLabel === null ? void 0 : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`, "aria-describedby": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : void 0, ref: edgeRef, children: [!reconnecting && jsx(EdgeComponent, { id: id2, source: edge.source, target: edge.target, type: edge.type, selected: edge.selected, animated: edge.animated, selectable: isSelectable, deletable: edge.deletable ?? !0, label: edge.label, labelStyle: edge.labelStyle, labelShowBg: edge.labelShowBg, labelBgStyle: edge.labelBgStyle, labelBgPadding: edge.labelBgPadding, labelBgBorderRadius: edge.labelBgBorderRadius, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, data: edge.data, style: edge.style, sourceHandleId: edge.sourceHandle, targetHandleId: edge.targetHandle, markerStart: markerStartUrl, markerEnd: markerEndUrl, pathOptions: "pathOptions" in edge ? edge.pathOptions : void 0, interactionWidth: edge.interactionWidth }), isReconnectable && jsx(EdgeUpdateAnchors, { edge, isReconnectable, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, setUpdateHover, setReconnecting })] }) });
}
const selector$a = (s2) => ({
  edgesFocusable: s2.edgesFocusable,
  edgesReconnectable: s2.edgesReconnectable,
  elementsSelectable: s2.elementsSelectable,
  connectionMode: s2.connectionMode,
  onError: s2.onError
});
function EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes: edgeTypes2, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {
  const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore$1(selector$a, shallow$1), edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);
  return jsxs("div", { className: "react-flow__edges", children: [jsx(MarkerDefinitions$1, { defaultColor: defaultMarkerColor, rfId }), edgeIds.map((id2) => jsx(EdgeWrapper, { id: id2, edgesFocusable, edgesReconnectable, elementsSelectable, noPanClassName, onReconnect, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onClick: onEdgeClick, reconnectRadius, onDoubleClick: onEdgeDoubleClick, onReconnectStart, onReconnectEnd, rfId, onError, edgeTypes: edgeTypes2, disableKeyboardA11y }, id2))] });
}
EdgeRendererComponent.displayName = "EdgeRenderer";
const EdgeRenderer = memo$2(EdgeRendererComponent), selector$9 = (s2) => `translate(${s2.transform[0]}px,${s2.transform[1]}px) scale(${s2.transform[2]})`;
function Viewport({ children: children2 }) {
  const transform2 = useStore$1(selector$9);
  return jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: transform2 }, children: children2 });
}
function useOnInitHandler(onInit) {
  const rfInstance = useReactFlow(), isInitialized = useRef(!1);
  useEffect(() => {
    !isInitialized.current && rfInstance.viewportInitialized && onInit && (setTimeout(() => onInit(rfInstance), 1), isInitialized.current = !0);
  }, [onInit, rfInstance.viewportInitialized]);
}
const selector$8 = (state) => state.panZoom?.syncViewport;
function useViewportSync(viewport) {
  const syncViewport = useStore$1(selector$8), store = useStoreApi();
  return useEffect(() => {
    viewport && (syncViewport?.(viewport), store.setState({ transform: [viewport.x, viewport.y, viewport.zoom] }));
  }, [viewport, syncViewport]), null;
}
function storeSelector$1(s2) {
  return s2.connection.inProgress ? { ...s2.connection, to: pointToRendererPoint(s2.connection.to, s2.transform) } : { ...s2.connection };
}
function getSelector(connectionSelector) {
  return storeSelector$1;
}
function useConnection(connectionSelector) {
  const combinedSelector = getSelector();
  return useStore$1(combinedSelector, shallow$1);
}
const selector$7 = (s2) => ({
  nodesConnectable: s2.nodesConnectable,
  isValid: s2.connection.isValid,
  inProgress: s2.connection.inProgress,
  width: s2.width,
  height: s2.height
});
function ConnectionLineWrapper({ containerStyle: containerStyle2, style: style2, type, component }) {
  const { nodesConnectable, width, height, isValid, inProgress } = useStore$1(selector$7, shallow$1);
  return !(width && nodesConnectable && inProgress) ? null : jsx("svg", { style: containerStyle2, width, height, className: "react-flow__connectionline react-flow__container", children: jsx("g", { className: cc(["react-flow__connection", getConnectionStatus(isValid)]), children: jsx(ConnectionLine, { style: style2, type, CustomComponent: component, isValid }) }) });
}
const ConnectionLine = ({ style: style2, type = ConnectionLineType.Bezier, CustomComponent, isValid }) => {
  const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();
  if (!inProgress)
    return;
  if (CustomComponent)
    return jsx(CustomComponent, { connectionLineType: type, connectionLineStyle: style2, fromNode, fromHandle, fromX: from.x, fromY: from.y, toX: to.x, toY: to.y, fromPosition, toPosition, connectionStatus: getConnectionStatus(isValid), toNode, toHandle });
  let path = "";
  const pathParams = {
    sourceX: from.x,
    sourceY: from.y,
    sourcePosition: fromPosition,
    targetX: to.x,
    targetY: to.y,
    targetPosition: toPosition
  };
  switch (type) {
    case ConnectionLineType.Bezier:
      [path] = getBezierPath(pathParams);
      break;
    case ConnectionLineType.SimpleBezier:
      [path] = getSimpleBezierPath(pathParams);
      break;
    case ConnectionLineType.Step:
      [path] = getSmoothStepPath({
        ...pathParams,
        borderRadius: 0
      });
      break;
    case ConnectionLineType.SmoothStep:
      [path] = getSmoothStepPath(pathParams);
      break;
    default:
      [path] = getStraightPath(pathParams);
  }
  return jsx("path", { d: path, fill: "none", className: "react-flow__connection-path", style: style2 });
};
ConnectionLine.displayName = "ConnectionLine";
const emptyTypes = {};
function useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {
  useRef(nodeOrEdgeTypes), useStoreApi(), useEffect(() => {
  }, [nodeOrEdgeTypes]);
}
function useStylesLoadedWarning() {
  useStoreApi(), useRef(!1), useEffect(() => {
  }, []);
}
function GraphViewComponent({ nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {
  return useNodeOrEdgeTypesWarning(nodeTypes2), useNodeOrEdgeTypesWarning(edgeTypes2), useStylesLoadedWarning(), useOnInitHandler(onInit), useViewportSync(viewport), jsx(FlowRenderer, { onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, onSelectionContextMenu, preventScrolling, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport: !!viewport, children: jsxs(Viewport, { children: [jsx(EdgeRenderer, { edgeTypes: edgeTypes2, onEdgeClick, onEdgeDoubleClick, onReconnect, onReconnectStart, onReconnectEnd, onlyRenderVisibleElements, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, defaultMarkerColor, noPanClassName, disableKeyboardA11y, rfId }), jsx(ConnectionLineWrapper, { style: connectionLineStyle, type: connectionLineType, component: connectionLineComponent, containerStyle: connectionLineContainerStyle }), jsx("div", { className: "react-flow__edgelabel-renderer" }), jsx(NodeRenderer, { nodeTypes: nodeTypes2, onNodeClick, onNodeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, nodeClickDistance, onlyRenderVisibleElements, noPanClassName, noDragClassName, disableKeyboardA11y, nodeExtent, rfId }), jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
GraphViewComponent.displayName = "GraphView";
const GraphView = memo$2(GraphViewComponent), getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent } = {}) => {
  const nodeLookup = /* @__PURE__ */ new Map(), parentLookup = /* @__PURE__ */ new Map(), connectionLookup = /* @__PURE__ */ new Map(), edgeLookup = /* @__PURE__ */ new Map(), storeEdges = defaultEdges ?? edges ?? [], storeNodes = defaultNodes ?? nodes ?? [], storeNodeOrigin = nodeOrigin ?? [0, 0], storeNodeExtent = nodeExtent ?? infiniteExtent;
  updateConnectionLookup(connectionLookup, edgeLookup, storeEdges), adoptUserNodes(storeNodes, nodeLookup, parentLookup, {
    nodeOrigin: storeNodeOrigin,
    nodeExtent: storeNodeExtent,
    elevateNodesOnSelect: !1
  });
  let transform2 = [0, 0, 1];
  if (fitView && width && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node2) => !!((node2.width || node2.initialWidth) && (node2.height || node2.initialHeight))
    }), { x: x2, y: y2, zoom: zoom2 } = getViewportForBounds(bounds, width, height, 0.5, 2, 0.1);
    transform2 = [x2, y2, zoom2];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: transform2,
    nodes: storeNodes,
    nodeLookup,
    parentLookup,
    edges: storeEdges,
    edgeLookup,
    connectionLookup,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: defaultNodes !== void 0,
    hasDefaultEdges: defaultEdges !== void 0,
    panZoom: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: infiniteExtent,
    nodeExtent: storeNodeExtent,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: ConnectionMode.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: storeNodeOrigin,
    nodeDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: fitView ?? !1,
    fitViewOptions: void 0,
    fitViewResolver: null,
    connection: { ...initialConnection },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: devWarn,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1
  };
}, createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent }) => createWithEqualityFn((set2, get2) => {
  async function resolveFitView() {
    const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width: width2, height: height2, minZoom, maxZoom } = get2();
    panZoom && (await fitViewport({
      nodes: nodeLookup,
      width: width2,
      height: height2,
      panZoom,
      minZoom,
      maxZoom
    }, fitViewOptions), fitViewResolver?.resolve(!0), set2({ fitViewResolver: null }));
  }
  return {
    ...getInitialState({ nodes, edges, width, height, fitView, nodeOrigin, nodeExtent, defaultNodes, defaultEdges }),
    setNodes: (nodes2) => {
      const { nodeLookup, parentLookup, nodeOrigin: nodeOrigin2, elevateNodesOnSelect, fitViewQueued } = get2(), nodesInitialized = adoptUserNodes(nodes2, nodeLookup, parentLookup, {
        nodeOrigin: nodeOrigin2,
        nodeExtent,
        elevateNodesOnSelect,
        checkEquality: !0
      });
      fitViewQueued && nodesInitialized ? (resolveFitView(), set2({ nodes: nodes2, fitViewQueued: !1, fitViewOptions: void 0 })) : set2({ nodes: nodes2 });
    },
    setEdges: (edges2) => {
      const { connectionLookup, edgeLookup } = get2();
      updateConnectionLookup(connectionLookup, edgeLookup, edges2), set2({ edges: edges2 });
    },
    setDefaultNodesAndEdges: (nodes2, edges2) => {
      if (nodes2) {
        const { setNodes } = get2();
        setNodes(nodes2), set2({ hasDefaultNodes: !0 });
      }
      if (edges2) {
        const { setEdges } = get2();
        setEdges(edges2), set2({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (updates) => {
      const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin: nodeOrigin2, nodeExtent: nodeExtent2, debug: debug2, fitViewQueued } = get2(), { changes, updatedInternals } = updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin2, nodeExtent2);
      updatedInternals && (updateAbsolutePositions(nodeLookup, parentLookup, { nodeOrigin: nodeOrigin2, nodeExtent: nodeExtent2 }), fitViewQueued ? (resolveFitView(), set2({ fitViewQueued: !1, fitViewOptions: void 0 })) : set2({}), changes?.length > 0 && (debug2 && console.log("React Flow: trigger node changes", changes), triggerNodeChanges?.(changes)));
    },
    updateNodePositions: (nodeDragItems, dragging = !1) => {
      const parentExpandChildren = [], changes = [], { nodeLookup, triggerNodeChanges } = get2();
      for (const [id2, dragItem] of nodeDragItems) {
        const node2 = nodeLookup.get(id2), expandParent = !!(node2?.expandParent && node2?.parentId && dragItem?.position), change = {
          id: id2,
          type: "position",
          position: expandParent ? {
            x: Math.max(0, dragItem.position.x),
            y: Math.max(0, dragItem.position.y)
          } : dragItem.position,
          dragging
        };
        expandParent && node2.parentId && parentExpandChildren.push({
          id: id2,
          parentId: node2.parentId,
          rect: {
            ...dragItem.internals.positionAbsolute,
            width: dragItem.measured.width ?? 0,
            height: dragItem.measured.height ?? 0
          }
        }), changes.push(change);
      }
      if (parentExpandChildren.length > 0) {
        const { parentLookup, nodeOrigin: nodeOrigin2 } = get2(), parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin2);
        changes.push(...parentExpandChanges);
      }
      triggerNodeChanges(changes);
    },
    triggerNodeChanges: (changes) => {
      const { onNodesChange, setNodes, nodes: nodes2, hasDefaultNodes, debug: debug2 } = get2();
      if (changes?.length) {
        if (hasDefaultNodes) {
          const updatedNodes = applyNodeChanges(changes, nodes2);
          setNodes(updatedNodes);
        }
        debug2 && console.log("React Flow: trigger node changes", changes), onNodesChange?.(changes);
      }
    },
    triggerEdgeChanges: (changes) => {
      const { onEdgesChange, setEdges, edges: edges2, hasDefaultEdges, debug: debug2 } = get2();
      if (changes?.length) {
        if (hasDefaultEdges) {
          const updatedEdges = applyEdgeChanges(changes, edges2);
          setEdges(updatedEdges);
        }
        debug2 && console.log("React Flow: trigger edge changes", changes), onEdgesChange?.(changes);
      }
    },
    addSelectedNodes: (selectedNodeIds) => {
      const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2();
      if (multiSelectionActive) {
        const nodeChanges = selectedNodeIds.map((nodeId) => createSelectionChange(nodeId, !0));
        triggerNodeChanges(nodeChanges);
        return;
      }
      triggerNodeChanges(getSelectionChanges(nodeLookup, /* @__PURE__ */ new Set([...selectedNodeIds]), !0)), triggerEdgeChanges(getSelectionChanges(edgeLookup));
    },
    addSelectedEdges: (selectedEdgeIds) => {
      const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2();
      if (multiSelectionActive) {
        const changedEdges = selectedEdgeIds.map((edgeId) => createSelectionChange(edgeId, !0));
        triggerEdgeChanges(changedEdges);
        return;
      }
      triggerEdgeChanges(getSelectionChanges(edgeLookup, /* @__PURE__ */ new Set([...selectedEdgeIds]))), triggerNodeChanges(getSelectionChanges(nodeLookup, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: nodes2, edges: edges2 } = {}) => {
      const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2(), nodesToUnselect = nodes2 || storeNodes, edgesToUnselect = edges2 || storeEdges, nodeChanges = nodesToUnselect.map((n2) => {
        const internalNode = nodeLookup.get(n2.id);
        return internalNode && (internalNode.selected = !1), createSelectionChange(n2.id, !1);
      }), edgeChanges = edgesToUnselect.map((edge) => createSelectionChange(edge.id, !1));
      triggerNodeChanges(nodeChanges), triggerEdgeChanges(edgeChanges);
    },
    setMinZoom: (minZoom) => {
      const { panZoom, maxZoom } = get2();
      panZoom?.setScaleExtent([minZoom, maxZoom]), set2({ minZoom });
    },
    setMaxZoom: (maxZoom) => {
      const { panZoom, minZoom } = get2();
      panZoom?.setScaleExtent([minZoom, maxZoom]), set2({ maxZoom });
    },
    setTranslateExtent: (translateExtent) => {
      get2().panZoom?.setTranslateExtent(translateExtent), set2({ translateExtent });
    },
    setPaneClickDistance: (clickDistance) => {
      get2().panZoom?.setClickDistance(clickDistance);
    },
    resetSelectedElements: () => {
      const { edges: edges2, nodes: nodes2, triggerNodeChanges, triggerEdgeChanges } = get2(), nodeChanges = nodes2.reduce((res, node2) => node2.selected ? [...res, createSelectionChange(node2.id, !1)] : res, []), edgeChanges = edges2.reduce((res, edge) => edge.selected ? [...res, createSelectionChange(edge.id, !1)] : res, []);
      triggerNodeChanges(nodeChanges), triggerEdgeChanges(edgeChanges);
    },
    setNodeExtent: (nextNodeExtent) => {
      const { nodes: nodes2, nodeLookup, parentLookup, nodeOrigin: nodeOrigin2, elevateNodesOnSelect, nodeExtent: nodeExtent2 } = get2();
      nextNodeExtent[0][0] === nodeExtent2[0][0] && nextNodeExtent[0][1] === nodeExtent2[0][1] && nextNodeExtent[1][0] === nodeExtent2[1][0] && nextNodeExtent[1][1] === nodeExtent2[1][1] || (adoptUserNodes(nodes2, nodeLookup, parentLookup, {
        nodeOrigin: nodeOrigin2,
        nodeExtent: nextNodeExtent,
        elevateNodesOnSelect,
        checkEquality: !1
      }), set2({ nodeExtent: nextNodeExtent }));
    },
    panBy: (delta) => {
      const { transform: transform2, width: width2, height: height2, panZoom, translateExtent } = get2();
      return panBy({ delta, panZoom, transform: transform2, translateExtent, width: width2, height: height2 });
    },
    cancelConnection: () => {
      set2({
        connection: { ...initialConnection }
      });
    },
    updateConnection: (connection) => {
      set2({ connection });
    },
    reset: () => set2({ ...getInitialState() })
  };
}, Object.is);
function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, fitView, nodeOrigin, nodeExtent, children: children2 }) {
  const [store] = useState(() => createStore({
    nodes,
    edges,
    defaultNodes,
    defaultEdges,
    width,
    height,
    fitView,
    nodeOrigin,
    nodeExtent
  }));
  return jsx(Provider$1, { value: store, children: jsx(BatchProvider, { children: children2 }) });
}
function Wrapper({ children: children2, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent }) {
  return useContext(StoreContext) ? jsx(Fragment$1, { children: children2 }) : jsx(ReactFlowProvider, { initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, fitView, nodeOrigin, nodeExtent, children: children2 });
}
const wrapperStyle = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = "Backspace", selectionKeyCode = "Shift", selectionOnDrag = !1, selectionMode = SelectionMode.Full, panActivationKeyCode = "Space", multiSelectionKeyCode = isMacOs() ? "Meta" : "Control", zoomActivationKeyCode = isMacOs() ? "Meta" : "Control", snapToGrid, snapGrid, onlyRenderVisibleElements = !1, selectNodesOnDrag, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = !0, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = !0, nodeExtent, defaultMarkerColor = "#b1b1b7", zoomOnScroll = !0, zoomOnPinch = !0, panOnScroll = !1, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = !0, panOnDrag = !0, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children: children2, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = "nodrag", noWheelClassName = "nowheel", noPanClassName = "nopan", fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = !1, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style: style2, id: id2, nodeDragThreshold, viewport, onViewportChange, width, height, colorMode = "light", debug: debug2, onScroll, ...rest }, ref) {
  const rfId = id2 || "1", colorModeClassName = useColorModeClass(colorMode), wrapperOnScroll = useCallback((e2) => {
    e2.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), onScroll?.(e2);
  }, [onScroll]);
  return jsx("div", { "data-testid": "rf__wrapper", ...rest, onScroll: wrapperOnScroll, style: { ...style2, ...wrapperStyle }, ref, className: cc(["react-flow", className, colorModeClassName]), id: id2, children: jsxs(Wrapper, { nodes, edges, width, height, fitView, nodeOrigin, nodeExtent, children: [jsx(GraphView, { onInit, onNodeClick, onEdgeClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, deleteKeyCode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, onlyRenderVisibleElements, defaultViewport: defaultViewport$1, translateExtent, minZoom, maxZoom, preventScrolling, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, defaultMarkerColor, noDragClassName, noWheelClassName, noPanClassName, rfId, disableKeyboardA11y, nodeExtent, viewport, onViewportChange }), jsx(StoreUpdater, { nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesReconnectable, elementsSelectable, elevateNodesOnSelect, elevateEdgesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, snapToGrid, snapGrid, connectionMode, translateExtent, connectOnClick, defaultEdgeOptions, fitView, fitViewOptions, onNodesDelete, onEdgesDelete, onDelete, onNodeDragStart, onNodeDrag, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, onMove, onMoveStart, onMoveEnd, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, onError, connectionRadius, isValidConnection, selectNodesOnDrag, nodeDragThreshold, onBeforeDelete, paneClickDistance, debug: debug2 }), jsx(SelectionListener, { onSelectionChange }), children2, jsx(Attribution, { proOptions, position: attributionPosition }), jsx(A11yDescriptions, { rfId, disableKeyboardA11y })] }) });
}
var index = fixedForwardRef(ReactFlow);
const selector$6 = (s2) => s2.domNode?.querySelector(".react-flow__edgelabel-renderer");
function EdgeLabelRenderer({ children: children2 }) {
  const edgeLabelRenderer = useStore$1(selector$6);
  return edgeLabelRenderer ? createPortal(children2, edgeLabelRenderer) : null;
}
function useInternalNode(id2) {
  return useStore$1(useCallback((s2) => s2.nodeLookup.get(id2), [id2]), shallow$1);
}
function LinePattern({ dimensions, lineWidth, variant, className }) {
  return jsx("path", { strokeWidth: lineWidth, d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`, className: cc(["react-flow__background-pattern", variant, className]) });
}
function DotPattern({ radius, className }) {
  return jsx("circle", { cx: radius, cy: radius, r: radius, className: cc(["react-flow__background-pattern", "dots", className]) });
}
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2.Lines = "lines", BackgroundVariant2.Dots = "dots", BackgroundVariant2.Cross = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));
const defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
}, selector$3$1 = (s2) => ({ transform: s2.transform, patternId: `pattern-${s2.rfId}` });
function BackgroundComponent({
  id: id2,
  variant = BackgroundVariant.Dots,
  // only used for dots and cross
  gap = 20,
  // only used for lines and cross
  size: size2,
  lineWidth = 1,
  offset: offset2 = 0,
  color: color2,
  bgColor,
  style: style2,
  className,
  patternClassName
}) {
  const ref = useRef(null), { transform: transform2, patternId } = useStore$1(selector$3$1, shallow$1), patternSize = size2 || defaultSize[variant], isDots = variant === BackgroundVariant.Dots, isCross = variant === BackgroundVariant.Cross, gapXY = Array.isArray(gap) ? gap : [gap, gap], scaledGap = [gapXY[0] * transform2[2] || 1, gapXY[1] * transform2[2] || 1], scaledSize = patternSize * transform2[2], offsetXY = Array.isArray(offset2) ? offset2 : [offset2, offset2], patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap, scaledOffset = [
    offsetXY[0] * transform2[2] || 1 + patternDimensions[0] / 2,
    offsetXY[1] * transform2[2] || 1 + patternDimensions[1] / 2
  ], _patternId = `${patternId}${id2 || ""}`;
  return jsxs("svg", { className: cc(["react-flow__background", className]), style: {
    ...style2,
    ...containerStyle,
    "--xy-background-color-props": bgColor,
    "--xy-background-pattern-color-props": color2
  }, ref, "data-testid": "rf__background", children: [jsx("pattern", { id: _patternId, x: transform2[0] % scaledGap[0], y: transform2[1] % scaledGap[1], width: scaledGap[0], height: scaledGap[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`, children: isDots ? jsx(DotPattern, { radius: scaledSize / 2, className: patternClassName }) : jsx(LinePattern, { dimensions: patternDimensions, lineWidth, variant, className: patternClassName }) }), jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${_patternId})` })] });
}
BackgroundComponent.displayName = "Background";
const Background$1 = memo$2(BackgroundComponent);
function PlusIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function MinusIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function FitViewIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function LockIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function UnlockIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function ControlButton({ children: children2, className, ...rest }) {
  return jsx("button", { type: "button", className: cc(["react-flow__controls-button", className]), ...rest, children: children2 });
}
const selector$2$1 = (s2) => ({
  isInteractive: s2.nodesDraggable || s2.nodesConnectable || s2.elementsSelectable,
  minZoomReached: s2.transform[2] <= s2.minZoom,
  maxZoomReached: s2.transform[2] >= s2.maxZoom
});
function ControlsComponent({ style: style2, showZoom = !0, showFitView = !0, showInteractive = !0, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children: children2, position = "bottom-left", orientation = "vertical", "aria-label": ariaLabel = "React Flow controls" }) {
  const store = useStoreApi(), { isInteractive, minZoomReached, maxZoomReached } = useStore$1(selector$2$1, shallow$1), { zoomIn, zoomOut, fitView } = useReactFlow(), onZoomInHandler = () => {
    zoomIn(), onZoomIn?.();
  }, onZoomOutHandler = () => {
    zoomOut(), onZoomOut?.();
  }, onFitViewHandler = () => {
    fitView(fitViewOptions), onFitView?.();
  }, onToggleInteractivity = () => {
    store.setState({
      nodesDraggable: !isInteractive,
      nodesConnectable: !isInteractive,
      elementsSelectable: !isInteractive
    }), onInteractiveChange?.(!isInteractive);
  };
  return jsxs(Panel, { className: cc(["react-flow__controls", orientation === "horizontal" ? "horizontal" : "vertical", className]), position, style: style2, "data-testid": "rf__controls", "aria-label": ariaLabel, children: [showZoom && jsxs(Fragment$1, { children: [jsx(ControlButton, { onClick: onZoomInHandler, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: maxZoomReached, children: jsx(PlusIcon, {}) }), jsx(ControlButton, { onClick: onZoomOutHandler, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: minZoomReached, children: jsx(MinusIcon, {}) })] }), showFitView && jsx(ControlButton, { className: "react-flow__controls-fitview", onClick: onFitViewHandler, title: "fit view", "aria-label": "fit view", children: jsx(FitViewIcon, {}) }), showInteractive && jsx(ControlButton, { className: "react-flow__controls-interactive", onClick: onToggleInteractivity, title: "toggle interactivity", "aria-label": "toggle interactivity", children: isInteractive ? jsx(UnlockIcon, {}) : jsx(LockIcon, {}) }), children2] });
}
ControlsComponent.displayName = "Controls";
memo$2(ControlsComponent);
function MiniMapNodeComponent({ id: id2, x: x2, y: y2, width, height, style: style2, color: color2, strokeColor, strokeWidth, className, borderRadius: borderRadius2, shapeRendering, selected: selected2, onClick }) {
  const { background, backgroundColor } = style2 || {}, fill = color2 || background || backgroundColor;
  return jsx("rect", { className: cc(["react-flow__minimap-node", { selected: selected2 }, className]), x: x2, y: y2, rx: borderRadius2, ry: borderRadius2, width, height, style: {
    fill,
    stroke: strokeColor,
    strokeWidth
  }, shapeRendering, onClick: onClick ? (event) => onClick(event, id2) : void 0 });
}
const MiniMapNode = memo$2(MiniMapNodeComponent), selectorNodeIds = (s2) => s2.nodes.map((node2) => node2.id), getAttrFunction = (func) => func instanceof Function ? func : () => func;
function MiniMapNodes({
  nodeStrokeColor,
  nodeColor,
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: NodeComponent = MiniMapNode,
  onClick
}) {
  const nodeIds = useStore$1(selectorNodeIds, shallow$1), nodeColorFunc = getAttrFunction(nodeColor), nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor), nodeClassNameFunc = getAttrFunction(nodeClassName), shapeRendering = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return jsx(Fragment$1, { children: nodeIds.map((nodeId) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    jsx(NodeComponentWrapper, { id: nodeId, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, NodeComponent, onClick, shapeRendering }, nodeId)
  )) });
}
function NodeComponentWrapperInner({ id: id2, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {
  const { node: node2, x: x2, y: y2, width, height } = useStore$1((s2) => {
    const { internals } = s2.nodeLookup.get(id2), node22 = internals.userNode, { x: x22, y: y22 } = internals.positionAbsolute, { width: width2, height: height2 } = getNodeDimensions(node22);
    return {
      node: node22,
      x: x22,
      y: y22,
      width: width2,
      height: height2
    };
  }, shallow$1);
  return !node2 || node2.hidden || !nodeHasDimensions(node2) ? null : jsx(NodeComponent, { x: x2, y: y2, width, height, style: node2.style, selected: !!node2.selected, className: nodeClassNameFunc(node2), color: nodeColorFunc(node2), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node2), strokeWidth: nodeStrokeWidth, shapeRendering, onClick, id: node2.id });
}
const NodeComponentWrapper = memo$2(NodeComponentWrapperInner);
var MiniMapNodes$1 = memo$2(MiniMapNodes);
const defaultWidth = 200, defaultHeight = 150, filterHidden = (node2) => !node2.hidden, selector$1$1 = (s2) => {
  const viewBB = {
    x: -s2.transform[0] / s2.transform[2],
    y: -s2.transform[1] / s2.transform[2],
    width: s2.width / s2.transform[2],
    height: s2.height / s2.transform[2]
  };
  return {
    viewBB,
    boundingRect: s2.nodeLookup.size > 0 ? getBoundsOfRects(getInternalNodesBounds(s2.nodeLookup, { filter: filterHidden }), viewBB) : viewBB,
    rfId: s2.rfId,
    panZoom: s2.panZoom,
    translateExtent: s2.translateExtent,
    flowWidth: s2.width,
    flowHeight: s2.height
  };
}, ARIA_LABEL_KEY = "react-flow__minimap-desc";
function MiniMapComponent({
  style: style2,
  className,
  nodeStrokeColor,
  nodeColor,
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent,
  bgColor,
  maskColor,
  maskStrokeColor,
  maskStrokeWidth,
  position = "bottom-right",
  onClick,
  onNodeClick,
  pannable = !1,
  zoomable = !1,
  ariaLabel = "React Flow mini map",
  inversePan,
  zoomStep = 10,
  offsetScale = 5
}) {
  const store = useStoreApi(), svg = useRef(null), { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight } = useStore$1(selector$1$1, shallow$1), elementWidth = style2?.width ?? defaultWidth, elementHeight = style2?.height ?? defaultHeight, scaledWidth = boundingRect.width / elementWidth, scaledHeight = boundingRect.height / elementHeight, viewScale = Math.max(scaledWidth, scaledHeight), viewWidth = viewScale * elementWidth, viewHeight = viewScale * elementHeight, offset2 = offsetScale * viewScale, x2 = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset2, y2 = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset2, width = viewWidth + offset2 * 2, height = viewHeight + offset2 * 2, labelledBy = `${ARIA_LABEL_KEY}-${rfId}`, viewScaleRef = useRef(0), minimapInstance = useRef();
  viewScaleRef.current = viewScale, useEffect(() => {
    if (svg.current && panZoom)
      return minimapInstance.current = XYMinimap({
        domNode: svg.current,
        panZoom,
        getTransform: () => store.getState().transform,
        getViewScale: () => viewScaleRef.current
      }), () => {
        minimapInstance.current?.destroy();
      };
  }, [panZoom]), useEffect(() => {
    minimapInstance.current?.update({
      translateExtent,
      width: flowWidth,
      height: flowHeight,
      inversePan,
      pannable,
      zoomStep,
      zoomable
    });
  }, [pannable, zoomable, inversePan, zoomStep, translateExtent, flowWidth, flowHeight]);
  const onSvgClick = onClick ? (event) => {
    const [x22, y22] = minimapInstance.current?.pointer(event) || [0, 0];
    onClick(event, { x: x22, y: y22 });
  } : void 0, onSvgNodeClick = onNodeClick ? useCallback((event, nodeId) => {
    const node2 = store.getState().nodeLookup.get(nodeId).internals.userNode;
    onNodeClick(event, node2);
  }, []) : void 0;
  return jsx(Panel, { position, style: {
    ...style2,
    "--xy-minimap-background-color-props": typeof bgColor == "string" ? bgColor : void 0,
    "--xy-minimap-mask-background-color-props": typeof maskColor == "string" ? maskColor : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof maskStrokeColor == "string" ? maskStrokeColor : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof maskStrokeWidth == "number" ? maskStrokeWidth * viewScale : void 0,
    "--xy-minimap-node-background-color-props": typeof nodeColor == "string" ? nodeColor : void 0,
    "--xy-minimap-node-stroke-color-props": typeof nodeStrokeColor == "string" ? nodeStrokeColor : void 0,
    "--xy-minimap-node-stroke-width-props": typeof nodeStrokeWidth == "number" ? nodeStrokeWidth : void 0
  }, className: cc(["react-flow__minimap", className]), "data-testid": "rf__minimap", children: jsxs("svg", { width: elementWidth, height: elementHeight, viewBox: `${x2} ${y2} ${width} ${height}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": labelledBy, ref: svg, onClick: onSvgClick, children: [ariaLabel && jsx("title", { id: labelledBy, children: ariaLabel }), jsx(MiniMapNodes$1, { onClick: onSvgNodeClick, nodeColor, nodeStrokeColor, nodeBorderRadius, nodeClassName, nodeStrokeWidth, nodeComponent }), jsx("path", { className: "react-flow__minimap-mask", d: `M${x2 - offset2},${y2 - offset2}h${width + offset2 * 2}v${height + offset2 * 2}h${-width - offset2 * 2}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
MiniMapComponent.displayName = "MiniMap";
memo$2(MiniMapComponent);
function ResizeControl({ nodeId, position, variant = ResizeControlVariant.Handle, className, style: style2 = {}, children: children2, color: color2, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = !1, shouldResize, onResizeStart, onResize, onResizeEnd }) {
  const contextNodeId = useNodeId(), id2 = typeof nodeId == "string" ? nodeId : contextNodeId, store = useStoreApi(), resizeControlRef = useRef(null), defaultPosition = variant === ResizeControlVariant.Line ? "right" : "bottom-right", controlPosition = position ?? defaultPosition, resizer = useRef(null);
  useEffect(() => {
    if (!(!resizeControlRef.current || !id2))
      return resizer.current || (resizer.current = XYResizer({
        domNode: resizeControlRef.current,
        nodeId: id2,
        getStoreItems: () => {
          const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();
          return {
            nodeLookup,
            transform: transform2,
            snapGrid,
            snapToGrid,
            nodeOrigin,
            paneDomNode: domNode
          };
        },
        onChange: (change, childChanges) => {
          const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState(), changes = [], nextPosition = { x: change.x, y: change.y }, node2 = nodeLookup.get(id2);
          if (node2 && node2.expandParent && node2.parentId) {
            const origin = node2.origin ?? nodeOrigin, width = change.width ?? node2.measured.width ?? 0, height = change.height ?? node2.measured.height ?? 0, child = {
              id: node2.id,
              parentId: node2.parentId,
              rect: {
                width,
                height,
                ...evaluateAbsolutePosition({
                  x: change.x ?? node2.position.x,
                  y: change.y ?? node2.position.y
                }, { width, height }, node2.parentId, nodeLookup, origin)
              }
            }, parentExpandChanges = handleExpandParent([child], nodeLookup, parentLookup, nodeOrigin);
            changes.push(...parentExpandChanges), nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : void 0, nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : void 0;
          }
          if (nextPosition.x !== void 0 && nextPosition.y !== void 0) {
            const positionChange = {
              id: id2,
              type: "position",
              position: { ...nextPosition }
            };
            changes.push(positionChange);
          }
          if (change.width !== void 0 && change.height !== void 0) {
            const dimensionChange = {
              id: id2,
              type: "dimensions",
              resizing: !0,
              setAttributes: !0,
              dimensions: {
                width: change.width,
                height: change.height
              }
            };
            changes.push(dimensionChange);
          }
          for (const childChange of childChanges) {
            const positionChange = {
              ...childChange,
              type: "position"
            };
            changes.push(positionChange);
          }
          triggerNodeChanges(changes);
        },
        onEnd: ({ width, height }) => {
          const dimensionChange = {
            id: id2,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width,
              height
            }
          };
          store.getState().triggerNodeChanges([dimensionChange]);
        }
      })), resizer.current.update({
        controlPosition,
        boundaries: {
          minWidth,
          minHeight,
          maxWidth,
          maxHeight
        },
        keepAspectRatio,
        onResizeStart,
        onResize,
        onResizeEnd,
        shouldResize
      }), () => {
        resizer.current?.destroy();
      };
  }, [
    controlPosition,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    onResizeStart,
    onResize,
    onResizeEnd,
    shouldResize
  ]);
  const positionClassNames = controlPosition.split("-"), colorStyleProp = variant === ResizeControlVariant.Line ? "borderColor" : "backgroundColor", controlStyle = color2 ? { ...style2, [colorStyleProp]: color2 } : style2;
  return jsx("div", { className: cc(["react-flow__resize-control", "nodrag", ...positionClassNames, variant, className]), ref: resizeControlRef, style: controlStyle, children: children2 });
}
memo$2(ResizeControl);
const selector$5 = (state) => state.domNode?.querySelector(".react-flow__renderer");
function NodeToolbarPortal({ children: children2 }) {
  const wrapperRef = useStore$1(selector$5);
  return wrapperRef ? createPortal(children2, wrapperRef) : null;
}
const nodeEqualityFn = (a2, b2) => a2?.internals.positionAbsolute.x !== b2?.internals.positionAbsolute.x || a2?.internals.positionAbsolute.y !== b2?.internals.positionAbsolute.y || a2?.measured.width !== b2?.measured.width || a2?.measured.height !== b2?.measured.height || a2?.selected !== b2?.selected || a2?.internals.z !== b2?.internals.z, nodesEqualityFn = (a2, b2) => {
  if (a2.size !== b2.size)
    return !1;
  for (const [key2, node2] of a2)
    if (nodeEqualityFn(node2, b2.get(key2)))
      return !1;
  return !0;
}, storeSelector = (state) => ({
  x: state.transform[0],
  y: state.transform[1],
  zoom: state.transform[2],
  selectedNodesCount: state.nodes.filter((node2) => node2.selected).length
});
function NodeToolbar({ nodeId, children: children2, className, style: style2, isVisible, position = Position.Top, offset: offset2 = 10, align = "center", ...rest }) {
  const contextNodeId = useNodeId(), nodesSelector2 = useCallback((state) => (Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId || ""]).reduce((res, id2) => {
    const node2 = state.nodeLookup.get(id2);
    return node2 && res.set(node2.id, node2), res;
  }, /* @__PURE__ */ new Map()), [nodeId, contextNodeId]), nodes = useStore$1(nodesSelector2, nodesEqualityFn), { x: x2, y: y2, zoom: zoom2, selectedNodesCount } = useStore$1(storeSelector, shallow$1);
  if (!(typeof isVisible == "boolean" ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1) || !nodes.size)
    return null;
  const nodeRect = getInternalNodesBounds(nodes), nodesArray = Array.from(nodes.values()), zIndex = Math.max(...nodesArray.map((node2) => node2.internals.z + 1)), wrapperStyle2 = {
    position: "absolute",
    transform: getNodeToolbarTransform(nodeRect, { x: x2, y: y2, zoom: zoom2 }, position, offset2, align),
    zIndex,
    ...style2
  };
  return jsx(NodeToolbarPortal, { children: jsx("div", { style: wrapperStyle2, className: cc(["react-flow__node-toolbar", className]), ...rest, "data-id": nodesArray.reduce((acc, node2) => `${acc}${node2.id} `, "").trim(), children: children2 }) });
}
var s$2 = { done: !1, hasNext: !1 };
function C(t2, ...o2) {
  let n2 = t2, u2 = o2.map((e2) => "lazy" in e2 ? y$4(e2) : void 0), p2 = 0;
  for (; p2 < o2.length; ) {
    if (u2[p2] === void 0 || !B(n2)) {
      let i2 = o2[p2];
      n2 = i2(n2), p2 += 1;
      continue;
    }
    let r2 = [];
    for (let i2 = p2; i2 < o2.length; i2++) {
      let l2 = u2[i2];
      if (l2 === void 0 || (r2.push(l2), l2.isSingle)) break;
    }
    let a2 = [];
    for (let i2 of n2) if (f$2(i2, a2, r2)) break;
    let { isSingle: s2 } = r2.at(-1);
    n2 = s2 ? a2[0] : a2, p2 += r2.length;
  }
  return n2;
}
function f$2(t2, o2, n2) {
  if (n2.length === 0) return o2.push(t2), !1;
  let u2 = t2, p2 = s$2, e2 = !1;
  for (let [r2, a2] of n2.entries()) {
    let { index: s2, items: i2 } = a2;
    if (i2.push(u2), p2 = a2(u2, s2, i2), a2.index += 1, p2.hasNext) {
      if (p2.hasMany ?? !1) {
        for (let l2 of p2.next) if (f$2(l2, o2, n2.slice(r2 + 1))) return !0;
        return e2;
      }
      u2 = p2.next;
    }
    if (!p2.hasNext) break;
    p2.done && (e2 = !0);
  }
  return p2.hasNext && o2.push(u2), e2;
}
function y$4(t2) {
  let { lazy: o2, lazyArgs: n2 } = t2, u2 = o2(...n2);
  return Object.assign(u2, { isSingle: o2.single ?? !1, index: 0, items: [] });
}
function B(t2) {
  return typeof t2 == "string" || typeof t2 == "object" && t2 !== null && Symbol.iterator in t2;
}
function y$3(t2, i2) {
  let a2 = i2.length - t2.length;
  if (a2 === 1) {
    let [n2, ...r2] = i2;
    return C(n2, { lazy: t2, lazyArgs: r2 });
  }
  if (a2 === 0) {
    let n2 = { lazy: t2, lazyArgs: i2 };
    return Object.assign((e2) => C(e2, n2), n2);
  }
  throw new Error("Wrong number of arguments");
}
function u$8(o2, n2, a2) {
  let t2 = (r2) => o2(r2, ...n2);
  return a2 === void 0 ? t2 : Object.assign(t2, { lazy: a2, lazyArgs: n2 });
}
function u$7(r2, n2, o2) {
  let a2 = r2.length - n2.length;
  if (a2 === 0) return r2(...n2);
  if (a2 === 1) return u$8(r2, n2, o2);
  throw new Error("Wrong number of arguments");
}
function r$6(...t2) {
  return u$7(Object.values, t2);
}
function i$8(...e2) {
  return y$3(a$6, e2);
}
function a$6() {
  let e2 = /* @__PURE__ */ new Set();
  return (t2) => e2.has(t2) ? s$2 : (e2.add(t2), { done: !1, hasNext: !0, next: t2 });
}
function i$7(...e2) {
  return u$7(r$5, e2);
}
var r$5 = (e2, t2) => e2.length >= t2, T$1 = { asc: (r2, n2) => r2 > n2, desc: (r2, n2) => r2 < n2 };
function s$1(r2, n2) {
  let [e2, ...o2] = n2;
  if (!m$1(e2)) {
    let t2 = u$6(...o2);
    return r2(e2, t2);
  }
  let a2 = u$6(e2, ...o2);
  return (t2) => r2(t2, a2);
}
function u$6(r2, n2, ...e2) {
  let o2 = typeof r2 == "function" ? r2 : r2[0], a2 = typeof r2 == "function" ? "asc" : r2[1], { [a2]: t2 } = T$1, i2 = n2 === void 0 ? void 0 : u$6(n2, ...e2);
  return (y2, c2) => {
    let p2 = o2(y2), l2 = o2(c2);
    return t2(p2, l2) ? 1 : t2(l2, p2) ? -1 : i2?.(y2, c2) ?? 0;
  };
}
function m$1(r2) {
  if (d$4(r2)) return !0;
  if (typeof r2 != "object" || !Array.isArray(r2)) return !1;
  let [n2, e2, ...o2] = r2;
  return d$4(n2) && typeof e2 == "string" && e2 in T$1 && o2.length === 0;
}
var d$4 = (r2) => typeof r2 == "function" && r2.length === 1;
function r$4(...n2) {
  return u$7(e$3, n2);
}
function e$3(n2, o2) {
  return o2(n2), n2;
}
function a$5(...r2) {
  return s$1(n$6, r2);
}
var n$6 = (r2, t2) => [...r2].sort(t2);
function l$4(...e2) {
  return u$7(u$5, e2);
}
var u$5 = (e2, a2, n2) => e2.reduce(a2, n2);
function t$7(...e2) {
  return u$7(r$3, e2);
}
function r$3(e2) {
  return [...e2].reverse();
}
var b = (n2) => (t2, e2) => {
  if (e2 === 0) return n2(t2);
  if (!Number.isInteger(e2)) throw new TypeError(`precision must be an integer: ${e2.toString()}`);
  if (e2 > 15 || e2 < -15) throw new RangeError("precision must be between -15 and 15");
  if (Number.isNaN(t2) || !Number.isFinite(t2)) return n2(t2);
  let s2 = u$4(t2, e2), r2 = n2(s2);
  return u$4(r2, -e2);
};
function u$4(n2, t2) {
  let e2 = n2.toString(), [s2, r2] = e2.split("e"), o2 = (r2 === void 0 ? 0 : Number.parseInt(r2, 10)) + t2, i2 = `${s2}e${o2.toString()}`;
  return Number.parseFloat(i2);
}
function p$2(...e2) {
  return u$7(t$6, e2);
}
var t$6 = (e2, o2) => e2[o2];
function d$3(...r2) {
  return u$7(i$6, r2);
}
var i$6 = (r2, t2) => {
  let a2 = [[], []];
  for (let [o2, e2] of r2.entries()) t2(e2, o2, r2) ? a2[0].push(e2) : a2[1].push(e2);
  return a2;
};
function i$5(...e2) {
  return u$7(o$4, e2);
}
function o$4(e2, n2) {
  let t2 = {};
  for (let r2 of n2) r2 in e2 && (t2[r2] = e2[r2]);
  return t2;
}
function d$2(...e2) {
  return u$7(i$4, e2);
}
function i$4(e2, o2) {
  let t2 = {};
  for (let [r2, n2] of Object.entries(e2)) o2(n2, r2, e2) && (t2[r2] = n2);
  return t2;
}
function y$2(...t2) {
  return u$7(f$1, t2);
}
function f$1(t2, e2) {
  if (!i$7(e2, 1)) return { ...t2 };
  if (!i$7(e2, 2)) {
    let { [e2[0]]: r2, ...m2 } = t2;
    return m2;
  }
  let o2 = { ...t2 };
  for (let r2 of e2) delete o2[r2];
  return o2;
}
function t$5(...n2) {
  return u$7(o$3, n2);
}
var o$3 = (n2) => n2.length === 1 ? n2[0] : void 0;
function r$2(o2) {
  if (typeof o2 != "object" || o2 === null) return !1;
  let e2 = Object.getPrototypeOf(o2);
  return e2 === null || e2 === Object.prototype;
}
function D(...e2) {
  return u$7(s, e2);
}
function s(e2, t2) {
  let r2 = { ...e2, ...t2 };
  for (let n2 in t2) {
    if (!(n2 in e2)) continue;
    let { [n2]: i2 } = e2;
    if (!r$2(i2)) continue;
    let { [n2]: c2 } = t2;
    r$2(c2) && (r2[n2] = s(i2, c2));
  }
  return r2;
}
function n$5(e2) {
  return !!e2;
}
function t$4(...n2) {
  return u$7(Object.keys, n2);
}
function a$4(...e2) {
  return u$7(n$4, e2);
}
var n$4 = (e2) => e2.at(-1);
function m(...a2) {
  return u$7(o$2, a2, p$1);
}
var o$2 = (a2, e2) => a2.map(e2), p$1 = (a2) => (e2, t2, r2) => ({ done: !1, hasNext: !0, next: a2(e2, t2, r2) });
function l$3(...n2) {
  return u$7(d$1, n2);
}
function d$1(n2, o2) {
  let e2 = {};
  for (let [a2, t2] of n2.entries()) {
    let [y2, u2] = o2(t2, a2, n2);
    e2[y2] = u2;
  }
  return e2;
}
function e$2(r2) {
  return typeof r2 == "number" && !Number.isNaN(r2);
}
function t$3(r2) {
  return typeof r2 == "string";
}
function n$3(e2) {
  return e2 === void 0 ? !0 : typeof e2 == "string" || Array.isArray(e2) ? e2.length === 0 : Object.keys(e2).length === 0;
}
function t$2(n2) {
  return typeof n2 == "function";
}
function n$2(l2) {
  return l2 !== null;
}
function l$2(n2) {
  return n2 != null;
}
function n$1(e2) {
  return e2 == null;
}
function o$1(r2) {
  return Array.isArray(r2);
}
function e$1(o2) {
  return typeof o2 == "boolean";
}
function n(e2) {
  return e2 !== void 0;
}
function i$3(...e2) {
  return u$7(p, e2);
}
var p = (e2, a2) => {
  let n2 = /* @__PURE__ */ new Map();
  for (let [d2, t2] of e2.entries()) {
    let y2 = a2(t2, d2, e2);
    if (y2 !== void 0) {
      let r2 = n2.get(y2);
      r2 === void 0 && (r2 = [], n2.set(y2, r2)), r2.push(t2);
    }
  }
  return Object.fromEntries(n2);
};
function k(...n2) {
  return u$7(u$3, n2);
}
function u$3(n2, e2) {
  if (n2 === e2 || Object.is(n2, e2)) return !0;
  if (typeof n2 != "object" || typeof e2 != "object" || n2 === null || e2 === null || Object.getPrototypeOf(n2) !== Object.getPrototypeOf(e2)) return !1;
  if (Array.isArray(n2)) return l$1(n2, e2);
  if (n2 instanceof Map) return a$3(n2, e2);
  if (n2 instanceof Set) return c$1(n2, e2);
  if (n2 instanceof Date) return n2.getTime() === e2.getTime();
  if (n2 instanceof RegExp) return n2.toString() === e2.toString();
  if (Object.keys(n2).length !== Object.keys(e2).length) return !1;
  for (let [r2, t2] of Object.entries(n2)) if (!(r2 in e2) || !u$3(t2, e2[r2])) return !1;
  return !0;
}
function l$1(n2, e2) {
  if (n2.length !== e2.length) return !1;
  for (let [r2, t2] of n2.entries()) if (!u$3(t2, e2[r2])) return !1;
  return !0;
}
function a$3(n2, e2) {
  if (n2.size !== e2.size) return !1;
  for (let [r2, t2] of n2.entries()) if (!e2.has(r2) || !u$3(t2, e2.get(r2))) return !1;
  return !0;
}
function c$1(n2, e2) {
  if (n2.size !== e2.size) return !1;
  let r2 = [...e2];
  for (let t2 of n2) {
    let o2 = !1;
    for (let [s2, f2] of r2.entries()) if (u$3(t2, f2)) {
      o2 = !0, r2.splice(s2, 1);
      break;
    }
    if (!o2) return !1;
  }
  return !0;
}
function j(...e2) {
  return u$7(c, e2);
}
function c(e2, u2) {
  for (let [t2, y2] of Object.entries(u2)) if (!Object.hasOwn(e2, t2) || !k(y2, e2[t2])) return !1;
  return !0;
}
function i$2(...e2) {
  return u$7(a$2, e2);
}
function a$2(e2, r2) {
  for (let [t2, o2] of Object.entries(e2)) r2(o2, t2, e2);
  return e2;
}
function t$1(...r2) {
  return u$7(Object.entries, r2);
}
function T(...a2) {
  return u$7(l, a2, y$1);
}
var l = (a2, r2) => a2.filter(r2), y$1 = (a2) => (r2, t2, o2) => a2(r2, t2, o2) ? { done: !1, hasNext: !0, next: r2 } : s$2, e = (n2) => Object.assign(n2, { single: !0 });
function f(...e$12) {
  return u$7(i$1, e$12, e(u$2));
}
var i$1 = (e2, n2) => e2.find(n2), u$2 = (e2) => (n2, t2, o2) => e2(n2, t2, o2) ? { done: !0, hasNext: !0, next: n2 } : s$2;
function d(...e$12) {
  return u$7(r$1, e$12, e(a$1));
}
var r$1 = ([e2]) => e2, a$1 = () => o, o = (e2) => ({ hasNext: !0, next: e2, done: !0 });
function a(...e2) {
  return u$7(r, e2);
}
var r = (e2, t2) => [...e2, ...t2];
function u$1(...e2) {
  return u$7(b(Math.ceil), e2);
}
function u(...n2) {
  return u$7(i, n2);
}
var i = (n2, { min: e2, max: r2 }) => e2 !== void 0 && n2 < e2 ? e2 : r2 !== void 0 && n2 > r2 ? r2 : n2;
function useSyncedRef(value) {
  const ref = useRef(value);
  return ref.current = value, useMemo(() => Object.freeze({
    get current() {
      return ref.current;
    }
  }), []);
}
function useUnmountEffect(effect) {
  const effectRef = useSyncedRef(effect);
  useEffect(
    () => () => {
      effectRef.current();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
}
function useDebouncedCallback(callback, deps, delay2, maxWait = 0) {
  const timeout2 = useRef(void 0), waitTimeout = useRef(void 0), cb = useRef(callback), lastCall = useRef(void 0), clear = () => {
    timeout2.current && (clearTimeout(timeout2.current), timeout2.current = void 0), waitTimeout.current && (clearTimeout(waitTimeout.current), waitTimeout.current = void 0);
  };
  return useUnmountEffect(clear), useEffect(() => {
    cb.current = callback;
  }, deps), useMemo(() => {
    const execute = () => {
      if (clear(), !lastCall.current)
        return;
      const context2 = lastCall.current;
      lastCall.current = void 0, cb.current.apply(context2.this, context2.args);
    }, wrapped = function(...args) {
      timeout2.current && clearTimeout(timeout2.current), lastCall.current = { args, this: this }, timeout2.current = setTimeout(execute, delay2), maxWait > 0 && !waitTimeout.current && (waitTimeout.current = setTimeout(execute, maxWait));
    };
    return Object.defineProperties(wrapped, {
      length: { value: callback.length },
      name: { value: `${callback.name || "anonymous"}__debounced__${delay2}` }
    }), wrapped;
  }, [delay2, maxWait, ...deps]);
}
const noop$1 = () => {
}, isBrowser = typeof globalThis < "u" && typeof navigator < "u" && typeof document < "u", isStrictEqual = (previous, next) => previous === next, basicDepsComparator = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (element !== d2[i2])
      return !1;
  return !0;
};
function useCustomCompareEffect(callback, deps, comparator = basicDepsComparator, effectHook = useEffect, ...effectHookRestArgs) {
  const dependencies = useRef(void 0);
  (dependencies.current === void 0 || isBrowser && !comparator(dependencies.current, deps)) && (dependencies.current = deps), effectHook(callback, dependencies.current, ...effectHookRestArgs);
}
function useDebouncedEffect(callback, deps, delay2, maxWait = 0) {
  useEffect(useDebouncedCallback(callback, deps, delay2, maxWait), deps);
}
const { valueOf, toString: toString$1 } = Object.prototype, isEqual = (a2, b2) => {
  const visited = /* @__PURE__ */ new WeakMap(), inner2 = (a3, b3) => {
    if (a3 === b3)
      return !0;
    if (typeof a3 != "object" || typeof b3 != "object" || !a3 || !b3)
      return a3 !== a3 && b3 !== b3;
    if (Object.getPrototypeOf(a3) !== Object.getPrototypeOf(b3))
      return !1;
    const { constructor } = a3;
    if (constructor === Date)
      return a3.getTime() === b3.getTime();
    if (constructor === RegExp)
      return a3.source === b3.source && a3.flags === b3.flags;
    if (constructor === Set) {
      if (a3.size !== b3.size)
        return !1;
      for (const value of a3)
        if (!b3.has(value))
          return !1;
      return !0;
    }
    if (constructor === ArrayBuffer && (a3 = new DataView(a3), b3 = new DataView(b3)), constructor === DataView || ArrayBuffer.isView(a3)) {
      if (constructor !== DataView && (a3 = new DataView(a3.buffer), b3 = new DataView(b3.buffer)), a3.byteLength !== b3.byteLength)
        return !1;
      for (let i2 = a3.byteLength; i2-- !== 0; )
        if (a3.getUint8(i2) !== b3.getUint8(i2))
          return !1;
      return !0;
    }
    if (visited.has(a3) && visited.get(a3) === b3)
      return !0;
    if (visited.set(a3, b3), constructor === Array) {
      if (a3.length !== b3.length)
        return !1;
      for (let i2 = a3.length; i2-- !== 0; )
        if (!inner2(a3[i2], b3[i2]))
          return !1;
      return !0;
    }
    if (constructor === Map) {
      if (a3.size !== b3.size)
        return !1;
      for (const entry of a3)
        if (!b3.has(entry[0]) || !inner2(entry[1], b3.get(entry[0])))
          return !1;
      return !0;
    }
    if (a3.valueOf !== valueOf && typeof a3.valueOf == "function" && typeof b3.valueOf == "function")
      return a3.valueOf() === b3.valueOf();
    if (a3.toString !== toString$1 && typeof a3.toString == "function" && typeof b3.toString == "function")
      return a3.toString() === b3.toString();
    const aKeys = Object.keys(a3);
    let key2;
    for (let l2 = aKeys.length; l2-- !== 0; )
      if (key2 = aKeys[l2], !Object.hasOwn(b3, key2) || !inner2(a3[key2], b3[key2]))
        return !1;
    return Object.keys(b3).length === aKeys.length;
  };
  return inner2(a2, b2);
};
function useDeepCompareEffect(callback, deps, effectHook = useEffect, ...effectHookRestArgs) {
  useCustomCompareEffect(callback, deps, isEqual, effectHook, ...effectHookRestArgs);
}
function useFirstMountState() {
  const isFirstMount = useRef(!0);
  return useEffect(() => {
    isFirstMount.current = !1;
  }, []), isFirstMount.current;
}
const useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect$1 : useEffect;
function useUpdateEffect$1(effect, deps) {
  const isFirstMount = useFirstMountState();
  useEffect(isFirstMount ? noop$1 : effect, deps);
}
const cancelTimeout = (id2) => {
  id2 && clearTimeout(id2);
};
function useTimeoutEffect(callback, ms) {
  const cbRef = useSyncedRef(callback), msRef = useSyncedRef(ms), timeoutIdRef = useRef(null), cancel = useCallback(() => {
    cancelTimeout(timeoutIdRef.current);
  }, []), reset = useCallback(() => {
    msRef.current !== void 0 && (cancel(), timeoutIdRef.current = setTimeout(() => {
      cbRef.current();
    }, msRef.current));
  }, []);
  return useEffect(() => (reset(), cancel), [ms]), [cancel, reset];
}
const useCustomCompareMemo = (factory2, deps, comparator) => {
  const dependencies = useRef(void 0);
  return (dependencies.current === void 0 || !comparator(dependencies.current, deps)) && (dependencies.current = deps), useMemo(factory2, dependencies.current);
};
function useDeepCompareMemo(factory2, deps) {
  return useCustomCompareMemo(factory2, deps, isEqual);
}
function usePreviousDistinct(value, predicate = isStrictEqual) {
  const [previousState, setPreviousState] = useState(), currentRef = useRef(value);
  return useUpdateEffect$1(() => {
    predicate(currentRef.current, value) || (setPreviousState(currentRef.current), currentRef.current = value);
  }, [value]), previousState;
}
function useAsync(asyncFn, initialValue) {
  const [state, setState] = useState({
    status: "not-executed",
    error: void 0,
    result: initialValue
  }), promiseRef = useRef(void 0), argsRef = useRef(void 0), methods = useSyncedRef({
    execute(...params) {
      argsRef.current = params;
      const promise = asyncFn(...params);
      return promiseRef.current = promise, setState((s2) => ({ ...s2, status: "loading" })), promise.then(
        (result) => {
          promise === promiseRef.current && setState((s2) => ({ ...s2, status: "success", error: void 0, result }));
        },
        // eslint-disable-next-line @typescript-eslint/use-unknown-in-catch-callback-variable
        (error) => {
          promise === promiseRef.current && setState((previousState) => ({ ...previousState, status: "error", error }));
        }
      ), promise;
    },
    reset() {
      setState({
        status: "not-executed",
        error: void 0,
        result: initialValue
      }), promiseRef.current = void 0, argsRef.current = void 0;
    }
  });
  return [
    state,
    useMemo(
      () => ({
        reset() {
          methods.current.reset();
        },
        execute: (...params) => methods.current.execute(...params)
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    ),
    { promise: promiseRef.current, lastArgs: argsRef.current }
  ];
}
const HandlerNames = [
  "onBurgerMenuClick",
  "onNavigateTo",
  "onOpenSource",
  "onCanvasClick",
  "onCanvasContextMenu",
  "onEdgeClick",
  "onEdgeContextMenu",
  "onNodeClick",
  "onNodeContextMenu",
  "onChange",
  "onCanvasDblClick"
], DiagramEventHandlersContext = createContext({
  ...l$3(HandlerNames, (name) => [name, null]),
  handlersRef: {
    current: {}
  }
});
function DiagramEventHandlers({
  handlers,
  children: children2
}) {
  const handlersRef = useSyncedRef(handlers), deps = HandlerNames.map((name) => t$2(handlers[name])), value = useMemo(() => ({
    ...l$3(HandlerNames, (name) => handlersRef.current[name] ? [name, (...args) => handlersRef.current[name]?.(...args)] : [name, null]),
    handlersRef
  }), [handlersRef, ...deps]);
  return /* @__PURE__ */ jsx(DiagramEventHandlersContext.Provider, { value, children: children2 });
}
function useDiagramEventHandlers() {
  return useContext(DiagramEventHandlersContext);
}
function useDiagramEventHandlersRef() {
  return useContext(DiagramEventHandlersContext).handlersRef;
}
var getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function(a2, b2, state) {
    return comparatorA(a2, b2, state) && comparatorB(a2, b2, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function(a2, b2, state) {
    if (!a2 || !b2 || typeof a2 != "object" || typeof b2 != "object")
      return areItemsEqual(a2, b2, state);
    var cache = state.cache, cachedA = cache.get(a2), cachedB = cache.get(b2);
    if (cachedA && cachedB)
      return cachedA === b2 && cachedB === a2;
    cache.set(a2, b2), cache.set(b2, a2);
    var result = areItemsEqual(a2, b2, state);
    return cache.delete(a2), cache.delete(b2), result;
  };
}
function getStrictProperties(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = Object.hasOwn || function(object, property) {
  return hasOwnProperty.call(object, property);
};
function sameValueZeroEqual(a2, b2) {
  return a2 === b2 || !a2 && !b2 && a2 !== a2 && b2 !== b2;
}
var PREACT_VNODE = "__v", PREACT_OWNER = "__o", REACT_OWNER = "_owner", getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;
function areArraysEqual(a2, b2, state) {
  var index2 = a2.length;
  if (b2.length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (!state.equals(a2[index2], b2[index2], index2, index2, a2, b2, state))
      return !1;
  return !0;
}
function areDatesEqual(a2, b2) {
  return sameValueZeroEqual(a2.getTime(), b2.getTime());
}
function areErrorsEqual(a2, b2) {
  return a2.name === b2.name && a2.message === b2.message && a2.cause === b2.cause && a2.stack === b2.stack;
}
function areFunctionsEqual(a2, b2) {
  return a2 === b2;
}
function areMapsEqual(a2, b2, state) {
  var size2 = a2.size;
  if (size2 !== b2.size)
    return !1;
  if (!size2)
    return !0;
  for (var matchedIndices = new Array(size2), aIterable = a2.entries(), aResult, bResult, index2 = 0; (aResult = aIterable.next()) && !aResult.done; ) {
    for (var bIterable = b2.entries(), hasMatch = !1, matchIndex = 0; (bResult = bIterable.next()) && !bResult.done; ) {
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      var aEntry = aResult.value, bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index2, matchIndex, a2, b2, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a2, b2, state)) {
        hasMatch = matchedIndices[matchIndex] = !0;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch)
      return !1;
    index2++;
  }
  return !0;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a2, b2, state) {
  var properties2 = keys(a2), index2 = properties2.length;
  if (keys(b2).length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (!isPropertyEqual(a2, b2, state, properties2[index2]))
      return !1;
  return !0;
}
function areObjectsEqualStrict(a2, b2, state) {
  var properties2 = getStrictProperties(a2), index2 = properties2.length;
  if (getStrictProperties(b2).length !== index2)
    return !1;
  for (var property, descriptorA, descriptorB; index2-- > 0; )
    if (property = properties2[index2], !isPropertyEqual(a2, b2, state, property) || (descriptorA = getOwnPropertyDescriptor(a2, property), descriptorB = getOwnPropertyDescriptor(b2, property), (descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)))
      return !1;
  return !0;
}
function arePrimitiveWrappersEqual(a2, b2) {
  return sameValueZeroEqual(a2.valueOf(), b2.valueOf());
}
function areRegExpsEqual(a2, b2) {
  return a2.source === b2.source && a2.flags === b2.flags;
}
function areSetsEqual(a2, b2, state) {
  var size2 = a2.size;
  if (size2 !== b2.size)
    return !1;
  if (!size2)
    return !0;
  for (var matchedIndices = new Array(size2), aIterable = a2.values(), aResult, bResult; (aResult = aIterable.next()) && !aResult.done; ) {
    for (var bIterable = b2.values(), hasMatch = !1, matchIndex = 0; (bResult = bIterable.next()) && !bResult.done; ) {
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a2, b2, state)) {
        hasMatch = matchedIndices[matchIndex] = !0;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch)
      return !1;
  }
  return !0;
}
function areTypedArraysEqual(a2, b2) {
  var index2 = a2.length;
  if (b2.length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (a2[index2] !== b2[index2])
      return !1;
  return !0;
}
function areUrlsEqual(a2, b2) {
  return a2.hostname === b2.hostname && a2.pathname === b2.pathname && a2.protocol === b2.protocol && a2.port === b2.port && a2.hash === b2.hash && a2.username === b2.username && a2.password === b2.password;
}
function isPropertyEqual(a2, b2, state, property) {
  return (property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a2.$$typeof || b2.$$typeof) ? !0 : hasOwn(b2, property) && state.equals(a2[property], b2[property], property, property, a2, b2, state);
}
var ARGUMENTS_TAG = "[object Arguments]", BOOLEAN_TAG = "[object Boolean]", DATE_TAG = "[object Date]", ERROR_TAG = "[object Error]", MAP_TAG = "[object Map]", NUMBER_TAG = "[object Number]", OBJECT_TAG = "[object Object]", REG_EXP_TAG = "[object RegExp]", SET_TAG = "[object Set]", STRING_TAG = "[object String]", URL_TAG = "[object URL]", isArray = Array.isArray, isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, assign = Object.assign, getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a) {
  var areArraysEqual2 = _a.areArraysEqual, areDatesEqual2 = _a.areDatesEqual, areErrorsEqual2 = _a.areErrorsEqual, areFunctionsEqual2 = _a.areFunctionsEqual, areMapsEqual2 = _a.areMapsEqual, areNumbersEqual2 = _a.areNumbersEqual, areObjectsEqual2 = _a.areObjectsEqual, arePrimitiveWrappersEqual2 = _a.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a.areRegExpsEqual, areSetsEqual2 = _a.areSetsEqual, areTypedArraysEqual2 = _a.areTypedArraysEqual, areUrlsEqual2 = _a.areUrlsEqual;
  return function(a2, b2, state) {
    if (a2 === b2)
      return !0;
    if (a2 == null || b2 == null)
      return !1;
    var type = typeof a2;
    if (type !== typeof b2)
      return !1;
    if (type !== "object")
      return type === "number" ? areNumbersEqual2(a2, b2, state) : type === "function" ? areFunctionsEqual2(a2, b2, state) : !1;
    var constructor = a2.constructor;
    if (constructor !== b2.constructor)
      return !1;
    if (constructor === Object)
      return areObjectsEqual2(a2, b2, state);
    if (isArray(a2))
      return areArraysEqual2(a2, b2, state);
    if (isTypedArray != null && isTypedArray(a2))
      return areTypedArraysEqual2(a2, b2, state);
    if (constructor === Date)
      return areDatesEqual2(a2, b2, state);
    if (constructor === RegExp)
      return areRegExpsEqual2(a2, b2, state);
    if (constructor === Map)
      return areMapsEqual2(a2, b2, state);
    if (constructor === Set)
      return areSetsEqual2(a2, b2, state);
    var tag = getTag(a2);
    return tag === DATE_TAG ? areDatesEqual2(a2, b2, state) : tag === REG_EXP_TAG ? areRegExpsEqual2(a2, b2, state) : tag === MAP_TAG ? areMapsEqual2(a2, b2, state) : tag === SET_TAG ? areSetsEqual2(a2, b2, state) : tag === OBJECT_TAG ? typeof a2.then != "function" && typeof b2.then != "function" && areObjectsEqual2(a2, b2, state) : tag === URL_TAG ? areUrlsEqual2(a2, b2, state) : tag === ERROR_TAG ? areErrorsEqual2(a2, b2, state) : tag === ARGUMENTS_TAG ? areObjectsEqual2(a2, b2, state) : tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG ? arePrimitiveWrappersEqual2(a2, b2, state) : !1;
  };
}
function createEqualityComparatorConfig(_a) {
  var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict, config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,
    areUrlsEqual
  };
  if (createCustomConfig && (config = assign({}, config, createCustomConfig(config))), circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual), areMapsEqual$1 = createIsCircular(config.areMapsEqual), areObjectsEqual$1 = createIsCircular(config.areObjectsEqual), areSetsEqual$12 = createIsCircular(config.areSetsEqual);
    config = assign({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$12
    });
  }
  return config;
}
function createInternalEqualityComparator(compare) {
  return function(a2, b2, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare(a2, b2, state);
  };
}
function createIsEqual(_a) {
  var circular = _a.circular, comparator = _a.comparator, createState2 = _a.createState, equals = _a.equals, strict = _a.strict;
  if (createState2)
    return function(a2, b2) {
      var _a2 = createState2(), _b = _a2.cache, cache = _b === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b, meta = _a2.meta;
      return comparator(a2, b2, {
        cache,
        equals,
        meta,
        strict
      });
    };
  if (circular)
    return function(a2, b2) {
      return comparator(a2, b2, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  var state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function(a2, b2) {
    return comparator(a2, b2, state);
  };
}
var deepEqual = createCustomEqual();
createCustomEqual({ strict: !0 });
createCustomEqual({ circular: !0 });
createCustomEqual({
  circular: !0,
  strict: !0
});
var shallowEqual = createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  strict: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: !0
});
function createCustomEqual(options) {
  options === void 0 && (options = {});
  var _a = options.circular, circular = _a === void 0 ? !1 : _a, createCustomInternalComparator = options.createInternalComparator, createState2 = options.createState, _b = options.strict, strict = _b === void 0 ? !1 : _b, config = createEqualityComparatorConfig(options), comparator = createEqualityComparator(config), equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState: createState2, equals, strict });
}
const FeatureNames = [
  "Controls",
  "ReadOnly",
  "FocusMode",
  "NavigateTo",
  "ElementDetails",
  "RelationshipDetails",
  "RelationshipBrowser",
  "Search",
  "NavigationButtons",
  "Notations",
  "DynamicViewWalkthrough",
  "EdgeEditing",
  "ViewTitle",
  "FitView",
  /**
   * LikeC4Model is available in context
   */
  "LikeC4Model",
  /**
   * Running in VSCode
   */
  "Vscode"
], AllDisabled = l$3(
  FeatureNames,
  (name) => [`enable${name}`, !1]
), DiagramFeaturesContext = createContext(AllDisabled), validate = (features) => {
  let {
    enableReadOnly,
    enableLikeC4Model,
    enableElementDetails,
    enableRelationshipDetails,
    enableRelationshipBrowser,
    enableSearch,
    enableEdgeEditing,
    ...rest
  } = features;
  return enableLikeC4Model || (enableElementDetails = !1, enableRelationshipDetails = !1, enableRelationshipBrowser = !1, enableSearch = !1), enableReadOnly && (enableEdgeEditing = !1), {
    enableReadOnly,
    enableLikeC4Model,
    enableElementDetails,
    enableRelationshipDetails,
    enableRelationshipBrowser,
    enableSearch,
    enableEdgeEditing,
    ...rest
  };
};
function DiagramFeatures({
  children: children2,
  features,
  overrides
}) {
  const outerScope = useContext(DiagramFeaturesContext), [scope, setScope] = useState(outerScope);
  return useEffect(
    () => {
      setScope((current) => {
        const next = validate({
          ...outerScope,
          ...features,
          ...overrides
        });
        return shallowEqual(current, next) ? current : next;
      });
    },
    [outerScope, features, overrides]
  ), /* @__PURE__ */ jsx(DiagramFeaturesContext.Provider, { value: scope, children: children2 });
}
DiagramFeatures.Overlays = ({ children: children2 }) => /* @__PURE__ */ jsx(
  DiagramFeatures,
  {
    overrides: {
      enableControls: !1,
      enableReadOnly: !0,
      enableEdgeEditing: !1
    },
    children: children2
  }
);
function useEnabledFeature(...names) {
  return i$5(useContext(DiagramFeaturesContext), m(names, (name) => `enable${name}`));
}
function useEnabledFeatures() {
  return useContext(DiagramFeaturesContext);
}
function IfEnabled({
  feature,
  children: children2,
  and = !0
}) {
  return useEnabledFeature(feature)[`enable${feature}`] === !0 && and ? /* @__PURE__ */ jsx(Fragment$1, { children: children2 }) : null;
}
function IfNotEnabled({
  feature,
  children: children2
}) {
  return useEnabledFeature(feature)[`enable${feature}`] !== !0 ? /* @__PURE__ */ jsx(Fragment$1, { children: children2 }) : null;
}
function EnsureMantine({ children: children2 }) {
  if (!useContext(MantineContext))
    throw new Error("LikeC4Diagram must be a child of MantineProvider");
  return /* @__PURE__ */ jsx(Fragment$1, { children: children2 });
}
EnsureMantine.displayName = "EnsureMantine";
var userGeneratedStr = "css,pos,insetX,insetY,insetEnd,end,insetStart,start,flexDir,p,pl,pr,pt,pb,py,paddingY,paddingX,px,pe,paddingEnd,ps,paddingStart,ml,mr,mt,mb,m,my,marginY,mx,marginX,me,marginEnd,ms,marginStart,ringWidth,ringColor,ring,ringOffset,w,minW,maxW,h,minH,maxH,textShadowColor,bgPosition,bgPositionX,bgPositionY,bgAttachment,bgClip,bg,bgColor,bgOrigin,bgImage,bgRepeat,bgBlendMode,bgSize,bgGradient,rounded,roundedTopLeft,roundedTopRight,roundedBottomRight,roundedBottomLeft,roundedTop,roundedRight,roundedBottom,roundedLeft,roundedStartStart,roundedStartEnd,roundedStart,roundedEndStart,roundedEndEnd,roundedEnd,borderX,borderXWidth,borderXColor,borderY,borderYWidth,borderYColor,borderStart,borderStartWidth,borderStartColor,borderEnd,borderEndWidth,borderEndColor,shadow,shadowColor,x,y,z,scrollMarginY,scrollMarginX,scrollPaddingY,scrollPaddingX,aspectRatio,boxDecorationBreak,zIndex,boxSizing,objectPosition,objectFit,overscrollBehavior,overscrollBehaviorX,overscrollBehaviorY,position,top,left,inset,insetInline,insetBlock,insetBlockEnd,insetBlockStart,insetInlineEnd,insetInlineStart,right,bottom,float,visibility,display,hideFrom,hideBelow,flexBasis,flex,flexDirection,flexGrow,flexShrink,gridTemplateColumns,gridTemplateRows,gridColumn,gridRow,gridColumnStart,gridColumnEnd,gridAutoFlow,gridAutoColumns,gridAutoRows,gap,gridGap,gridRowGap,gridColumnGap,rowGap,columnGap,justifyContent,alignContent,alignItems,alignSelf,padding,paddingLeft,paddingRight,paddingTop,paddingBottom,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingInline,paddingInlineEnd,paddingInlineStart,marginLeft,marginRight,marginTop,marginBottom,margin,marginBlock,marginBlockEnd,marginBlockStart,marginInline,marginInlineEnd,marginInlineStart,spaceX,spaceY,outlineWidth,outlineColor,outline,outlineOffset,divideX,divideY,divideColor,divideStyle,width,inlineSize,minWidth,minInlineSize,maxWidth,maxInlineSize,height,blockSize,minHeight,minBlockSize,maxHeight,maxBlockSize,color,fontFamily,fontSize,fontSizeAdjust,fontPalette,fontKerning,fontFeatureSettings,fontWeight,fontSmoothing,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariationSettings,fontVariantNumeric,letterSpacing,lineHeight,textAlign,textDecoration,textDecorationColor,textEmphasisColor,textDecorationStyle,textDecorationThickness,textUnderlineOffset,textTransform,textIndent,textShadow,textOverflow,verticalAlign,wordBreak,textWrap,truncate,lineClamp,listStyleType,listStylePosition,listStyleImage,listStyle,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundAttachment,backgroundClip,background,backgroundColor,backgroundOrigin,backgroundImage,backgroundRepeat,backgroundBlendMode,backgroundSize,backgroundGradient,textGradient,gradientFromPosition,gradientToPosition,gradientFrom,gradientTo,gradientVia,gradientViaPosition,borderRadius,borderTopLeftRadius,borderTopRightRadius,borderBottomRightRadius,borderBottomLeftRadius,borderTopRadius,borderRightRadius,borderBottomRadius,borderLeftRadius,borderStartStartRadius,borderStartEndRadius,borderStartRadius,borderEndStartRadius,borderEndEndRadius,borderEndRadius,border,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,borderColor,borderInline,borderInlineWidth,borderInlineColor,borderBlock,borderBlockWidth,borderBlockColor,borderLeft,borderLeftColor,borderInlineStart,borderInlineStartWidth,borderInlineStartColor,borderRight,borderRightColor,borderInlineEnd,borderInlineEndWidth,borderInlineEndColor,borderTop,borderTopColor,borderBottom,borderBottomColor,borderBlockEnd,borderBlockEndColor,borderBlockStart,borderBlockStartColor,opacity,boxShadow,boxShadowColor,mixBlendMode,filter,brightness,contrast,grayscale,hueRotate,invert,saturate,sepia,dropShadow,blur,backdropFilter,backdropBlur,backdropBrightness,backdropContrast,backdropGrayscale,backdropHueRotate,backdropInvert,backdropOpacity,backdropSaturate,backdropSepia,borderCollapse,borderSpacing,borderSpacingX,borderSpacingY,tableLayout,transitionTimingFunction,transitionDelay,transitionDuration,transitionProperty,transition,animation,animationName,animationTimingFunction,animationDuration,animationDelay,animationPlayState,animationComposition,animationFillMode,animationDirection,animationIterationCount,animationRange,animationState,animationRangeStart,animationRangeEnd,animationTimeline,transformOrigin,transformBox,transformStyle,transform,rotate,rotateX,rotateY,rotateZ,scale,scaleX,scaleY,translate,translateX,translateY,translateZ,accentColor,caretColor,scrollBehavior,scrollbar,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollMargin,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollMarginBottom,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollPaddingBottom,scrollSnapAlign,scrollSnapStop,scrollSnapType,scrollSnapStrictness,scrollSnapMargin,scrollSnapMarginTop,scrollSnapMarginBottom,scrollSnapMarginLeft,scrollSnapMarginRight,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,touchAction,userSelect,overflow,overflowWrap,overflowX,overflowY,overflowAnchor,overflowBlock,overflowInline,overflowClipBox,overflowClipMargin,overscrollBehaviorBlock,overscrollBehaviorInline,fill,stroke,strokeWidth,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,srOnly,debug,appearance,backfaceVisibility,clipPath,hyphens,mask,maskImage,maskSize,textSizeAdjust,container,containerName,containerType,cursor,likec4Palette,likec4RelationPalette,colorPalette,_hover,_focus,_focusWithin,_focusVisible,_disabled,_active,_visited,_target,_readOnly,_readWrite,_empty,_checked,_enabled,_expanded,_highlighted,_complete,_incomplete,_dragging,_before,_after,_firstLetter,_firstLine,_marker,_selection,_file,_backdrop,_first,_last,_only,_even,_odd,_firstOfType,_lastOfType,_onlyOfType,_peerFocus,_peerHover,_peerActive,_peerFocusWithin,_peerFocusVisible,_peerDisabled,_peerChecked,_peerInvalid,_peerExpanded,_peerPlaceholderShown,_groupFocus,_groupHover,_groupActive,_groupFocusWithin,_groupFocusVisible,_groupDisabled,_groupChecked,_groupExpanded,_groupInvalid,_indeterminate,_required,_valid,_invalid,_autofill,_inRange,_outOfRange,_placeholder,_placeholderShown,_pressed,_selected,_grabbed,_underValue,_overValue,_atValue,_default,_optional,_open,_closed,_fullscreen,_loading,_hidden,_current,_currentPage,_currentStep,_today,_unavailable,_rangeStart,_rangeEnd,_now,_topmost,_motionReduce,_motionSafe,_print,_landscape,_portrait,_dark,_light,_osDark,_osLight,_highContrast,_lessContrast,_moreContrast,_ltr,_rtl,_scrollbar,_scrollbarThumb,_scrollbarTrack,_horizontal,_vertical,_icon,_starting,_reduceGraphics,_reduceGraphicsOnPan,_noReduceGraphics,_whenPanning,_smallZoom,_compoundTransparent,_edgeActive,_whenHovered,_whenSelected,_whenDimmed,_whenFocused,_shapeSizeXs,_shapeSizeSm,_shapeSizeMd,_shapeSizeLg,_shapeSizeXl,_shapeRectangle,_shapePerson,_shapeBrowser,_shapeMobile,_shapeCylinder,_shapeStorage,_shapeQueue,xs,xsOnly,xsDown,sm,smOnly,smDown,md,mdOnly,mdDown,lg,lgOnly,lgDown,xl,xlOnly,xlDown,xsToSm,xsToMd,xsToLg,xsToXl,smToMd,smToLg,smToXl,mdToLg,mdToXl,lgToXl,textStyle,animationStyle", userGenerated = userGeneratedStr.split(","), cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,WebkitUserSelect,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,anchorName,anchorScope,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimeline,animationTimingFunction,appearance,aspectRatio,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBlockStyle,borderBlockWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineColor,borderInlineEnd,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderInlineStyle,borderInlineWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,clipRule,color,colorInterpolationFilters,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,cx,cy,d,direction,display,dominantBaseline,emptyCells,fieldSizing,fill,fillOpacity,fillRule,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,floodColor,floodOpacity,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontVariationSettings,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,interpolateSize,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lightingColor,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,marker,markerEnd,markerMid,markerStart,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,positionAnchor,positionArea,positionTry,positionTryFallbacks,positionTryOrder,positionVisibility,printColorAdjust,quotes,r,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,rx,ry,scale,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginBottom,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockEnd,scrollPaddingBlockStart,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,scrollbarColor,scrollbarGutter,scrollbarWidth,shapeImageThreshold,shapeMargin,shapeOutside,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,tabSize,tableLayout,textAlign,textAlignLast,textAnchor,textBox,textBoxEdge,textBoxTrim,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textSpacingTrim,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,textWrapMode,textWrapStyle,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,vectorEffect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,x,y,zIndex,zoom,alignmentBaseline,baselineShift,colorInterpolation,colorRendering,glyphOrientationVertical", allCssProperties = cssPropertiesStr.split(",").concat(userGenerated), properties = new Map(allCssProperties.map((prop) => [prop, !0])), cssPropertySelectorRegex = /&|@/, isCssProperty = /* @__PURE__ */ memo$1((prop) => properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop));
const defaultShouldForwardProp = (prop, variantKeys) => !variantKeys.includes(prop) && !isCssProperty(prop), composeShouldForwardProps = (tag, shouldForwardProp) => tag.__shouldForwardProps__ && shouldForwardProp ? (propName) => tag.__shouldForwardProps__(propName) && shouldForwardProp(propName) : shouldForwardProp, composeCvaFn = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  if (cvaA.__cva__ && cvaB.__cva__ || cvaA.__recipe__ && cvaB.__recipe__) return cvaA.merge(cvaB);
  const error = new TypeError("Cannot merge cva with recipe. Please use either cva or recipe.");
  throw TypeError.captureStackTrace?.(error), error;
}, getDisplayName = (Component2) => typeof Component2 == "string" ? Component2 : Component2?.displayName || Component2?.name || "Component";
function styledFn(Dynamic, configOrCva = {}, options = {}) {
  const cvaFn = configOrCva.__cva__ || configOrCva.__recipe__ ? configOrCva : cva(configOrCva), forwardFn = options.shouldForwardProp || defaultShouldForwardProp, shouldForwardProp = (prop) => forwardFn(prop, cvaFn.variantKeys), defaultProps2 = Object.assign(
    options.dataAttr && configOrCva.__name__ ? { "data-recipe": configOrCva.__name__ } : {},
    options.defaultProps
  ), __cvaFn__ = composeCvaFn(Dynamic.__cva__, cvaFn), __shouldForwardProps__ = composeShouldForwardProps(Dynamic, shouldForwardProp), __base__ = Dynamic.__base__ || Dynamic, StyledComponent = /* @__PURE__ */ forwardRef(function(props, ref) {
    const { as: Element2 = __base__, children: children2, ...restProps } = props, combinedProps = useMemo(() => Object.assign({}, defaultProps2, restProps), [restProps]), [htmlProps2, forwardedProps, variantProps2, styleProps, elementProps] = useMemo(() => splitProps(combinedProps, normalizeHTMLProps.keys, __shouldForwardProps__, __cvaFn__.variantKeys, isCssProperty), [combinedProps]);
    function recipeClass() {
      const { css: cssStyles, ...propStyles } = styleProps, compoundVariantStyles = __cvaFn__.__getCompoundVariantCss__?.(variantProps2);
      return cx(__cvaFn__(variantProps2, !1), css(compoundVariantStyles, propStyles, cssStyles), combinedProps.className);
    }
    function cvaClass() {
      const { css: cssStyles, ...propStyles } = styleProps, cvaStyles = __cvaFn__.raw(variantProps2);
      return cx(css(cvaStyles, propStyles, cssStyles), combinedProps.className);
    }
    const classes2 = configOrCva.__recipe__ ? recipeClass : cvaClass;
    return createElement(Element2, {
      ref,
      ...forwardedProps,
      ...elementProps,
      ...normalizeHTMLProps(htmlProps2),
      className: classes2()
    }, combinedProps.children ?? children2);
  }), name = getDisplayName(__base__);
  return StyledComponent.displayName = `styled.${name}`, StyledComponent.__cva__ = __cvaFn__, StyledComponent.__base__ = __base__, StyledComponent.__shouldForwardProps__ = shouldForwardProp, StyledComponent;
}
function createJsxFactory() {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(styledFn, {
    apply(_, __, args) {
      return styledFn(...args);
    },
    get(_, el) {
      return cache.has(el) || cache.set(el, styledFn(el)), cache.get(el);
    }
  });
}
const styled = /* @__PURE__ */ createJsxFactory(), boxConfig = {
  transform(props) {
    return props;
  }
}, getBoxStyle = (styles = {}) => {
  const _styles = getPatternStyles(boxConfig, styles);
  return boxConfig.transform(_styles, patternFns);
}, Box = /* @__PURE__ */ forwardRef(function(props, ref) {
  const [patternProps, restProps] = splitProps(props, []), styleProps = getBoxStyle(patternProps), mergedProps = { ref, ...styleProps, ...restProps };
  return createElement(styled.div, mergedProps);
}), containerConfig = {
  transform(props) {
    return {
      position: "relative",
      maxWidth: "8xl",
      mx: "auto",
      px: { base: "4", md: "6", lg: "8" },
      ...props
    };
  }
}, getContainerStyle = (styles = {}) => {
  const _styles = getPatternStyles(containerConfig, styles);
  return containerConfig.transform(_styles, patternFns);
}, container$5 = (styles) => css(getContainerStyle(styles));
container$5.raw = getContainerStyle;
let listenerQueue = [], lqIndex = 0;
const QUEUE_ITEMS_PER_LISTENER = 4;
let epoch = 0, atom = (initialValue) => {
  let listeners = [], $atom = {
    get() {
      return $atom.lc || $atom.listen(() => {
      })(), $atom.value;
    },
    lc: 0,
    listen(listener) {
      return $atom.lc = listeners.push(listener), () => {
        for (let i2 = lqIndex + QUEUE_ITEMS_PER_LISTENER; i2 < listenerQueue.length; )
          listenerQueue[i2] === listener ? listenerQueue.splice(i2, QUEUE_ITEMS_PER_LISTENER) : i2 += QUEUE_ITEMS_PER_LISTENER;
        let index2 = listeners.indexOf(listener);
        ~index2 && (listeners.splice(index2, 1), --$atom.lc || $atom.off());
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners)
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER)
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      oldValue !== newValue && ($atom.value = newValue, $atom.notify(oldValue));
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      return listener($atom.value), unbind;
    },
    value: initialValue
  };
  return $atom;
};
const MOUNT = 5, UNMOUNT = 6, REVERT_MUTATION = 10;
let on = (object, listener, eventKey, mutateStore) => (object.events = object.events || {}, object.events[eventKey + REVERT_MUTATION] || (object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
  object.events[eventKey].reduceRight((event, l2) => (l2(event), event), {
    shared: {},
    ...eventProps
  });
})), object.events[eventKey] = object.events[eventKey] || [], object.events[eventKey].push(listener), () => {
  let currentListeners = object.events[eventKey], index2 = currentListeners.indexOf(listener);
  currentListeners.splice(index2, 1), currentListeners.length || (delete object.events[eventKey], object.events[eventKey + REVERT_MUTATION](), delete object.events[eventKey + REVERT_MUTATION]);
}), STORE_UNMOUNT_DELAY = 1e3, onMount = ($store, initialize) => on($store, (payload) => {
  let destroy = initialize(payload);
  destroy && $store.events[UNMOUNT].push(destroy);
}, MOUNT, (runListeners) => {
  let originListen = $store.listen;
  $store.listen = (...args) => (!$store.lc && !$store.active && ($store.active = !0, runListeners()), originListen(...args));
  let originOff = $store.off;
  return $store.events[UNMOUNT] = [], $store.off = () => {
    originOff(), setTimeout(() => {
      if ($store.active && !$store.lc) {
        $store.active = !1;
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
      }
    }, STORE_UNMOUNT_DELAY);
  }, () => {
    $store.listen = originListen, $store.off = originOff;
  };
}), computedStore = (stores, cb, batched) => {
  Array.isArray(stores) || (stores = [stores]);
  let previousArgs, currentEpoch, set2 = () => {
    if (currentEpoch === epoch) return;
    currentEpoch = epoch;
    let args = stores.map(($store) => $store.get());
    if (!previousArgs || args.some((arg, i2) => arg !== previousArgs[i2])) {
      previousArgs = args;
      let value = cb(...args);
      value && value.then && value.t ? value.then((asyncValue) => {
        previousArgs === args && $computed.set(asyncValue);
      }) : ($computed.set(value), currentEpoch = epoch);
    }
  }, $computed = atom(void 0), get2 = $computed.get;
  $computed.get = () => (set2(), get2());
  let run = set2;
  return onMount($computed, () => {
    let unbinds = stores.map(($store) => $store.listen(run));
    return set2(), () => {
      for (let unbind of unbinds) unbind();
    };
  }), $computed;
}, computed = (stores, fn) => computedStore(stores, fn);
function listenKeys($store, keys2, listener) {
  let keysSet = new Set(keys2).add(void 0);
  return $store.listen((value, oldValue, changed) => {
    keysSet.has(changed) && listener(value, oldValue, changed);
  });
}
let emit = (snapshotRef, onChange) => (value) => {
  snapshotRef.current !== value && (snapshotRef.current = value, onChange());
};
function useStore(store, { keys: keys2, deps = [store, keys2] } = {}) {
  let snapshotRef = useRef();
  snapshotRef.current = store.get();
  let subscribe = useCallback((onChange) => (emit(snapshotRef, onChange)(store.value), keys2?.length > 0 ? listenKeys(store, keys2, emit(snapshotRef, onChange)) : store.listen(emit(snapshotRef, onChange))), deps), get2 = () => snapshotRef.current;
  return useSyncExternalStore(subscribe, get2, get2);
}
const [ReduceGraphicsModeCtx, useReducedGraphics] = createOptionalContext();
function useIsReducedGraphics() {
  const isReduced = useReducedGraphics();
  return isReduced === null && console.warn("ReduceGraphicsMode is not provided"), isReduced ?? !1;
}
const [PanningAtomSafeCtx, usePanningAtom] = createSafeContext(
  "PanningAtomSafeCtx is not provided"
);
function ReduceGraphicsContext({ reduceGraphics, children: children2 }) {
  const $isPanningRef = useRef(null);
  return $isPanningRef.current || ($isPanningRef.current = atom(reduceGraphics)), /* @__PURE__ */ jsx(PanningAtomSafeCtx, { value: $isPanningRef.current, children: /* @__PURE__ */ jsx(ReduceGraphicsModeCtx, { value: reduceGraphics, children: children2 }) });
}
function useIsPanning() {
  return useStore(usePanningAtom());
}
const RootContainerContext = createContext(createRef());
function RootContainer({
  className,
  reduceGraphics = !1,
  children: children2
}) {
  const ref = useRef(null), $isPanning = usePanningAtom();
  return useEffect(() => $isPanning.listen((isPanning) => {
    isPanning ? ref.current?.setAttribute("data-likec4-diagram-panning", "true") : ref.current?.removeAttribute("data-likec4-diagram-panning");
  }), [$isPanning]), /* @__PURE__ */ jsx(
    Box,
    {
      className: cx("likec4-root", className),
      ref,
      ...reduceGraphics && {
        "data-likec4-reduced-graphics": !0
      },
      children: /* @__PURE__ */ jsx(RootContainerContext.Provider, { value: ref, children: children2 })
    }
  );
}
function useRootContainer() {
  return useContext(RootContainerContext).current;
}
const [
  ControlsCustomLayoutProvider,
  useControlsCustomLayout
] = createOptionalContext(null);
function toStyle(name, colors2) {
  const darken2 = (color2) => `color-mix(in srgb, ${color2} 80%, black)`;
  return `
:where([data-likec4-color=${name}]) {
  --colors-likec4-palette-hi-contrast: ${colors2.elements.hiContrast};
  --colors-likec4-palette-lo-contrast: ${colors2.elements.loContrast};
  --colors-likec4-palette-fill: ${colors2.elements.fill};
  --colors-likec4-palette-stroke: ${colors2.elements.stroke};
  --colors-likec4-relation-stroke: ${colors2.relationships.lineColor};
  --colors-likec4-relation-stroke-selected: color-mix(in srgb, ${colors2.relationships.lineColor}, var(--colors-likec4-mix-color) 20%);
  --colors-likec4-relation-label: ${colors2.relationships.labelColor};
  --colors-likec4-relation-label-bg: ${colors2.relationships.labelBgColor};
}
:where(.likec4-compound-node[data-likec4-color=${name}]) {
  --colors-likec4-palette-fill: ${darken2(colors2.elements.fill)};
  --colors-likec4-palette-stroke: ${darken2(colors2.elements.stroke)};
}
  `;
}
const LikeC4CustomColors = memo$2(({ customColors }) => {
  const styles = t$1(customColors).map(([name, color2]) => toStyle(name, color2)).join(`
`), nonce = useMantineStyleNonce()?.();
  return /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx("style", { type: "text/css", dangerouslySetInnerHTML: { __html: styles }, nonce }) });
}, deepEqual);
LikeC4CustomColors.displayName = "LikeC4CustomColors";
const noop = () => {
}, depsShallowEqual = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (!shallowEqual(element, d2[i2]))
      return !1;
  return !0;
};
function useUpdateEffect(callback, deps, equalityFn, effectHook) {
  const isFirstMount = useFirstMountState();
  useCustomCompareEffect(
    isFirstMount ? noop : callback,
    deps,
    depsShallowEqual,
    effectHook
  );
}
const useXYFlow = useReactFlow;
function useXYStore(selector3, equalityFn) {
  return useStore$1(
    useCallbackRef(selector3),
    shallowEqual
  );
}
const useXYStoreApi = useStoreApi, useXYInternalNode = useInternalNode, selectZoom = (state) => state.transform[2] < 0.2;
function useIsZoomTooSmall() {
  return useStore$1(selectZoom);
}
const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
function crt(v) {
  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
}
const pi$2 = Math.PI, tau$1 = 2 * pi$2, quart = pi$2 / 2, epsilon$2 = 1e-6, nMax = Number.MAX_SAFE_INTEGER || 9007199254740991, nMin = Number.MIN_SAFE_INTEGER || -9007199254740991, ZERO = { x: 0, y: 0, z: 0 }, utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t2, derivativeFn) {
    const d2 = derivativeFn(t2);
    let l2 = d2.x * d2.x + d2.y * d2.y;
    return typeof d2.z < "u" && (l2 += d2.z * d2.z), sqrt$1(l2);
  },
  compute: function(t2, points, _3d) {
    if (t2 === 0)
      return points[0].t = 0, points[0];
    const order = points.length - 1;
    if (t2 === 1)
      return points[order].t = 1, points[order];
    const mt = 1 - t2;
    let p2 = points;
    if (order === 0)
      return points[0].t = t2, points[0];
    if (order === 1) {
      const ret = {
        x: mt * p2[0].x + t2 * p2[1].x,
        y: mt * p2[0].y + t2 * p2[1].y,
        t: t2
      };
      return _3d && (ret.z = mt * p2[0].z + t2 * p2[1].z), ret;
    }
    if (order < 4) {
      let mt2 = mt * mt, t22 = t2 * t2, a2, b2, c2, d2 = 0;
      order === 2 ? (p2 = [p2[0], p2[1], p2[2], ZERO], a2 = mt2, b2 = mt * t2 * 2, c2 = t22) : order === 3 && (a2 = mt2 * mt, b2 = mt2 * t2 * 3, c2 = mt * t22 * 3, d2 = t2 * t22);
      const ret = {
        x: a2 * p2[0].x + b2 * p2[1].x + c2 * p2[2].x + d2 * p2[3].x,
        y: a2 * p2[0].y + b2 * p2[1].y + c2 * p2[2].y + d2 * p2[3].y,
        t: t2
      };
      return _3d && (ret.z = a2 * p2[0].z + b2 * p2[1].z + c2 * p2[2].z + d2 * p2[3].z), ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    for (; dCpts.length > 1; ) {
      for (let i2 = 0; i2 < dCpts.length - 1; i2++)
        dCpts[i2] = {
          x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t2,
          y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t2
        }, typeof dCpts[i2].z < "u" && (dCpts[i2].z = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t2);
      dCpts.splice(dCpts.length - 1, 1);
    }
    return dCpts[0].t = t2, dCpts[0];
  },
  computeWithRatios: function(t2, points, ratios, _3d) {
    const mt = 1 - t2, r2 = ratios, p2 = points;
    let f1 = r2[0], f2 = r2[1], f3 = r2[2], f4 = r2[3], d2;
    if (f1 *= mt, f2 *= t2, p2.length === 2)
      return d2 = f1 + f2, {
        x: (f1 * p2[0].x + f2 * p2[1].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z) / d2 : !1,
        t: t2
      };
    if (f1 *= mt, f2 *= 2 * mt, f3 *= t2 * t2, p2.length === 3)
      return d2 = f1 + f2 + f3, {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z) / d2 : !1,
        t: t2
      };
    if (f1 *= mt, f2 *= 1.5 * mt, f3 *= 3 * mt, f4 *= t2 * t2 * t2, p2.length === 4)
      return d2 = f1 + f2 + f3 + f4, {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x + f4 * p2[3].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y + f4 * p2[3].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z + f4 * p2[3].z) / d2 : !1,
        t: t2
      };
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p2 = points, d2 = p2.length, c2 = d2 - 1; d2 > 1; d2--, c2--) {
      const list2 = [];
      for (let j2 = 0, dpt; j2 < c2; j2++)
        dpt = {
          x: c2 * (p2[j2 + 1].x - p2[j2].x),
          y: c2 * (p2[j2 + 1].y - p2[j2].y)
        }, _3d && (dpt.z = c2 * (p2[j2 + 1].z - p2[j2].z)), list2.push(dpt);
      dpoints.push(list2), p2 = list2;
    }
    return dpoints;
  },
  between: function(v, m2, M) {
    return m2 <= v && v <= M || utils.approximately(v, m2) || utils.approximately(v, M);
  },
  approximately: function(a2, b2, precision) {
    return abs$1(a2 - b2) <= (precision || epsilon$2);
  },
  length: function(derivativeFn) {
    const len = utils.Tvalues.length;
    let sum = 0;
    for (let i2 = 0, t2; i2 < len; i2++)
      t2 = 0.5 * utils.Tvalues[i2] + 0.5, sum += utils.Cvalues[i2] * utils.arcfn(t2, derivativeFn);
    return 0.5 * sum;
  },
  map: function(v, ds, de, ts, te) {
    const d1 = de - ds, d2 = te - ts, v2 = v - ds, r2 = v2 / d1;
    return ts + d2 * r2;
  },
  lerp: function(r2, v1, v2) {
    const ret = {
      x: v1.x + r2 * (v2.x - v1.x),
      y: v1.y + r2 * (v2.y - v1.y)
    };
    return v1.z !== void 0 && v2.z !== void 0 && (ret.z = v1.z + r2 * (v2.z - v1.z)), ret;
  },
  pointToString: function(p2) {
    let s2 = p2.x + "/" + p2.y;
    return typeof p2.z < "u" && (s2 += "/" + p2.z), s2;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o2, v1, v2) {
    const dx1 = v1.x - o2.x, dy1 = v1.y - o2.y, dx2 = v2.x - o2.x, dy2 = v2.y - o2.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },
  // round as string, to avoid rounding errors
  round: function(v, d2) {
    const s2 = "" + v, pos = s2.indexOf(".");
    return parseFloat(s2.substring(0, pos + 1 + d2));
  },
  dist: function(p1, p2) {
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },
  closest: function(LUT, point2) {
    let mdist = pow(2, 63), mpos, d2;
    return LUT.forEach(function(p2, idx) {
      d2 = utils.dist(point2, p2), d2 < mdist && (mdist = d2, mpos = idx);
    }), { mdist, mpos };
  },
  abcratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const bottom = pow(t2, n2) + pow(1 - t2, n2), top = bottom - 1;
    return abs$1(top / bottom);
  },
  projectionratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const top = pow(1 - t2, n2), bottom = pow(t2, n2) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d2 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    return d2 == 0 ? !1 : { x: nx / d2, y: ny / d2 };
  },
  lli4: function(p1, p2, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },
  lli: function(v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function(p1, p2) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    return sections.forEach(function(s2) {
      const bbox = s2.bbox();
      mx > bbox.x.min && (mx = bbox.x.min), my > bbox.y.min && (my = bbox.y.min), MX < bbox.x.max && (MX = bbox.x.max), MY < bbox.y.max && (MY = bbox.y.max);
    }), {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [], a1 = [s1.startcap, s1.forward, s1.back, s1.endcap], a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    return a1.forEach(function(l1) {
      l1.virtual || a2.forEach(function(l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        iss.length > 0 && (iss.c1 = l1, iss.c2 = l2, iss.s1 = s1, iss.s2 = s2, intersections.push(iss));
      });
    }), intersections;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length, fpl = forward.points.length, start2 = utils.makeline(back.points[bpl - 1], forward.points[0]), end = utils.makeline(forward.points[fpl - 1], back.points[0]), shape = {
      startcap: start2,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start2, forward, back, end])
    };
    return shape.intersections = function(s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    }, shape;
  },
  getminmax: function(curve2, d2, list2) {
    if (!list2) return { min: 0, max: 0 };
    let min2 = nMax, max2 = nMin, t2, c2;
    list2.indexOf(0) === -1 && (list2 = [0].concat(list2)), list2.indexOf(1) === -1 && list2.push(1);
    for (let i2 = 0, len = list2.length; i2 < len; i2++)
      t2 = list2[i2], c2 = curve2.get(t2), c2[d2] < min2 && (min2 = c2[d2]), c2[d2] > max2 && (max2 = c2[d2]);
    return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
  },
  align: function(points, line) {
    const tx = line.p1.x, ty = line.p1.y, a2 = -atan2(line.p2.y - ty, line.p2.x - tx), d2 = function(v) {
      return {
        x: (v.x - tx) * cos$1(a2) - (v.y - ty) * sin$1(a2),
        y: (v.x - tx) * sin$1(a2) + (v.y - ty) * cos$1(a2)
      };
    };
    return points.map(d2);
  },
  roots: function(points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order = points.length - 1, aligned = utils.align(points, line), reduce = function(t2) {
      return 0 <= t2 && t2 <= 1;
    };
    if (order === 2) {
      const a3 = aligned[0].y, b3 = aligned[1].y, c3 = aligned[2].y, d3 = a3 - 2 * b3 + c3;
      if (d3 !== 0) {
        const m1 = -sqrt$1(b3 * b3 - a3 * c3), m2 = -a3 + b3, v12 = -(m1 + m2) / d3, v2 = -(-m1 + m2) / d3;
        return [v12, v2].filter(reduce);
      } else if (b3 !== c3 && d3 === 0)
        return [(2 * b3 - c3) / (2 * b3 - 2 * c3)].filter(reduce);
      return [];
    }
    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d2 = -pa + 3 * pb - 3 * pc + pd, a2 = 3 * pa - 6 * pb + 3 * pc, b2 = -3 * pa + 3 * pb, c2 = pa;
    if (utils.approximately(d2, 0)) {
      if (utils.approximately(a2, 0))
        return utils.approximately(b2, 0) ? [] : [-c2 / b2].filter(reduce);
      const q3 = sqrt$1(b2 * b2 - 4 * a2 * c2), a22 = 2 * a2;
      return [(q3 - b2) / a22, (-b2 - q3) / a22].filter(reduce);
    }
    a2 /= d2, b2 /= d2, c2 /= d2;
    const p2 = (3 * b2 - a2 * a2) / 3, p3 = p2 / 3, q = (2 * a2 * a2 * a2 - 9 * a2 * b2 + 27 * c2) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p2 / 3, mp33 = mp3 * mp3 * mp3, r2 = sqrt$1(mp33), t2 = -q / (2 * r2), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos$1(cosphi), crtr = crt(r2), t1 = 2 * crtr;
      return x1 = t1 * cos$1(phi / 3) - a2 / 3, x2 = t1 * cos$1((phi + tau$1) / 3) - a2 / 3, x3 = t1 * cos$1((phi + 2 * tau$1) / 3) - a2 / 3, [x1, x2, x3].filter(reduce);
    } else {
      if (discriminant === 0)
        return u1 = q2 < 0 ? crt(-q2) : -crt(q2), x1 = 2 * u1 - a2 / 3, x2 = -u1 - a2 / 3, [x1, x2].filter(reduce);
      {
        const sd = sqrt$1(discriminant);
        return u1 = crt(-q2 + sd), v1 = crt(q2 + sd), [u1 - v1 - a2 / 3].filter(reduce);
      }
    }
  },
  droots: function(p2) {
    if (p2.length === 3) {
      const a2 = p2[0], b2 = p2[1], c2 = p2[2], d2 = a2 - 2 * b2 + c2;
      if (d2 !== 0) {
        const m1 = -sqrt$1(b2 * b2 - a2 * c2), m2 = -a2 + b2, v1 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
        return [v1, v2];
      } else if (b2 !== c2 && d2 === 0)
        return [(2 * b2 - c2) / (2 * (b2 - c2))];
      return [];
    }
    if (p2.length === 2) {
      const a2 = p2[0], b2 = p2[1];
      return a2 !== b2 ? [a2 / (a2 - b2)] : [];
    }
    return [];
  },
  curvature: function(t2, d1, d2, _3d, kOnly) {
    let num, dnm, adk, dk, k2 = 0, r2 = 0;
    const d3 = utils.compute(t2, d1), dd = utils.compute(t2, d2), qdsum = d3.x * d3.x + d3.y * d3.y;
    if (_3d ? (num = sqrt$1(
      pow(d3.y * dd.z - dd.y * d3.z, 2) + pow(d3.z * dd.x - dd.z * d3.x, 2) + pow(d3.x * dd.y - dd.x * d3.y, 2)
    ), dnm = pow(qdsum + d3.z * d3.z, 3 / 2)) : (num = d3.x * dd.y - d3.y * dd.x, dnm = pow(qdsum, 3 / 2)), num === 0 || dnm === 0)
      return { k: 0, r: 0 };
    if (k2 = num / dnm, r2 = dnm / num, !kOnly) {
      const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, !0).k, nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, !0).k;
      dk = (nk - k2 + (k2 - pk)) / 2, adk = (abs$1(nk - k2) + abs$1(k2 - pk)) / 2;
    }
    return { k: k2, r: r2, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p2 = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a2 = p2[2].x * p2[1].y, b2 = p2[3].x * p2[1].y, c2 = p2[1].x * p2[2].y, d2 = p2[3].x * p2[2].y, v1 = 18 * (-3 * a2 + 2 * b2 + 3 * c2 - d2), v2 = 18 * (3 * a2 - b2 - 3 * c2), v3 = 18 * (c2 - a2);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t2 = -v3 / v2;
        if (0 <= t2 && t2 <= 1) return [t2];
      }
      return [];
    }
    const d22 = 2 * v1;
    if (utils.approximately(d22, 0)) return [];
    const trm = v2 * v2 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v2) / d22, -(v2 + sq) / d22].filter(function(r2) {
      return 0 <= r2 && r2 <= 1;
    });
  },
  bboxoverlap: function(b1, b2) {
    const dims = ["x", "y"], len = dims.length;
    for (let i2 = 0, dim, l2, t2, d2; i2 < len; i2++)
      if (dim = dims[i2], l2 = b1[dim].mid, t2 = b2[dim].mid, d2 = (b1[dim].size + b2[dim].size) / 2, abs$1(l2 - t2) >= d2) return !1;
    return !0;
  },
  expandbox: function(bbox, _bbox) {
    _bbox.x.min < bbox.x.min && (bbox.x.min = _bbox.x.min), _bbox.y.min < bbox.y.min && (bbox.y.min = _bbox.y.min), _bbox.z && _bbox.z.min < bbox.z.min && (bbox.z.min = _bbox.z.min), _bbox.x.max > bbox.x.max && (bbox.x.max = _bbox.x.max), _bbox.y.max > bbox.y.max && (bbox.y.max = _bbox.y.max), _bbox.z && _bbox.z.max > bbox.z.max && (bbox.z.max = _bbox.z.max), bbox.x.mid = (bbox.x.min + bbox.x.max) / 2, bbox.y.mid = (bbox.y.min + bbox.y.max) / 2, bbox.z && (bbox.z.mid = (bbox.z.min + bbox.z.max) / 2), bbox.x.size = bbox.x.max - bbox.x.min, bbox.y.size = bbox.y.max - bbox.y.min, bbox.z && (bbox.z.size = bbox.z.max - bbox.z.min);
  },
  pairiteration: function(c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c2.bbox(), r2 = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold)
      return [
        (r2 * (c1._t1 + c1._t2) / 2 | 0) / r2 + "/" + (r2 * (c2._t1 + c2._t2) / 2 | 0) / r2
      ];
    let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs = pairs.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    return pairs.length === 0 || (pairs.forEach(function(pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    }), results = results.filter(function(v, i2) {
      return results.indexOf(v) === i2;
    })), results;
  },
  getccenter: function(p1, p2, p3) {
    const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r2 = utils.dist(arc, p1);
    let s2 = atan2(p1.y - arc.y, p1.x - arc.x), m2 = atan2(p2.y - arc.y, p2.x - arc.x), e2 = atan2(p3.y - arc.y, p3.x - arc.x), _;
    return s2 < e2 ? ((s2 > m2 || m2 > e2) && (s2 += tau$1), s2 > e2 && (_ = e2, e2 = s2, s2 = _)) : e2 < m2 && m2 < s2 ? (_ = e2, e2 = s2, s2 = _) : e2 += tau$1, arc.s = s2, arc.e = e2, arc.r = r2, arc;
  },
  numberSort: function(a2, b2) {
    return a2 - b2;
  }
};
class PolyBezier {
  constructor(curves) {
    this.curves = [], this._3d = !1, curves && (this.curves = curves, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve2) {
      return utils.pointsToString(curve2.points);
    }).join(", ") + "]";
  }
  addCurve(curve2) {
    this.curves.push(curve2), this._3d = this._3d || curve2._3d;
  }
  length() {
    return this.curves.map(function(v) {
      return v.length();
    }).reduce(function(a2, b2) {
      return a2 + b2;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c2 = this.curves;
    for (var bbox = c2[0].bbox(), i2 = 1; i2 < c2.length; i2++)
      utils.expandbox(bbox, c2[i2].bbox());
    return bbox;
  }
  offset(d2) {
    const offset2 = [];
    return this.curves.forEach(function(v) {
      offset2.push(...v.offset(d2));
    }), new PolyBezier(offset2);
  }
}
const { abs, min, max, cos, sin, acos, sqrt } = Math, pi$1 = Math.PI;
class Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice(), coordlen = !1;
    if (typeof args[0] == "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point3) {
        ["x", "y", "z"].forEach(function(d2) {
          typeof point3[d2] < "u" && newargs.push(point3[d2]);
        });
      }), args = newargs;
    }
    let higher = !1;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        higher = !0;
      }
    } else if (len !== 6 && len !== 8 && len !== 9 && len !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z < "u", points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point2 = {
        x: args[idx],
        y: args[idx + 1]
      };
      _3d && (point2.z = args[idx + 2]), points.push(point2);
    }
    const order = this.order = points.length - 1, dims = this.dims = ["x", "y"];
    _3d && dims.push("z"), this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order] }), baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t2, p2) => t2 + abs(p2.y), 0) < baselength / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(p1, p2, p3, t2) {
    if (typeof t2 > "u" && (t2 = 0.5), t2 === 0)
      return new Bezier(p2, p2, p3);
    if (t2 === 1)
      return new Bezier(p1, p2, p2);
    const abc = Bezier.getABC(2, p1, p2, p3, t2);
    return new Bezier(p1, abc.A, p3);
  }
  static cubicFromPoints(S, B2, E, t2, d1) {
    typeof t2 > "u" && (t2 = 0.5);
    const abc = Bezier.getABC(3, S, B2, E, t2);
    typeof d1 > "u" && (d1 = utils.dist(B2, abc.C));
    const d2 = d1 * (1 - t2) / t2, selen = utils.dist(S, E), lx = (E.x - S.x) / selen, ly = (E.y - S.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly, e1 = { x: B2.x - bx1, y: B2.y - by1 }, e2 = { x: B2.x + bx2, y: B2.y + by2 }, A = abc.A, v1 = { x: A.x + (e1.x - A.x) / (1 - t2), y: A.y + (e1.y - A.y) / (1 - t2) }, v2 = { x: A.x + (e2.x - A.x) / t2, y: A.y + (e2.y - A.y) / t2 }, nc1 = { x: S.x + (v1.x - S.x) / t2, y: S.y + (v1.y - S.y) / t2 }, nc2 = {
      x: E.x + (v2.x - E.x) / (1 - t2),
      y: E.y + (v2.y - E.y) / (1 - t2)
    };
    return new Bezier(S, nc1, nc2, E);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const p2 = this.points, x2 = p2[0].x, y2 = p2[0].y, s2 = ["M", x2, y2, this.order === 2 ? "Q" : "C"];
    for (let i2 = 1, last2 = p2.length; i2 < last2; i2++)
      s2.push(p2[i2].x), s2.push(p2[i2].y);
    return s2.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = ratios, this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    print !== this._print && (this._print = print, this.update());
  }
  coordDigest() {
    return this.points.map(function(c2, pos) {
      return "" + pos + c2.x + c2.y + (c2.z ? c2.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = utils.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const points = this.points, angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order = 2, S, B2, E, t2 = 0.5) {
    const u2 = utils.projectionratio(t2, order), um = 1 - u2, C2 = {
      x: u2 * S.x + um * E.x,
      y: u2 * S.y + um * E.y
    }, s2 = utils.abcratio(t2, order);
    return { A: {
      x: B2.x + (B2.x - C2.x) / s2,
      y: B2.y + (B2.y - C2.y) / s2
    }, B: B2, C: C2, S, E };
  }
  getABC(t2, B2) {
    B2 = B2 || this.get(t2);
    let S = this.points[0], E = this.points[this.order];
    return Bezier.getABC(this.order, S, B2, E, t2);
  }
  getLUT(steps) {
    if (this.verify(), steps = steps || 100, this._lut.length === steps + 1)
      return this._lut;
    this._lut = [], steps++, this._lut = [];
    for (let i2 = 0, p2, t2; i2 < steps; i2++)
      t2 = i2 / (steps - 1), p2 = this.compute(t2), p2.t = t2, this._lut.push(p2);
    return this._lut;
  }
  on(point2, error) {
    error = error || 5;
    const lut = this.getLUT(), hits = [];
    for (let i2 = 0, c2, t2 = 0; i2 < lut.length; i2++)
      c2 = lut[i2], utils.dist(c2, point2) < error && (hits.push(c2), t2 += i2 / lut.length);
    return hits.length ? t /= hits.length : !1;
  }
  project(point2) {
    const LUT = this.getLUT(), l2 = LUT.length - 1, closest = utils.closest(LUT, point2), mpos = closest.mpos, t1 = (mpos - 1) / l2, t2 = (mpos + 1) / l2, step = 0.1 / l2;
    let mdist = closest.mdist, t3 = t1, ft = t3, p2;
    mdist += 1;
    for (let d2; t3 < t2 + step; t3 += step)
      p2 = this.compute(t3), d2 = utils.dist(point2, p2), d2 < mdist && (mdist = d2, ft = t3);
    return ft = ft < 0 ? 0 : ft > 1 ? 1 : ft, p2 = this.compute(ft), p2.t = ft, p2.d = mdist, p2;
  }
  get(t2) {
    return this.compute(t2);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t2) {
    return this.ratios ? utils.computeWithRatios(t2, this.points, this.ratios, this._3d) : utils.compute(t2, this.points, this._3d, this.ratios);
  }
  raise() {
    const p2 = this.points, np = [p2[0]], k2 = p2.length;
    for (let i2 = 1, pi2, pim; i2 < k2; i2++)
      pi2 = p2[i2], pim = p2[i2 - 1], np[i2] = {
        x: (k2 - i2) / k2 * pi2.x + i2 / k2 * pim.x,
        y: (k2 - i2) / k2 * pi2.y + i2 / k2 * pim.y
      };
    return np[k2] = p2[k2 - 1], new Bezier(np);
  }
  derivative(t2) {
    return utils.compute(t2, this.dpoints[0], this._3d);
  }
  dderivative(t2) {
    return utils.compute(t2, this.dpoints[1], this._3d);
  }
  align() {
    let p2 = this.points;
    return new Bezier(utils.align(p2, { p1: p2[0], p2: p2[p2.length - 1] }));
  }
  curvature(t2) {
    return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t2) {
    return this._3d ? this.__normal3(t2) : this.__normal2(t2);
  }
  __normal2(t2) {
    const d2 = this.derivative(t2), q = sqrt(d2.x * d2.x + d2.y * d2.y);
    return { t: t2, x: -d2.y / q, y: d2.x / q };
  }
  __normal3(t2) {
    const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1, r1.y /= q1, r1.z /= q1, r2.x /= q2, r2.y /= q2, r2.z /= q2;
    const c2 = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    }, m2 = sqrt(c2.x * c2.x + c2.y * c2.y + c2.z * c2.z);
    c2.x /= m2, c2.y /= m2, c2.z /= m2;
    const R = [
      c2.x * c2.x,
      c2.x * c2.y - c2.z,
      c2.x * c2.z + c2.y,
      c2.x * c2.y + c2.z,
      c2.y * c2.y,
      c2.y * c2.z - c2.x,
      c2.x * c2.z - c2.y,
      c2.y * c2.z + c2.x,
      c2.z * c2.z
    ];
    return {
      t: t2,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
    };
  }
  hull(t2) {
    let p2 = this.points, _p = [], q = [], idx = 0;
    for (q[idx++] = p2[0], q[idx++] = p2[1], q[idx++] = p2[2], this.order === 3 && (q[idx++] = p2[3]); p2.length > 1; ) {
      _p = [];
      for (let i2 = 0, pt, l2 = p2.length - 1; i2 < l2; i2++)
        pt = utils.lerp(t2, p2[i2], p2[i2 + 1]), q[idx++] = pt, _p.push(pt);
      p2 = _p;
    }
    return q;
  }
  split(t1, t2) {
    if (t1 === 0 && t2)
      return this.split(t2).left;
    if (t2 === 1)
      return this.split(t1).right;
    const q = this.hull(t1), result = {
      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),
      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),
      span: q
    };
    return result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2), result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2), t2 ? (t2 = utils.map(t2, t1, 1, 0, 1), result.right.split(t2).left) : result;
  }
  extrema() {
    const result = {};
    let roots = [];
    return this.dims.forEach(
      function(dim) {
        let mfn = function(v) {
          return v[dim];
        }, p2 = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p2), this.order === 3 && (p2 = this.dpoints[1].map(mfn), result[dim] = result[dim].concat(utils.droots(p2))), result[dim] = result[dim].filter(function(t2) {
          return t2 >= 0 && t2 <= 1;
        }), roots = roots.concat(result[dim].sort(utils.numberSort));
      }.bind(this)
    ), result.values = roots.sort(utils.numberSort).filter(function(v, idx) {
      return roots.indexOf(v) === idx;
    }), result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    return this.dims.forEach(
      function(d2) {
        result[d2] = utils.getminmax(this, d2, extrema[d2]);
      }.bind(this)
    ), result;
  }
  overlaps(curve2) {
    const lbbox = this.bbox(), tbbox = curve2.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t2, d2) {
    if (typeof d2 < "u") {
      const c2 = this.get(t2), n2 = this.normal(t2), ret = {
        c: c2,
        n: n2,
        x: c2.x + n2.x * d2,
        y: c2.y + n2.y * d2
      };
      return this._3d && (ret.z = c2.z + n2.z * d2), ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p2) {
        const ret = {
          x: p2.x + t2 * nv.x,
          y: p2.y + t2 * nv.y
        };
        return p2.z && nv.z && (ret.z = p2.z + t2 * nv.z), ret;
      });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function(s2) {
      return s2._linear ? s2.offset(t2)[0] : s2.scale(t2);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]), a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return !1;
    }
    const n1 = this.normal(0), n2 = this.normal(1);
    let s2 = n1.x * n2.x + n1.y * n2.y;
    return this._3d && (s2 += n1.z * n2.z), abs(acos(s2)) < pi$1 / 3;
  }
  reduce() {
    let i2, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [], extrema = this.extrema().values;
    for (extrema.indexOf(0) === -1 && (extrema = [0].concat(extrema)), extrema.indexOf(1) === -1 && extrema.push(1), t1 = extrema[0], i2 = 1; i2 < extrema.length; i2++)
      t2 = extrema[i2], segment = this.split(t1, t2), segment._t1 = t1, segment._t2 = t2, pass1.push(segment), t1 = t2;
    return pass1.forEach(function(p1) {
      for (t1 = 0, t2 = 0; t2 <= 1; )
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step)
          if (segment = p1.split(t1, t2), !segment.simple()) {
            if (t2 -= step, abs(t1 - t2) < step)
              return [];
            segment = p1.split(t1, t2), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2), pass2.push(segment), t1 = t2;
            break;
          }
      t1 < 1 && (segment = p1.split(t1, 1), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = p1._t2, pass2.push(segment));
    }), pass2;
  }
  translate(v, d1, d2) {
    d2 = typeof d2 == "number" ? d2 : d1;
    const o2 = this.order;
    let d3 = this.points.map((_, i2) => (1 - i2 / o2) * d1 + i2 / o2 * d2);
    return new Bezier(
      this.points.map((p2, i2) => ({
        x: p2.x + v.x * d3[i2],
        y: p2.y + v.y * d3[i2]
      }))
    );
  }
  scale(d2) {
    const order = this.order;
    let distanceFn = !1;
    if (typeof d2 == "function" && (distanceFn = d2), distanceFn && order === 2)
      return this.raise().scale(distanceFn);
    const clockwise = this.clockwise, points = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d2,
        distanceFn ? distanceFn(1) : d2
      );
    const r1 = distanceFn ? distanceFn(0) : d2, r2 = distanceFn ? distanceFn(1) : d2, v = [this.offset(0, 10), this.offset(1, 10)], np = [], o2 = utils.lli4(v[0], v[0].c, v[1], v[1].c);
    if (!o2)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(t2) {
      const p2 = np[t2 * order] = utils.copy(points[t2 * order]);
      p2.x += (t2 ? r2 : r1) * v[t2].n.x, p2.y += (t2 ? r2 : r1) * v[t2].n.y;
    }), distanceFn ? ([0, 1].forEach(function(t2) {
      if (!(order === 2 && t2)) {
        var p2 = points[t2 + 1], ov = {
          x: p2.x - o2.x,
          y: p2.y - o2.y
        }, rc = distanceFn ? distanceFn((t2 + 1) / order) : d2;
        distanceFn && !clockwise && (rc = -rc);
        var m2 = sqrt(ov.x * ov.x + ov.y * ov.y);
        ov.x /= m2, ov.y /= m2, np[t2 + 1] = {
          x: p2.x + rc * ov.x,
          y: p2.y + rc * ov.y
        };
      }
    }), new Bezier(np)) : ([0, 1].forEach((t2) => {
      if (order === 2 && t2) return;
      const p2 = np[t2 * order], d3 = this.derivative(t2), p22 = { x: p2.x + d3.x, y: p2.y + d3.y };
      np[t2 + 1] = utils.lli4(p2, p22, o2, points[t2 + 1]);
    }), new Bezier(np));
  }
  outline(d1, d2, d3, d4) {
    if (d2 = d2 === void 0 ? d1 : d2, this._linear) {
      const n2 = this.normal(0), start2 = this.points[0], end = this.points[this.points.length - 1];
      let s2, mid, e2;
      d3 === void 0 && (d3 = d1, d4 = d2), s2 = { x: start2.x + n2.x * d1, y: start2.y + n2.y * d1 }, e2 = { x: end.x + n2.x * d3, y: end.y + n2.y * d3 }, mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const fline = [s2, mid, e2];
      s2 = { x: start2.x - n2.x * d2, y: start2.y - n2.y * d2 }, e2 = { x: end.x - n2.x * d4, y: end.y - n2.y * d4 }, mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const bline = [e2, mid, s2], ls2 = utils.makeline(bline[2], fline[0]), le2 = utils.makeline(fline[2], bline[0]), segments2 = [ls2, new Bezier(fline), le2, new Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p2, alen = 0, tlen = this.length();
    const graduated = typeof d3 < "u" && typeof d4 < "u";
    function linearDistanceFunction(s2, e2, tlen2, alen2, slen) {
      return function(v) {
        const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d5 = e2 - s2;
        return utils.map(v, 0, 1, s2 + f1 * d5, s2 + f2 * d5);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      graduated ? (fcurves.push(
        segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
      ), bcurves.push(
        segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
      )) : (fcurves.push(segment.scale(d1)), bcurves.push(segment.scale(-d2))), alen += slen;
    }), bcurves = bcurves.map(function(s2) {
      return p2 = s2.points, p2[3] ? s2.points = [p2[3], p2[2], p2[1], p2[0]] : s2.points = [p2[2], p2[1], p2[0]], s2;
    }).reverse();
    const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves, shapes = [];
    for (let i2 = 1, len = outline.length; i2 < len / 2; i2++) {
      const shape = utils.makeshape(
        outline[i2],
        outline[len - i2],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i2 > 1, shape.endcap.virtual = i2 < len / 2 - 1, shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve2, curveIntersectionThreshold) {
    return curve2 ? curve2.p1 && curve2.p2 ? this.lineIntersects(curve2) : (curve2 instanceof Bezier && (curve2 = curve2.reduce()), this.curveintersects(
      this.reduce(),
      curve2,
      curveIntersectionThreshold
    )) : this.selfintersects(curveIntersectionThreshold);
  }
  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);
    return utils.roots(this.points, line).filter((t2) => {
      var p2 = this.get(t2);
      return utils.between(p2.x, mx, MX) && utils.between(p2.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i2 = 0, result, left, right; i2 < len; i2++)
      left = reduced.slice(i2, i2 + 1), right = reduced.slice(i2 + 2), result = this.curveintersects(left, right, curveIntersectionThreshold), results.push(...result);
    return results;
  }
  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    c1.forEach(function(l2) {
      c2.forEach(function(r2) {
        l2.overlaps(r2) && pairs.push({ left: l2, right: r2 });
      });
    });
    let intersections = [];
    return pairs.forEach(function(pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      result.length > 0 && (intersections = intersections.concat(result));
    }), intersections;
  }
  arcs(errorThreshold) {
    return errorThreshold = errorThreshold || 0.5, this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s2, e2) {
    const q = (e2 - s2) / 4, c1 = this.get(s2 + q), c2 = this.get(e2 - q), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0, t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc, prev_arc, curr_good = !1, prev_good = !1, done, t_m = t_e, prev_e = 1;
      do
        if (prev_good = curr_good, prev_arc = arc, t_m = (t_s + t_e) / 2, np2 = this.get(t_m), np3 = this.get(t_e), arc = utils.getccenter(np1, np2, np3), arc.interval = {
          start: t_s,
          end: t_e
        }, curr_good = this._error(arc, np1, t_s, t_e) <= errorThreshold, done = prev_good && !curr_good, done || (prev_e = t_e), curr_good) {
          if (t_e >= 1) {
            if (arc.interval.end = prev_e = 1, prev_arc = arc, t_e > 1) {
              let d2 = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e)
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d2, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else
          t_e = t_m;
      while (!done && safety++ < 100);
      if (safety >= 100)
        break;
      prev_arc = prev_arc || arc, circles.push(prev_arc), t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
}
function toDomPrecision(v) {
  return v === null ? 0.01 : Math.round(v * 100) / 100;
}
function bezierControlPoints(diagramEdge) {
  let [start2, ...bezierPoints] = diagramEdge.points;
  invariant$2(start2, "start should be defined");
  const handles = [
    // start
  ];
  for (; hasAtLeast(bezierPoints, 3); ) {
    const [cp1, cp2, end, ...rest] = bezierPoints, bezier = new Bezier(start2[0], start2[1], cp1[0], cp1[1], cp2[0], cp2[1], end[0], end[1]), inflections = bezier.inflections();
    inflections.length === 0 && inflections.push(0.5), inflections.forEach((t2) => {
      const { x: x2, y: y2 } = bezier.get(t2);
      handles.push({
        x: Math.round(x2),
        y: Math.round(y2)
      });
    }), bezierPoints = rest, start2 = end;
  }
  return invariant$2(bezierPoints.length === 0, "all points should be consumed"), handles;
}
const isClose = (a2, b2) => Math.abs(a2 - b2) < 3.1;
function isSamePoint(a2, b2) {
  const [ax, ay] = o$1(a2) ? a2 : [a2.x, a2.y], [bx, by] = o$1(b2) ? b2 : [b2.x, b2.y];
  return isClose(ax, bx) && isClose(ay, by);
}
function stopPropagation$1(e2) {
  return e2.stopPropagation();
}
function centerXYInternalNode(nd) {
  const { width, height } = getNodeDimensions(nd);
  return {
    x: nd.internals.positionAbsolute.x + width / 2,
    y: nd.internals.positionAbsolute.y + height / 2
  };
}
function bezierPath(bezierSpline) {
  let [start2, ...points] = bezierSpline;
  invariant$2(start2, "start should be defined");
  let path = `M ${start2[0]},${start2[1]}`;
  for (; hasAtLeast(points, 3); ) {
    const [cp1, cp2, end, ...rest] = points;
    path = path + ` C ${cp1[0]},${cp1[1]} ${cp2[0]},${cp2[1]} ${end[0]},${end[1]}`, points = rest;
  }
  return invariant$2(points.length === 0, "all points should be consumed"), path;
}
function literalToEnum(value) {
  switch (value) {
    case "dots":
      return BackgroundVariant.Dots;
    case "lines":
      return BackgroundVariant.Lines;
    case "cross":
      return BackgroundVariant.Cross;
    default:
      nonexhaustive(value);
  }
}
function Background({ background }) {
  return typeof background == "string" ? /* @__PURE__ */ jsx(Background$1, { variant: literalToEnum(background), size: 2, gap: 20 }) : /* @__PURE__ */ jsx(Background$1, { ...background });
}
const ZIndexes = {
  Compound: 0,
  Edge: 2,
  Element: 2,
  Max: 8
}, MinZoom = 0.05, MaxZoom = 2;
var Base;
((Base2) => {
  const _setDimmed = (v, dimmed) => (v.data.dimmed ?? !1) === dimmed ? v : {
    ...v,
    data: {
      ...v.data,
      dimmed
    }
  };
  function setDimmed(arg1, arg2) {
    return arg2 !== void 0 ? _setDimmed(arg1, arg2) : (v) => _setDimmed(v, arg1);
  }
  Base2.setDimmed = setDimmed;
  const _setHovered = (v, hovered) => (v.data.hovered ?? !1) === hovered ? v : {
    ...v,
    data: {
      ...v.data,
      hovered
    }
  };
  function setHovered(arg1, arg2) {
    return arg2 !== void 0 ? _setHovered(arg1, arg2) : (v) => _setHovered(v, arg1);
  }
  Base2.setHovered = setHovered;
  function _setData(value, state) {
    return j(value.data, state) ? value : {
      ...value,
      data: {
        ...value.data,
        ...state
      }
    };
  }
  function setData(arg1, arg2) {
    return arg2 !== void 0 ? _setData(arg1, arg2) : (edge) => _setData(edge, arg1);
  }
  Base2.setData = setData;
})(Base || (Base = {}));
const cssTransparentBg = css({
  background: "transparent !important",
  "--xy-background-color": "transparent !important"
}), cssReactFlow = css({
  // '@supports': {
  //   // https://wojtek.im/journal/targeting-safari-with-css-media-query
  //   '(hanging-punctuation: first) and (font: -apple-system-body) and (-webkit-appearance: none)': {
  //     // TODO: this workaround disables animations in Safari (to improve performance)
  //     vars: {
  //       [vars.safariAnimationHook]: '',
  //     },
  //   },
  // },
  "--xy-background-color": "{colors.mantine.colors.body}",
  "--xy-background-pattern-color": {
    _dark: "{colors.mantine.colors.dark[5]}",
    _light: "{colors.mantine.colors.gray[4]}"
  },
  "& .react-flow__pane": {
    WebkitUserSelect: "none"
  },
  "& .react-flow__attribution": {
    display: "none"
  }
}), BaseXYFlow = ({
  nodes,
  edges,
  onEdgesChange,
  onNodesChange,
  className,
  pannable = !0,
  zoomable = !0,
  nodesSelectable = !0,
  nodesDraggable = !1,
  background = "dots",
  children: children2,
  colorMode = "system",
  fitViewPadding = 0,
  fitView = !0,
  zoomOnDoubleClick = !1,
  onViewportResize,
  onMoveEnd,
  ...props
}) => {
  const isBgWithPattern = background !== "transparent" && background !== "solid", isZoomTooSmall = useIsZoomTooSmall(), xystore = useXYStoreApi();
  return /* @__PURE__ */ jsxs(
    index,
    {
      colorMode,
      nodes,
      edges,
      className: cx(
        cssReactFlow,
        background === "transparent" && cssTransparentBg,
        className
      ),
      ...isZoomTooSmall && {
        "data-likec4-zoom-small": !0
      },
      zoomOnPinch: zoomable,
      zoomOnScroll: !pannable && zoomable,
      ...!zoomable && {
        zoomActivationKeyCode: null
      },
      zoomOnDoubleClick,
      maxZoom: zoomable ? MaxZoom : 1,
      minZoom: zoomable ? MinZoom : 1,
      fitView,
      fitViewOptions: useMemo(() => ({
        minZoom: MinZoom,
        maxZoom: 1,
        padding: fitViewPadding,
        includeHiddenNodes: !1
      }), [fitViewPadding]),
      preventScrolling: zoomable || pannable,
      defaultMarkerColor: "var(--xy-edge-stroke)",
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      panOnScroll: pannable,
      panOnDrag: pannable,
      ...!pannable && {
        panActivationKeyCode: null,
        selectionKeyCode: null
      },
      elementsSelectable: nodesSelectable,
      nodesFocusable: nodesDraggable || nodesSelectable,
      edgesFocusable: !1,
      nodesDraggable,
      nodeDragThreshold: 4,
      nodeClickDistance: 3,
      paneClickDistance: 3,
      elevateNodesOnSelect: !1,
      selectNodesOnDrag: !1,
      onNodesChange,
      onEdgesChange,
      onMoveEnd: useCallbackRef((event, { x: x2, y: y2, zoom: zoom2 }) => {
        const roundedX = Math.round(x2), roundedY = Math.round(y2);
        (x2 !== roundedX || y2 !== roundedY) && xystore.setState({ transform: [roundedX, roundedY, zoom2] }), onMoveEnd?.(event, { x: roundedX, y: roundedY, zoom: zoom2 });
      }),
      onNodeMouseEnter: useCallbackRef((_event, node2) => {
        node2.data.hovered || onNodesChange([{
          id: node2.id,
          type: "replace",
          item: Base.setHovered(node2, !0)
        }]);
      }),
      onNodeMouseLeave: useCallbackRef((_event, node2) => {
        node2.data.hovered && onNodesChange([{
          id: node2.id,
          type: "replace",
          item: Base.setHovered(node2, !1)
        }]);
      }),
      onEdgeMouseEnter: useCallbackRef((_event, edge) => {
        edge.data.hovered || onEdgesChange([{
          id: edge.id,
          type: "replace",
          item: Base.setHovered(edge, !0)
        }]);
      }),
      onEdgeMouseLeave: useCallbackRef((_event, edge) => {
        edge.data.hovered && onEdgesChange([{
          id: edge.id,
          type: "replace",
          item: Base.setHovered(edge, !1)
        }]);
      }),
      onNodeDoubleClick: stopPropagation$1,
      onEdgeDoubleClick: stopPropagation$1,
      ...props,
      children: [
        /* @__PURE__ */ jsxs(Fragment, { children: [
          isBgWithPattern && /* @__PURE__ */ jsx(Background, { background }),
          onViewportResize && /* @__PURE__ */ jsx(ViewportResizeHanlder, { onViewportResize })
        ] }, "_internals"),
        children2
      ]
    }
  );
}, selectDimensions = ({ width, height }) => (width || 1) * (height || 1), ViewportResizeHanlder = ({
  onViewportResize
}) => {
  const square = useStore$1(selectDimensions);
  return useUpdateEffect(onViewportResize, [square]), null;
};
var xstateReact_cjs = {}, xstate_cjs = {}, xstateActors_cjs = {}, raise60cebf03_cjs = {}, xstateDev_cjs = {}, hasRequiredXstateDev_cjs;
function requireXstateDev_cjs() {
  if (hasRequiredXstateDev_cjs) return xstateDev_cjs;
  hasRequiredXstateDev_cjs = 1, Object.defineProperty(xstateDev_cjs, "__esModule", { value: !0 });
  function getGlobal() {
    if (typeof globalThis < "u")
      return globalThis;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal < "u")
      return commonjsGlobal;
  }
  function getDevTools() {
    const w = getGlobal();
    if (w.__xstate__)
      return w.__xstate__;
  }
  function registerService(service) {
    if (typeof window > "u")
      return;
    const devTools = getDevTools();
    devTools && devTools.register(service);
  }
  const devToolsAdapter = (service) => {
    if (typeof window > "u")
      return;
    const devTools = getDevTools();
    devTools && devTools.register(service);
  };
  return xstateDev_cjs.devToolsAdapter = devToolsAdapter, xstateDev_cjs.getGlobal = getGlobal, xstateDev_cjs.registerService = registerService, xstateDev_cjs;
}
var hasRequiredRaise60cebf03_cjs;
function requireRaise60cebf03_cjs() {
  if (hasRequiredRaise60cebf03_cjs) return raise60cebf03_cjs;
  hasRequiredRaise60cebf03_cjs = 1;
  var dev_dist_xstateDev = requireXstateDev_cjs();
  class Mailbox {
    constructor(_process) {
      this._process = _process, this._active = !1, this._current = null, this._last = null;
    }
    start() {
      this._active = !0, this.flush();
    }
    clear() {
      this._current && (this._current.next = null, this._last = this._current);
    }
    enqueue(event) {
      const enqueued = {
        value: event,
        next: null
      };
      if (this._current) {
        this._last.next = enqueued, this._last = enqueued;
        return;
      }
      this._current = enqueued, this._last = enqueued, this._active && this.flush();
    }
    flush() {
      for (; this._current; ) {
        const consumed = this._current;
        this._process(consumed.value), this._current = consumed.next;
      }
      this._last = null;
    }
  }
  const STATE_DELIMITER = ".", TARGETLESS_KEY = "", NULL_EVENT = "", STATE_IDENTIFIER = "#", WILDCARD = "*", XSTATE_INIT = "xstate.init", XSTATE_ERROR = "xstate.error", XSTATE_STOP = "xstate.stop";
  function createAfterEvent(delayRef, id2) {
    return {
      type: `xstate.after.${delayRef}.${id2}`
    };
  }
  function createDoneStateEvent(id2, output) {
    return {
      type: `xstate.done.state.${id2}`,
      output
    };
  }
  function createDoneActorEvent(invokeId, output) {
    return {
      type: `xstate.done.actor.${invokeId}`,
      output,
      actorId: invokeId
    };
  }
  function createErrorActorEvent(id2, error) {
    return {
      type: `xstate.error.actor.${id2}`,
      error,
      actorId: id2
    };
  }
  function createInitEvent(input2) {
    return {
      type: XSTATE_INIT,
      input: input2
    };
  }
  function reportUnhandledError(err) {
    setTimeout(() => {
      throw err;
    });
  }
  const symbolObservable = typeof Symbol == "function" && Symbol.observable || "@@observable";
  function matchesState(parentStateId, childStateId) {
    const parentStateValue = toStateValue(parentStateId), childStateValue = toStateValue(childStateId);
    return typeof childStateValue == "string" ? typeof parentStateValue == "string" ? childStateValue === parentStateValue : !1 : typeof parentStateValue == "string" ? parentStateValue in childStateValue : Object.keys(parentStateValue).every((key2) => key2 in childStateValue ? matchesState(parentStateValue[key2], childStateValue[key2]) : !1);
  }
  function toStatePath(stateId) {
    if (isArray2(stateId))
      return stateId;
    const result = [];
    let segment = "";
    for (let i2 = 0; i2 < stateId.length; i2++) {
      switch (stateId.charCodeAt(i2)) {
        // \
        case 92:
          segment += stateId[i2 + 1], i2++;
          continue;
        // .
        case 46:
          result.push(segment), segment = "";
          continue;
      }
      segment += stateId[i2];
    }
    return result.push(segment), result;
  }
  function toStateValue(stateValue) {
    if (isMachineSnapshot(stateValue))
      return stateValue.value;
    if (typeof stateValue != "string")
      return stateValue;
    const statePath = toStatePath(stateValue);
    return pathToStateValue(statePath);
  }
  function pathToStateValue(statePath) {
    if (statePath.length === 1)
      return statePath[0];
    const value = {};
    let marker = value;
    for (let i2 = 0; i2 < statePath.length - 1; i2++)
      if (i2 === statePath.length - 2)
        marker[statePath[i2]] = statePath[i2 + 1];
      else {
        const previous = marker;
        marker = {}, previous[statePath[i2]] = marker;
      }
    return value;
  }
  function mapValues(collection, iteratee) {
    const result = {}, collectionKeys = Object.keys(collection);
    for (let i2 = 0; i2 < collectionKeys.length; i2++) {
      const key2 = collectionKeys[i2];
      result[key2] = iteratee(collection[key2], key2, collection, i2);
    }
    return result;
  }
  function toArrayStrict(value) {
    return isArray2(value) ? value : [value];
  }
  function toArray2(value) {
    return value === void 0 ? [] : toArrayStrict(value);
  }
  function resolveOutput(mapper, context2, event, self2) {
    return typeof mapper == "function" ? mapper({
      context: context2,
      event,
      self: self2
    }) : mapper;
  }
  function isArray2(value) {
    return Array.isArray(value);
  }
  function isErrorActorEvent(event) {
    return event.type.startsWith("xstate.error.actor");
  }
  function toTransitionConfigArray(configLike) {
    return toArrayStrict(configLike).map((transitionLike) => typeof transitionLike > "u" || typeof transitionLike == "string" ? {
      target: transitionLike
    } : transitionLike);
  }
  function normalizeTarget(target) {
    if (!(target === void 0 || target === TARGETLESS_KEY))
      return toArray2(target);
  }
  function toObserver(nextHandler, errorHandler, completionHandler) {
    const isObserver = typeof nextHandler == "object", self2 = isObserver ? nextHandler : void 0;
    return {
      next: (isObserver ? nextHandler.next : nextHandler)?.bind(self2),
      error: (isObserver ? nextHandler.error : errorHandler)?.bind(self2),
      complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self2)
    };
  }
  function createInvokeId(stateNodeId, index2) {
    return `${index2}.${stateNodeId}`;
  }
  function resolveReferencedActor(machine, src) {
    const match = src.match(/^xstate\.invoke\.(\d+)\.(.*)/);
    if (!match)
      return machine.implementations.actors[src];
    const [, indexStr, nodeId] = match, invokeConfig = machine.getStateNodeById(nodeId).config.invoke;
    return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;
  }
  function getAllOwnEventDescriptors(snapshot) {
    return [.../* @__PURE__ */ new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];
  }
  function createScheduledEventId(actorRef, id2) {
    return `${actorRef.sessionId}.${id2}`;
  }
  let idCounter2 = 0;
  function createSystem(rootActor, options) {
    const children2 = /* @__PURE__ */ new Map(), keyedActors = /* @__PURE__ */ new Map(), reverseKeyedActors = /* @__PURE__ */ new WeakMap(), inspectionObservers = /* @__PURE__ */ new Set(), timerMap = {}, {
      clock: clock2,
      logger
    } = options, scheduler = {
      schedule: (source, target, event, delay2, id2 = Math.random().toString(36).slice(2)) => {
        const scheduledEvent = {
          source,
          target,
          event,
          delay: delay2,
          id: id2,
          startedAt: Date.now()
        }, scheduledEventId = createScheduledEventId(source, id2);
        system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;
        const timeout2 = clock2.setTimeout(() => {
          delete timerMap[scheduledEventId], delete system._snapshot._scheduledEvents[scheduledEventId], system._relay(source, target, event);
        }, delay2);
        timerMap[scheduledEventId] = timeout2;
      },
      cancel: (source, id2) => {
        const scheduledEventId = createScheduledEventId(source, id2), timeout2 = timerMap[scheduledEventId];
        delete timerMap[scheduledEventId], delete system._snapshot._scheduledEvents[scheduledEventId], timeout2 !== void 0 && clock2.clearTimeout(timeout2);
      },
      cancelAll: (actorRef) => {
        for (const scheduledEventId in system._snapshot._scheduledEvents) {
          const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];
          scheduledEvent.source === actorRef && scheduler.cancel(actorRef, scheduledEvent.id);
        }
      }
    }, sendInspectionEvent = (event) => {
      if (!inspectionObservers.size)
        return;
      const resolvedInspectionEvent = {
        ...event,
        rootId: rootActor.sessionId
      };
      inspectionObservers.forEach((observer) => observer.next?.(resolvedInspectionEvent));
    }, system = {
      _snapshot: {
        _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}
      },
      _bookId: () => `x:${idCounter2++}`,
      _register: (sessionId, actorRef) => (children2.set(sessionId, actorRef), sessionId),
      _unregister: (actorRef) => {
        children2.delete(actorRef.sessionId);
        const systemId = reverseKeyedActors.get(actorRef);
        systemId !== void 0 && (keyedActors.delete(systemId), reverseKeyedActors.delete(actorRef));
      },
      get: (systemId) => keyedActors.get(systemId),
      _set: (systemId, actorRef) => {
        const existing = keyedActors.get(systemId);
        if (existing && existing !== actorRef)
          throw new Error(`Actor with system ID '${systemId}' already exists.`);
        keyedActors.set(systemId, actorRef), reverseKeyedActors.set(actorRef, systemId);
      },
      inspect: (observerOrFn) => {
        const observer = toObserver(observerOrFn);
        return inspectionObservers.add(observer), {
          unsubscribe() {
            inspectionObservers.delete(observer);
          }
        };
      },
      _sendInspectionEvent: sendInspectionEvent,
      _relay: (source, target, event) => {
        system._sendInspectionEvent({
          type: "@xstate.event",
          sourceRef: source,
          actorRef: target,
          event
        }), target._send(event);
      },
      scheduler,
      getSnapshot: () => ({
        _scheduledEvents: {
          ...system._snapshot._scheduledEvents
        }
      }),
      start: () => {
        const scheduledEvents = system._snapshot._scheduledEvents;
        system._snapshot._scheduledEvents = {};
        for (const scheduledId in scheduledEvents) {
          const {
            source,
            target,
            event,
            delay: delay2,
            id: id2
          } = scheduledEvents[scheduledId];
          scheduler.schedule(source, target, event, delay2, id2);
        }
      },
      _clock: clock2,
      _logger: logger
    };
    return system;
  }
  let executingCustomAction = !1;
  const $$ACTOR_TYPE = 1;
  let ProcessingStatus = /* @__PURE__ */ function(ProcessingStatus2) {
    return ProcessingStatus2[ProcessingStatus2.NotStarted = 0] = "NotStarted", ProcessingStatus2[ProcessingStatus2.Running = 1] = "Running", ProcessingStatus2[ProcessingStatus2.Stopped = 2] = "Stopped", ProcessingStatus2;
  }({});
  const defaultOptions2 = {
    clock: {
      setTimeout: (fn, ms) => setTimeout(fn, ms),
      clearTimeout: (id2) => clearTimeout(id2)
    },
    logger: console.log.bind(console),
    devTools: !1
  };
  class Actor {
    /**
     * Creates a new actor instance for the given logic with the provided options,
     * if any.
     *
     * @param logic The logic to create an actor from
     * @param options Actor options
     */
    constructor(logic, options) {
      this.logic = logic, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new Mailbox(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = ProcessingStatus.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this._systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
      const resolvedOptions = {
        ...defaultOptions2,
        ...options
      }, {
        clock: clock2,
        logger,
        parent,
        syncSnapshot,
        id: id2,
        systemId,
        inspect
      } = resolvedOptions;
      this.system = parent ? parent.system : createSystem(this, {
        clock: clock2,
        logger
      }), inspect && !parent && this.system.inspect(toObserver(inspect)), this.sessionId = this.system._bookId(), this.id = id2 ?? this.sessionId, this.logger = options?.logger ?? this.system._logger, this.clock = options?.clock ?? this.system._clock, this._parent = parent, this._syncSnapshot = syncSnapshot, this.options = resolvedOptions, this.src = resolvedOptions.src ?? logic, this.ref = this, this._actorScope = {
        self: this,
        id: this.id,
        sessionId: this.sessionId,
        logger: this.logger,
        defer: (fn) => {
          this._deferred.push(fn);
        },
        system: this.system,
        stopChild: (child) => {
          if (child._parent !== this)
            throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
          child._stop();
        },
        emit: (emittedEvent) => {
          const listeners = this.eventListeners.get(emittedEvent.type), wildcardListener = this.eventListeners.get("*");
          if (!listeners && !wildcardListener)
            return;
          const allListeners = [...listeners ? listeners.values() : [], ...wildcardListener ? wildcardListener.values() : []];
          for (const handler of allListeners)
            handler(emittedEvent);
        },
        actionExecutor: (action) => {
          const exec = () => {
            if (this._actorScope.system._sendInspectionEvent({
              type: "@xstate.action",
              actorRef: this,
              action: {
                type: action.type,
                params: action.params
              }
            }), !action.exec)
              return;
            const saveExecutingCustomAction = executingCustomAction;
            try {
              executingCustomAction = !0, action.exec(action.info, action.params);
            } finally {
              executingCustomAction = saveExecutingCustomAction;
            }
          };
          this._processingStatus === ProcessingStatus.Running ? exec() : this._deferred.push(exec);
        }
      }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
        type: "@xstate.actor",
        actorRef: this
      }), systemId && (this._systemId = systemId, this.system._set(systemId, this)), this._initState(options?.snapshot ?? options?.state), systemId && this._snapshot.status !== "active" && this.system._unregister(this);
    }
    _initState(persistedState) {
      try {
        this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);
      } catch (err) {
        this._snapshot = {
          status: "error",
          output: void 0,
          error: err
        };
      }
    }
    update(snapshot, event) {
      this._snapshot = snapshot;
      let deferredFn;
      for (; deferredFn = this._deferred.shift(); )
        try {
          deferredFn();
        } catch (err) {
          this._deferred.length = 0, this._snapshot = {
            ...snapshot,
            status: "error",
            error: err
          };
        }
      switch (this._snapshot.status) {
        case "active":
          for (const observer of this.observers)
            try {
              observer.next?.(snapshot);
            } catch (err) {
              reportUnhandledError(err);
            }
          break;
        case "done":
          for (const observer of this.observers)
            try {
              observer.next?.(snapshot);
            } catch (err) {
              reportUnhandledError(err);
            }
          this._stopProcedure(), this._complete(), this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
          break;
        case "error":
          this._error(this._snapshot.error);
          break;
      }
      this.system._sendInspectionEvent({
        type: "@xstate.snapshot",
        actorRef: this,
        event,
        snapshot
      });
    }
    /**
     * Subscribe an observer to an actors snapshot values.
     *
     * @remarks
     * The observer will receive the actors snapshot value when it is emitted.
     * The observer can be:
     *
     * - A plain function that receives the latest snapshot, or
     * - An observer object whose `.next(snapshot)` method receives the latest
     *   snapshot
     *
     * @example
     *
     * ```ts
     * // Observer as a plain function
     * const subscription = actor.subscribe((snapshot) => {
     *   console.log(snapshot);
     * });
     * ```
     *
     * @example
     *
     * ```ts
     * // Observer as an object
     * const subscription = actor.subscribe({
     *   next(snapshot) {
     *     console.log(snapshot);
     *   },
     *   error(err) {
     *     // ...
     *   },
     *   complete() {
     *     // ...
     *   }
     * });
     * ```
     *
     * The return value of `actor.subscribe(observer)` is a subscription object
     * that has an `.unsubscribe()` method. You can call
     * `subscription.unsubscribe()` to unsubscribe the observer:
     *
     * @example
     *
     * ```ts
     * const subscription = actor.subscribe((snapshot) => {
     *   // ...
     * });
     *
     * // Unsubscribe the observer
     * subscription.unsubscribe();
     * ```
     *
     * When the actor is stopped, all of its observers will automatically be
     * unsubscribed.
     *
     * @param observer - Either a plain function that receives the latest
     *   snapshot, or an observer object whose `.next(snapshot)` method receives
     *   the latest snapshot
     */
    subscribe(nextListenerOrObserver, errorListener, completeListener) {
      const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
      if (this._processingStatus !== ProcessingStatus.Stopped)
        this.observers.add(observer);
      else
        switch (this._snapshot.status) {
          case "done":
            try {
              observer.complete?.();
            } catch (err) {
              reportUnhandledError(err);
            }
            break;
          case "error": {
            const err = this._snapshot.error;
            if (!observer.error)
              reportUnhandledError(err);
            else
              try {
                observer.error(err);
              } catch (err2) {
                reportUnhandledError(err2);
              }
            break;
          }
        }
      return {
        unsubscribe: () => {
          this.observers.delete(observer);
        }
      };
    }
    on(type, handler) {
      let listeners = this.eventListeners.get(type);
      listeners || (listeners = /* @__PURE__ */ new Set(), this.eventListeners.set(type, listeners));
      const wrappedHandler = handler.bind(void 0);
      return listeners.add(wrappedHandler), {
        unsubscribe: () => {
          listeners.delete(wrappedHandler);
        }
      };
    }
    /** Starts the Actor from the initial state */
    start() {
      if (this._processingStatus === ProcessingStatus.Running)
        return this;
      this._syncSnapshot && this.subscribe({
        next: (snapshot) => {
          snapshot.status === "active" && this.system._relay(this, this._parent, {
            type: `xstate.snapshot.${this.id}`,
            snapshot
          });
        },
        error: () => {
        }
      }), this.system._register(this.sessionId, this), this._systemId && this.system._set(this._systemId, this), this._processingStatus = ProcessingStatus.Running;
      const initEvent = createInitEvent(this.options.input);
      switch (this.system._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: this._parent,
        actorRef: this,
        event: initEvent
      }), this._snapshot.status) {
        case "done":
          return this.update(this._snapshot, initEvent), this;
        case "error":
          return this._error(this._snapshot.error), this;
      }
      if (this._parent || this.system.start(), this.logic.start)
        try {
          this.logic.start(this._snapshot, this._actorScope);
        } catch (err) {
          return this._snapshot = {
            ...this._snapshot,
            status: "error",
            error: err
          }, this._error(err), this;
        }
      return this.update(this._snapshot, initEvent), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
    }
    _process(event) {
      let nextState, caughtError;
      try {
        nextState = this.logic.transition(this._snapshot, event, this._actorScope);
      } catch (err) {
        caughtError = {
          err
        };
      }
      if (caughtError) {
        const {
          err
        } = caughtError;
        this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: err
        }, this._error(err);
        return;
      }
      this.update(nextState, event), event.type === XSTATE_STOP && (this._stopProcedure(), this._complete());
    }
    _stop() {
      return this._processingStatus === ProcessingStatus.Stopped ? this : (this.mailbox.clear(), this._processingStatus === ProcessingStatus.NotStarted ? (this._processingStatus = ProcessingStatus.Stopped, this) : (this.mailbox.enqueue({
        type: XSTATE_STOP
      }), this));
    }
    /** Stops the Actor and unsubscribe all listeners. */
    stop() {
      if (this._parent)
        throw new Error("A non-root actor cannot be stopped directly.");
      return this._stop();
    }
    _complete() {
      for (const observer of this.observers)
        try {
          observer.complete?.();
        } catch (err) {
          reportUnhandledError(err);
        }
      this.observers.clear();
    }
    _reportError(err) {
      if (!this.observers.size) {
        this._parent || reportUnhandledError(err);
        return;
      }
      let reportError = !1;
      for (const observer of this.observers) {
        const errorListener = observer.error;
        reportError ||= !errorListener;
        try {
          errorListener?.(err);
        } catch (err2) {
          reportUnhandledError(err2);
        }
      }
      this.observers.clear(), reportError && reportUnhandledError(err);
    }
    _error(err) {
      this._stopProcedure(), this._reportError(err), this._parent && this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));
    }
    // TODO: atm children don't belong entirely to the actor so
    // in a way - it's not even super aware of them
    // so we can't stop them from here but we really should!
    // right now, they are being stopped within the machine's transition
    // but that could throw and leave us with "orphaned" active actors
    _stopProcedure() {
      return this._processingStatus !== ProcessingStatus.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new Mailbox(this._process.bind(this)), this._processingStatus = ProcessingStatus.Stopped, this.system._unregister(this), this);
    }
    /** @internal */
    _send(event) {
      this._processingStatus !== ProcessingStatus.Stopped && this.mailbox.enqueue(event);
    }
    /**
     * Sends an event to the running Actor to trigger a transition.
     *
     * @param event The event to send
     */
    send(event) {
      this.system._relay(void 0, this, event);
    }
    attachDevTools() {
      const {
        devTools
      } = this.options;
      devTools && (typeof devTools == "function" ? devTools : dev_dist_xstateDev.devToolsAdapter)(this);
    }
    toJSON() {
      return {
        xstate$$type: $$ACTOR_TYPE,
        id: this.id
      };
    }
    /**
     * Obtain the internal state of the actor, which can be persisted.
     *
     * @remarks
     * The internal state can be persisted from any actor, not only machines.
     *
     * Note that the persisted state is not the same as the snapshot from
     * {@link Actor.getSnapshot}. Persisted state represents the internal state of
     * the actor, while snapshots represent the actor's last emitted value.
     *
     * Can be restored with {@link ActorOptions.state}
     * @see https://stately.ai/docs/persistence
     */
    getPersistedSnapshot(options) {
      return this.logic.getPersistedSnapshot(this._snapshot, options);
    }
    [symbolObservable]() {
      return this;
    }
    /**
     * Read an actors snapshot synchronously.
     *
     * @remarks
     * The snapshot represent an actor's last emitted value.
     *
     * When an actor receives an event, its internal state may change. An actor
     * may emit a snapshot when a state transition occurs.
     *
     * Note that some actors, such as callback actors generated with
     * `fromCallback`, will not emit snapshots.
     * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
     * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
     */
    getSnapshot() {
      return this._snapshot;
    }
  }
  function createActor(logic, ...[options]) {
    return new Actor(logic, options);
  }
  const interpret = createActor;
  function resolveCancel(_, snapshot, actionArgs, actionParams, {
    sendId
  }) {
    const resolvedSendId = typeof sendId == "function" ? sendId(actionArgs, actionParams) : sendId;
    return [snapshot, {
      sendId: resolvedSendId
    }, void 0];
  }
  function executeCancel(actorScope, params) {
    actorScope.defer(() => {
      actorScope.system.scheduler.cancel(actorScope.self, params.sendId);
    });
  }
  function cancel(sendId) {
    function cancel2(_args, _params) {
    }
    return cancel2.type = "xstate.cancel", cancel2.sendId = sendId, cancel2.resolve = resolveCancel, cancel2.execute = executeCancel, cancel2;
  }
  function resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {
    id: id2,
    systemId,
    src,
    input: input2,
    syncSnapshot
  }) {
    const logic = typeof src == "string" ? resolveReferencedActor(snapshot.machine, src) : src, resolvedId = typeof id2 == "function" ? id2(actionArgs) : id2;
    let actorRef, resolvedInput;
    return logic && (resolvedInput = typeof input2 == "function" ? input2({
      context: snapshot.context,
      event: actionArgs.event,
      self: actorScope.self
    }) : input2, actorRef = createActor(logic, {
      id: resolvedId,
      src,
      parent: actorScope.self,
      syncSnapshot,
      systemId,
      input: resolvedInput
    })), [cloneMachineSnapshot(snapshot, {
      children: {
        ...snapshot.children,
        [resolvedId]: actorRef
      }
    }), {
      id: id2,
      systemId,
      actorRef,
      src,
      input: resolvedInput
    }, void 0];
  }
  function executeSpawn(actorScope, {
    actorRef
  }) {
    actorRef && actorScope.defer(() => {
      actorRef._processingStatus !== ProcessingStatus.Stopped && actorRef.start();
    });
  }
  function spawnChild(...[src, {
    id: id2,
    systemId,
    input: input2,
    syncSnapshot = !1
  } = {}]) {
    function spawnChild2(_args, _params) {
    }
    return spawnChild2.type = "xstate.spawnChild", spawnChild2.id = id2, spawnChild2.systemId = systemId, spawnChild2.src = src, spawnChild2.input = input2, spawnChild2.syncSnapshot = syncSnapshot, spawnChild2.resolve = resolveSpawn, spawnChild2.execute = executeSpawn, spawnChild2;
  }
  function resolveStop(_, snapshot, args, actionParams, {
    actorRef
  }) {
    const actorRefOrString = typeof actorRef == "function" ? actorRef(args, actionParams) : actorRef, resolvedActorRef = typeof actorRefOrString == "string" ? snapshot.children[actorRefOrString] : actorRefOrString;
    let children2 = snapshot.children;
    return resolvedActorRef && (children2 = {
      ...children2
    }, delete children2[resolvedActorRef.id]), [cloneMachineSnapshot(snapshot, {
      children: children2
    }), resolvedActorRef, void 0];
  }
  function executeStop(actorScope, actorRef) {
    if (actorRef) {
      if (actorScope.system._unregister(actorRef), actorRef._processingStatus !== ProcessingStatus.Running) {
        actorScope.stopChild(actorRef);
        return;
      }
      actorScope.defer(() => {
        actorScope.stopChild(actorRef);
      });
    }
  }
  function stopChild(actorRef) {
    function stop2(_args, _params) {
    }
    return stop2.type = "xstate.stopChild", stop2.actorRef = actorRef, stop2.resolve = resolveStop, stop2.execute = executeStop, stop2;
  }
  const stop = stopChild;
  function checkStateIn(snapshot, _, {
    stateValue
  }) {
    if (typeof stateValue == "string" && isStateId(stateValue)) {
      const target = snapshot.machine.getStateNodeById(stateValue);
      return snapshot._nodes.some((sn) => sn === target);
    }
    return snapshot.matches(stateValue);
  }
  function stateIn(stateValue) {
    function stateIn2() {
      return !1;
    }
    return stateIn2.check = checkStateIn, stateIn2.stateValue = stateValue, stateIn2;
  }
  function checkNot(snapshot, {
    context: context2,
    event
  }, {
    guards
  }) {
    return !evaluateGuard(guards[0], context2, event, snapshot);
  }
  function not(guard) {
    function not2(_args, _params) {
      return !1;
    }
    return not2.check = checkNot, not2.guards = [guard], not2;
  }
  function checkAnd(snapshot, {
    context: context2,
    event
  }, {
    guards
  }) {
    return guards.every((guard) => evaluateGuard(guard, context2, event, snapshot));
  }
  function and(guards) {
    function and2(_args, _params) {
      return !1;
    }
    return and2.check = checkAnd, and2.guards = guards, and2;
  }
  function checkOr(snapshot, {
    context: context2,
    event
  }, {
    guards
  }) {
    return guards.some((guard) => evaluateGuard(guard, context2, event, snapshot));
  }
  function or(guards) {
    function or2(_args, _params) {
      return !1;
    }
    return or2.check = checkOr, or2.guards = guards, or2;
  }
  function evaluateGuard(guard, context2, event, snapshot) {
    const {
      machine
    } = snapshot, isInline = typeof guard == "function", resolved = isInline ? guard : machine.implementations.guards[typeof guard == "string" ? guard : guard.type];
    if (!isInline && !resolved)
      throw new Error(`Guard '${typeof guard == "string" ? guard : guard.type}' is not implemented.'.`);
    if (typeof resolved != "function")
      return evaluateGuard(resolved, context2, event, snapshot);
    const guardArgs = {
      context: context2,
      event
    }, guardParams = isInline || typeof guard == "string" ? void 0 : "params" in guard ? typeof guard.params == "function" ? guard.params({
      context: context2,
      event
    }) : guard.params : void 0;
    return "check" in resolved ? resolved.check(
      snapshot,
      guardArgs,
      resolved
      // this holds all params
    ) : resolved(guardArgs, guardParams);
  }
  const isAtomicStateNode = (stateNode) => stateNode.type === "atomic" || stateNode.type === "final";
  function getChildren2(stateNode) {
    return Object.values(stateNode.states).filter((sn) => sn.type !== "history");
  }
  function getProperAncestors(stateNode, toStateNode) {
    const ancestors = [];
    if (toStateNode === stateNode)
      return ancestors;
    let m2 = stateNode.parent;
    for (; m2 && m2 !== toStateNode; )
      ancestors.push(m2), m2 = m2.parent;
    return ancestors;
  }
  function getAllStateNodes(stateNodes) {
    const nodeSet = new Set(stateNodes), adjList = getAdjList(nodeSet);
    for (const s2 of nodeSet)
      if (s2.type === "compound" && (!adjList.get(s2) || !adjList.get(s2).length))
        getInitialStateNodesWithTheirAncestors(s2).forEach((sn) => nodeSet.add(sn));
      else if (s2.type === "parallel") {
        for (const child of getChildren2(s2))
          if (child.type !== "history" && !nodeSet.has(child)) {
            const initialStates = getInitialStateNodesWithTheirAncestors(child);
            for (const initialStateNode of initialStates)
              nodeSet.add(initialStateNode);
          }
      }
    for (const s2 of nodeSet) {
      let m2 = s2.parent;
      for (; m2; )
        nodeSet.add(m2), m2 = m2.parent;
    }
    return nodeSet;
  }
  function getValueFromAdj(baseNode, adjList) {
    const childStateNodes = adjList.get(baseNode);
    if (!childStateNodes)
      return {};
    if (baseNode.type === "compound") {
      const childStateNode = childStateNodes[0];
      if (childStateNode) {
        if (isAtomicStateNode(childStateNode))
          return childStateNode.key;
      } else
        return {};
    }
    const stateValue = {};
    for (const childStateNode of childStateNodes)
      stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
    return stateValue;
  }
  function getAdjList(stateNodes) {
    const adjList = /* @__PURE__ */ new Map();
    for (const s2 of stateNodes)
      adjList.has(s2) || adjList.set(s2, []), s2.parent && (adjList.has(s2.parent) || adjList.set(s2.parent, []), adjList.get(s2.parent).push(s2));
    return adjList;
  }
  function getStateValue(rootNode, stateNodes) {
    const config = getAllStateNodes(stateNodes);
    return getValueFromAdj(rootNode, getAdjList(config));
  }
  function isInFinalState(stateNodeSet, stateNode) {
    return stateNode.type === "compound" ? getChildren2(stateNode).some((s2) => s2.type === "final" && stateNodeSet.has(s2)) : stateNode.type === "parallel" ? getChildren2(stateNode).every((sn) => isInFinalState(stateNodeSet, sn)) : stateNode.type === "final";
  }
  const isStateId = (str) => str[0] === STATE_IDENTIFIER;
  function getCandidates(stateNode, receivedEventType) {
    return stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter((eventDescriptor) => {
      if (eventDescriptor === WILDCARD)
        return !0;
      if (!eventDescriptor.endsWith(".*"))
        return !1;
      const partialEventTokens = eventDescriptor.split("."), eventTokens = receivedEventType.split(".");
      for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {
        const partialEventToken = partialEventTokens[tokenIndex], eventToken = eventTokens[tokenIndex];
        if (partialEventToken === "*")
          return tokenIndex === partialEventTokens.length - 1;
        if (partialEventToken !== eventToken)
          return !1;
      }
      return !0;
    }).sort((a2, b2) => b2.length - a2.length).flatMap((key2) => stateNode.transitions.get(key2));
  }
  function getDelayedTransitions(stateNode) {
    const afterConfig = stateNode.config.after;
    if (!afterConfig)
      return [];
    const mutateEntryExit = (delay2) => {
      const afterEvent = createAfterEvent(delay2, stateNode.id), eventType = afterEvent.type;
      return stateNode.entry.push(raise2(afterEvent, {
        id: eventType,
        delay: delay2
      })), stateNode.exit.push(cancel(eventType)), eventType;
    };
    return Object.keys(afterConfig).flatMap((delay2) => {
      const configTransition = afterConfig[delay2], resolvedTransition = typeof configTransition == "string" ? {
        target: configTransition
      } : configTransition, resolvedDelay = Number.isNaN(+delay2) ? delay2 : +delay2, eventType = mutateEntryExit(resolvedDelay);
      return toArray2(resolvedTransition).map((transition) => ({
        ...transition,
        event: eventType,
        delay: resolvedDelay
      }));
    }).map((delayedTransition) => {
      const {
        delay: delay2
      } = delayedTransition;
      return {
        ...formatTransition(stateNode, delayedTransition.event, delayedTransition),
        delay: delay2
      };
    });
  }
  function formatTransition(stateNode, descriptor, transitionConfig) {
    const normalizedTarget = normalizeTarget(transitionConfig.target), reenter = transitionConfig.reenter ?? !1, target = resolveTarget(stateNode, normalizedTarget), transition = {
      ...transitionConfig,
      actions: toArray2(transitionConfig.actions),
      guard: transitionConfig.guard,
      target,
      source: stateNode,
      reenter,
      eventType: descriptor,
      toJSON: () => ({
        ...transition,
        source: `#${stateNode.id}`,
        target: target ? target.map((t2) => `#${t2.id}`) : void 0
      })
    };
    return transition;
  }
  function formatTransitions(stateNode) {
    const transitions2 = /* @__PURE__ */ new Map();
    if (stateNode.config.on)
      for (const descriptor of Object.keys(stateNode.config.on)) {
        if (descriptor === NULL_EVENT)
          throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
        const transitionsConfig = stateNode.config.on[descriptor];
        transitions2.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t2) => formatTransition(stateNode, descriptor, t2)));
      }
    if (stateNode.config.onDone) {
      const descriptor = `xstate.done.state.${stateNode.id}`;
      transitions2.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
    for (const invokeDef of stateNode.invoke) {
      if (invokeDef.onDone) {
        const descriptor = `xstate.done.actor.${invokeDef.id}`;
        transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t2) => formatTransition(stateNode, descriptor, t2)));
      }
      if (invokeDef.onError) {
        const descriptor = `xstate.error.actor.${invokeDef.id}`;
        transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t2) => formatTransition(stateNode, descriptor, t2)));
      }
      if (invokeDef.onSnapshot) {
        const descriptor = `xstate.snapshot.${invokeDef.id}`;
        transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t2) => formatTransition(stateNode, descriptor, t2)));
      }
    }
    for (const delayedTransition of stateNode.after) {
      let existing = transitions2.get(delayedTransition.eventType);
      existing || (existing = [], transitions2.set(delayedTransition.eventType, existing)), existing.push(delayedTransition);
    }
    return transitions2;
  }
  function formatInitialTransition(stateNode, _target) {
    const resolvedTarget = typeof _target == "string" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : void 0;
    if (!resolvedTarget && _target)
      throw new Error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
        `Initial state node "${_target}" not found on parent state node #${stateNode.id}`
      );
    const transition = {
      source: stateNode,
      actions: !_target || typeof _target == "string" ? [] : toArray2(_target.actions),
      eventType: null,
      reenter: !1,
      target: resolvedTarget ? [resolvedTarget] : [],
      toJSON: () => ({
        ...transition,
        source: `#${stateNode.id}`,
        target: resolvedTarget ? [`#${resolvedTarget.id}`] : []
      })
    };
    return transition;
  }
  function resolveTarget(stateNode, targets) {
    if (targets !== void 0)
      return targets.map((target) => {
        if (typeof target != "string")
          return target;
        if (isStateId(target))
          return stateNode.machine.getStateNodeById(target);
        const isInternalTarget = target[0] === STATE_DELIMITER;
        if (isInternalTarget && !stateNode.parent)
          return getStateNodeByPath(stateNode, target.slice(1));
        const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
        if (stateNode.parent)
          try {
            return getStateNodeByPath(stateNode.parent, resolvedTarget);
          } catch (err) {
            throw new Error(`Invalid transition definition for state node '${stateNode.id}':
${err.message}`);
          }
        else
          throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
      });
  }
  function resolveHistoryDefaultTransition(stateNode) {
    const normalizedTarget = normalizeTarget(stateNode.config.target);
    return normalizedTarget ? {
      target: normalizedTarget.map((t2) => typeof t2 == "string" ? getStateNodeByPath(stateNode.parent, t2) : t2)
    } : stateNode.parent.initial;
  }
  function isHistoryNode(stateNode) {
    return stateNode.type === "history";
  }
  function getInitialStateNodesWithTheirAncestors(stateNode) {
    const states = getInitialStateNodes(stateNode);
    for (const initialState of states)
      for (const ancestor of getProperAncestors(initialState, stateNode))
        states.add(ancestor);
    return states;
  }
  function getInitialStateNodes(stateNode) {
    const set2 = /* @__PURE__ */ new Set();
    function iter(descStateNode) {
      if (!set2.has(descStateNode)) {
        if (set2.add(descStateNode), descStateNode.type === "compound")
          iter(descStateNode.initial.target[0]);
        else if (descStateNode.type === "parallel")
          for (const child of getChildren2(descStateNode))
            iter(child);
      }
    }
    return iter(stateNode), set2;
  }
  function getStateNode(stateNode, stateKey) {
    if (isStateId(stateKey))
      return stateNode.machine.getStateNodeById(stateKey);
    if (!stateNode.states)
      throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
    const result = stateNode.states[stateKey];
    if (!result)
      throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
    return result;
  }
  function getStateNodeByPath(stateNode, statePath) {
    if (typeof statePath == "string" && isStateId(statePath))
      try {
        return stateNode.machine.getStateNodeById(statePath);
      } catch {
      }
    const arrayStatePath = toStatePath(statePath).slice();
    let currentStateNode = stateNode;
    for (; arrayStatePath.length; ) {
      const key2 = arrayStatePath.shift();
      if (!key2.length)
        break;
      currentStateNode = getStateNode(currentStateNode, key2);
    }
    return currentStateNode;
  }
  function getStateNodes(stateNode, stateValue) {
    if (typeof stateValue == "string") {
      const childStateNode = stateNode.states[stateValue];
      if (!childStateNode)
        throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);
      return [stateNode, childStateNode];
    }
    const childStateKeys = Object.keys(stateValue), childStateNodes = childStateKeys.map((subStateKey) => getStateNode(stateNode, subStateKey)).filter(Boolean);
    return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {
      const subStateNode = getStateNode(stateNode, subStateKey);
      if (!subStateNode)
        return allSubStateNodes;
      const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
      return allSubStateNodes.concat(subStateNodes);
    }, []));
  }
  function transitionAtomicNode(stateNode, stateValue, snapshot, event) {
    const next = getStateNode(stateNode, stateValue).next(snapshot, event);
    return !next || !next.length ? stateNode.next(snapshot, event) : next;
  }
  function transitionCompoundNode(stateNode, stateValue, snapshot, event) {
    const subStateKeys = Object.keys(stateValue), childStateNode = getStateNode(stateNode, subStateKeys[0]), next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);
    return !next || !next.length ? stateNode.next(snapshot, event) : next;
  }
  function transitionParallelNode(stateNode, stateValue, snapshot, event) {
    const allInnerTransitions = [];
    for (const subStateKey of Object.keys(stateValue)) {
      const subStateValue = stateValue[subStateKey];
      if (!subStateValue)
        continue;
      const subStateNode = getStateNode(stateNode, subStateKey), innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);
      innerTransitions && allInnerTransitions.push(...innerTransitions);
    }
    return allInnerTransitions.length ? allInnerTransitions : stateNode.next(snapshot, event);
  }
  function transitionNode(stateNode, stateValue, snapshot, event) {
    return typeof stateValue == "string" ? transitionAtomicNode(stateNode, stateValue, snapshot, event) : Object.keys(stateValue).length === 1 ? transitionCompoundNode(stateNode, stateValue, snapshot, event) : transitionParallelNode(stateNode, stateValue, snapshot, event);
  }
  function getHistoryNodes(stateNode) {
    return Object.keys(stateNode.states).map((key2) => stateNode.states[key2]).filter((sn) => sn.type === "history");
  }
  function isDescendant(childStateNode, parentStateNode) {
    let marker = childStateNode;
    for (; marker.parent && marker.parent !== parentStateNode; )
      marker = marker.parent;
    return marker.parent === parentStateNode;
  }
  function hasIntersection(s1, s2) {
    const set1 = new Set(s1), set2 = new Set(s2);
    for (const item of set1)
      if (set2.has(item))
        return !0;
    for (const item of set2)
      if (set1.has(item))
        return !0;
    return !1;
  }
  function removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {
    const filteredTransitions = /* @__PURE__ */ new Set();
    for (const t1 of enabledTransitions) {
      let t1Preempted = !1;
      const transitionsToRemove = /* @__PURE__ */ new Set();
      for (const t2 of filteredTransitions)
        if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t2], stateNodeSet, historyValue)))
          if (isDescendant(t1.source, t2.source))
            transitionsToRemove.add(t2);
          else {
            t1Preempted = !0;
            break;
          }
      if (!t1Preempted) {
        for (const t3 of transitionsToRemove)
          filteredTransitions.delete(t3);
        filteredTransitions.add(t1);
      }
    }
    return Array.from(filteredTransitions);
  }
  function findLeastCommonAncestor(stateNodes) {
    const [head, ...tail] = stateNodes;
    for (const ancestor of getProperAncestors(head, void 0))
      if (tail.every((sn) => isDescendant(sn, ancestor)))
        return ancestor;
  }
  function getEffectiveTargetStates(transition, historyValue) {
    if (!transition.target)
      return [];
    const targets = /* @__PURE__ */ new Set();
    for (const targetNode of transition.target)
      if (isHistoryNode(targetNode))
        if (historyValue[targetNode.id])
          for (const node2 of historyValue[targetNode.id])
            targets.add(node2);
        else
          for (const node2 of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue))
            targets.add(node2);
      else
        targets.add(targetNode);
    return [...targets];
  }
  function getTransitionDomain(transition, historyValue) {
    const targetStates = getEffectiveTargetStates(transition, historyValue);
    if (!targetStates)
      return;
    if (!transition.reenter && targetStates.every((target) => target === transition.source || isDescendant(target, transition.source)))
      return transition.source;
    const lca = findLeastCommonAncestor(targetStates.concat(transition.source));
    if (lca)
      return lca;
    if (!transition.reenter)
      return transition.source.machine.root;
  }
  function computeExitSet(transitions2, stateNodeSet, historyValue) {
    const statesToExit = /* @__PURE__ */ new Set();
    for (const t2 of transitions2)
      if (t2.target?.length) {
        const domain = getTransitionDomain(t2, historyValue);
        t2.reenter && t2.source === domain && statesToExit.add(domain);
        for (const stateNode of stateNodeSet)
          isDescendant(stateNode, domain) && statesToExit.add(stateNode);
      }
    return [...statesToExit];
  }
  function areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {
    if (prevStateNodes.length !== nextStateNodeSet.size)
      return !1;
    for (const node2 of prevStateNodes)
      if (!nextStateNodeSet.has(node2))
        return !1;
    return !0;
  }
  function microstep(transitions2, currentSnapshot, actorScope, event, isInitial, internalQueue) {
    if (!transitions2.length)
      return currentSnapshot;
    const mutStateNodeSet = new Set(currentSnapshot._nodes);
    let historyValue = currentSnapshot.historyValue;
    const filteredTransitions = removeConflictingTransitions(transitions2, mutStateNodeSet, historyValue);
    let nextState = currentSnapshot;
    isInitial || ([nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor)), nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap((t2) => t2.actions), internalQueue, void 0), nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);
    const nextStateNodes = [...mutStateNodeSet];
    nextState.status === "done" && (nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a2, b2) => b2.order - a2.order).flatMap((state) => state.exit), internalQueue, void 0));
    try {
      return historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet) ? nextState : cloneMachineSnapshot(nextState, {
        _nodes: nextStateNodes,
        historyValue
      });
    } catch (e2) {
      throw e2;
    }
  }
  function getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {
    if (rootNode.output === void 0)
      return;
    const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== void 0 && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : void 0);
    return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);
  }
  function enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {
    let nextSnapshot = currentSnapshot;
    const statesToEnter = /* @__PURE__ */ new Set(), statesForDefaultEntry = /* @__PURE__ */ new Set();
    computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter), isInitial && statesForDefaultEntry.add(currentSnapshot.machine.root);
    const completedNodes = /* @__PURE__ */ new Set();
    for (const stateNodeToEnter of [...statesToEnter].sort((a2, b2) => a2.order - b2.order)) {
      mutStateNodeSet.add(stateNodeToEnter);
      const actions = [];
      actions.push(...stateNodeToEnter.entry);
      for (const invokeDef of stateNodeToEnter.invoke)
        actions.push(spawnChild(invokeDef.src, {
          ...invokeDef,
          syncSnapshot: !!invokeDef.onSnapshot
        }));
      if (statesForDefaultEntry.has(stateNodeToEnter)) {
        const initialActions = stateNodeToEnter.initial.actions;
        actions.push(...initialActions);
      }
      if (nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)), stateNodeToEnter.type === "final") {
        const parent = stateNodeToEnter.parent;
        let ancestorMarker = parent?.type === "parallel" ? parent : parent?.parent, rootCompletionNode = ancestorMarker || stateNodeToEnter;
        for (parent?.type === "compound" && internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== void 0 ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : void 0)); ancestorMarker?.type === "parallel" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker); )
          completedNodes.add(ancestorMarker), internalQueue.push(createDoneStateEvent(ancestorMarker.id)), rootCompletionNode = ancestorMarker, ancestorMarker = ancestorMarker.parent;
        if (ancestorMarker)
          continue;
        nextSnapshot = cloneMachineSnapshot(nextSnapshot, {
          status: "done",
          output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)
        });
      }
    }
    return nextSnapshot;
  }
  function computeEntrySet(transitions2, historyValue, statesForDefaultEntry, statesToEnter) {
    for (const t2 of transitions2) {
      const domain = getTransitionDomain(t2, historyValue);
      for (const s2 of t2.target || [])
        !isHistoryNode(s2) && // if the target is different than the source then it will *definitely* be entered
        (t2.source !== s2 || // we know that the domain can't lie within the source
        // if it's different than the source then it's outside of it and it means that the target has to be entered as well
        t2.source !== domain || // reentering transitions always enter the target, even if it's the source itself
        t2.reenter) && (statesToEnter.add(s2), statesForDefaultEntry.add(s2)), addDescendantStatesToEnter(s2, historyValue, statesForDefaultEntry, statesToEnter);
      const targetStates = getEffectiveTargetStates(t2, historyValue);
      for (const s2 of targetStates) {
        const ancestors = getProperAncestors(s2, domain);
        domain?.type === "parallel" && ancestors.push(domain), addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t2.source.parent && t2.reenter ? void 0 : domain);
      }
    }
  }
  function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
    if (isHistoryNode(stateNode))
      if (historyValue[stateNode.id]) {
        const historyStateNodes = historyValue[stateNode.id];
        for (const s2 of historyStateNodes)
          statesToEnter.add(s2), addDescendantStatesToEnter(s2, historyValue, statesForDefaultEntry, statesToEnter);
        for (const s2 of historyStateNodes)
          addProperAncestorStatesToEnter(s2, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      } else {
        const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);
        for (const s2 of historyDefaultTransition.target)
          statesToEnter.add(s2), historyDefaultTransition === stateNode.parent?.initial && statesForDefaultEntry.add(stateNode.parent), addDescendantStatesToEnter(s2, historyValue, statesForDefaultEntry, statesToEnter);
        for (const s2 of historyDefaultTransition.target)
          addProperAncestorStatesToEnter(s2, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      }
    else if (stateNode.type === "compound") {
      const [initialState] = stateNode.initial.target;
      isHistoryNode(initialState) || (statesToEnter.add(initialState), statesForDefaultEntry.add(initialState)), addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter), addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
    } else if (stateNode.type === "parallel")
      for (const child of getChildren2(stateNode).filter((sn) => !isHistoryNode(sn)))
        [...statesToEnter].some((s2) => isDescendant(s2, child)) || (isHistoryNode(child) || (statesToEnter.add(child), statesForDefaultEntry.add(child)), addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter));
  }
  function addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {
    for (const anc of ancestors)
      if ((!reentrancyDomain || isDescendant(anc, reentrancyDomain)) && statesToEnter.add(anc), anc.type === "parallel")
        for (const child of getChildren2(anc).filter((sn) => !isHistoryNode(sn)))
          [...statesToEnter].some((s2) => isDescendant(s2, child)) || (statesToEnter.add(child), addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter));
  }
  function addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
    addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));
  }
  function exitStates(currentSnapshot, event, actorScope, transitions2, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {
    let nextSnapshot = currentSnapshot;
    const statesToExit = computeExitSet(transitions2, mutStateNodeSet, historyValue);
    statesToExit.sort((a2, b2) => b2.order - a2.order);
    let changedHistory;
    for (const exitStateNode of statesToExit)
      for (const historyNode of getHistoryNodes(exitStateNode)) {
        let predicate;
        historyNode.history === "deep" ? predicate = (sn) => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode) : predicate = (sn) => sn.parent === exitStateNode, changedHistory ??= {
          ...historyValue
        }, changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);
      }
    for (const s2 of statesToExit)
      nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s2.exit, ...s2.invoke.map((def) => stopChild(def.id))], internalQueue, void 0), mutStateNodeSet.delete(s2);
    return [nextSnapshot, changedHistory || historyValue];
  }
  function getAction(machine, actionType) {
    return machine.implementations.actions[actionType];
  }
  function resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {
    const {
      machine
    } = currentSnapshot;
    let intermediateSnapshot = currentSnapshot;
    for (const action of actions) {
      const isInline = typeof action == "function", resolvedAction = isInline ? action : (
        // the existing type of `.actions` assumes non-nullable `TExpressionAction`
        // it's fine to cast this here to get a common type and lack of errors in the rest of the code
        // our logic below makes sure that we call those 2 "variants" correctly
        getAction(machine, typeof action == "string" ? action : action.type)
      ), actionArgs = {
        context: intermediateSnapshot.context,
        event,
        self: actorScope.self,
        system: actorScope.system
      }, actionParams = isInline || typeof action == "string" ? void 0 : "params" in action ? typeof action.params == "function" ? action.params({
        context: intermediateSnapshot.context,
        event
      }) : action.params : void 0;
      if (!resolvedAction || !("resolve" in resolvedAction)) {
        actorScope.actionExecutor({
          type: typeof action == "string" ? action : typeof action == "object" ? action.type : action.name || "(anonymous)",
          info: actionArgs,
          params: actionParams,
          exec: resolvedAction
        });
        continue;
      }
      const builtinAction = resolvedAction, [nextState, params, actions2] = builtinAction.resolve(
        actorScope,
        intermediateSnapshot,
        actionArgs,
        actionParams,
        resolvedAction,
        // this holds all params
        extra
      );
      intermediateSnapshot = nextState, "retryResolve" in builtinAction && retries?.push([builtinAction, params]), "execute" in builtinAction && actorScope.actionExecutor({
        type: builtinAction.type,
        info: actionArgs,
        params,
        exec: builtinAction.execute.bind(null, actorScope, params)
      }), actions2 && (intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions2, extra, retries));
    }
    return intermediateSnapshot;
  }
  function resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {
    const retries = deferredActorIds ? [] : void 0, nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {
      internalQueue,
      deferredActorIds
    }, retries);
    return retries?.forEach(([builtinAction, params]) => {
      builtinAction.retryResolve(actorScope, nextState, params);
    }), nextState;
  }
  function macrostep(snapshot, event, actorScope, internalQueue) {
    let nextSnapshot = snapshot;
    const microstates = [];
    function addMicrostate(microstate, event2, transitions2) {
      actorScope.system._sendInspectionEvent({
        type: "@xstate.microstep",
        actorRef: actorScope.self,
        event: event2,
        snapshot: microstate,
        _transitions: transitions2
      }), microstates.push(microstate);
    }
    if (event.type === XSTATE_STOP)
      return nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {
        status: "stopped"
      }), addMicrostate(nextSnapshot, event, []), {
        snapshot: nextSnapshot,
        microstates
      };
    let nextEvent = event;
    if (nextEvent.type !== XSTATE_INIT) {
      const currentEvent = nextEvent, isErr = isErrorActorEvent(currentEvent), transitions2 = selectTransitions(currentEvent, nextSnapshot);
      if (isErr && !transitions2.length)
        return nextSnapshot = cloneMachineSnapshot(snapshot, {
          status: "error",
          error: currentEvent.error
        }), addMicrostate(nextSnapshot, currentEvent, []), {
          snapshot: nextSnapshot,
          microstates
        };
      nextSnapshot = microstep(
        transitions2,
        snapshot,
        actorScope,
        nextEvent,
        !1,
        // isInitial
        internalQueue
      ), addMicrostate(nextSnapshot, currentEvent, transitions2);
    }
    let shouldSelectEventlessTransitions = !0;
    for (; nextSnapshot.status === "active"; ) {
      let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];
      const previousState = enabledTransitions.length ? nextSnapshot : void 0;
      if (!enabledTransitions.length) {
        if (!internalQueue.length)
          break;
        nextEvent = internalQueue.shift(), enabledTransitions = selectTransitions(nextEvent, nextSnapshot);
      }
      nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, !1, internalQueue), shouldSelectEventlessTransitions = nextSnapshot !== previousState, addMicrostate(nextSnapshot, nextEvent, enabledTransitions);
    }
    return nextSnapshot.status !== "active" && stopChildren(nextSnapshot, nextEvent, actorScope), {
      snapshot: nextSnapshot,
      microstates
    };
  }
  function stopChildren(nextState, event, actorScope) {
    return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map((child) => stopChild(child)), [], void 0);
  }
  function selectTransitions(event, nextState) {
    return nextState.machine.getTransitionData(nextState, event);
  }
  function selectEventlessTransitions(nextState, event) {
    const enabledTransitionSet = /* @__PURE__ */ new Set(), atomicStates = nextState._nodes.filter(isAtomicStateNode);
    for (const stateNode of atomicStates)
      loop: for (const s2 of [stateNode].concat(getProperAncestors(stateNode, void 0)))
        if (s2.always) {
          for (const transition of s2.always)
            if (transition.guard === void 0 || evaluateGuard(transition.guard, nextState.context, event, nextState)) {
              enabledTransitionSet.add(transition);
              break loop;
            }
        }
    return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);
  }
  function resolveStateValue(rootNode, stateValue) {
    const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));
    return getStateValue(rootNode, [...allStateNodes]);
  }
  function isMachineSnapshot(value) {
    return !!value && typeof value == "object" && "machine" in value && "value" in value;
  }
  const machineSnapshotMatches = function(testValue) {
    return matchesState(testValue, this.value);
  }, machineSnapshotHasTag = function(tag) {
    return this.tags.has(tag);
  }, machineSnapshotCan = function(event) {
    const transitionData = this.machine.getTransitionData(this, event);
    return !!transitionData?.length && // Check that at least one transition is not forbidden
    transitionData.some((t2) => t2.target !== void 0 || t2.actions.length);
  }, machineSnapshotToJSON = function() {
    const {
      _nodes: nodes,
      tags,
      machine,
      getMeta,
      toJSON: toJSON2,
      can,
      hasTag,
      matches,
      ...jsonValues
    } = this;
    return {
      ...jsonValues,
      tags: Array.from(tags)
    };
  }, machineSnapshotGetMeta = function() {
    return this._nodes.reduce((acc, stateNode) => (stateNode.meta !== void 0 && (acc[stateNode.id] = stateNode.meta), acc), {});
  };
  function createMachineSnapshot(config, machine) {
    return {
      status: config.status,
      output: config.output,
      error: config.error,
      machine,
      context: config.context,
      _nodes: config._nodes,
      value: getStateValue(machine.root, config._nodes),
      tags: new Set(config._nodes.flatMap((sn) => sn.tags)),
      children: config.children,
      historyValue: config.historyValue || {},
      matches: machineSnapshotMatches,
      hasTag: machineSnapshotHasTag,
      can: machineSnapshotCan,
      getMeta: machineSnapshotGetMeta,
      toJSON: machineSnapshotToJSON
    };
  }
  function cloneMachineSnapshot(snapshot, config = {}) {
    return createMachineSnapshot({
      ...snapshot,
      ...config
    }, snapshot.machine);
  }
  function getPersistedSnapshot(snapshot, options) {
    const {
      _nodes: nodes,
      tags,
      machine,
      children: children2,
      context: context2,
      can,
      hasTag,
      matches,
      getMeta,
      toJSON,
      ...jsonValues
    } = snapshot, childrenJson = {};
    for (const id2 in children2) {
      const child = children2[id2];
      childrenJson[id2] = {
        snapshot: child.getPersistedSnapshot(options),
        src: child.src,
        systemId: child._systemId,
        syncSnapshot: child._syncSnapshot
      };
    }
    return {
      ...jsonValues,
      context: persistContext(context2),
      children: childrenJson
    };
  }
  function persistContext(contextPart) {
    let copy;
    for (const key2 in contextPart) {
      const value = contextPart[key2];
      if (value && typeof value == "object")
        if ("sessionId" in value && "send" in value && "ref" in value)
          copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
            ...contextPart
          }, copy[key2] = {
            xstate$$type: $$ACTOR_TYPE,
            id: value.id
          };
        else {
          const result = persistContext(value);
          result !== value && (copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
            ...contextPart
          }, copy[key2] = result);
        }
    }
    return copy ?? contextPart;
  }
  function resolveRaise(_, snapshot, args, actionParams, {
    event: eventOrExpr,
    id: id2,
    delay: delay2
  }, {
    internalQueue
  }) {
    const delaysMap = snapshot.machine.implementations.delays;
    if (typeof eventOrExpr == "string")
      throw new Error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`
      );
    const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
    let resolvedDelay;
    if (typeof delay2 == "string") {
      const configDelay = delaysMap && delaysMap[delay2];
      resolvedDelay = typeof configDelay == "function" ? configDelay(args, actionParams) : configDelay;
    } else
      resolvedDelay = typeof delay2 == "function" ? delay2(args, actionParams) : delay2;
    return typeof resolvedDelay != "number" && internalQueue.push(resolvedEvent), [snapshot, {
      event: resolvedEvent,
      id: id2,
      delay: resolvedDelay
    }, void 0];
  }
  function executeRaise(actorScope, params) {
    const {
      event,
      delay: delay2,
      id: id2
    } = params;
    if (typeof delay2 == "number") {
      actorScope.defer(() => {
        const self2 = actorScope.self;
        actorScope.system.scheduler.schedule(self2, self2, event, delay2, id2);
      });
      return;
    }
  }
  function raise2(eventOrExpr, options) {
    function raise3(_args, _params) {
    }
    return raise3.type = "xstate.raise", raise3.event = eventOrExpr, raise3.id = options?.id, raise3.delay = options?.delay, raise3.resolve = resolveRaise, raise3.execute = executeRaise, raise3;
  }
  return raise60cebf03_cjs.$$ACTOR_TYPE = $$ACTOR_TYPE, raise60cebf03_cjs.Actor = Actor, raise60cebf03_cjs.NULL_EVENT = NULL_EVENT, raise60cebf03_cjs.ProcessingStatus = ProcessingStatus, raise60cebf03_cjs.STATE_DELIMITER = STATE_DELIMITER, raise60cebf03_cjs.XSTATE_ERROR = XSTATE_ERROR, raise60cebf03_cjs.XSTATE_STOP = XSTATE_STOP, raise60cebf03_cjs.and = and, raise60cebf03_cjs.cancel = cancel, raise60cebf03_cjs.cloneMachineSnapshot = cloneMachineSnapshot, raise60cebf03_cjs.createActor = createActor, raise60cebf03_cjs.createErrorActorEvent = createErrorActorEvent, raise60cebf03_cjs.createInitEvent = createInitEvent, raise60cebf03_cjs.createInvokeId = createInvokeId, raise60cebf03_cjs.createMachineSnapshot = createMachineSnapshot, raise60cebf03_cjs.evaluateGuard = evaluateGuard, raise60cebf03_cjs.formatInitialTransition = formatInitialTransition, raise60cebf03_cjs.formatTransition = formatTransition, raise60cebf03_cjs.formatTransitions = formatTransitions, raise60cebf03_cjs.getAllOwnEventDescriptors = getAllOwnEventDescriptors, raise60cebf03_cjs.getAllStateNodes = getAllStateNodes, raise60cebf03_cjs.getCandidates = getCandidates, raise60cebf03_cjs.getDelayedTransitions = getDelayedTransitions, raise60cebf03_cjs.getInitialStateNodes = getInitialStateNodes, raise60cebf03_cjs.getPersistedSnapshot = getPersistedSnapshot, raise60cebf03_cjs.getStateNodeByPath = getStateNodeByPath, raise60cebf03_cjs.getStateNodes = getStateNodes, raise60cebf03_cjs.interpret = interpret, raise60cebf03_cjs.isInFinalState = isInFinalState, raise60cebf03_cjs.isMachineSnapshot = isMachineSnapshot, raise60cebf03_cjs.isStateId = isStateId, raise60cebf03_cjs.macrostep = macrostep, raise60cebf03_cjs.mapValues = mapValues, raise60cebf03_cjs.matchesState = matchesState, raise60cebf03_cjs.microstep = microstep, raise60cebf03_cjs.not = not, raise60cebf03_cjs.or = or, raise60cebf03_cjs.pathToStateValue = pathToStateValue, raise60cebf03_cjs.raise = raise2, raise60cebf03_cjs.resolveActionsAndContext = resolveActionsAndContext, raise60cebf03_cjs.resolveReferencedActor = resolveReferencedActor, raise60cebf03_cjs.resolveStateValue = resolveStateValue, raise60cebf03_cjs.spawnChild = spawnChild, raise60cebf03_cjs.stateIn = stateIn, raise60cebf03_cjs.stop = stop, raise60cebf03_cjs.stopChild = stopChild, raise60cebf03_cjs.toArray = toArray2, raise60cebf03_cjs.toObserver = toObserver, raise60cebf03_cjs.toStatePath = toStatePath, raise60cebf03_cjs.toTransitionConfigArray = toTransitionConfigArray, raise60cebf03_cjs.transitionNode = transitionNode, raise60cebf03_cjs;
}
var hasRequiredXstateActors_cjs;
function requireXstateActors_cjs() {
  if (hasRequiredXstateActors_cjs) return xstateActors_cjs;
  hasRequiredXstateActors_cjs = 1, Object.defineProperty(xstateActors_cjs, "__esModule", { value: !0 });
  var guards_dist_xstateGuards = /* @__PURE__ */ requireRaise60cebf03_cjs();
  requireXstateDev_cjs();
  function fromTransition(transition, initialContext) {
    return {
      config: transition,
      transition: (snapshot, event, actorScope) => ({
        ...snapshot,
        context: transition(snapshot.context, event, actorScope)
      }),
      getInitialSnapshot: (_, input2) => ({
        status: "active",
        output: void 0,
        error: void 0,
        context: typeof initialContext == "function" ? initialContext({
          input: input2
        }) : initialContext
      }),
      getPersistedSnapshot: (snapshot) => snapshot,
      restoreSnapshot: (snapshot) => snapshot
    };
  }
  const instanceStates = /* @__PURE__ */ new WeakMap();
  function fromCallback(callback) {
    return {
      config: callback,
      start: (state, actorScope) => {
        const {
          self: self2,
          system,
          emit: emit2
        } = actorScope, callbackState = {
          receivers: void 0,
          dispose: void 0
        };
        instanceStates.set(self2, callbackState), callbackState.dispose = callback({
          input: state.input,
          system,
          self: self2,
          sendBack: (event) => {
            self2.getSnapshot().status !== "stopped" && self2._parent && system._relay(self2, self2._parent, event);
          },
          receive: (listener) => {
            callbackState.receivers ??= /* @__PURE__ */ new Set(), callbackState.receivers.add(listener);
          },
          emit: emit2
        });
      },
      transition: (state, event, actorScope) => {
        const callbackState = instanceStates.get(actorScope.self);
        return event.type === guards_dist_xstateGuards.XSTATE_STOP ? (state = {
          ...state,
          status: "stopped",
          error: void 0
        }, callbackState.dispose?.(), state) : (callbackState.receivers?.forEach((receiver) => receiver(event)), state);
      },
      getInitialSnapshot: (_, input2) => ({
        status: "active",
        output: void 0,
        error: void 0,
        input: input2
      }),
      getPersistedSnapshot: (snapshot) => snapshot,
      restoreSnapshot: (snapshot) => snapshot
    };
  }
  const XSTATE_OBSERVABLE_NEXT = "xstate.observable.next", XSTATE_OBSERVABLE_ERROR = "xstate.observable.error", XSTATE_OBSERVABLE_COMPLETE = "xstate.observable.complete";
  function fromObservable(observableCreator) {
    return {
      config: observableCreator,
      transition: (snapshot, event) => {
        if (snapshot.status !== "active")
          return snapshot;
        switch (event.type) {
          case XSTATE_OBSERVABLE_NEXT:
            return {
              ...snapshot,
              context: event.data
            };
          case XSTATE_OBSERVABLE_ERROR:
            return {
              ...snapshot,
              status: "error",
              error: event.data,
              input: void 0,
              _subscription: void 0
            };
          case XSTATE_OBSERVABLE_COMPLETE:
            return {
              ...snapshot,
              status: "done",
              input: void 0,
              _subscription: void 0
            };
          case guards_dist_xstateGuards.XSTATE_STOP:
            return snapshot._subscription.unsubscribe(), {
              ...snapshot,
              status: "stopped",
              input: void 0,
              _subscription: void 0
            };
          default:
            return snapshot;
        }
      },
      getInitialSnapshot: (_, input2) => ({
        status: "active",
        output: void 0,
        error: void 0,
        context: void 0,
        input: input2,
        _subscription: void 0
      }),
      start: (state, {
        self: self2,
        system,
        emit: emit2
      }) => {
        state.status !== "done" && (state._subscription = observableCreator({
          input: state.input,
          system,
          self: self2,
          emit: emit2
        }).subscribe({
          next: (value) => {
            system._relay(self2, self2, {
              type: XSTATE_OBSERVABLE_NEXT,
              data: value
            });
          },
          error: (err) => {
            system._relay(self2, self2, {
              type: XSTATE_OBSERVABLE_ERROR,
              data: err
            });
          },
          complete: () => {
            system._relay(self2, self2, {
              type: XSTATE_OBSERVABLE_COMPLETE
            });
          }
        }));
      },
      getPersistedSnapshot: ({
        _subscription,
        ...state
      }) => state,
      restoreSnapshot: (state) => ({
        ...state,
        _subscription: void 0
      })
    };
  }
  function fromEventObservable(lazyObservable) {
    return {
      config: lazyObservable,
      transition: (state, event) => {
        if (state.status !== "active")
          return state;
        switch (event.type) {
          case XSTATE_OBSERVABLE_ERROR:
            return {
              ...state,
              status: "error",
              error: event.data,
              input: void 0,
              _subscription: void 0
            };
          case XSTATE_OBSERVABLE_COMPLETE:
            return {
              ...state,
              status: "done",
              input: void 0,
              _subscription: void 0
            };
          case guards_dist_xstateGuards.XSTATE_STOP:
            return state._subscription.unsubscribe(), {
              ...state,
              status: "stopped",
              input: void 0,
              _subscription: void 0
            };
          default:
            return state;
        }
      },
      getInitialSnapshot: (_, input2) => ({
        status: "active",
        output: void 0,
        error: void 0,
        context: void 0,
        input: input2,
        _subscription: void 0
      }),
      start: (state, {
        self: self2,
        system,
        emit: emit2
      }) => {
        state.status !== "done" && (state._subscription = lazyObservable({
          input: state.input,
          system,
          self: self2,
          emit: emit2
        }).subscribe({
          next: (value) => {
            self2._parent && system._relay(self2, self2._parent, value);
          },
          error: (err) => {
            system._relay(self2, self2, {
              type: XSTATE_OBSERVABLE_ERROR,
              data: err
            });
          },
          complete: () => {
            system._relay(self2, self2, {
              type: XSTATE_OBSERVABLE_COMPLETE
            });
          }
        }));
      },
      getPersistedSnapshot: ({
        _subscription,
        ...snapshot
      }) => snapshot,
      restoreSnapshot: (snapshot) => ({
        ...snapshot,
        _subscription: void 0
      })
    };
  }
  const XSTATE_PROMISE_RESOLVE = "xstate.promise.resolve", XSTATE_PROMISE_REJECT = "xstate.promise.reject", controllerMap = /* @__PURE__ */ new WeakMap();
  function fromPromise(promiseCreator) {
    return {
      config: promiseCreator,
      transition: (state, event, scope) => {
        if (state.status !== "active")
          return state;
        switch (event.type) {
          case XSTATE_PROMISE_RESOLVE: {
            const resolvedValue = event.data;
            return {
              ...state,
              status: "done",
              output: resolvedValue,
              input: void 0
            };
          }
          case XSTATE_PROMISE_REJECT:
            return {
              ...state,
              status: "error",
              error: event.data,
              input: void 0
            };
          case guards_dist_xstateGuards.XSTATE_STOP:
            return controllerMap.get(scope.self)?.abort(), {
              ...state,
              status: "stopped",
              input: void 0
            };
          default:
            return state;
        }
      },
      start: (state, {
        self: self2,
        system,
        emit: emit2
      }) => {
        if (state.status !== "active")
          return;
        const controller = new AbortController();
        controllerMap.set(self2, controller), Promise.resolve(promiseCreator({
          input: state.input,
          system,
          self: self2,
          signal: controller.signal,
          emit: emit2
        })).then((response) => {
          self2.getSnapshot().status === "active" && (controllerMap.delete(self2), system._relay(self2, self2, {
            type: XSTATE_PROMISE_RESOLVE,
            data: response
          }));
        }, (errorData) => {
          self2.getSnapshot().status === "active" && (controllerMap.delete(self2), system._relay(self2, self2, {
            type: XSTATE_PROMISE_REJECT,
            data: errorData
          }));
        });
      },
      getInitialSnapshot: (_, input2) => ({
        status: "active",
        output: void 0,
        error: void 0,
        input: input2
      }),
      getPersistedSnapshot: (snapshot) => snapshot,
      restoreSnapshot: (snapshot) => snapshot
    };
  }
  const emptyLogic = fromTransition((_) => {
  }, void 0);
  function createEmptyActor() {
    return guards_dist_xstateGuards.createActor(emptyLogic);
  }
  return xstateActors_cjs.createEmptyActor = createEmptyActor, xstateActors_cjs.fromCallback = fromCallback, xstateActors_cjs.fromEventObservable = fromEventObservable, xstateActors_cjs.fromObservable = fromObservable, xstateActors_cjs.fromPromise = fromPromise, xstateActors_cjs.fromTransition = fromTransition, xstateActors_cjs;
}
var logA019fbd0_cjs = {}, hasRequiredLogA019fbd0_cjs;
function requireLogA019fbd0_cjs() {
  if (hasRequiredLogA019fbd0_cjs) return logA019fbd0_cjs;
  hasRequiredLogA019fbd0_cjs = 1;
  var guards_dist_xstateGuards = /* @__PURE__ */ requireRaise60cebf03_cjs();
  function createSpawner(actorScope, {
    machine,
    context: context2
  }, event, spawnedChildren) {
    const spawn = (src, options) => {
      if (typeof src == "string") {
        const logic = guards_dist_xstateGuards.resolveReferencedActor(machine, src);
        if (!logic)
          throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
        const actorRef = guards_dist_xstateGuards.createActor(logic, {
          id: options?.id,
          parent: actorScope.self,
          syncSnapshot: options?.syncSnapshot,
          input: typeof options?.input == "function" ? options.input({
            context: context2,
            event,
            self: actorScope.self
          }) : options?.input,
          src,
          systemId: options?.systemId
        });
        return spawnedChildren[actorRef.id] = actorRef, actorRef;
      } else
        return guards_dist_xstateGuards.createActor(src, {
          id: options?.id,
          parent: actorScope.self,
          syncSnapshot: options?.syncSnapshot,
          input: options?.input,
          src,
          systemId: options?.systemId
        });
    };
    return (src, options) => {
      const actorRef = spawn(src, options);
      return spawnedChildren[actorRef.id] = actorRef, actorScope.defer(() => {
        actorRef._processingStatus !== guards_dist_xstateGuards.ProcessingStatus.Stopped && actorRef.start();
      }), actorRef;
    };
  }
  function resolveAssign(actorScope, snapshot, actionArgs, actionParams, {
    assignment
  }) {
    if (!snapshot.context)
      throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
    const spawnedChildren = {}, assignArgs = {
      context: snapshot.context,
      event: actionArgs.event,
      spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),
      self: actorScope.self,
      system: actorScope.system
    };
    let partialUpdate = {};
    if (typeof assignment == "function")
      partialUpdate = assignment(assignArgs, actionParams);
    else
      for (const key2 of Object.keys(assignment)) {
        const propAssignment = assignment[key2];
        partialUpdate[key2] = typeof propAssignment == "function" ? propAssignment(assignArgs, actionParams) : propAssignment;
      }
    const updatedContext = Object.assign({}, snapshot.context, partialUpdate);
    return [guards_dist_xstateGuards.cloneMachineSnapshot(snapshot, {
      context: updatedContext,
      children: Object.keys(spawnedChildren).length ? {
        ...snapshot.children,
        ...spawnedChildren
      } : snapshot.children
    }), void 0, void 0];
  }
  function assign2(assignment) {
    function assign3(_args, _params) {
    }
    return assign3.type = "xstate.assign", assign3.assignment = assignment, assign3.resolve = resolveAssign, assign3;
  }
  function resolveEmit(_, snapshot, args, actionParams, {
    event: eventOrExpr
  }) {
    const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
    return [snapshot, {
      event: resolvedEvent
    }, void 0];
  }
  function executeEmit(actorScope, {
    event
  }) {
    actorScope.defer(() => actorScope.emit(event));
  }
  function emit2(eventOrExpr) {
    function emit3(_args, _params) {
    }
    return emit3.type = "xstate.emit", emit3.event = eventOrExpr, emit3.resolve = resolveEmit, emit3.execute = executeEmit, emit3;
  }
  let SpecialTargets = /* @__PURE__ */ function(SpecialTargets2) {
    return SpecialTargets2.Parent = "#_parent", SpecialTargets2.Internal = "#_internal", SpecialTargets2;
  }({});
  function resolveSendTo(actorScope, snapshot, args, actionParams, {
    to,
    event: eventOrExpr,
    id: id2,
    delay: delay2
  }, extra) {
    const delaysMap = snapshot.machine.implementations.delays;
    if (typeof eventOrExpr == "string")
      throw new Error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`
      );
    const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
    let resolvedDelay;
    if (typeof delay2 == "string") {
      const configDelay = delaysMap && delaysMap[delay2];
      resolvedDelay = typeof configDelay == "function" ? configDelay(args, actionParams) : configDelay;
    } else
      resolvedDelay = typeof delay2 == "function" ? delay2(args, actionParams) : delay2;
    const resolvedTarget = typeof to == "function" ? to(args, actionParams) : to;
    let targetActorRef;
    if (typeof resolvedTarget == "string") {
      if (resolvedTarget === SpecialTargets.Parent ? targetActorRef = actorScope.self._parent : resolvedTarget === SpecialTargets.Internal ? targetActorRef = actorScope.self : resolvedTarget.startsWith("#_") ? targetActorRef = snapshot.children[resolvedTarget.slice(2)] : targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget], !targetActorRef)
        throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);
    } else
      targetActorRef = resolvedTarget || actorScope.self;
    return [snapshot, {
      to: targetActorRef,
      targetId: typeof resolvedTarget == "string" ? resolvedTarget : void 0,
      event: resolvedEvent,
      id: id2,
      delay: resolvedDelay
    }, void 0];
  }
  function retryResolveSendTo(_, snapshot, params) {
    typeof params.to == "string" && (params.to = snapshot.children[params.to]);
  }
  function executeSendTo(actorScope, params) {
    actorScope.defer(() => {
      const {
        to,
        event,
        delay: delay2,
        id: id2
      } = params;
      if (typeof delay2 == "number") {
        actorScope.system.scheduler.schedule(actorScope.self, to, event, delay2, id2);
        return;
      }
      actorScope.system._relay(
        actorScope.self,
        // at this point, in a deferred task, it should already be mutated by retryResolveSendTo
        // if it initially started as a string
        to,
        event.type === guards_dist_xstateGuards.XSTATE_ERROR ? guards_dist_xstateGuards.createErrorActorEvent(actorScope.self.id, event.data) : event
      );
    });
  }
  function sendTo(to, eventOrExpr, options) {
    function sendTo2(_args, _params) {
    }
    return sendTo2.type = "xstate.sendTo", sendTo2.to = to, sendTo2.event = eventOrExpr, sendTo2.id = options?.id, sendTo2.delay = options?.delay, sendTo2.resolve = resolveSendTo, sendTo2.retryResolve = retryResolveSendTo, sendTo2.execute = executeSendTo, sendTo2;
  }
  function sendParent(event, options) {
    return sendTo(SpecialTargets.Parent, event, options);
  }
  function forwardTo(target, options) {
    return sendTo(target, ({
      event
    }) => event, options);
  }
  function resolveEnqueueActions(actorScope, snapshot, args, actionParams, {
    collect
  }) {
    const actions = [], enqueue = function(action) {
      actions.push(action);
    };
    return enqueue.assign = (...args2) => {
      actions.push(assign2(...args2));
    }, enqueue.cancel = (...args2) => {
      actions.push(guards_dist_xstateGuards.cancel(...args2));
    }, enqueue.raise = (...args2) => {
      actions.push(guards_dist_xstateGuards.raise(...args2));
    }, enqueue.sendTo = (...args2) => {
      actions.push(sendTo(...args2));
    }, enqueue.sendParent = (...args2) => {
      actions.push(sendParent(...args2));
    }, enqueue.spawnChild = (...args2) => {
      actions.push(guards_dist_xstateGuards.spawnChild(...args2));
    }, enqueue.stopChild = (...args2) => {
      actions.push(guards_dist_xstateGuards.stopChild(...args2));
    }, enqueue.emit = (...args2) => {
      actions.push(emit2(...args2));
    }, collect({
      context: args.context,
      event: args.event,
      enqueue,
      check: (guard) => guards_dist_xstateGuards.evaluateGuard(guard, snapshot.context, args.event, snapshot),
      self: actorScope.self,
      system: actorScope.system
    }, actionParams), [snapshot, void 0, actions];
  }
  function enqueueActions(collect) {
    function enqueueActions2(_args, _params) {
    }
    return enqueueActions2.type = "xstate.enqueueActions", enqueueActions2.collect = collect, enqueueActions2.resolve = resolveEnqueueActions, enqueueActions2;
  }
  function resolveLog(_, snapshot, actionArgs, actionParams, {
    value,
    label: label2
  }) {
    return [snapshot, {
      value: typeof value == "function" ? value(actionArgs, actionParams) : value,
      label: label2
    }, void 0];
  }
  function executeLog({
    logger
  }, {
    value,
    label: label2
  }) {
    label2 ? logger(label2, value) : logger(value);
  }
  function log(value = ({
    context: context2,
    event
  }) => ({
    context: context2,
    event
  }), label2) {
    function log2(_args, _params) {
    }
    return log2.type = "xstate.log", log2.value = value, log2.label = label2, log2.resolve = resolveLog, log2.execute = executeLog, log2;
  }
  return logA019fbd0_cjs.SpecialTargets = SpecialTargets, logA019fbd0_cjs.assign = assign2, logA019fbd0_cjs.emit = emit2, logA019fbd0_cjs.enqueueActions = enqueueActions, logA019fbd0_cjs.forwardTo = forwardTo, logA019fbd0_cjs.log = log, logA019fbd0_cjs.sendParent = sendParent, logA019fbd0_cjs.sendTo = sendTo, logA019fbd0_cjs;
}
var hasRequiredXstate_cjs;
function requireXstate_cjs() {
  if (hasRequiredXstate_cjs) return xstate_cjs;
  hasRequiredXstate_cjs = 1, Object.defineProperty(xstate_cjs, "__esModule", { value: !0 });
  var actors_dist_xstateActors = requireXstateActors_cjs(), guards_dist_xstateGuards = /* @__PURE__ */ requireRaise60cebf03_cjs(), log = /* @__PURE__ */ requireLogA019fbd0_cjs();
  requireXstateDev_cjs();
  function assertEvent(event, type) {
    const types = guards_dist_xstateGuards.toArray(type);
    if (!types.includes(event.type)) {
      const typesText = types.length === 1 ? `type "${types[0]}"` : `one of types "${types.join('", "')}"`;
      throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);
    }
  }
  const cache = /* @__PURE__ */ new WeakMap();
  function memo2(object, key2, fn) {
    let memoizedData = cache.get(object);
    return memoizedData ? key2 in memoizedData || (memoizedData[key2] = fn()) : (memoizedData = {
      [key2]: fn()
    }, cache.set(object, memoizedData)), memoizedData[key2];
  }
  const EMPTY_OBJECT = {}, toSerializableAction = (action) => typeof action == "string" ? {
    type: action
  } : typeof action == "function" ? "resolve" in action ? {
    type: action.type
  } : {
    type: action.name
  } : action;
  class StateNode {
    constructor(config, options) {
      if (this.config = config, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = options._parent, this.key = options._key, this.machine = options._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(guards_dist_xstateGuards.STATE_DELIMITER), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? guards_dist_xstateGuards.mapValues(this.config.states, (stateConfig, key2) => new StateNode(stateConfig, {
        _parent: this,
        _key: key2,
        _machine: this.machine
      })) : EMPTY_OBJECT, this.type === "compound" && !this.config.initial)
        throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
      this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = guards_dist_xstateGuards.toArray(this.config.entry).slice(), this.exit = guards_dist_xstateGuards.toArray(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = guards_dist_xstateGuards.toArray(config.tags).slice();
    }
    /** @internal */
    _initialize() {
      this.transitions = guards_dist_xstateGuards.formatTransitions(this), this.config.always && (this.always = guards_dist_xstateGuards.toTransitionConfigArray(this.config.always).map((t2) => guards_dist_xstateGuards.formatTransition(this, guards_dist_xstateGuards.NULL_EVENT, t2))), Object.keys(this.states).forEach((key2) => {
        this.states[key2]._initialize();
      });
    }
    /** The well-structured state node definition. */
    get definition() {
      return {
        id: this.id,
        key: this.key,
        version: this.machine.version,
        type: this.type,
        initial: this.initial ? {
          target: this.initial.target,
          source: this,
          actions: this.initial.actions.map(toSerializableAction),
          eventType: null,
          reenter: !1,
          toJSON: () => ({
            target: this.initial.target.map((t2) => `#${t2.id}`),
            source: `#${this.id}`,
            actions: this.initial.actions.map(toSerializableAction),
            eventType: null
          })
        } : void 0,
        history: this.history,
        states: guards_dist_xstateGuards.mapValues(this.states, (state) => state.definition),
        on: this.on,
        transitions: [...this.transitions.values()].flat().map((t2) => ({
          ...t2,
          actions: t2.actions.map(toSerializableAction)
        })),
        entry: this.entry.map(toSerializableAction),
        exit: this.exit.map(toSerializableAction),
        meta: this.meta,
        order: this.order || -1,
        output: this.output,
        invoke: this.invoke,
        description: this.description,
        tags: this.tags
      };
    }
    /** @internal */
    toJSON() {
      return this.definition;
    }
    /** The logic invoked as actors by this state node. */
    get invoke() {
      return memo2(this, "invoke", () => guards_dist_xstateGuards.toArray(this.config.invoke).map((invokeConfig, i2) => {
        const {
          src,
          systemId
        } = invokeConfig, resolvedId = invokeConfig.id ?? guards_dist_xstateGuards.createInvokeId(this.id, i2), sourceName = typeof src == "string" ? src : `xstate.invoke.${guards_dist_xstateGuards.createInvokeId(this.id, i2)}`;
        return {
          ...invokeConfig,
          src: sourceName,
          id: resolvedId,
          systemId,
          toJSON() {
            const {
              onDone,
              onError,
              ...invokeDefValues
            } = invokeConfig;
            return {
              ...invokeDefValues,
              type: "xstate.invoke",
              src: sourceName,
              id: resolvedId
            };
          }
        };
      }));
    }
    /** The mapping of events to transitions. */
    get on() {
      return memo2(this, "on", () => [...this.transitions].flatMap(([descriptor, t2]) => t2.map((t3) => [descriptor, t3])).reduce((map, [descriptor, transition2]) => (map[descriptor] = map[descriptor] || [], map[descriptor].push(transition2), map), {}));
    }
    get after() {
      return memo2(this, "delayedTransitions", () => guards_dist_xstateGuards.getDelayedTransitions(this));
    }
    get initial() {
      return memo2(this, "initial", () => guards_dist_xstateGuards.formatInitialTransition(this, this.config.initial));
    }
    /** @internal */
    next(snapshot, event) {
      const eventType = event.type, actions = [];
      let selectedTransition;
      const candidates = memo2(this, `candidates-${eventType}`, () => guards_dist_xstateGuards.getCandidates(this, eventType));
      for (const candidate of candidates) {
        const {
          guard
        } = candidate, resolvedContext = snapshot.context;
        let guardPassed = !1;
        try {
          guardPassed = !guard || guards_dist_xstateGuards.evaluateGuard(guard, resolvedContext, event, snapshot);
        } catch (err) {
          const guardType = typeof guard == "string" ? guard : typeof guard == "object" ? guard.type : void 0;
          throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ""}in transition for event '${eventType}' in state node '${this.id}':
${err.message}`);
        }
        if (guardPassed) {
          actions.push(...candidate.actions), selectedTransition = candidate;
          break;
        }
      }
      return selectedTransition ? [selectedTransition] : void 0;
    }
    /** All the event types accepted by this state node and its descendants. */
    get events() {
      return memo2(this, "events", () => {
        const {
          states
        } = this, events = new Set(this.ownEvents);
        if (states)
          for (const stateId of Object.keys(states)) {
            const state = states[stateId];
            if (state.states)
              for (const event of state.events)
                events.add(`${event}`);
          }
        return Array.from(events);
      });
    }
    /**
     * All the events that have transitions directly from this state node.
     *
     * Excludes any inert events.
     */
    get ownEvents() {
      const events = new Set([...this.transitions.keys()].filter((descriptor) => this.transitions.get(descriptor).some((transition2) => !(!transition2.target && !transition2.actions.length && !transition2.reenter))));
      return Array.from(events);
    }
  }
  const STATE_IDENTIFIER = "#";
  class StateMachine {
    constructor(config, implementations) {
      this.config = config, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = config.id || "(machine)", this.implementations = {
        actors: implementations?.actors ?? {},
        actions: implementations?.actions ?? {},
        delays: implementations?.delays ?? {},
        guards: implementations?.guards ?? {}
      }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new StateNode(config, {
        _key: this.id,
        _machine: this
      }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
    }
    /**
     * Clones this state machine with the provided implementations and merges the
     * `context` (if provided).
     *
     * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
     *   `context`) to recursively merge with the existing options.
     * @returns A new `StateMachine` instance with the provided implementations.
     */
    provide(implementations) {
      const {
        actions,
        guards,
        actors,
        delays
      } = this.implementations;
      return new StateMachine(this.config, {
        actions: {
          ...actions,
          ...implementations.actions
        },
        guards: {
          ...guards,
          ...implementations.guards
        },
        actors: {
          ...actors,
          ...implementations.actors
        },
        delays: {
          ...delays,
          ...implementations.delays
        }
      });
    }
    resolveState(config) {
      const resolvedStateValue = guards_dist_xstateGuards.resolveStateValue(this.root, config.value), nodeSet = guards_dist_xstateGuards.getAllStateNodes(guards_dist_xstateGuards.getStateNodes(this.root, resolvedStateValue));
      return guards_dist_xstateGuards.createMachineSnapshot({
        _nodes: [...nodeSet],
        context: config.context || {},
        children: {},
        status: guards_dist_xstateGuards.isInFinalState(nodeSet, this.root) ? "done" : config.status || "active",
        output: config.output,
        error: config.error,
        historyValue: config.historyValue
      }, this);
    }
    /**
     * Determines the next snapshot given the current `snapshot` and received
     * `event`. Calculates a full macrostep from all microsteps.
     *
     * @param snapshot The current snapshot
     * @param event The received event
     */
    transition(snapshot, event, actorScope) {
      return guards_dist_xstateGuards.macrostep(snapshot, event, actorScope, []).snapshot;
    }
    /**
     * Determines the next state given the current `state` and `event`. Calculates
     * a microstep.
     *
     * @param state The current state
     * @param event The received event
     */
    microstep(snapshot, event, actorScope) {
      return guards_dist_xstateGuards.macrostep(snapshot, event, actorScope, []).microstates;
    }
    getTransitionData(snapshot, event) {
      return guards_dist_xstateGuards.transitionNode(this.root, snapshot.value, snapshot, event) || [];
    }
    /**
     * The initial state _before_ evaluating any microsteps. This "pre-initial"
     * state is provided to initial actions executed in the initial state.
     */
    getPreInitialState(actorScope, initEvent, internalQueue) {
      const {
        context: context2
      } = this.config, preInitial = guards_dist_xstateGuards.createMachineSnapshot({
        context: typeof context2 != "function" && context2 ? context2 : {},
        _nodes: [this.root],
        children: {},
        status: "active"
      }, this);
      if (typeof context2 == "function") {
        const assignment = ({
          spawn,
          event,
          self: self2
        }) => context2({
          spawn,
          input: event.input,
          self: self2
        });
        return guards_dist_xstateGuards.resolveActionsAndContext(preInitial, initEvent, actorScope, [log.assign(assignment)], internalQueue, void 0);
      }
      return preInitial;
    }
    /**
     * Returns the initial `State` instance, with reference to `self` as an
     * `ActorRef`.
     */
    getInitialSnapshot(actorScope, input2) {
      const initEvent = guards_dist_xstateGuards.createInitEvent(input2), internalQueue = [], preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue), nextState = guards_dist_xstateGuards.microstep([{
        target: [...guards_dist_xstateGuards.getInitialStateNodes(this.root)],
        source: this.root,
        reenter: !0,
        actions: [],
        eventType: null,
        toJSON: null
        // TODO: fix
      }], preInitialState, actorScope, initEvent, !0, internalQueue), {
        snapshot: macroState
      } = guards_dist_xstateGuards.macrostep(nextState, initEvent, actorScope, internalQueue);
      return macroState;
    }
    start(snapshot) {
      Object.values(snapshot.children).forEach((child) => {
        child.getSnapshot().status === "active" && child.start();
      });
    }
    getStateNodeById(stateId) {
      const fullPath = guards_dist_xstateGuards.toStatePath(stateId), relativePath = fullPath.slice(1), resolvedStateId = guards_dist_xstateGuards.isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0], stateNode = this.idMap.get(resolvedStateId);
      if (!stateNode)
        throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
      return guards_dist_xstateGuards.getStateNodeByPath(stateNode, relativePath);
    }
    get definition() {
      return this.root.definition;
    }
    toJSON() {
      return this.definition;
    }
    getPersistedSnapshot(snapshot, options) {
      return guards_dist_xstateGuards.getPersistedSnapshot(snapshot, options);
    }
    restoreSnapshot(snapshot, _actorScope) {
      const children2 = {}, snapshotChildren = snapshot.children;
      Object.keys(snapshotChildren).forEach((actorId) => {
        const actorData = snapshotChildren[actorId], childState = actorData.snapshot, src = actorData.src, logic = typeof src == "string" ? guards_dist_xstateGuards.resolveReferencedActor(this, src) : src;
        if (!logic)
          return;
        const actorRef = guards_dist_xstateGuards.createActor(logic, {
          id: actorId,
          parent: _actorScope.self,
          syncSnapshot: actorData.syncSnapshot,
          snapshot: childState,
          src,
          systemId: actorData.systemId
        });
        children2[actorId] = actorRef;
      });
      const restoredSnapshot = guards_dist_xstateGuards.createMachineSnapshot({
        ...snapshot,
        children: children2,
        _nodes: Array.from(guards_dist_xstateGuards.getAllStateNodes(guards_dist_xstateGuards.getStateNodes(this.root, snapshot.value)))
      }, this), seen = /* @__PURE__ */ new Set();
      function reviveContext(contextPart, children3) {
        if (!seen.has(contextPart)) {
          seen.add(contextPart);
          for (const key2 in contextPart) {
            const value = contextPart[key2];
            if (value && typeof value == "object") {
              if ("xstate$$type" in value && value.xstate$$type === guards_dist_xstateGuards.$$ACTOR_TYPE) {
                contextPart[key2] = children3[value.id];
                continue;
              }
              reviveContext(value, children3);
            }
          }
        }
      }
      return reviveContext(restoredSnapshot.context, children2), restoredSnapshot;
    }
  }
  function createMachine(config, implementations) {
    return new StateMachine(config, implementations);
  }
  function createInertActorScope(actorLogic) {
    const self2 = guards_dist_xstateGuards.createActor(actorLogic);
    return {
      self: self2,
      defer: () => {
      },
      id: "",
      logger: () => {
      },
      sessionId: "",
      stopChild: () => {
      },
      system: self2.system,
      emit: () => {
      },
      actionExecutor: () => {
      }
    };
  }
  function getInitialSnapshot(actorLogic, ...[input2]) {
    const actorScope = createInertActorScope(actorLogic);
    return actorLogic.getInitialSnapshot(actorScope, input2);
  }
  function getNextSnapshot(actorLogic, snapshot, event) {
    const inertActorScope = createInertActorScope(actorLogic);
    return inertActorScope.self._snapshot = snapshot, actorLogic.transition(snapshot, event, inertActorScope);
  }
  function setup({
    schemas,
    actors,
    actions,
    guards,
    delays
  }) {
    return {
      createMachine: (config) => createMachine({
        ...config,
        schemas
      }, {
        actors,
        actions,
        guards,
        delays
      })
    };
  }
  class SimulatedClock {
    constructor() {
      this.timeouts = /* @__PURE__ */ new Map(), this._now = 0, this._id = 0, this._flushing = !1, this._flushingInvalidated = !1;
    }
    now() {
      return this._now;
    }
    getId() {
      return this._id++;
    }
    setTimeout(fn, timeout2) {
      this._flushingInvalidated = this._flushing;
      const id2 = this.getId();
      return this.timeouts.set(id2, {
        start: this.now(),
        timeout: timeout2,
        fn
      }), id2;
    }
    clearTimeout(id2) {
      this._flushingInvalidated = this._flushing, this.timeouts.delete(id2);
    }
    set(time2) {
      if (this._now > time2)
        throw new Error("Unable to travel back in time");
      this._now = time2, this.flushTimeouts();
    }
    flushTimeouts() {
      if (this._flushing) {
        this._flushingInvalidated = !0;
        return;
      }
      this._flushing = !0;
      const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {
        const endA = timeoutA.start + timeoutA.timeout;
        return timeoutB.start + timeoutB.timeout > endA ? -1 : 1;
      });
      for (const [id2, timeout2] of sorted) {
        if (this._flushingInvalidated) {
          this._flushingInvalidated = !1, this._flushing = !1, this.flushTimeouts();
          return;
        }
        this.now() - timeout2.start >= timeout2.timeout && (this.timeouts.delete(id2), timeout2.fn.call(null));
      }
      this._flushing = !1;
    }
    increment(ms) {
      this._now += ms, this.flushTimeouts();
    }
  }
  function toPromise(actor) {
    return new Promise((resolve, reject) => {
      actor.subscribe({
        complete: () => {
          resolve(actor.getSnapshot().output);
        },
        error: reject
      });
    });
  }
  function transition(logic, snapshot, event) {
    const executableActions = [], actorScope = createInertActorScope(logic);
    return actorScope.actionExecutor = (action) => {
      executableActions.push(action);
    }, [logic.transition(snapshot, event, actorScope), executableActions];
  }
  function initialTransition(logic, ...[input2]) {
    const executableActions = [], actorScope = createInertActorScope(logic);
    return actorScope.actionExecutor = (action) => {
      executableActions.push(action);
    }, [logic.getInitialSnapshot(actorScope, input2), executableActions];
  }
  const defaultWaitForOptions = {
    timeout: 1 / 0
    // much more than 10 seconds
  };
  function waitFor(actorRef, predicate, options) {
    const resolvedOptions = {
      ...defaultWaitForOptions,
      ...options
    };
    return new Promise((res, rej) => {
      const {
        signal
      } = resolvedOptions;
      if (signal?.aborted) {
        rej(signal.reason);
        return;
      }
      let done = !1;
      const handle = resolvedOptions.timeout === 1 / 0 ? void 0 : setTimeout(() => {
        dispose(), rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));
      }, resolvedOptions.timeout), dispose = () => {
        clearTimeout(handle), done = !0, sub?.unsubscribe(), abortListener && signal.removeEventListener("abort", abortListener);
      };
      function checkEmitted(emitted) {
        predicate(emitted) && (dispose(), res(emitted));
      }
      let abortListener, sub;
      checkEmitted(actorRef.getSnapshot()), !done && (signal && (abortListener = () => {
        dispose(), rej(signal.reason);
      }, signal.addEventListener("abort", abortListener)), sub = actorRef.subscribe({
        next: checkEmitted,
        error: (err) => {
          dispose(), rej(err);
        },
        complete: () => {
          dispose(), rej(new Error("Actor terminated without satisfying predicate"));
        }
      }), done && sub.unsubscribe());
    });
  }
  return xstate_cjs.createEmptyActor = actors_dist_xstateActors.createEmptyActor, xstate_cjs.fromCallback = actors_dist_xstateActors.fromCallback, xstate_cjs.fromEventObservable = actors_dist_xstateActors.fromEventObservable, xstate_cjs.fromObservable = actors_dist_xstateActors.fromObservable, xstate_cjs.fromPromise = actors_dist_xstateActors.fromPromise, xstate_cjs.fromTransition = actors_dist_xstateActors.fromTransition, xstate_cjs.Actor = guards_dist_xstateGuards.Actor, xstate_cjs.__unsafe_getAllOwnEventDescriptors = guards_dist_xstateGuards.getAllOwnEventDescriptors, xstate_cjs.and = guards_dist_xstateGuards.and, xstate_cjs.cancel = guards_dist_xstateGuards.cancel, xstate_cjs.createActor = guards_dist_xstateGuards.createActor, xstate_cjs.getStateNodes = guards_dist_xstateGuards.getStateNodes, xstate_cjs.interpret = guards_dist_xstateGuards.interpret, xstate_cjs.isMachineSnapshot = guards_dist_xstateGuards.isMachineSnapshot, xstate_cjs.matchesState = guards_dist_xstateGuards.matchesState, xstate_cjs.not = guards_dist_xstateGuards.not, xstate_cjs.or = guards_dist_xstateGuards.or, xstate_cjs.pathToStateValue = guards_dist_xstateGuards.pathToStateValue, xstate_cjs.raise = guards_dist_xstateGuards.raise, xstate_cjs.spawnChild = guards_dist_xstateGuards.spawnChild, xstate_cjs.stateIn = guards_dist_xstateGuards.stateIn, xstate_cjs.stop = guards_dist_xstateGuards.stop, xstate_cjs.stopChild = guards_dist_xstateGuards.stopChild, xstate_cjs.toObserver = guards_dist_xstateGuards.toObserver, xstate_cjs.SpecialTargets = log.SpecialTargets, xstate_cjs.assign = log.assign, xstate_cjs.emit = log.emit, xstate_cjs.enqueueActions = log.enqueueActions, xstate_cjs.forwardTo = log.forwardTo, xstate_cjs.log = log.log, xstate_cjs.sendParent = log.sendParent, xstate_cjs.sendTo = log.sendTo, xstate_cjs.SimulatedClock = SimulatedClock, xstate_cjs.StateMachine = StateMachine, xstate_cjs.StateNode = StateNode, xstate_cjs.assertEvent = assertEvent, xstate_cjs.createMachine = createMachine, xstate_cjs.getInitialSnapshot = getInitialSnapshot, xstate_cjs.getNextSnapshot = getNextSnapshot, xstate_cjs.initialTransition = initialTransition, xstate_cjs.setup = setup, xstate_cjs.toPromise = toPromise, xstate_cjs.transition = transition, xstate_cjs.waitFor = waitFor, xstate_cjs;
}
var hasRequiredXstateReact_cjs;
function requireXstateReact_cjs() {
  if (hasRequiredXstateReact_cjs) return xstateReact_cjs;
  hasRequiredXstateReact_cjs = 1, Object.defineProperty(xstateReact_cjs, "__esModule", { value: !0 });
  var React2 = React__default, useIsomorphicLayoutEffect2 = requireUseIsomorphicLayoutEffect_cjs(), xstate = /* @__PURE__ */ requireXstate_cjs(), withSelector2 = requireWithSelector(), shim2 = requireShim();
  function _interopDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function _interopNamespace(e2) {
    if (e2 && e2.__esModule) return e2;
    var n2 = /* @__PURE__ */ Object.create(null);
    return e2 && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default") {
        var d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: !0,
          get: function() {
            return e2[k2];
          }
        });
      }
    }), n2.default = e2, Object.freeze(n2);
  }
  var React__namespace = /* @__PURE__ */ _interopNamespace(React2), useIsomorphicLayoutEffect__default = /* @__PURE__ */ _interopDefault(useIsomorphicLayoutEffect2);
  const forEachActor = (actorRef, callback) => {
    callback(actorRef);
    const children2 = actorRef.getSnapshot().children;
    children2 && Object.values(children2).forEach((child) => {
      forEachActor(child, callback);
    });
  };
  function stopRootWithRehydration(actorRef) {
    const persistedSnapshots = [];
    forEachActor(actorRef, (ref) => {
      persistedSnapshots.push([ref, ref.getSnapshot()]), ref.observers = /* @__PURE__ */ new Set();
    });
    const systemSnapshot = actorRef.system.getSnapshot?.();
    actorRef.stop(), actorRef.system._snapshot = systemSnapshot, persistedSnapshots.forEach(([ref, snapshot]) => {
      ref._processingStatus = 0, ref._snapshot = snapshot;
    });
  }
  function useIdleActorRef(logic, ...[options]) {
    let [[currentConfig, actorRef], setCurrent] = React2.useState(() => {
      const actorRef2 = xstate.createActor(logic, options);
      return [logic.config, actorRef2];
    });
    if (logic.config !== currentConfig) {
      const newActorRef = xstate.createActor(logic, {
        ...options,
        snapshot: actorRef.getPersistedSnapshot({
          __unsafeAllowInlineActors: !0
        })
      });
      setCurrent([logic.config, newActorRef]), actorRef = newActorRef;
    }
    return useIsomorphicLayoutEffect__default.default(() => {
      actorRef.logic.implementations = logic.implementations;
    }), actorRef;
  }
  function useActorRef(machine, ...[options, observerOrListener]) {
    const actorRef = useIdleActorRef(machine, options);
    return React2.useEffect(() => {
      if (!observerOrListener)
        return;
      const sub = actorRef.subscribe(xstate.toObserver(observerOrListener));
      return () => {
        sub.unsubscribe();
      };
    }, [observerOrListener]), React2.useEffect(() => (actorRef.start(), () => {
      stopRootWithRehydration(actorRef);
    }), [actorRef]), actorRef;
  }
  function defaultCompare(a2, b2) {
    return a2 === b2;
  }
  function useSelector(actor, selector3, compare = defaultCompare) {
    const subscribe = React2.useCallback((handleStoreChange) => {
      if (!actor)
        return () => {
        };
      const {
        unsubscribe
      } = actor.subscribe(handleStoreChange);
      return unsubscribe;
    }, [actor]), boundGetSnapshot = React2.useCallback(() => actor?.getSnapshot(), [actor]);
    return withSelector2.useSyncExternalStoreWithSelector(subscribe, boundGetSnapshot, boundGetSnapshot, selector3, compare);
  }
  function createActorContext(actorLogic, actorOptions) {
    const ReactContext = /* @__PURE__ */ React__namespace.createContext(null), OriginalProvider = ReactContext.Provider;
    function Provider2({
      children: children2,
      logic: providedLogic = actorLogic,
      machine,
      options: providedOptions
    }) {
      if (machine)
        throw new Error('The "machine" prop has been deprecated. Please use "logic" instead.');
      const actor = useActorRef(providedLogic, {
        ...actorOptions,
        ...providedOptions
      });
      return /* @__PURE__ */ React__namespace.createElement(OriginalProvider, {
        value: actor,
        children: children2
      });
    }
    Provider2.displayName = "ActorProvider";
    function useContext2() {
      const actor = React__namespace.useContext(ReactContext);
      if (!actor)
        throw new Error(`You used a hook from "${Provider2.displayName}" but it's not inside a <${Provider2.displayName}> component.`);
      return actor;
    }
    function useSelector$1(selector3, compare) {
      const actor = useContext2();
      return useSelector(actor, selector3, compare);
    }
    return {
      Provider: Provider2,
      useActorRef: useContext2,
      useSelector: useSelector$1
    };
  }
  function is(x2, y2) {
    return x2 === y2 ? x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2 : x2 !== x2 && y2 !== y2;
  }
  function shallowEqual2(objA, objB) {
    if (is(objA, objB)) return !0;
    if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
      return !1;
    const keysA = Object.keys(objA), keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return !1;
    for (let i2 = 0; i2 < keysA.length; i2++)
      if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is(objA[keysA[i2]], objB[keysA[i2]]))
        return !1;
    return !0;
  }
  function useActor(logic, ...[options]) {
    const actorRef = useIdleActorRef(logic, options), getSnapshot = React2.useCallback(() => actorRef.getSnapshot(), [actorRef]), subscribe = React2.useCallback((handleStoreChange) => {
      const {
        unsubscribe
      } = actorRef.subscribe(handleStoreChange);
      return unsubscribe;
    }, [actorRef]), actorSnapshot = shim2.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
    return React2.useEffect(() => (actorRef.start(), () => {
      stopRootWithRehydration(actorRef);
    }), [actorRef]), [actorSnapshot, actorRef.send, actorRef];
  }
  function useMachine(machine, ...[options]) {
    return useActor(machine, options);
  }
  return xstateReact_cjs.createActorContext = createActorContext, xstateReact_cjs.shallowEqual = shallowEqual2, xstateReact_cjs.useActor = useActor, xstateReact_cjs.useActorRef = useActorRef, xstateReact_cjs.useMachine = useMachine, xstateReact_cjs.useSelector = useSelector, xstateReact_cjs;
}
var xstateReact_cjsExports = /* @__PURE__ */ requireXstateReact_cjs();
function typedSystem(system) {
  return {
    get overlaysActorRef() {
      return system.get("overlays") ?? null;
    },
    get diagramActorRef() {
      return system.get("diagram") ?? null;
    }
  };
}
function findDiagramNode(ctx, xynodeId) {
  return ctx.view.nodes.find((n2) => n2.id === xynodeId) ?? null;
}
function findDiagramEdge(ctx, xyedgeId) {
  return ctx.view.edges.find((e2) => e2.id === xyedgeId) ?? null;
}
function focusedBounds(params) {
  const knownAbsolutes = /* @__PURE__ */ new Map(), b2 = params.context.xynodes.reduce((acc, node2) => {
    let position = node2.position;
    if (node2.parentId) {
      const parent = knownAbsolutes.get(node2.parentId) ?? { x: 0, y: 0 };
      position = {
        x: position.x + parent.x,
        y: position.y + parent.y
      };
    }
    if (knownAbsolutes.set(node2.id, position), node2.hidden || node2.data.dimmed)
      return acc;
    const width = node2.measured?.width ?? node2.width ?? node2.initialWidth, height = node2.measured?.height ?? node2.height ?? node2.initialHeight;
    return {
      minX: Math.min(acc.minX, position.x),
      minY: Math.min(acc.minY, position.y),
      maxX: Math.max(acc.maxX, position.x + width),
      maxY: Math.max(acc.maxY, position.y + height)
    };
  }, {
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  });
  return b2.minX === 1 / 0 ? {
    bounds: params.context.view.bounds
  } : {
    duration: 350,
    bounds: {
      x: b2.minX - 10,
      y: b2.minY - 10,
      width: b2.maxX - b2.minX + 20,
      height: b2.maxY - b2.minY + 20
    }
  };
}
const DiagramActorSafeContext = createContext(null);
DiagramActorSafeContext.displayName = "DiagramActorSafeContext";
const DiagramActorContextProvider = DiagramActorSafeContext.Provider, useDiagramActorRef = () => {
  const ctx = useContext(DiagramActorSafeContext);
  if (ctx === null)
    throw new Error("DiagramActorRef is not provided");
  return ctx;
};
function useDiagram() {
  const actor = useDiagramActorRef();
  return useMemo(() => ({
    actor,
    send: actor.send,
    navigateTo: (viewId, fromNode) => {
      actor.send({
        type: "navigate.to",
        viewId,
        ...fromNode && { fromNode }
      });
    },
    navigate: (direction) => {
      actor.send({ type: `navigate.${direction}` });
    },
    fitDiagram: (duration = 350) => {
      actor.send({ type: "fitDiagram", duration });
    },
    openRelationshipsBrowser: (fqn2) => {
      actor.send({ type: "open.relationshipsBrowser", fqn: fqn2 });
    },
    openSource: (params) => {
      actor.send({ type: "open.source", ...params });
    },
    openElementDetails: (fqn2, fromNode) => {
      actor.send({ type: "open.elementDetails", fqn: fqn2, fromNode });
    },
    openRelationshipDetails: (...params) => {
      params.length === 1 ? actor.send({ type: "open.relationshipDetails", params: { edgeId: params[0] } }) : actor.send({ type: "open.relationshipDetails", params: { source: params[0], target: params[1] } });
    },
    updateNodeData: (nodeId, data) => {
      actor.send({ type: "update.nodeData", nodeId, data });
    },
    updateEdgeData: (edgeId, data) => {
      actor.send({
        type: "update.edgeData",
        edgeId,
        // @ts-expect-error TODO: fix this
        data
      });
    },
    scheduleSaveManualLayout: () => {
      actor.send({ type: "saveManualLayout.schedule" });
    },
    /**
     * @returns true if there was pending request to save layout
     */
    cancelSaveManualLayout: () => {
      const syncState = actor.getSnapshot().children.syncLayout?.getSnapshot().value;
      return actor.send({ type: "saveManualLayout.cancel" }), syncState === "pending" || syncState === "paused";
    },
    align: (mode) => {
      actor.send({ type: "layout.align", mode });
    },
    resetEdgeControlPoints: () => {
      actor.send({ type: "layout.resetEdgeControlPoints" });
    },
    focusNode: (nodeId) => {
      actor.send({ type: "focus.node", nodeId });
    },
    /**
     * @warning Do not use in render phase
     */
    get currentView() {
      return actor.getSnapshot().context.view;
    },
    /**
     * @warning Do not use in render phase
     */
    getSnapshot: () => actor.getSnapshot(),
    /**
     * @warning Do not use in render phase
     */
    getContext: () => actor.getSnapshot().context,
    /**
     * @warning Do not use in render phase
     */
    findDiagramNode: (xynodeId) => findDiagramNode(actor.getSnapshot().context, xynodeId),
    /**
     * @warning Do not use in render phase
     */
    findDiagramEdge: (xyedgeId) => findDiagramEdge(actor.getSnapshot().context, xyedgeId),
    startWalkthrough: () => {
      actor.send({ type: "walkthrough.start" });
    },
    walkthroughStep: (direction = "next") => {
      actor.send({ type: "walkthrough.step", direction });
    },
    stopWalkthrough: () => {
      actor.send({ type: "walkthrough.end" });
    },
    toggleFeature: (feature, forceValue) => {
      actor.send({ type: "toggle.feature", feature, ...forceValue !== void 0 && { forceValue } });
    },
    highlightNotation: (notation, kind) => {
      actor.send({ type: "notations.highlight", notation, ...kind && { kind } });
    },
    unhighlightNotation: () => {
      actor.send({ type: "notations.unhighlight" });
    }
  }), [actor]);
}
function useDiagramActorSnapshot(selector3, compare = shallowEqual) {
  const actorRef = useDiagramActorRef();
  return xstateReact_cjsExports.useSelector(actorRef, useCallbackRef(selector3), compare);
}
function useDiagramSyncLayoutState(selector3, compare = shallowEqual) {
  const syncLayoutActorRef = useDiagramActorSnapshot((s2) => s2.context.syncLayoutActorRef);
  return xstateReact_cjsExports.useSelector(syncLayoutActorRef, useCallbackRef(selector3), compare);
}
function useDiagramContext(selector3, compare = shallowEqual) {
  const actorRef = useDiagramActorRef();
  return xstateReact_cjsExports.useSelector(actorRef, useCallbackRef((s2) => selector3(s2.context)), compare);
}
function constant(x2) {
  return function() {
    return x2;
  };
}
const epsilon$1 = 1e-12, pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
    this._ += arguments[i2] + strings[i2];
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15) return append;
  const k2 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
      this._ += Math.round(arguments[i2] * k2) / k2 + strings[i2];
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    if (x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null)
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    else if (l01_2 > epsilon) if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2)
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      Math.abs(t01 - 1) > epsilon && this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`, this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    if (x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    this._x1 === null ? this._append`M${x0},${y0}` : (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) && this._append`L${x0},${y0}`, r2 && (da < 0 && (da = da % tau + tau), da > tauEpsilon ? this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}` : da > epsilon && this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`);
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  return shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null)
      digits = null;
    else {
      const d2 = Math.floor(_);
      if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d2;
    }
    return shape;
  }, () => new Path(digits);
}
function array(x2) {
  return typeof x2 == "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context2) {
  this._context = context2;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context2) {
  return new Linear(context2);
}
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}
function d3line(x$1, y$12) {
  var defined = constant(!0), context2 = null, curve2 = curveLinear, output = null, path = withPath(line);
  x$1 = typeof x$1 == "function" ? x$1 : x$1 === void 0 ? x : constant(x$1), y$12 = typeof y$12 == "function" ? y$12 : y$12 === void 0 ? y : constant(y$12);
  function line(data) {
    var i2, n2 = (data = array(data)).length, d2, defined0 = !1, buffer;
    for (context2 == null && (output = curve2(buffer = path())), i2 = 0; i2 <= n2; ++i2)
      !(i2 < n2 && defined(d2 = data[i2], i2, data)) === defined0 && ((defined0 = !defined0) ? output.lineStart() : output.lineEnd()), defined0 && output.point(+x$1(d2, i2, data), +y$12(d2, i2, data));
    if (buffer) return output = null, buffer + "" || null;
  }
  return line.x = function(_) {
    return arguments.length ? (x$1 = typeof _ == "function" ? _ : constant(+_), line) : x$1;
  }, line.y = function(_) {
    return arguments.length ? (y$12 = typeof _ == "function" ? _ : constant(+_), line) : y$12;
  }, line.defined = function(_) {
    return arguments.length ? (defined = typeof _ == "function" ? _ : constant(!!_), line) : defined;
  }, line.curve = function(_) {
    return arguments.length ? (curve2 = _, context2 != null && (output = curve2(context2)), line) : curve2;
  }, line.context = function(_) {
    return arguments.length ? (_ == null ? context2 = output = null : output = curve2(context2 = _), line) : context2;
  }, line;
}
function point$1(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context2, tension) {
  this._context = context2, this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$1(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2, this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom(tension) {
  function cardinal(context2) {
    return new Cardinal(context2, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom(+tension2);
  }, cardinal;
})(0);
function CardinalOpen(context2, tension) {
  this._context = context2, this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom2(tension) {
  function cardinal(context2) {
    return new CardinalOpen(context2, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom2(+tension2);
  }, cardinal;
})(0);
function point(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$1) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2, y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon$1) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2, y22 = (y22 * b2 + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context2, alpha2) {
  this._context = context2, this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom3(alpha2) {
  function catmullRom(context2) {
    return alpha2 ? new CatmullRom(context2, alpha2) : new Cardinal(context2, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom3(+alpha3);
  }, catmullRom;
})(0.5);
function CatmullRomOpen(context2, alpha2) {
  this._context = context2, this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCatmullRomOpen = function custom4(alpha2) {
  function catmullRom(context2) {
    return alpha2 ? new CatmullRomOpen(context2, alpha2) : new CardinalOpen(context2, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom4(+alpha3);
  }, catmullRom;
}(0.5), createRecipe = (name, defaultVariants, compoundVariants) => {
  const getVariantProps = (variants) => ({
    [name]: "__ignore__",
    ...defaultVariants,
    ...compact(variants)
  });
  return {
    recipeFn: (variants, withCompoundVariants = !0) => {
      const recipeCss = createCss({
        conditions: {
          shift: sortConditions,
          finalize: finalizeConditions,
          breakpoints: { keys: ["base", "xs", "sm", "md", "lg", "xl"] }
        },
        utility: {
          toHash: (path, hashFn) => hashFn(path.join(":")),
          transform: (prop, value) => (assertCompoundVariant(name, compoundVariants, variants, prop), value === "__ignore__" ? { className: name } : (value = withoutSpace(value), { className: `${name}--${prop}_${value}` }))
        }
      }), recipeStyles = getVariantProps(variants);
      if (withCompoundVariants) {
        const compoundVariantStyles = getCompoundVariantCss(compoundVariants, recipeStyles);
        return cx(recipeCss(recipeStyles), css(compoundVariantStyles));
      }
      return recipeCss(recipeStyles);
    },
    getVariantProps,
    __getCompoundVariantCss__: (variants) => getCompoundVariantCss(compoundVariants, getVariantProps(variants))
  };
}, mergeRecipes = (recipeA, recipeB) => {
  if (recipeA && !recipeB) return recipeA;
  if (!recipeA && recipeB) return recipeB;
  const recipeFn = (...args) => cx(recipeA(...args), recipeB(...args)), variantKeys = uniq(recipeA.variantKeys, recipeB.variantKeys), variantMap = variantKeys.reduce((acc, key2) => (acc[key2] = uniq(recipeA.variantMap[key2], recipeB.variantMap[key2]), acc), {});
  return Object.assign(recipeFn, {
    __recipe__: !0,
    __name__: `${recipeA.__name__} ${recipeB.__name__}`,
    raw: (props) => props,
    variantKeys,
    variantMap,
    splitVariantProps(props) {
      return splitProps(props, variantKeys);
    }
  });
}, actionBtnFn = /* @__PURE__ */ createRecipe("action-btn", {
  size: "md",
  radius: "md",
  variant: "filled"
}, []), actionBtnVariantMap = {
  variant: [
    "transparent",
    "filled"
  ],
  size: [
    "sm",
    "md"
  ],
  radius: [
    "sm",
    "md"
  ]
}, actionBtnVariantKeys = Object.keys(actionBtnVariantMap), actionBtn$1 = /* @__PURE__ */ Object.assign(memo$1(actionBtnFn.recipeFn), {
  __recipe__: !0,
  __name__: "actionBtn",
  __getCompoundVariantCss__: actionBtnFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: actionBtnVariantKeys,
  variantMap: actionBtnVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, actionBtnVariantKeys);
  },
  getVariantProps: actionBtnFn.getVariantProps
}), MotionButton = /* @__PURE__ */ createMinimalMotionComponent("button"), MotionDiv = /* @__PURE__ */ createMinimalMotionComponent("div"), compoundActionBtn = cva({
  base: {
    transitionDuration: "normal",
    "[data-compound-title-inverse] &": {
      _dark: {
        "--actionbtn-color": "color-mix(in srgb, {colors.likec4.palette.loContrast} 60%, {colors.likec4.palette.fill})"
      },
      _light: {
        "--actionbtn-color": "{colors.likec4.palette.stroke}",
        "--actionbtn-color-hovered": "{colors.likec4.palette.stroke}",
        "--actionbtn-color-hovered-btn": "{colors.likec4.palette.hiContrast}",
        "--actionbtn-bg-hovered": "{colors.likec4.palette.fill/50}",
        "--actionbtn-bg-hovered-btn": "{colors.likec4.palette.fill}"
      }
    }
  },
  variants: {
    delay: {
      true: {
        // Debounce CSS transition
        transitionDelay: {
          base: "0.2s",
          _hover: "0s"
        }
      }
    }
  }
});
function CompoundActionButton({
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  const isHoverDebounced = useDebouncedValue(isHovered, isHovered ? 130 : 0)[0] && isHovered;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      className: cx(
        css({
          position: "absolute",
          top: "5px",
          left: "4px",
          _smallZoom: {
            display: "none"
          }
        }),
        "compound-action"
      ),
      children: /* @__PURE__ */ jsx(
        MotionDiv,
        {
          initial: !1,
          animate: {
            scale: isHoverDebounced ? 1.2 : 1,
            x: isHoverDebounced ? -1 : 0,
            y: isHoverDebounced ? -1 : 0
          },
          whileHover: {
            scale: 1.4,
            x: -2,
            y: -2
          },
          whileTap: { scale: 1 },
          children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              className: cx(
                "nodrag nopan",
                compoundActionBtn({
                  delay: isHovered && !isHoverDebounced
                }),
                actionBtn$1()
              ),
              onClick,
              onDoubleClick: stopPropagation$1,
              children: icon2 ?? /* @__PURE__ */ jsx(IconZoomScan, { stroke: 2 })
            }
          )
        }
      )
    }
  );
}
function CompoundDetailsButton({
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  const isHoverDebounced = useDebouncedValue(isHovered, isHovered ? 130 : 0)[0] && isHovered;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      className: cx(
        css({
          position: "absolute",
          top: "[2px]",
          right: "[2px]",
          _smallZoom: {
            display: "none"
          }
        }),
        "details-button"
      ),
      onClick: stopPropagation$1,
      children: /* @__PURE__ */ jsx(
        MotionDiv,
        {
          initial: !1,
          animate: {
            scale: isHoverDebounced ? 1.2 : 1,
            opacity: isHoverDebounced ? 1 : 0.6
          },
          whileHover: {
            scale: 1.4
          },
          whileTap: { scale: 1 },
          children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              className: cx(
                "nodrag nopan",
                compoundActionBtn({
                  delay: isHovered && !isHoverDebounced
                }),
                css({
                  _whenHovered: {
                    opacity: 0.75
                  },
                  _hover: {
                    opacity: 1
                  }
                }),
                actionBtn$1({ variant: "transparent" })
              ),
              onClick,
              onDoubleClick: stopPropagation$1,
              children: icon2 ?? /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
            }
          )
        }
      )
    }
  );
}
const borderWidth = {
  var: "--_border-width",
  ref: "var(--_border-width, 2px)"
}, borderRadius$1 = {
  var: "--_border-radius",
  ref: "var(--_border-radius, 4px)"
}, compoundOpacity = {
  var: "--_compound-opacity",
  ref: "var(--_compound-opacity, 1)"
}, borderOpacityPercent = {
  var: "--_border-opacity-percent",
  ref: "var(--_border-opacity-percent, 100%)"
}, root$2 = css.raw({
  position: "relative",
  width: "100%",
  height: "100%",
  padding: "0",
  margin: "0",
  border: "transparent",
  pointerEvents: "none",
  _before: {
    borderRadius: borderRadius$1.ref,
    content: '" "',
    position: "absolute",
    top: "0",
    left: "0",
    width: "100%",
    height: "100%",
    border: "transparent",
    background: "likec4.palette.fill",
    backgroundClip: "padding-box",
    transitionDelay: ".075ms"
  },
  _noReduceGraphics: {
    _before: {
      transition: "all {durations.slow} {easings.inOut}"
    },
    "&[data-likec4-hovered='true']": {
      _before: {
        transitionDelay: ".2s",
        transitionTimingFunction: "in"
      }
    }
  },
  "&:is([data-compound-transparent])": {
    _before: {
      opacity: compoundOpacity.ref,
      borderWidth: `calc(${borderWidth.ref} - 1px)`
    }
  }
}), compoundBorder = css.raw({
  borderRadius: borderRadius$1.ref,
  padding: "0",
  margin: "0",
  transition: "all 250ms {easings.inOut}",
  cursor: "default",
  position: "absolute",
  top: "0",
  left: "0",
  width: "100%",
  height: "100%",
  pointerEvents: "none",
  background: "transparent",
  borderStyle: "dashed",
  borderWidth: `[${borderWidth.ref}]`,
  borderColor: `[color-mix(in srgb, {colors.likec4.palette.stroke} ${borderOpacityPercent.ref}, transparent)]`
}), indicatorSvg = css.raw({
  position: "absolute",
  top: "0",
  left: "0",
  width: "100%",
  height: "100%",
  pointerEvents: "none",
  overflow: "visible",
  visibility: "hidden",
  _whenFocused: {
    visibility: "visible"
  },
  _whenSelected: {
    visibility: "visible"
  },
  _whenPanning: {
    display: "none"
  }
}), indicatorRect = css.raw({
  stroke: "[color-mix(in srgb, {colors.likec4.palette.stroke} 60%, {colors.likec4.palette.hiContrast})]",
  strokeWidth: "4",
  fill: "[none]",
  animationStyle: "indicator",
  _light: {
    stroke: "[color-mix(in srgb, {colors.likec4.palette.stroke} 80%, {colors.likec4.palette.hiContrast})]"
  }
}), compound = sva({
  slots: ["root", "compoundBorder", "indicatorSvg", "indicatorRect"],
  className: "compound-container",
  base: {
    root: root$2,
    compoundBorder,
    indicatorSvg,
    indicatorRect
  },
  variants: {
    isTransparent: {
      false: {
        root: {
          _before: {
            boxShadow: {
              _noReduceGraphics: "0 4px 10px 0.5px rgba(0,0,0,0.1) , 0 2px 2px -1px rgba(0,0,0,0.4)",
              _whenSelected: "none",
              _whenPanning: "none !important"
            }
          }
        }
      },
      true: {
        root: {}
      }
    }
  }
});
function CompoundNodeContainer({
  nodeProps: {
    selected: isSelected2 = !1,
    data: {
      hovered: isHovered = !1,
      dimmed: isDimmed = !1,
      ...data
    }
  },
  children: children2,
  style: style2,
  ...rest
}) {
  const isReducedGraphics = useIsReducedGraphics(), isTransparent = e$2(data.style.opacity) && data.style.opacity < 99;
  let opacity = u((data.style.opacity ?? 100) / 100, {
    min: 0,
    max: 1
  });
  isTransparent && isHovered && !isReducedGraphics && (opacity = Math.min(opacity + 0.08, 1));
  const MIN_OPACITY = 65, borderOpacity = MIN_OPACITY + u((100 - MIN_OPACITY) * opacity, {
    min: 0,
    max: 100 - MIN_OPACITY
  }), classes2 = compound({
    isTransparent
  }), depth = u(data.depth ?? 1, {
    min: 1,
    max: 5
  });
  return /* @__PURE__ */ jsxs(
    m$2.div,
    {
      className: cx(
        css({
          likec4Palette: `${data.color}.${depth}`
        }),
        classes2.root,
        "likec4-compound-node"
      ),
      initial: !1,
      "data-likec4-hovered": isHovered,
      "data-likec4-color": data.color,
      "data-compound-depth": depth,
      ...isTransparent && {
        "data-compound-transparent": !0,
        "data-compound-title-inverse": opacity < 0.5
      },
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        ...style2,
        // @ts-expect-error
        [compoundOpacity.var]: opacity,
        [borderWidth.var]: "3px",
        [borderRadius$1.var]: "6px",
        [borderOpacityPercent.var]: `${borderOpacity}%`
      },
      ...rest,
      children: [
        isTransparent && data.style.border !== "none" && /* @__PURE__ */ jsx(
          "div",
          {
            className: classes2.compoundBorder,
            style: {
              borderStyle: data.style.border ?? "dashed"
            }
          }
        ),
        /* @__PURE__ */ jsx("svg", { className: classes2.indicatorSvg, children: /* @__PURE__ */ jsx(
          "rect",
          {
            className: classes2.indicatorRect,
            x: 0,
            y: 0,
            width: "100%",
            height: "100%",
            rx: 6
          }
        ) }),
        children2
      ]
    }
  );
}
const titleContainer = css({
  position: "absolute",
  display: "flex",
  alignItems: "center",
  gap: "6px",
  left: "14px",
  top: "4px",
  right: "30px",
  width: "auto",
  minHeight: "30px",
  ":where(.react-flow__node.draggable) &": {
    pointerEvents: "all",
    cursor: "grab"
  },
  ".likec4-compound-node:has(.compound-action) &": {
    paddingLeft: "22px"
  }
}), titleText = css({
  flex: "1",
  fontFamily: "likec4.compound",
  fontWeight: 600,
  fontSize: "15px",
  textTransform: "uppercase",
  letterSpacing: "0.2px",
  color: "likec4.palette.loContrast",
  "[data-compound-title-inverse] &": {
    color: {
      base: "[color-mix(in srgb, {colors.likec4.palette.loContrast} 60%, {colors.likec4.palette.fill})]",
      _light: "likec4.palette.stroke"
    }
  }
}), iconSize$3 = "20px", cssIcon = css({
  flex: `0 0 ${iconSize$3}`,
  height: `${iconSize$3}`,
  width: `${iconSize$3}`,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  mixBlendMode: {
    base: "hard-light",
    _reduceGraphicsOnPan: "normal"
  },
  "& svg, & img": {
    width: "100%",
    height: "auto",
    maxHeight: "100%",
    pointerEvents: "none",
    filter: {
      base: [
        "drop-shadow(0 0 3px rgb(0 0 0 / 12%))",
        "drop-shadow(0 1px 8px rgb(0 0 0 / 8%))",
        "drop-shadow(1px 1px 16px rgb(0 0 0 / 3%))"
      ],
      _reduceGraphicsOnPan: "none"
    }
  },
  "& img": {
    objectFit: "contain"
  }
});
function CompoundTitle({ id: id2, data }) {
  const elementIcon2 = IconRenderer({
    element: {
      id: id2,
      title: data.title,
      icon: data.icon
    },
    className: cssIcon
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      className: cx(
        titleContainer,
        "likec4-compound-title"
      ),
      children: [
        elementIcon2,
        /* @__PURE__ */ jsx(Text, { className: titleText, truncate: "end", children: data.title })
      ]
    }
  );
}
const isSame = (a2, b2) => Math.abs(a2 - b2) < 2.5, edgePropsEqual = (prev, next) => prev.id === next.id && deepEqual(prev.selected ?? !1, next.selected ?? !1) && deepEqual(prev.animated ?? !1, next.animated ?? !1) && deepEqual(prev.source, next.source) && deepEqual(prev.sourceHandleId ?? null, next.sourceHandleId ?? null) && deepEqual(prev.sourcePosition, next.sourcePosition) && deepEqual(prev.target, next.target) && deepEqual(prev.targetHandleId ?? null, next.targetHandleId ?? null) && deepEqual(prev.targetPosition, next.targetPosition) && isSame(prev.sourceX, next.sourceX) && isSame(prev.sourceY, next.sourceY) && isSame(prev.targetX, next.targetX) && isSame(prev.targetY, next.targetY) && deepEqual(prev.data, next.data);
function customEdge(Edge) {
  return memo$2(Edge, edgePropsEqual);
}
const nodePropsEqual = (prev, next) => prev.id === next.id && deepEqual(prev.selected ?? !1, next.selected ?? !1) && deepEqual(prev.dragging ?? !1, next.dragging ?? !1) && deepEqual(prev.width ?? 0, next.width ?? 0) && deepEqual(prev.height ?? 0, next.height ?? 0) && deepEqual(prev.zIndex ?? 0, next.zIndex ?? 0) && deepEqual(prev.data, next.data);
function customNode(Node2) {
  return memo$2(Node2, nodePropsEqual);
}
const isSelected$1 = ".react-flow__edge.selected", edgeStroke = "--xy-edge-stroke", edgeStrokeSelected = "--xy-edge-stroke-selected", labelColor = "--xy-edge-label-color", labelBg = "--xy-edge-label-background-color", edgeVars = css({
  [edgeStroke]: "{colors.likec4.relation.stroke}",
  [edgeStrokeSelected]: "{colors.likec4.relation.stroke.selected}",
  [labelColor]: {
    base: "{colors.likec4.relation.label}",
    _light: "color-mix(in srgb, {colors.likec4.relation.label}, rgba(255 255 255 / 0.85) 40%)"
  },
  [labelBg]: {
    _light: "{colors.likec4.relation.label.bg/60}",
    _dark: "{colors.likec4.relation.label.bg/50}"
  },
  "--xy-edge-stroke-width": "3",
  "&:is([data-likec4-hovered='true'],[data-edge-active='true'])": {
    [edgeStroke]: "{colors.likec4.relation.stroke.selected}",
    _whenSelected: {
      "--xy-edge-stroke-width": "4"
    }
  }
}), edgeContainer = css({
  _reduceGraphics: {
    transition: "none"
  }
}), _hideOnReducedGraphics = css.raw({
  _reduceGraphicsOnPan: {
    display: "none"
  },
  _smallZoom: {
    display: "none"
  }
}), hideOnReducedGraphics = css(_hideOnReducedGraphics), edgePathBg = css(_hideOnReducedGraphics, {
  fill: "[none]",
  strokeWidth: "calc(var(--xy-edge-stroke-width) + 2)",
  strokeOpacity: 0.08,
  transitionProperty: "stroke-width, stroke-opacity",
  transitionDuration: "fast",
  transitionTimingFunction: "inOut",
  _whenHovered: {
    transitionTimingFunction: "out",
    strokeWidth: "calc(var(--xy-edge-stroke-width) + 4)",
    strokeOpacity: 0.2
  },
  _whenSelected: {
    strokeWidth: "calc(var(--xy-edge-stroke-width) + 6)",
    strokeOpacity: 0.25,
    _whenHovered: {
      strokeOpacity: 0.4
    }
  }
}), markerContext = css({
  fill: "[var(--xy-edge-stroke)]",
  stroke: "[var(--xy-edge-stroke)]"
}), cssEdgePath = css({
  fill: "[none!]",
  strokeDashoffset: 10,
  _noReduceGraphics: {
    transition: "stroke 130ms ease-out,stroke-width 130ms ease-out"
  },
  _whenHovered: {
    animationStyle: "xyedgeAnimated",
    animationDelay: "450ms"
  },
  [`:where(${isSelected$1}, [data-edge-active='true'], [data-edge-animated='true']) &`]: {
    animationStyle: "xyedgeAnimated",
    animationDelay: "0ms"
  },
  ":where([data-edge-dir='back']) &": {
    animationDirection: "reverse"
  },
  _whenDimmed: {
    animationPlayState: "paused"
  },
  _smallZoom: {
    animationName: "none"
  },
  _whenPanning: {
    strokeDasharray: "none !important",
    animationName: "none"
  }
}), aiBg = {
  var: "--ai-bg"
}, actionBtn = css({
  // zIndex: 'calc(var(--layer-overlays, 1) + 1)',
  pointerEvents: "all",
  // color: `xyedge.label`,
  cursor: "pointer",
  opacity: 0.75,
  transition: "fast",
  // backgroundColor: aiBg.ref,
  [aiBg.var]: "var(--xy-edge-label-background-color)",
  "--ai-hover": "color-mix(in srgb , var(--xy-edge-label-background-color), {colors.likec4.mixColor} 10%)",
  "--ai-size": "var(--ai-size-sm)",
  "--ai-radius": "var(--mantine-radius-sm)",
  _hover: {
    translateY: "1px",
    scale: 1.15
  },
  _active: {
    translateY: "-1px",
    scale: "0.9"
  },
  _whenHovered: {
    opacity: 1
  },
  "& .tabler-icon": {
    width: "80%",
    height: "80%",
    strokeWidth: "2"
  }
});
function EdgeActionButton({ icon: icon2, onClick }) {
  return /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      className: cx("nodrag nopan", actionBtn),
      onPointerDownCapture: stopPropagation$1,
      onClick,
      role: "button",
      onDoubleClick: stopPropagation$1,
      children: icon2 ?? /* @__PURE__ */ jsx(IconZoomScan, {})
    }
  );
}
function EdgeContainer({
  className,
  component = "g",
  data: {
    color: color2 = "gray",
    hovered: isHovered = !1,
    active: isActive = !1,
    dimmed: isDimmed = !1,
    ...data
  },
  children: children2,
  style: style2
}) {
  const props = {
    className: cx(
      css({
        likec4RelationPalette: color2
      }),
      edgeVars,
      edgeContainer,
      className
    ),
    "data-likec4-color": color2,
    "data-edge-dir": data.dir ?? "forward",
    "data-edge-active": isActive,
    "data-edge-animated": isActive,
    "data-likec4-hovered": isHovered,
    ...isDimmed !== !1 && {
      "data-likec4-dimmed": isDimmed
    }
  };
  return component === "svg" ? /* @__PURE__ */ jsx("svg", { style: style2, ...props, children: children2 }) : (invariant$2(component === "g", 'EdgeContainer: component must be "g" or "svg"'), /* @__PURE__ */ jsx("g", { style: style2, ...props, children: children2 }));
}
const labelBorderRadius = "4px";
css({
  position: "absolute",
  top: 4,
  right: 4
});
css({
  userSelect: "all",
  textAlign: "left",
  whiteSpaceCollapse: "preserve-breaks",
  textWrap: "pretty",
  lineHeight: "1.25",
  "--text-fz": "{fontSizes.sm}",
  md: {
    "--text-fz": "{fontSizes.md}"
  }
});
const translate = {
  var: "--edge-translate",
  ref: "var(--edge-translate)"
}, edgeLabelContainer = css({
  top: 0,
  left: 0,
  position: "absolute",
  pointerEvents: "all",
  cursor: "pointer",
  width: "auto",
  height: "auto",
  background: "[var(--xy-edge-label-background-color)]",
  color: "[var(--xy-edge-label-color)]",
  border: "0px solid transparent",
  borderRadius: labelBorderRadius,
  transform: `${translate.ref}`,
  transition: "fast",
  "&:is([data-likec4-hovered='true'])": {
    transition: "all 190ms {easings.inOut}",
    transform: "var(--edge-translate, translate(0px, 0px)) scale(1.12)",
    transitionDelay: "100ms"
  },
  _noReduceGraphics: {
    mixBlendMode: {
      _dark: "plus-lighter",
      _light: "screen"
    }
  },
  _smallZoom: {
    display: "none"
  },
  _reduceGraphicsOnPan: {
    display: "none"
  }
}), labelsva = sva({
  slots: ["root", "stepNumber", "labelContents", "labelText", "labelTechnology"],
  base: {
    root: {
      fontFamily: "likec4.relation",
      padding: "3px 5px 5px 5px",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      width: "max-content",
      maxWidth: "100%",
      gap: "4px"
    },
    stepNumber: {
      alignSelf: "stretch",
      flex: "0 0 auto",
      fontWeight: 600,
      fontSize: "14px",
      lineHeight: "1",
      padding: "5px 5px",
      textAlign: "center",
      minWidth: "22px",
      borderTopLeftRadius: labelBorderRadius,
      borderBottomLeftRadius: labelBorderRadius,
      background: "[color-mix(in srgb, {colors.likec4.relation.label.bg}, {colors.likec4.mixColor} 10%)]",
      fontVariantNumeric: "tabular-nums",
      // _dark: {
      ':where([data-likec4-color="gray"]) &': {
        _dark: {
          background: "[color-mix(in srgb, {colors.likec4.relation.label.bg}, {colors.likec4.mixColor} 15%)]"
        }
      }
    },
    labelContents: {
      display: "contents",
      _empty: {
        display: "none !important"
      }
    },
    labelText: {
      whiteSpaceCollapse: "preserve-breaks",
      fontSize: "14px",
      lineHeight: "1.185"
    },
    labelTechnology: {
      textAlign: "center",
      whiteSpaceCollapse: "preserve-breaks",
      fontSize: "11px",
      lineHeight: "1",
      opacity: 0.75
    }
  },
  variants: {
    isStepEdge: {
      false: {},
      true: {
        root: {
          flexDirection: "row",
          gap: "4px",
          padding: "0px"
        },
        labelContents: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          padding: "2px 5px 4px 0px"
        },
        labelText: {
          padding: "2px 6px 4px 0px"
        }
      }
    }
  },
  defaultVariants: {
    isStepEdge: !1
  }
});
function EdgeLabel({
  edgeProps: {
    id: id2,
    data: {
      label: label2,
      technology: technology2
    }
  },
  className,
  style: style2,
  children: children2,
  ...rest
}) {
  const stepNum = isStepEdgeId(id2) ? extractStep(id2) : null, classes2 = labelsva({
    isStepEdge: stepNum !== null
  });
  return /* @__PURE__ */ jsxs(Box, { className: cx(classes2.root, className), ...rest, children: [
    stepNum !== null && /* @__PURE__ */ jsx(Box, { className: classes2.stepNumber, children: stepNum }),
    /* @__PURE__ */ jsxs(Box, { className: classes2.labelContents, children: [
      n$5(label2) && /* @__PURE__ */ jsx(Text, { component: "div", className: classes2.labelText, lineClamp: 5, children: label2 }),
      n$5(technology2) && /* @__PURE__ */ jsx(Text, { component: "div", className: classes2.labelTechnology, children: "[ " + technology2 + " ]" }),
      children2
    ] })
  ] });
}
const toCssVarValue = (value) => {
  if (value !== void 0)
    return e$2(value) ? `${Math.round(value)}px` : value;
};
function EdgeLabelContainer({
  edgeProps: {
    id: id2,
    data: {
      hovered: isHovered = !1,
      active: isActive = !1,
      dimmed: isDimmed = !1,
      labelBBox,
      color: color2 = "gray"
    }
  },
  labelPosition: labelXY,
  className,
  style: style2,
  children: children2,
  ...rest
}) {
  let zIndex = ZIndexes.Edge;
  (isHovered || isActive) && (zIndex = ZIndexes.Element + 1);
  let labelX = labelXY?.x ?? labelBBox?.x, labelY = labelXY?.y ?? labelBBox?.y;
  if (labelX === void 0 || labelY === void 0)
    return null;
  const translate$1 = labelXY?.translate;
  return /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsx(
    "div",
    {
      className: cx(
        css({
          likec4RelationPalette: color2
        }),
        edgeVars,
        edgeLabelContainer,
        "nodrag nopan",
        "likec4-edge-label-container",
        className
      ),
      "data-likec4-hovered": isHovered,
      "data-likec4-color": color2,
      "data-edge-active": isActive,
      "data-edge-animated": isActive,
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        top: toCssVarValue(labelY),
        left: toCssVarValue(labelX),
        ...translate$1 && {
          [translate.var]: translate$1
        },
        ...labelBBox && {
          maxWidth: labelBBox.width + 18
        },
        zIndex,
        ...style2
      },
      ...rest,
      children: /* @__PURE__ */ jsx(
        "div",
        {
          style: {
            display: "contents"
          },
          // Work around to keep same global selector data-likec4-dimmed
          ...isDimmed !== !1 && {
            "data-likec4-dimmed": isDimmed
          },
          children: children2
        }
      )
    },
    id2
  ) }, id2);
}
const Open = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 14 16",
    refX: 5,
    refY: 4,
    markerWidth: "7",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M0,0 L7,4 L0,8 L4,4 Z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeDasharray: 0,
        strokeWidth: 1,
        strokeLinecap: "round"
      }
    )
  }
), Arrow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        fill: "context-stroke",
        strokeWidth: 0
      }
    )
  }
), Crow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 12",
    refX: 8,
    refY: 4,
    markerWidth: "8",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 8 0 L 0 4 L 8 8 M 8 4 L 0 4",
        fill: "none",
        strokeWidth: 1
      }
    )
  }
), OArrow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        strokeWidth: 1.25,
        strokeLinejoin: "miter",
        strokeLinecap: "square"
      }
    )
  }
), Diamond = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 5,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        fill: "context-stroke",
        strokeWidth: 0,
        strokeLinecap: "round"
      }
    )
  }
), ODiamond = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 6,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        strokeWidth: 1.25,
        strokeLinecap: "round"
      }
    )
  }
), Dot = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 0,
        fill: "context-stroke",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), ODot = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 1.25,
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), EdgeMarkers = {
  Arrow,
  Crow,
  OArrow,
  Open,
  Diamond,
  ODiamond,
  Dot,
  ODot
};
function arrowTypeToMarker(arrowType) {
  if (!(!arrowType || arrowType === "none"))
    switch (arrowType) {
      case "normal":
        return "Arrow";
      case "crow":
        return "Crow";
      case "onormal":
        return "OArrow";
      case "diamond":
        return "Diamond";
      case "odiamond":
        return "ODiamond";
      case "open":
      case "vee":
        return "Open";
      case "dot":
        return "Dot";
      case "odot":
        return "ODot";
      default:
        nonexhaustive(arrowType);
    }
}
const EdgePath = forwardRef(({
  edgeProps: {
    id: id2,
    data: {
      line,
      dir,
      tail,
      head
    },
    style: style2,
    interactionWidth
  },
  onEdgePointerDown,
  strokeWidth,
  svgPath
}, svgPathRef) => {
  let markerStartName = arrowTypeToMarker(tail), markerEndName = arrowTypeToMarker(head ?? "normal");
  dir === "back" && ([markerStartName, markerEndName] = [markerEndName, markerStartName]);
  const MarkerStart = markerStartName ? EdgeMarkers[markerStartName] : null, MarkerEnd = markerEndName ? EdgeMarkers[markerEndName] : null, isDotted = line === "dotted", isDashed = isDotted || line === "dashed";
  let strokeDasharray;
  return isDotted ? strokeDasharray = "1,8" : isDashed && (strokeDasharray = "8,10"), /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        className: cx(
          "react-flow__edge-interaction",
          hideOnReducedGraphics,
          css({
            fill: "[none]",
            strokeOpacity: 0
          })
        ),
        d: svgPath,
        strokeWidth: interactionWidth ?? 10
      }
    ),
    /* @__PURE__ */ jsxs("g", { className: markerContext, onPointerDown: onEdgePointerDown, children: [
      /* @__PURE__ */ jsxs("defs", { children: [
        MarkerStart && /* @__PURE__ */ jsx(MarkerStart, { id: "start" + id2 }),
        MarkerEnd && /* @__PURE__ */ jsx(MarkerEnd, { id: "end" + id2 })
      ] }),
      /* @__PURE__ */ jsx(
        "path",
        {
          className: cx("react-flow__edge-path", edgePathBg),
          d: svgPath,
          style: style2,
          strokeLinecap: "round"
        }
      ),
      /* @__PURE__ */ jsx(
        "path",
        {
          ref: svgPathRef,
          className: cx(
            "react-flow__edge-path",
            "react-flow__edge-interaction",
            cssEdgePath
          ),
          d: svgPath,
          style: style2,
          strokeWidth,
          strokeLinecap: "round",
          strokeDasharray,
          markerStart: MarkerStart ? `url(#start${id2})` : void 0,
          markerEnd: MarkerEnd ? `url(#end${id2})` : void 0
        }
      )
    ] })
  ] });
}), container$4 = css({
  position: "absolute",
  top: "calc(100% - 28px)",
  // transform: 'translateY(-100%)',
  left: 0,
  width: "100%",
  minHeight: "28px",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  _smallZoom: {
    display: "none"
  }
  // zIndex: 10,
}), actionButtons = css({
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
function ElementActionButtons({
  selected: selected2 = !1,
  data: {
    hovered: isHovered = !1
  },
  buttons: buttons2
}) {
  const id2 = useId$1(), zoomTooSmall = useIsZoomTooSmall();
  return !buttons2.length || zoomTooSmall ? null : /* @__PURE__ */ jsx(Box$1, { className: container$4, children: /* @__PURE__ */ jsx(
    Box$1,
    {
      component: MotionDiv,
      layoutRoot: !0,
      initial: !1,
      style: {
        originY: 0,
        gap: "8px"
      },
      animate: {
        opacity: isHovered || selected2 ? 1 : 0.75,
        scale: isHovered ? 1.1 : selected2 ? 0.9 : 0.8,
        y: isHovered || selected2 ? 6 : 0
      },
      "data-likec4-hovered": isHovered,
      className: cx("nodrag nopan", actionButtons),
      children: buttons2.map((button2, index2) => /* @__PURE__ */ jsx(
        ActionIcon$1,
        {
          component: MotionButton,
          className: actionBtn$1({}),
          initial: !1,
          whileTap: { scale: 1 },
          whileHover: {
            scale: 1.3
          },
          onClick: button2.onClick,
          onDoubleClick: stopPropagation$1,
          children: button2.icon
        },
        `${id2}-${button2.key ?? index2}`
      ))
    },
    `${id2}-action-buttons`
  ) });
}
const container$3 = css({
  position: "absolute",
  top: 2,
  right: 2,
  _shapeBrowser: {
    right: "5px"
  },
  _shapeCylinder: {
    top: "14px"
  },
  _shapeStorage: {
    top: "14px"
  },
  _shapeQueue: {
    top: "1px",
    right: "12px"
  },
  _smallZoom: {
    display: "none"
  }
});
function ElementDetailsButton({
  selected: selected2 = !1,
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  const id2 = useId$1();
  return /* @__PURE__ */ jsx(Box$1, { className: cx(container$3, "details-button"), children: /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      className: cx("nodrag nopan", actionBtn$1({ variant: "transparent" })),
      component: MotionButton,
      initial: !1,
      style: {
        originX: 0.45,
        originY: 0.55
      },
      animate: isHovered || selected2 ? {
        scale: 1.2,
        opacity: 0.8
      } : {
        scale: 1,
        opacity: 0.5
      },
      whileHover: {
        scale: 1.4,
        opacity: 1
      },
      whileTap: { scale: 1.15 },
      onClick,
      onDoubleClick: stopPropagation$1,
      children: icon2 ?? /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
    },
    id2
  ) });
}
const container$2 = css({
  position: "relative",
  width: "100%",
  height: "100%",
  padding: 0,
  margin: 0,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  pointerEvents: "none",
  _before: {
    content: '" "',
    position: "absolute",
    top: "calc(100% - 4px)",
    left: 0,
    width: "100%",
    height: "24px",
    background: "[transparent]",
    pointerEvents: "all"
  },
  _focusVisible: {
    outline: "none"
  },
  // _whenDimmed: {
  //   opacity: 0.25,
  //   transition: `opacity 400ms {easings.inOut}, filter 500ms {easings.inOut}`,
  //   transitionDelay: '50ms',
  //   grayscale: 0.85,
  //   blur: '2px',
  //   // filter: `grayscale(0.85) ${fallbackVar(vars.safariAnimationHook, 'blur(2px)')}`,
  // },
  // _whenDimmedImmediate: {
  //   opacity: 0.25,
  //   grayscale: 0.85,
  //   blur: '2px',
  //   // transition: `opacity 100ms ${easings.inOut}, filter 100ms ${easings.inOut}`,
  //   // filter: `grayscale(0.85) ${fallbackVar(vars.safariAnimationHook, 'blur(2px)')}`,
  // },
  _reduceGraphicsOnPan: {
    _before: {
      display: "none"
    }
  },
  ":where(.react-flow__node.selectable:not(.dragging)) &": {
    cursor: "pointer"
  }
});
function nodeSizes({
  size: size2,
  padding,
  textSize
}) {
  return !size2 && textSize && (size2 = textSize), !textSize && size2 && (textSize = size2), !padding && size2 && (padding = size2), size2 ??= DefaultShapeSize, textSize ??= DefaultTextSize, padding ??= DefaultPaddingSize, {
    size: size2,
    padding,
    textSize
  };
}
const ElementNodeContainer = forwardRef(({
  nodeProps: {
    selected: selected2 = !1,
    selectable = !1,
    data: {
      hovered: isHovered = !1,
      dimmed: isDimmed = !1,
      ...data
    }
  },
  style: style2,
  children: children2,
  ...rest
}, ref) => {
  let scale2 = 1;
  switch (!0) {
    case isHovered:
      scale2 = 1.05;
      break;
    case selected2:
      scale2 = 1.02;
      break;
  }
  const {
    size: size2,
    padding,
    textSize
  } = nodeSizes(data.style);
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: MotionDiv,
      ref,
      className: cx(
        css({
          likec4Palette: data.color
        }),
        container$2,
        "group",
        "likec4-element-node"
      ),
      initial: !1,
      ...selectable && {
        animate: {
          scale: scale2
        },
        whileTap: { scale: 0.98 }
      },
      "data-likec4-hovered": isHovered,
      "data-likec4-color": data.color,
      "data-likec4-shape": data.shape,
      "data-likec4-shape-size": size2,
      "data-likec4-spacing": padding,
      "data-likec4-text-size": textSize,
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        ...style2
      },
      ...rest,
      children: children2
    }
  );
});
ElementNodeContainer.displayName = "ElementNodeContainer";
const indicator = css({
  _smallZoom: {
    visibility: "hidden"
  },
  stroke: "likec4.palette.loContrast",
  fill: "[none]",
  strokeWidth: 8,
  strokeOpacity: 0.8,
  visibility: "hidden",
  pointerEvents: "none",
  _light: {
    stroke: "[color-mix(in srgb, {colors.likec4.palette.fill} 50%,rgb(121, 121, 121))]"
  },
  _whenFocused: {
    visibility: "visible"
  },
  _groupFocusVisible: {
    visibility: "visible"
  },
  _whenSelected: {
    animationStyle: "indicator",
    visibility: "visible"
  }
}), fillElementFill = css({
  fill: "likec4.palette.fill"
});
css({
  fill: "likec4.palette.stroke"
});
const fillMixStroke = css({
  fill: "[color-mix(in srgb, {colors.likec4.palette.stroke} 90%, {colors.likec4.palette.fill})]",
  ".shape-svg-multiple &": {
    fill: "likec4.palette.fill"
  }
}), shapeBase = css.raw({
  top: 0,
  left: 0,
  position: "absolute",
  width: "100%",
  height: "100%",
  pointerEvents: "none",
  fill: "likec4.palette.fill",
  stroke: "likec4.palette.stroke",
  overflow: "visible"
  // zIndex is removed to improve rendering performance
  // this forces to keep shape in the same layer as the node
  // zIndex: -1,
}), shapeSvgMultiple = cx(
  "shape-svg-multiple",
  css(shapeBase, {
    transformOrigin: {
      base: "50% 50%",
      _shapeQueue: "75% 25%",
      _shapeCylinder: "50% 100%",
      _shapeStorage: "50% 100%"
    },
    transform: "translate(14px, 14px) perspective(300px) translateZ(-8px)",
    filter: "brightness(0.65) saturate(0.8)",
    stroke: "[none]",
    display: {
      _smallZoom: "none",
      _reduceGraphicsOnPan: "none",
      _whenSelected: "none",
      _whenFocused: "none"
    }
  })
), shapeSvg = css(shapeBase, {
  transition: "fill 120ms linear, filter 130ms {easings.inOut}",
  transitionDelay: "0ms",
  filter: `
      drop-shadow(0 2px 1px rgba(0, 0, 0, 0.21))
      drop-shadow(0 1px 1px color-mix(in srgb, {colors.likec4.palette.stroke} 40%, transparent))
      drop-shadow(0 5px 3px rgba(0, 0, 0, 0.1))
    `,
  _whenHovered: {
    filter: `
        drop-shadow(0 2px 1px rgba(0, 0, 0, 0.25))
        drop-shadow(0 8px 3px rgba(0, 0, 0, 0.1))
        drop-shadow(0 10px 10px rgba(0, 0, 0, 0.05))
        `
  },
  ":where([data-likec4-level='true']) &": {
    filter: `
        drop-shadow(0 2px 1px rgba(0, 0, 0, 0.25))
        drop-shadow(0 8px 3px rgba(0, 0, 0, 0.1))
        drop-shadow(0 10px 10px rgba(0, 0, 0, 0.05))
        `
  },
  _whenSelected: {
    filter: "none"
  },
  _smallZoom: {
    filter: "none"
  },
  _whenPanning: {
    transition: "none",
    filter: "none"
  }
});
function cylinderSVGPath(diameter, height, tilt = 0.065) {
  const radius = Math.round(diameter / 2), rx = radius, ry = toDomPrecision(tilt * radius), tiltAdjustedHeight = height - 2 * ry;
  return {
    path: `  M ${diameter},${ry}
        a ${rx},${ry} 0,0,0 ${-diameter} 0
        l 0,${tiltAdjustedHeight}
        a ${rx},${ry} 0,0,0 ${diameter} 0
        l 0,${-tiltAdjustedHeight}
        z
        `.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
function queueSVGPath(width, height, tilt = 0.185) {
  const diameter = height, ry = Math.round(diameter / 2), rx = toDomPrecision(diameter / 2 * tilt), tiltAdjustedWidth = width - 2 * rx;
  return {
    path: `
    M ${rx},0
    a ${rx},${ry} 0,0,0 0 ${diameter}
    l ${tiltAdjustedWidth},0
    a ${rx},${ry} 0,0,0 0 ${-diameter}
    z`.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
const PersonIcon = {
  width: 115,
  height: 120,
  path: "M57.9197 0C10.9124 0 33.5766 54.75 33.5766 54.75C38.6131 62.25 45.3285 60.75 45.3285 66C45.3285 70.5 39.4526 72 33.5766 72.75C24.3431 72.75 15.9489 71.25 7.55474 84.75C2.51825 93 0 120 0 120H115C115 120 112.482 93 108.285 84.75C99.8905 70.5 91.4963 72.75 82.2628 72C76.3869 71.25 70.5109 69.75 70.5109 65.25C70.5109 60.75 77.2263 62.25 82.2628 54C82.2628 54.75 104.927 0 57.9197 0V0Z"
};
function ElementShapeSvg({ shape, w, h }) {
  switch (shape) {
    case "mobile":
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            className: fillMixStroke,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { className: fillElementFill, strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 17, cy: h / 2, r: 12 }),
          /* @__PURE__ */ jsx("rect", { x: 33, y: 12, width: w - 44, height: h - 24, rx: 5 })
        ] })
      ] });
    case "browser":
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            className: fillMixStroke,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { className: fillElementFill, strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 16, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 36, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 56, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("rect", { x: 70, y: 8, width: w - 80, height: 17, rx: 4 }),
          /* @__PURE__ */ jsx("rect", { x: 10, y: 32, width: w - 20, height: h - 42, rx: 4 })
        ] })
      ] });
    case "person":
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsx(
          "svg",
          {
            x: w - PersonIcon.width - 6,
            y: h - PersonIcon.height,
            width: PersonIcon.width,
            height: PersonIcon.height,
            viewBox: `0 0 ${PersonIcon.width} ${PersonIcon.height}`,
            className: fillMixStroke,
            children: /* @__PURE__ */ jsx(
              "path",
              {
                strokeWidth: 0,
                d: PersonIcon.path
              }
            )
          }
        )
      ] });
    case "queue": {
      const { path, rx, ry } = queueSVGPath(w, h);
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx("ellipse", { cx: rx, cy: ry, ry: ry - 0.75, rx, className: fillMixStroke, strokeWidth: 2 })
      ] });
    }
    case "storage":
    case "cylinder": {
      const { path, rx, ry } = cylinderSVGPath(w, h);
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx("ellipse", { cx: rx, cy: ry, ry, rx: rx - 0.75, className: fillMixStroke, strokeWidth: 2 })
      ] });
    }
    case "rectangle":
      return /* @__PURE__ */ jsx(
        "rect",
        {
          width: w,
          height: h,
          rx: 6,
          strokeWidth: 0
        }
      );
    default:
      return nonexhaustive(shape);
  }
}
function ElementShape({ data, width, height, isMultiple = !1, withSelectedIndicator = !0 }) {
  let w = width && width > 10 ? width : data.width, h = height && height > 10 ? height : data.height;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    isMultiple && /* @__PURE__ */ jsx("svg", { className: clsx(shapeSvgMultiple), viewBox: `0 0 ${w} ${h}`, children: /* @__PURE__ */ jsx(ElementShapeSvg, { shape: data.shape, w, h }) }),
    /* @__PURE__ */ jsxs("svg", { className: shapeSvg, viewBox: `0 0 ${w} ${h}`, children: [
      withSelectedIndicator && /* @__PURE__ */ jsx(SelectedIndicator, { shape: data.shape, w, h }),
      /* @__PURE__ */ jsx(ElementShapeSvg, { shape: data.shape, w, h })
    ] })
  ] });
}
function SelectedIndicator({ shape, w, h }) {
  let svg;
  switch (shape) {
    case "queue":
      svg = /* @__PURE__ */ jsx("path", { d: queueSVGPath(w, h).path });
      break;
    case "storage":
    case "cylinder": {
      svg = /* @__PURE__ */ jsx("path", { d: cylinderSVGPath(w, h).path });
      break;
    }
    default: {
      svg = /* @__PURE__ */ jsx(
        "rect",
        {
          x: -1,
          y: -1,
          width: w + 2,
          height: h + 2,
          rx: 6
        }
      );
      break;
    }
  }
  return /* @__PURE__ */ jsx("g", { className: indicator, children: svg });
}
const iconSize$2 = "--icon-size", title$4 = css.raw({
  textStyle: "likec4.node.primary",
  flex: "0 0 auto",
  textAlign: "center",
  color: "likec4.palette.hiContrast"
}), description$2 = css.raw({
  flex: "0 1 auto",
  textStyle: "likec4.node.secondary",
  color: "likec4.palette.loContrast",
  textAlign: "center",
  textOverflow: "ellipsis",
  overflow: "hidden",
  _shapeSizeXs: {
    display: "none"
  },
  _smallZoom: {
    display: "none"
  }
}), technology = css.raw({
  flex: "0 0 auto",
  textStyle: "likec4.node.secondary",
  color: "likec4.palette.loContrast",
  fontSize: "calc(var(--likec4-text-size) * 0.635)",
  lineHeight: 1.125,
  textAlign: "center",
  textWrap: "balance",
  opacity: 0.92,
  _whenHovered: {
    opacity: 1
  },
  _shapeSizeXs: {
    display: "none"
  },
  _shapeSizeSm: {
    display: "none"
  },
  _smallZoom: {
    display: "none"
  }
}), varIconSize = `var(${iconSize$2})`, elementIcon$2 = css({
  flex: `0 0 ${varIconSize}`,
  height: varIconSize,
  width: varIconSize,
  display: "flex",
  alignSelf: "flex-start",
  alignItems: "center",
  justifyContent: "center",
  mixBlendMode: {
    base: "hard-light",
    _reduceGraphicsOnPan: "normal"
  },
  "& svg, & img": {
    width: "100%",
    height: "auto",
    maxHeight: "100%",
    pointerEvents: "none",
    filter: {
      base: [
        "drop-shadow(0 0 3px rgb(0 0 0 / 12%))",
        "drop-shadow(0 1px 8px rgb(0 0 0 / 8%))",
        "drop-shadow(1px 1px 16px rgb(0 0 0 / 3%))"
      ],
      _reduceGraphicsOnPan: "none"
    }
  },
  "& img": {
    objectFit: "contain"
  }
}), elementTitle = sva({
  slots: ["root", "textContainer", "title", "description", "technology"],
  base: {
    root: {
      position: "relative",
      flex: "1",
      height: "fit-content",
      width: "fit-content",
      margin: "0 auto",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "row",
      paddingTop: "var(--likec4-spacing)",
      paddingBottom: "var(--likec4-spacing)",
      paddingLeft: "calc(var(--likec4-spacing) + 8px)",
      paddingRight: "calc(var(--likec4-spacing) + 8px)",
      overflow: "hidden",
      pointerEvents: "none",
      gap: "12px",
      _shapeQueue: {
        paddingLeft: "46px",
        paddingRight: "16px"
      },
      _shapeMobile: {
        paddingLeft: "46px",
        paddingRight: "16px"
      },
      _shapeCylinder: {
        paddingTop: "30px"
      },
      _shapeStorage: {
        paddingTop: "30px"
      },
      _shapeBrowser: {
        paddingTop: "32px",
        paddingBottom: "28px"
      },
      _shapeSizeXs: {
        [iconSize$2]: "24px"
      },
      _shapeSizeSm: {
        [iconSize$2]: "36px"
      },
      _shapeSizeMd: {
        [iconSize$2]: "60px"
      },
      _shapeSizeLg: {
        [iconSize$2]: "82px",
        gap: "16px"
      },
      _shapeSizeXl: {
        [iconSize$2]: "90px",
        gap: "16px"
      }
    },
    textContainer: {
      height: "fit-content",
      width: "fit-content",
      flex: "0 1 auto",
      display: "flex",
      flexDirection: "column",
      alignItems: "stretch",
      justifyContent: "center",
      flexWrap: "nowrap",
      overflow: "hidden",
      gap: "8px"
    },
    title: title$4,
    description: description$2,
    technology
  },
  variants: {
    hasIcon: {
      false: {},
      true: {
        root: {
          gap: "16px"
        },
        textContainer: {
          minWidth: `calc(50% + ${varIconSize})`,
          alignItems: "flex-start"
        },
        title: {
          textAlign: "left"
        },
        description: {
          textAlign: "left"
        },
        technology: {
          textAlign: "left"
        }
      }
    },
    hasDescription: {
      false: {},
      true: {}
    },
    hasTechnology: {
      false: {},
      true: {}
    }
  },
  compoundVariants: [
    {
      hasDescription: !0,
      hasTechnology: !0,
      css: {
        textContainer: {
          gap: "6px"
        }
      }
    }
  ],
  defaultVariants: {
    hasIcon: !1
  }
});
function ElementTitle({ id: id2, data, iconSize: iconSize2 }) {
  const elementIcon2 = IconRenderer({
    element: {
      id: id2,
      title: data.title,
      icon: data.icon
    },
    className: elementIcon$2
  }), classes2 = elementTitle({
    hasIcon: n$5(elementIcon2),
    hasDescription: !n$3(data.description ?? ""),
    hasTechnology: !n$3(data.technology ?? "")
  }), size2 = nodeSizes(data.style).size, isSmOrXs = size2 === "sm" || size2 === "xs";
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      className: cx(
        classes2.root,
        "likec4-element"
      ),
      style: {
        ...e$2(iconSize2) && {
          [iconSize$2]: `${iconSize2}px`
        }
      },
      children: [
        elementIcon2,
        /* @__PURE__ */ jsxs(Box$1, { className: cx(classes2.textContainer, "likec4-element-main-props"), children: [
          /* @__PURE__ */ jsx(
            Text,
            {
              component: "h3",
              className: cx(classes2.title, "likec4-element-title"),
              lineClamp: isSmOrXs ? 2 : 3,
              children: data.title
            }
          ),
          data.technology && /* @__PURE__ */ jsx(
            Text,
            {
              component: "div",
              className: cx(classes2.technology, "likec4-element-technology"),
              children: data.technology
            }
          ),
          data.description && /* @__PURE__ */ jsx(
            Text,
            {
              component: "div",
              className: cx(classes2.description, "likec4-element-description"),
              lineClamp: isSmOrXs ? 3 : 5,
              children: data.description
            }
          )
        ] })
      ]
    }
  );
}
const style = {
  top: "50%",
  left: "50%",
  visibility: "hidden"
}, DefaultHandles = () => /* @__PURE__ */ jsxs(Fragment$1, { children: [
  /* @__PURE__ */ jsx(Handle, { type: "target", position: Position.Top, style }),
  /* @__PURE__ */ jsx(Handle, { type: "source", position: Position.Bottom, style })
] });
class VectorImpl {
  constructor(x2, y2) {
    this.x = x2, this.y = y2;
  }
  static create(position) {
    return new VectorImpl(position.x, position.y);
  }
  static add(a2, b2) {
    return { x: a2.x + b2.x, y: a2.y + b2.y };
  }
  static sub(a2, b2) {
    return { x: a2.x - b2.x, y: a2.y - b2.y };
  }
  static mul(a2, b2) {
    return { x: a2.x * b2, y: a2.y * b2 };
  }
  static dot(a2, b2) {
    return a2.x * b2.x + a2.y * b2.y;
  }
  static cross(a2, b2) {
    return new VectorImpl(a2.y * b2.x - a2.x * b2.y, a2.x * b2.y - a2.y * b2.x);
  }
  static setLength(a2, length) {
    return vector(a2).setLength(length);
  }
  add(b2) {
    return new VectorImpl(this.x + b2.x, this.y + b2.y);
  }
  sub(b2) {
    return new VectorImpl(this.x - b2.x, this.y - b2.y);
  }
  mul(b2) {
    return new VectorImpl(this.x * b2, this.y * b2);
  }
  dot(b2) {
    return this.x * b2.x + this.y * b2.y;
  }
  cross(b2) {
    return new VectorImpl(this.y * b2.x - this.x * b2.y, this.x * b2.y - this.y * b2.x);
  }
  abs() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  setLength(length) {
    return this.mul(length / this.abs());
  }
}
function vector(source) {
  return VectorImpl.create(source);
}
const isSelected = ".react-flow__edge.selected", controlPointsContainer = css({
  overflow: "visible",
  position: "absolute",
  pointerEvents: "none",
  top: 0,
  left: 0,
  mixBlendMode: "normal"
}), controlPoint = css({
  fill: "likec4.relation.stroke",
  stroke: "likec4.relation.stroke",
  fillOpacity: 0.75,
  strokeWidth: 1,
  cursor: "grab",
  pointerEvents: "auto",
  visibility: "hidden",
  _hover: {
    fillOpacity: 1,
    stroke: "mantine.colors.primary.filledHover",
    strokeWidth: 10,
    transition: "stroke 100ms ease-out, stroke-width 100ms ease-out"
  },
  [`:where(${isSelected}, [data-likec4-hovered='true']) &`]: {
    visibility: "visible",
    transition: "fill-opacity 150ms ease-out, stroke 150ms ease-out, stroke-width 150ms ease-out",
    transitionDelay: "50ms",
    fillOpacity: 1,
    strokeWidth: 5
  }
}), controlDragging = css({
  cursor: "grabbing",
  "& *": {
    cursor: "grabbing !important"
  },
  "& .react-flow__edge-interaction": {
    cursor: "grabbing !important"
  }
});
function useMantinePortalProps() {
  const target = useRootContainer();
  return useMemo(() => target ? { portalProps: { target }, withinPortal: !0 } : { withinPortal: !1 }, [target]);
}
const edgeNoteCloseButton = css({
  position: "absolute",
  top: 1,
  right: 1,
  zIndex: 9
}), edgeNoteText = css({
  userSelect: "all",
  textAlign: "left",
  whiteSpaceCollapse: "preserve-breaks",
  textWrap: "pretty",
  lineHeight: 1.25,
  "--text-fz": "{fontSizes.sm}",
  md: {
    "--text-fz": "{fontSizes.md}"
  }
}), NotePopover = ({ notes, children: children2 }) => {
  const {
    isActive,
    isParallel,
    hasNext,
    hasPrevious
  } = useDiagramContext((s2) => ({
    isActive: n$2(s2.activeWalkthrough),
    isParallel: n$5(s2.activeWalkthrough?.parallelPrefix),
    hasNext: s2.xyedges.findIndex((e2) => e2.id === s2.activeWalkthrough?.stepId) < s2.xyedges.length - 1,
    hasPrevious: s2.xyedges.findIndex((e2) => e2.id === s2.activeWalkthrough?.stepId) > 0
  })), diagram = useDiagram(), [isOpened, setIsOpened] = useState(!1), portalProps = useMantinePortalProps();
  return useDebouncedEffect(
    () => {
      setIsOpened(!0);
    },
    [],
    300
  ), /* @__PURE__ */ jsxs(
    Popover,
    {
      shadow: "xs",
      offset: 16,
      opened: isOpened,
      closeOnClickOutside: !1,
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: children2 }),
        /* @__PURE__ */ jsxs(
          PopoverDropdown,
          {
            component: Stack,
            p: "xs",
            onPointerDownCapture: stopPropagation$1,
            onClick: stopPropagation$1,
            onDoubleClick: stopPropagation$1,
            children: [
              /* @__PURE__ */ jsx(ScrollAreaAutosize, { miw: 180, maw: 450, mah: 350, type: "scroll", mx: "auto", mt: 2, children: /* @__PURE__ */ jsx(Text, { component: "div", className: edgeNoteText, p: 4, children: notes }) }),
              /* @__PURE__ */ jsx(
                CloseButton,
                {
                  size: "xs",
                  className: edgeNoteCloseButton,
                  onClick: () => setIsOpened(!1)
                }
              ),
              (hasPrevious || hasNext) && /* @__PURE__ */ jsxs(Group, { gap: 0, justify: hasPrevious ? "flex-start" : "flex-end", children: [
                hasPrevious && /* @__PURE__ */ jsx(
                  Button,
                  {
                    variant: "subtle",
                    radius: "xs",
                    size: "compact-xs",
                    onClick: () => diagram.walkthroughStep("previous"),
                    children: "back"
                  }
                ),
                hasNext && /* @__PURE__ */ jsx(
                  Button,
                  {
                    variant: "subtle",
                    radius: "xs",
                    size: "compact-xs",
                    onClick: () => diagram.walkthroughStep("next"),
                    children: "next"
                  }
                )
              ] })
            ]
          }
        )
      ]
    }
  );
}, link = cva({
  base: {
    display: "flex",
    overflow: "hidden",
    alignItems: "center",
    gap: "micro",
    justifyContent: "stretch",
    transitionProperty: "all",
    transitionDuration: "fast",
    transitionTimingFunction: "inOut",
    border: "1px dashed {colors.mantine.colors.defaultBorder}",
    rounded: "sm",
    cursor: "pointer",
    color: "mantine.colors.gray[7]",
    _dark: {
      color: "mantine.colors.dark[1]"
    },
    _hover: {
      transitionTimingFunction: "out",
      color: "mantine.colors.defaultColor",
      background: "mantine.colors.defaultHover"
    }
  },
  variants: {
    size: {
      sm: {
        minHeight: "22px",
        padding: "2px 8px 2px 2px"
      },
      md: {
        minHeight: "30px",
        padding: "3px 16px 3px 3px"
      }
    }
  }
}), titleBox = css({
  flex: "1 1 100%",
  transition: "transform 100ms {easings.inOut}",
  _groupHover: {
    transitionTimingFunction: "out",
    transitionDelay: "50ms",
    transform: "translateX(1px)"
  }
});
function Link({
  value,
  size: size2 = "md"
}) {
  const isNormalSize = size2 === "md", url = value.url.includes("://") ? value.url : new window.URL(value.url, window.location.href).toString();
  return /* @__PURE__ */ jsx(CopyButton$1, { value: url, children: ({ copied, copy }) => /* @__PURE__ */ jsxs(
    Anchor,
    {
      href: url,
      target: "_blank",
      underline: "never",
      className: cx(
        "group",
        link({ size: size2 })
      ),
      onClick: stopPropagation$1,
      children: [
        /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            className: css({
              flex: "0"
            }),
            tabIndex: -1,
            size: isNormalSize ? 24 : 20,
            variant: copied ? "light" : "subtle",
            color: copied ? "teal" : "gray",
            onClick: (e2) => {
              e2.stopPropagation(), e2.preventDefault(), copy();
            },
            children: copied ? /* @__PURE__ */ jsx(IconCheck, {}) : /* @__PURE__ */ jsx(IconCopy, { style: { width: "65%", opacity: 0.65 } })
          }
        ),
        /* @__PURE__ */ jsxs(Box$1, { className: titleBox, children: [
          /* @__PURE__ */ jsx(
            Text,
            {
              component: "div",
              fz: isNormalSize ? "xs" : 11,
              truncate: !0,
              lh: isNormalSize ? 1.3 : 1.2,
              fw: value.title ? 500 : 400,
              children: value.title || url
            }
          ),
          value.title && /* @__PURE__ */ jsx(Text, { component: "div", fz: isNormalSize ? 10 : 9, c: "dimmed", lh: isNormalSize ? 1.2 : 1.1, truncate: !0, children: url })
        ] })
      ]
    }
  ) });
}
const LikeC4ModelContext$1 = createContext(null);
function useLikeC4Model$1(strict, type) {
  const model = useContext(LikeC4ModelContext$1);
  if (t$3(type) && l$2(model) && model.type !== type)
    throw new Error(`Invalid LikeC4ModelContext, expected "${type}" but got "${model.type}" in context`);
  if (n(strict) && strict === !0 && !model)
    throw new Error("No LikeC4Model found in context");
  return model;
}
const sortByLabel = (a2, b2) => compareNatural(a2.label, b2.label);
function buildNode(element) {
  return {
    label: element.title,
    value: element.id,
    children: [...element.children()].map(buildNode).sort(sortByLabel)
  };
}
function useLikeC4ElementsTree(viewId) {
  const model = useLikeC4Model$1(!0);
  return useMemo(() => viewId ? [...model.view(viewId).roots()].map(buildNode).sort(sortByLabel) : [...model.roots()].map(buildNode).sort(sortByLabel), [model, viewId ?? null]);
}
const menuDropdown = css({
  overflowY: "scroll",
  minWidth: "250px",
  maxWidth: "min(90vw, 500px)"
}), menuItemRelationship = css({
  gap: 4
}), endpoint = css({
  display: "block",
  fontSize: "xxs",
  fontWeight: 500,
  whiteSpace: "nowrap",
  padding: "2px 4px",
  borderRadius: 2,
  background: "likec4.palette.fill/30",
  lineHeight: "[1.11]",
  mixBlendMode: "hard-light",
  color: {
    _light: "[color-mix(in srgb, {colors.likec4.palette.stroke}, {colors.likec4.mixColor} 60%)]",
    _dark: "likec4.palette.loContrast"
  }
  // _dark: {
  //   background: `likec4.palette.fill/60`,
  // },
}), title$3 = css({
  whiteSpaceCollapse: "preserve-breaks",
  fontSize: "xs"
});
css({
  whiteSpaceCollapse: "preserve-breaks",
  fontSize: "xs"
});
const stopPropagation = (e2) => e2.stopPropagation(), Tooltip$4 = Tooltip$5.withProps({
  color: "gray",
  fz: "xs",
  openDelay: 300,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
}), RelationshipsDropdownMenu = memo$2(({
  edgeId,
  source,
  target,
  disabled = !1,
  children: children2
}) => {
  const { diagramEdge, sourceNode, targetNode } = useDiagramContext((ctx) => ({
    diagramEdge: findDiagramEdge(ctx, edgeId),
    sourceNode: findDiagramNode(ctx, source),
    targetNode: findDiagramNode(ctx, target)
  })), likec4model = useLikeC4Model$1(!0), diagram = useDiagram(), portalProps = useMantinePortalProps(), onClickOpenOverlay = useCallback((e2) => {
    e2.stopPropagation(), diagram.openRelationshipDetails(edgeId);
  }, [edgeId]);
  if (!diagramEdge || !sourceNode || !targetNode)
    return /* @__PURE__ */ jsx(Fragment$1, { children: children2 });
  const [direct, nested] = C(
    diagramEdge.relations,
    m((id2) => {
      try {
        return likec4model.findRelationship(id2);
      } catch (e2) {
        return console.error(
          `View is cached and likec4model missing relationship ${id2} from ${sourceNode.id} -> ${targetNode.id}`,
          e2
        ), null;
      }
    }),
    T(n$5),
    d$3((r2) => r2.source.id === sourceNode.id && r2.target.id === targetNode.id)
  ), renderRelationship = (relationship, index2) => /* @__PURE__ */ jsxs(Fragment, { children: [
    index2 > 0 && /* @__PURE__ */ jsx(MenuDivider, { opacity: 0.65 }),
    /* @__PURE__ */ jsx(
      MenuItem,
      {
        onClick: onClickOpenOverlay,
        component: Relationship,
        relationship,
        sourceNode,
        targetNode,
        edge: diagramEdge
      }
    )
  ] }, relationship.id);
  return direct.length + nested.length === 0 ? /* @__PURE__ */ jsx(Fragment$1, { children: children2 }) : /* @__PURE__ */ jsxs(
    Menu,
    {
      trigger: "click-hover",
      openDelay: 300,
      closeDelay: 450,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      closeOnEscape: !0,
      keepMounted: !1,
      closeOnItemClick: !1,
      disabled,
      position: "bottom-start",
      middlewares: { size: { padding: 8 } },
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(MenuTarget, { children: children2 }),
        /* @__PURE__ */ jsxs(
          MenuDropdown,
          {
            className: menuDropdown,
            onPointerDownCapture: stopPropagation,
            onPointerDown: stopPropagation,
            onClick: stopPropagation,
            children: [
              direct.length > 0 && /* @__PURE__ */ jsxs(Fragment$1, { children: [
                /* @__PURE__ */ jsx(MenuLabel, { children: "direct relationships" }),
                direct.map(renderRelationship)
              ] }),
              nested.length > 0 && /* @__PURE__ */ jsxs(Fragment$1, { children: [
                direct.length > 0 && /* @__PURE__ */ jsx(MenuDivider, {}),
                /* @__PURE__ */ jsx(MenuLabel, { children: "resolved from nested" }),
                nested.map(renderRelationship)
              ] }),
              /* @__PURE__ */ jsx(Box$1, { pos: "absolute", top: 5, right: 6, children: /* @__PURE__ */ jsx(
                ActionIcon$1,
                {
                  size: 24,
                  variant: "subtle",
                  onClick: onClickOpenOverlay,
                  children: /* @__PURE__ */ jsx(IconInfoCircle, { style: { width: "70%" } })
                }
              ) })
            ]
          }
        )
      ]
    }
  );
}), Relationship = forwardRef(({
  className,
  relationship: r2,
  edge,
  sourceNode,
  targetNode,
  ...props
}, ref) => {
  const diagram = useDiagram(), { enableNavigateTo } = useEnabledFeature("NavigateTo"), { onOpenSource } = useDiagramEventHandlers(), viewId = diagram.currentView.id, sourceId = getShortId(r2, r2.source.id, sourceNode), targetId = getShortId(r2, r2.target.id, targetNode), navigateTo = enableNavigateTo && r2.navigateTo?.id !== viewId ? r2.navigateTo?.id : void 0, links = r2.links;
  return /* @__PURE__ */ jsxs(Stack, { ref, className: cx(menuItemRelationship, className), ...props, children: [
    /* @__PURE__ */ jsxs(Group, { gap: 4, children: [
      /* @__PURE__ */ jsx(Text, { component: "div", className: cx(css({ likec4Palette: sourceNode.color }), endpoint), children: sourceId }),
      /* @__PURE__ */ jsx(IconArrowRight, { stroke: 2.5, size: "11px", opacity: 0.65 }),
      /* @__PURE__ */ jsx(Text, { component: "div", className: cx(css({ likec4Palette: targetNode.color }), endpoint), children: targetId }),
      (navigateTo || !!onOpenSource) && /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 100, children: [
        /* @__PURE__ */ jsx(Space, { w: "xs" }),
        navigateTo && /* @__PURE__ */ jsx(Tooltip$4, { label: "Open dynamic view", children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            className: cx("nodrag nopan"),
            size: "sm",
            radius: "sm",
            variant: "default",
            onPointerDownCapture: stopPropagation,
            onClick: (event) => {
              event.stopPropagation(), diagram.navigateTo(navigateTo);
            },
            role: "button",
            children: /* @__PURE__ */ jsx(IconZoomScan, { size: "80%", stroke: 2 })
          }
        ) }),
        /* @__PURE__ */ jsx(IfEnabled, { feature: "Vscode", children: /* @__PURE__ */ jsx(Tooltip$4, { label: "Open source", children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            className: cx("nodrag nopan"),
            size: "sm",
            radius: "sm",
            variant: "default",
            onPointerDownCapture: stopPropagation,
            onClick: (event) => {
              event.stopPropagation(), diagram.openSource({ relation: r2.id });
            },
            role: "button",
            children: /* @__PURE__ */ jsx(IconFileSymlink, { size: "80%", stroke: 2 })
          }
        ) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsx(Box$1, { className: title$3, children: r2.title || "untitled" }),
    r2.description && /* @__PURE__ */ jsx(Text, { size: "xs", c: "dimmed", children: r2.description }),
    links.length > 0 && /* @__PURE__ */ jsx(
      Stack,
      {
        gap: 3,
        justify: "stretch",
        align: "stretch",
        children: links.map((link2) => /* @__PURE__ */ jsx(Link, { size: "sm", value: link2 }, link2.url))
      }
    )
  ] });
});
function getShortId(r2, actualEndpointId, diagramNode) {
  const diagramNodeId = r2.isDeploymentRelation() ? diagramNode.id : DiagramNode.modelRef(diagramNode) || "";
  return nameFromFqn(diagramNodeId) + actualEndpointId.slice(diagramNodeId.length);
}
function getNodeCenter(node2) {
  const { width, height } = getNodeDimensions(node2), { x: x2, y: y2 } = node2.internals.positionAbsolute;
  return {
    x: x2 + width / 2,
    y: y2 + height / 2
  };
}
function getNodeIntersectionFromCenterToPoint(intersectionNode, target, nodeMargin = 0) {
  const nodeCenter = getNodeCenter(intersectionNode), { width, height } = getNodeDimensions(intersectionNode), v = new VectorImpl(target.x, target.y).sub(nodeCenter), xScale = (nodeMargin + (width || 0) / 2) / v.x, yScale = (nodeMargin + (height || 0) / 2) / v.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
  return vector(v).mul(scale2).add(nodeCenter);
}
const curve = d3line().curve(curveCatmullRomOpen).x((d2) => d2.x).y((d2) => d2.y), selectActiveStepId = (s2) => s2.context.activeWalkthrough?.stepId ?? null, RelationshipEdge$2 = customEdge((props) => {
  const isPanning = useIsPanning(), [isControlPointDragging, setIsControlPointDragging] = useState(!1), xyflowStore = useXYStoreApi(), xyflow2 = useXYFlow(), diagram = useDiagram(), activeWalkthroughStep = useDiagramActorSnapshot(selectActiveStepId), { enableNavigateTo, enableEdgeEditing, enableRelationshipDetails } = useEnabledFeatures(), {
    id: id2,
    source,
    sourceX,
    sourceY,
    target,
    targetX,
    targetY,
    selected: selected2 = !1,
    data: {
      id: edgeId,
      points,
      hovered = !1,
      active = !1,
      dimmed = !1,
      labelBBox,
      labelXY,
      ...data
    },
    style: style2 = {}
  } = props, navigateTo = enableNavigateTo ? data.navigateTo : void 0, sourceNode = nonNullable(useXYInternalNode(source), `source node ${source} not found`), targetNode = nonNullable(useXYInternalNode(target), `target node ${target} not found`), isModified = n$5(data.controlPoints) || !isSamePoint(sourceNode.internals.positionAbsolute, sourceNode.data.position) || !isSamePoint(targetNode.internals.positionAbsolute, targetNode.data.position);
  let controlPoints = data.controlPoints ?? bezierControlPoints(props.data), edgePath;
  if (isModified) {
    const sourceCenterPos = { x: sourceX, y: sourceY }, targetCenterPos = { x: targetX, y: targetY }, nodeMargin = 6, points2 = data.dir === "back" ? [
      targetCenterPos,
      getNodeIntersectionFromCenterToPoint(targetNode, d(controlPoints) ?? sourceCenterPos, nodeMargin),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(sourceNode, a$4(controlPoints) ?? targetCenterPos, nodeMargin),
      sourceCenterPos
    ] : [
      sourceCenterPos,
      getNodeIntersectionFromCenterToPoint(sourceNode, d(controlPoints) ?? targetCenterPos, nodeMargin),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(targetNode, a$4(controlPoints) ?? sourceCenterPos, nodeMargin),
      targetCenterPos
    ];
    edgePath = nonNullable(curve(points2));
  } else
    edgePath = bezierPath(points);
  let labelX = labelBBox?.x ?? 0, labelY = labelBBox?.y ?? 0;
  const [labelPos, setLabelPos] = useState({
    x: labelXY?.x ?? labelX,
    y: labelXY?.y ?? labelY
  }), svgPathRef = useRef(null);
  useEffect(() => {
    const path = svgPathRef.current;
    if (!path) return;
    const dompoint = path.getPointAtLength(path.getTotalLength() * 0.5), point2 = {
      x: Math.round(dompoint.x),
      y: Math.round(dompoint.y)
    };
    setLabelPos((current) => isSamePoint(current, point2) ? current : point2);
  }, [edgePath]), useDebouncedEffect(
    () => {
      !labelBBox || labelBBox.x === labelPos.x && labelBBox.y === labelPos.y || diagram.updateEdgeData(id2, {
        labelXY: {
          x: labelPos.x,
          y: labelPos.y
        }
      });
    },
    [labelPos],
    50,
    300
  ), (isModified || isControlPointDragging) && (labelX = labelPos.x, labelY = labelPos.y);
  const onLmbControlPointerDown = (index2, e2, domNode) => {
    const { addSelectedEdges } = xyflowStore.getState();
    addSelectedEdges([id2]);
    const wasCanceled = diagram.cancelSaveManualLayout();
    e2.stopPropagation();
    let hasMoved = !1, pointer2 = { x: e2.clientX, y: e2.clientY };
    const onPointerMove = (e22) => {
      const clientPoint = {
        x: e22.clientX,
        y: e22.clientY
      };
      if (!isSamePoint(pointer2, clientPoint)) {
        setIsControlPointDragging(!0), hasMoved = !0, pointer2 = clientPoint;
        const { x: x2, y: y2 } = xyflow2.screenToFlowPosition(pointer2, { snapToGrid: !1 }), cp = controlPoints.slice();
        cp[index2] = {
          x: Math.round(x2),
          y: Math.round(y2)
        }, diagram.updateEdgeData(id2, {
          controlPoints: cp
        });
      }
      e22.stopPropagation();
    }, onPointerUp = (e22) => {
      domNode.removeEventListener("pointermove", onPointerMove, {
        capture: !0
      }), hasMoved && e22.stopPropagation(), (hasMoved || wasCanceled) && diagram.scheduleSaveManualLayout(), setIsControlPointDragging(!1);
    };
    domNode.addEventListener("pointermove", onPointerMove, {
      capture: !0
    }), domNode.addEventListener("pointerup", onPointerUp, {
      once: !0,
      capture: !0
    });
  }, onRmbControlPointerDown = (index2, e2, domNode) => {
    if (controlPoints.length <= 1)
      return;
    const onPointerUp = (e22) => {
      const newControlPoints = controlPoints.slice();
      newControlPoints.splice(index2, 1), e22.stopPropagation(), setTimeout(() => {
        diagram.updateEdgeData(id2, { controlPoints: newControlPoints }), diagram.scheduleSaveManualLayout();
      }, 10);
    };
    domNode.addEventListener("pointerup", onPointerUp, {
      once: !0,
      capture: !0
    }), e2.stopPropagation();
  }, onControlPointerDown = (index2, e2) => {
    const { domNode } = xyflowStore.getState();
    if (!(!domNode || e2.pointerType !== "mouse"))
      switch (e2.button) {
        case 0:
          onLmbControlPointerDown(index2, e2, domNode);
          break;
        case 2:
          onRmbControlPointerDown(index2, e2, domNode);
          break;
      }
  }, onEdgePointerDown = (e2) => {
    const { domNode } = xyflowStore.getState();
    if (!domNode || e2.pointerType !== "mouse" || e2.button !== 2)
      return;
    const points2 = [
      new VectorImpl(sourceX, sourceY),
      ...controlPoints.map(vector) || [],
      new VectorImpl(targetX, targetY)
    ];
    let pointer2 = { x: e2.clientX, y: e2.clientY };
    const newPoint = vector(xyflow2.screenToFlowPosition(pointer2, { snapToGrid: !1 }));
    let insertionIndex = 0, minDistance = 1 / 0;
    for (let i2 = 0; i2 < points2.length - 1; i2++) {
      const a2 = points2[i2], b2 = points2[i2 + 1], fromCurrentToNext = b2.sub(a2), fromCurrentToNew = newPoint.sub(a2), fromNextToNew = newPoint.sub(b2);
      if (fromCurrentToNext.dot(fromCurrentToNew) * fromCurrentToNext.dot(fromNextToNew) < 0) {
        const distanceToEdge = Math.abs(fromCurrentToNext.cross(fromCurrentToNew).abs() / fromCurrentToNext.abs());
        distanceToEdge < minDistance && (minDistance = distanceToEdge, insertionIndex = i2);
      }
    }
    const newControlPoints = controlPoints.slice() || [];
    newControlPoints.splice(insertionIndex, 0, newPoint), diagram.updateEdgeData(id2, { controlPoints: newControlPoints }), diagram.scheduleSaveManualLayout(), e2.stopPropagation();
  };
  let zIndex = ZIndexes.Edge;
  (hovered || active) && (zIndex = ZIndexes.Element + 1);
  let edgeLabel2 = /* @__PURE__ */ jsx(EdgeLabel, { edgeProps: props, children: !isControlPointDragging && navigateTo && /* @__PURE__ */ jsx(
    EdgeActionButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo);
      }
    }
  ) });
  if (!isControlPointDragging && !isPanning) {
    const notes = props.data.notes;
    notes && activeWalkthroughStep === props.id ? edgeLabel2 = /* @__PURE__ */ jsx(NotePopover, { notes, children: edgeLabel2 }) : enableRelationshipDetails && (edgeLabel2 = /* @__PURE__ */ jsx(
      RelationshipsDropdownMenu,
      {
        disabled: !!dimmed,
        source,
        target,
        edgeId,
        children: edgeLabel2
      }
    ));
  }
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(EdgeContainer, { ...props, className: clsx(isControlPointDragging && controlDragging), children: [
      /* @__PURE__ */ jsx(
        EdgePath,
        {
          edgeProps: props,
          svgPath: edgePath,
          ref: svgPathRef,
          ...enableEdgeEditing && {
            onEdgePointerDown
          }
        }
      ),
      /* @__PURE__ */ jsx(
        EdgeLabelContainer,
        {
          edgeProps: props,
          labelPosition: {
            x: labelX,
            y: labelY,
            translate: isModified ? "translate(-50%, 0)" : void 0
          },
          children: edgeLabel2
        }
      )
    ] }),
    enableEdgeEditing && controlPoints.length > 0 && (selected2 || hovered || isControlPointDragging) && /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsx(
      EdgeContainer,
      {
        component: "svg",
        className: controlPointsContainer,
        ...props,
        style: {
          ...style2,
          zIndex
        },
        children: /* @__PURE__ */ jsx(
          "g",
          {
            onContextMenu: (e2) => {
              e2.preventDefault(), e2.stopPropagation();
            },
            children: controlPoints.map((p2, i2) => /* @__PURE__ */ jsx(
              "circle",
              {
                onPointerDown: (e2) => onControlPointerDown(i2, e2),
                className: clsx("nodrag nopan", controlPoint),
                cx: Math.round(p2.x),
                cy: Math.round(p2.y),
                r: 3
              },
              "controlPoints" + edgeId + "#" + i2
            ))
          }
        )
      }
    ) })
  ] });
}), CompoundActions = (props) => {
  const { enableNavigateTo } = useEnabledFeature("NavigateTo"), diagram = useDiagram(), { navigateTo } = props.data;
  return navigateTo && enableNavigateTo ? /* @__PURE__ */ jsx(
    CompoundActionButton,
    {
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo, props.id);
      },
      ...props
    }
  ) : null;
}, ElementActions$2 = (props) => {
  const { enableNavigateTo, enableRelationshipBrowser } = useEnabledFeature("RelationshipBrowser", "NavigateTo"), diagram = useDiagram(), buttons2 = [], { navigateTo, modelFqn } = props.data;
  return navigateTo && enableNavigateTo && buttons2.push({
    key: "navigate",
    icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.navigateTo(navigateTo, props.id);
    }
  }), enableRelationshipBrowser && buttons2.push({
    key: "relationships",
    icon: /* @__PURE__ */ jsx(IconTransform, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openRelationshipsBrowser(modelFqn);
    }
  }), /* @__PURE__ */ jsx(
    ElementActionButtons,
    {
      buttons: buttons2,
      ...props
    }
  );
}, DeploymentElementActions = (props) => {
  const { enableNavigateTo, enableRelationshipBrowser } = useEnabledFeature("NavigateTo", "RelationshipBrowser"), diagram = useDiagram(), buttons2 = [], { navigateTo, modelFqn } = props.data;
  return navigateTo && enableNavigateTo && buttons2.push({
    key: "navigate",
    icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.navigateTo(navigateTo, props.id);
    }
  }), enableRelationshipBrowser && modelFqn && buttons2.push({
    key: "relationships",
    icon: /* @__PURE__ */ jsx(IconTransform, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openRelationshipsBrowser(modelFqn);
    }
  }), /* @__PURE__ */ jsx(ElementActionButtons, { buttons: buttons2, ...props });
}, {
  primary,
  secondary,
  muted,
  ...otherColors
} = defaultTheme.elements, themedColors = [
  { key: "primary", value: primary.fill },
  { key: "secondary", value: secondary.fill },
  { key: "muted", value: muted.fill }
], colors$1 = t$4(otherColors).map((key2) => ({
  key: key2,
  value: defaultTheme.elements[key2].fill
})), Tooltip$3 = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4,
  withinPortal: !1
});
function useHandlers(target, props) {
  const { onChange: triggerOnChange } = useDiagramEventHandlers(), diagram = useDiagram(), [originalColor, setOriginalColor] = useState(null), onColorPreview = useCallbackRef((color2) => {
    if (color2 === null) {
      invariant$2(originalColor, "originalColor is null"), setOriginalColor(null), diagram.updateNodeData(props.id, {
        color: originalColor
      });
      return;
    }
    setOriginalColor((value) => value ?? props.data.color), diagram.updateNodeData(props.id, {
      color: color2
    });
  }), onChange = useCallbackRef((change) => {
    triggerOnChange?.({
      change: {
        op: "change-element-style",
        style: change,
        targets: [target]
      }
    });
    const { shape, color: color2, ...style2 } = change;
    diagram.updateNodeData(props.id, {
      ...shape && { shape },
      ...color2 && { color: color2 },
      style: style2
    });
  });
  return {
    elementColor: originalColor ?? props.data.color,
    onColorPreview,
    onChange
  };
}
function BrowseRelationshipsButton({ fqn: fqn2 }) {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(Tooltip$3, { label: "Browse relationships", children: /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      size: "sm",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openRelationshipsBrowser(fqn2);
      },
      children: /* @__PURE__ */ jsx(
        IconTransform,
        {
          stroke: 2,
          style: {
            width: "72%",
            height: "72%"
          }
        }
      )
    }
  ) });
}
function GoToSourceButton(props) {
  const { onOpenSource } = useDiagramEventHandlers();
  return onOpenSource ? /* @__PURE__ */ jsx(Tooltip$3, { label: "Open source", children: /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      size: "sm",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), props.elementId ? onOpenSource?.({
          element: props.elementId
        }) : props.deploymentId && onOpenSource?.({
          deployment: props.deploymentId
        });
      },
      children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "70%" } })
    }
  ) }) : null;
}
function ColorButton({
  elementColor,
  elementOpacity,
  onColorPreview,
  isOpacityEditable = !1,
  onChange,
  ...props
}) {
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      position: "right-end",
      offset: 2,
      withinPortal: !1,
      ...props,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Button, { variant: "subtle", color: "gray", size: "compact-xs", px: 3, children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: defaultTheme.elements[elementColor]?.fill,
            size: 14,
            withShadow: !0,
            style: { color: "#fff", cursor: "pointer" }
          }
        ) }) }),
        /* @__PURE__ */ jsxs(PopoverDropdown, { p: "xs", children: [
          /* @__PURE__ */ jsx(
            ColorSwatches,
            {
              elementColor,
              onColorPreview,
              onChange: (color2) => onChange({ color: color2 })
            }
          ),
          isOpacityEditable && /* @__PURE__ */ jsxs(Fragment$1, { children: [
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(Divider$1, { label: "opacity", labelPosition: "left" }),
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(
              OpacityOption,
              {
                elementOpacity,
                onOpacityChange: (opacity) => {
                  onChange({ opacity });
                }
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function ColorSwatches({
  elementColor,
  onColorPreview,
  onChange
}) {
  const changeColor = (color2) => (e2) => {
    e2.stopPropagation(), onColorPreview(null), elementColor !== color2 && onChange(color2);
  };
  return /* @__PURE__ */ jsx(Stack, { gap: 2, onMouseLeave: () => onColorPreview(null), children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 1e3, closeDelay: 300, children: [
    /* @__PURE__ */ jsx(Flex, { maw: 120, gap: "6", justify: "flex-start", align: "flex-start", direction: "row", wrap: "wrap", children: themedColors.map(({ key: key2, value }) => /* @__PURE__ */ jsx(
      Tooltip$5,
      {
        label: key2,
        fz: "xs",
        color: "dark",
        offset: 2,
        withinPortal: !1,
        transitionProps: { duration: 140, transition: "slide-up" },
        children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: value,
            size: 18,
            withShadow: !0,
            onMouseEnter: () => onColorPreview(key2),
            onClick: changeColor(key2),
            style: { color: "#fff", cursor: "pointer" },
            children: elementColor === key2 && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
          }
        )
      },
      key2
    )) }),
    /* @__PURE__ */ jsx(
      Flex,
      {
        mt: "sm",
        maw: 110,
        gap: "6",
        justify: "flex-start",
        align: "flex-start",
        direction: "row",
        wrap: "wrap",
        children: colors$1.map(({ key: key2, value }) => /* @__PURE__ */ jsx(
          Tooltip$5,
          {
            label: key2,
            fz: "xs",
            color: "dark",
            offset: 2,
            transitionProps: { duration: 140, transition: "slide-up" },
            children: /* @__PURE__ */ jsx(
              ColorSwatch,
              {
                color: value,
                size: 18,
                onMouseEnter: () => onColorPreview(key2),
                onClick: changeColor(key2),
                style: { color: "#fff", cursor: "pointer" },
                children: elementColor === key2 && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
              }
            )
          },
          key2
        ))
      }
    )
  ] }) });
}
function OpacityOption({
  elementOpacity = 100,
  onOpacityChange
}) {
  const [value, setValue] = useState(elementOpacity);
  return useUpdateEffect$1(() => {
    setValue(elementOpacity);
  }, [elementOpacity]), /* @__PURE__ */ jsx(
    Slider,
    {
      size: "sm",
      color: "dark",
      value,
      onChange: setValue,
      onChangeEnd: onOpacityChange
    }
  );
}
const toolbarTitle = css({
  color: "mantine.colors.dimmed",
  fontSize: "10px",
  fontWeight: 600,
  maxWidth: "220px",
  cursor: "default",
  userSelect: "all",
  textOverflow: "ellipsis",
  overflow: "hidden",
  whiteSpace: "nowrap"
}), useSelectedNodesCount = () => useDiagramContext((s2) => s2.xynodes.filter((x2) => x2.selected).length);
function Toolbar({ title: title2, children: children2, nodeProps, ...props }) {
  const selectedNodesCount = useSelectedNodesCount(), {
    selected: selected2 = !1,
    dragging = !1,
    data: {
      hovered = !1
    }
  } = nodeProps, _isToolbarVisible = hovered && selectedNodesCount === 0 || selected2 && selectedNodesCount === 1;
  let delay2 = 150;
  _isToolbarVisible ? selected2 ? delay2 = 100 : delay2 = 1e3 : selectedNodesCount > 0 && (delay2 = 50);
  const [isToolbarVisible] = useDebouncedValue(_isToolbarVisible, delay2);
  return isToolbarVisible ? /* @__PURE__ */ jsx(
    NodeToolbar,
    {
      isVisible: !dragging,
      offset: 4,
      ...props,
      children: /* @__PURE__ */ jsx(
        Paper,
        {
          className: clsx("nodrag", "nopan"),
          px: 5,
          pb: 8,
          pt: 4,
          radius: "sm",
          shadow: "xl",
          onDoubleClickCapture: stopPropagation$1,
          onPointerDown: stopPropagation$1,
          onClick: stopPropagation$1,
          onDoubleClick: stopPropagation$1,
          withBorder: !0,
          children: /* @__PURE__ */ jsxs(Stack, { gap: "6px", children: [
            /* @__PURE__ */ jsx(Box$1, { px: "4px", children: /* @__PURE__ */ jsx(Text, { className: toolbarTitle, children: title2 }) }),
            /* @__PURE__ */ jsx(Group, { gap: 4, children: children2 })
          ] })
        }
      )
    }
  ) : null;
}
function CompoundElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeature("RelationshipBrowser", "Vscode"), {
    data: {
      style: style2,
      modelFqn
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(modelFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: modelFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            isOpacityEditable: !0,
            elementOpacity: style2?.opacity,
            onChange,
            position: "left-start"
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style2?.border,
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: modelFqn }),
        enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function CompoundDeploymentToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeature("RelationshipBrowser", "Vscode"), {
    data: {
      deploymentFqn,
      style: style2,
      modelFqn
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(deploymentFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: deploymentFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            isOpacityEditable: !0,
            elementOpacity: style2?.opacity,
            onChange,
            position: "left-start"
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style2?.border,
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { deploymentId: deploymentFqn }),
        enableRelationshipBrowser && modelFqn && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function BorderStyleOption({
  elementBorderStyle = "dashed",
  onChange
}) {
  const [value, setValue] = useState(elementBorderStyle);
  return useEffect(() => {
    setValue(elementBorderStyle);
  }, [elementBorderStyle]), /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(
    SegmentedControl,
    {
      size: "xs",
      fullWidth: !0,
      withItemsBorders: !1,
      value,
      onChange: (v) => {
        const border = v;
        setValue(border), onChange({ border });
      },
      styles: {
        label: {
          paddingTop: 2,
          paddingBottom: 2
        }
      },
      data: [
        { label: "Solid", value: "solid" },
        { label: "Dashed", value: "dashed" },
        { label: "Dotted", value: "dotted" },
        { label: "None", value: "none" }
      ]
    }
  ) });
}
function ElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeature("RelationshipBrowser", "Vscode"), {
    data: {
      shape,
      modelFqn
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(modelFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: modelFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ElementShapeButton,
          {
            elementShape: shape,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            onChange,
            position: "right-end"
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: modelFqn }),
        enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function DeploymentElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeature("RelationshipBrowser", "Vscode"), {
    data: {
      shape,
      deploymentFqn,
      modelFqn
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(deploymentFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: deploymentFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ElementShapeButton,
          {
            elementShape: shape,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            onChange,
            position: "right-end"
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { deploymentId: deploymentFqn }),
        enableRelationshipBrowser && modelFqn && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function ElementShapeButton({
  elementShape,
  onChange
}) {
  return /* @__PURE__ */ jsxs(
    Menu,
    {
      openDelay: 300,
      closeDelay: 450,
      floatingStrategy: "fixed",
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      closeOnEscape: !0,
      closeOnItemClick: !1,
      position: "top-start",
      offset: 2,
      styles: {
        item: {
          padding: "calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-xs)"
        }
      },
      withinPortal: !1,
      children: [
        /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
          Button,
          {
            variant: "light",
            color: "gray",
            size: "compact-xs",
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 12 }),
            children: elementShape
          }
        ) }),
        /* @__PURE__ */ jsx(
          MenuDropdown,
          {
            onDoubleClick: stopPropagation$1,
            onClick: stopPropagation$1,
            children: ElementShapes.map((shape) => /* @__PURE__ */ jsx(
              MenuItem,
              {
                fz: 12,
                fw: 500,
                value: shape,
                rightSection: elementShape === shape ? /* @__PURE__ */ jsx(IconCheck, { size: 12 }) : void 0,
                onClick: (e2) => {
                  e2.stopPropagation(), onChange({ shape });
                },
                children: shape
              },
              shape
            ))
          }
        )
      ]
    }
  );
}
const ElementDetailsButtonWithHandler$2 = ({ fqn: fqn2, ...props }) => {
  const { enableElementDetails } = useEnabledFeature("ElementDetails"), diagram = useDiagram();
  return enableElementDetails ? /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(fqn2, props.id);
      }
    }
  ) : null;
}, ElementNode$2 = customNode((props) => /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
  /* @__PURE__ */ jsx(ElementShape, { ...props, isMultiple: props.data.isMultiple }),
  /* @__PURE__ */ jsx(ElementTitle, { ...props }),
  /* @__PURE__ */ jsx(ElementActions$2, { ...props }),
  /* @__PURE__ */ jsx(
    ElementDetailsButtonWithHandler$2,
    {
      fqn: props.data.modelFqn,
      ...props
    }
  ),
  /* @__PURE__ */ jsx(IfNotEnabled, { feature: "ReadOnly", children: /* @__PURE__ */ jsx(ElementToolbar, { ...props }) }),
  /* @__PURE__ */ jsx(DefaultHandles, {})
] })), DeploymentNode = customNode((props) => /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
  /* @__PURE__ */ jsx(ElementShape, { ...props, isMultiple: props.data.isMultiple }),
  /* @__PURE__ */ jsx(ElementTitle, { ...props }),
  /* @__PURE__ */ jsx(DeploymentElementActions, { ...props }),
  !!props.data.modelFqn && /* @__PURE__ */ jsx(
    ElementDetailsButtonWithHandler$2,
    {
      fqn: props.data.modelFqn,
      ...props
    }
  ),
  /* @__PURE__ */ jsx(IfNotEnabled, { feature: "ReadOnly", children: /* @__PURE__ */ jsx(DeploymentElementToolbar, { ...props }) }),
  /* @__PURE__ */ jsx(DefaultHandles, {})
] })), CompoundElementNode = customNode((props) => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsxs(CompoundNodeContainer, { nodeProps: props, children: [
    /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
    /* @__PURE__ */ jsx(CompoundActions, { ...props }),
    /* @__PURE__ */ jsx(IfEnabled, { feature: "ElementDetails", children: /* @__PURE__ */ jsx(
      CompoundDetailsButton,
      {
        ...props,
        onClick: (e2) => {
          e2.stopPropagation(), diagram.openElementDetails(props.data.modelFqn, props.id);
        }
      }
    ) }),
    /* @__PURE__ */ jsx(IfNotEnabled, { feature: "ReadOnly", children: /* @__PURE__ */ jsx(CompoundElementToolbar, { ...props }) }),
    /* @__PURE__ */ jsx(DefaultHandles, {})
  ] });
}), CompoundDeploymentNode = customNode((props) => /* @__PURE__ */ jsxs(CompoundNodeContainer, { nodeProps: props, children: [
  /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
  /* @__PURE__ */ jsx(CompoundActions, { ...props }),
  /* @__PURE__ */ jsx(IfNotEnabled, { feature: "ReadOnly", children: /* @__PURE__ */ jsx(CompoundDeploymentToolbar, { ...props }) }),
  /* @__PURE__ */ jsx(DefaultHandles, {})
] })), ViewGroupNode = customNode((props) => /* @__PURE__ */ jsxs(CompoundNodeContainer, { nodeProps: props, children: [
  /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
  /* @__PURE__ */ jsx(DefaultHandles, {})
] })), nodeTypes$2 = {
  element: ElementNode$2,
  deployment: DeploymentNode,
  "compound-element": CompoundElementNode,
  "compound-deployment": CompoundDeploymentNode,
  "view-group": ViewGroupNode
}, edgeTypes$2 = {
  relationship: RelationshipEdge$2
}, select = (s2) => s2.children.overlays;
function useOverlaysActorRef() {
  return useDiagramActorSnapshot(select, Object.is);
}
var reactErrorBoundary_cjs = {}, hasRequiredReactErrorBoundary_cjs;
function requireReactErrorBoundary_cjs() {
  if (hasRequiredReactErrorBoundary_cjs) return reactErrorBoundary_cjs;
  hasRequiredReactErrorBoundary_cjs = 1, Object.defineProperty(reactErrorBoundary_cjs, "__esModule", { value: !0 });
  var react = React__default;
  const ErrorBoundaryContext = react.createContext(null), initialState = {
    didCatch: !1,
    error: null
  };
  class ErrorBoundary extends react.Component {
    constructor(props) {
      super(props), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = initialState;
    }
    static getDerivedStateFromError(error) {
      return {
        didCatch: !0,
        error
      };
    }
    resetErrorBoundary() {
      const {
        error
      } = this.state;
      if (error !== null) {
        for (var _this$props$onReset, _this$props, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 || _this$props$onReset.call(_this$props, {
          args,
          reason: "imperative-api"
        }), this.setState(initialState);
      }
    }
    componentDidCatch(error, info) {
      var _this$props$onError, _this$props2;
      (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 || _this$props$onError.call(_this$props2, error, info);
    }
    componentDidUpdate(prevProps, prevState) {
      const {
        didCatch
      } = this.state, {
        resetKeys
      } = this.props;
      if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
        var _this$props$onReset2, _this$props3;
        (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 || _this$props$onReset2.call(_this$props3, {
          next: resetKeys,
          prev: prevProps.resetKeys,
          reason: "keys"
        }), this.setState(initialState);
      }
    }
    render() {
      const {
        children: children2,
        fallbackRender,
        FallbackComponent,
        fallback
      } = this.props, {
        didCatch,
        error
      } = this.state;
      let childToRender = children2;
      if (didCatch) {
        const props = {
          error,
          resetErrorBoundary: this.resetErrorBoundary
        };
        if (typeof fallbackRender == "function")
          childToRender = fallbackRender(props);
        else if (FallbackComponent)
          childToRender = react.createElement(FallbackComponent, props);
        else if (fallback !== void 0)
          childToRender = fallback;
        else
          throw error;
      }
      return react.createElement(ErrorBoundaryContext.Provider, {
        value: {
          didCatch,
          error,
          resetErrorBoundary: this.resetErrorBoundary
        }
      }, childToRender);
    }
  }
  function hasArrayChanged() {
    let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return a2.length !== b2.length || a2.some((item, index2) => !Object.is(item, b2[index2]));
  }
  function assertErrorBoundaryContext(value) {
    if (value == null || typeof value.didCatch != "boolean" || typeof value.resetErrorBoundary != "function")
      throw new Error("ErrorBoundaryContext not found");
  }
  function useErrorBoundary() {
    const context2 = react.useContext(ErrorBoundaryContext);
    assertErrorBoundaryContext(context2);
    const [state, setState] = react.useState({
      error: null,
      hasError: !1
    }), memoized = react.useMemo(() => ({
      resetBoundary: () => {
        context2.resetErrorBoundary(), setState({
          error: null,
          hasError: !1
        });
      },
      showBoundary: (error) => setState({
        error,
        hasError: !0
      })
    }), [context2.resetErrorBoundary]);
    if (state.hasError)
      throw state.error;
    return memoized;
  }
  function withErrorBoundary(component, errorBoundaryProps) {
    const Wrapped = react.forwardRef((props, ref) => react.createElement(ErrorBoundary, errorBoundaryProps, react.createElement(component, {
      ...props,
      ref
    }))), name = component.displayName || component.name || "Unknown";
    return Wrapped.displayName = "withErrorBoundary(".concat(name, ")"), Wrapped;
  }
  return reactErrorBoundary_cjs.ErrorBoundary = ErrorBoundary, reactErrorBoundary_cjs.ErrorBoundaryContext = ErrorBoundaryContext, reactErrorBoundary_cjs.useErrorBoundary = useErrorBoundary, reactErrorBoundary_cjs.withErrorBoundary = withErrorBoundary, reactErrorBoundary_cjs;
}
var reactErrorBoundary_cjsExports = /* @__PURE__ */ requireReactErrorBoundary_cjs();
const ElementDetailsActorContext = createContext(null);
ElementDetailsActorContext.displayName = "ElementDetailsActorContext";
const useElementDetailsActorRef = () => {
  const ctx = useContext(ElementDetailsActorContext);
  if (ctx === null)
    throw new Error("ElementDetailsActorRef is not provided");
  return ctx;
}, backdropBlur$1 = "--_blur", backdropOpacity$1 = "--_opacity", dialog$1 = css({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  position: "fixed",
  inset: 0,
  width: "100vw",
  height: "100vh",
  maxWidth: "100vw",
  maxHeight: "100vh",
  background: "[transparent]",
  border: "transparent",
  _backdrop: {
    // WebkitBackdropFilter: `blur(${backdropBlur})`,
    backdropFilter: "auto",
    backdropBlur: `var(${backdropBlur$1})`,
    backgroundColor: `[rgb(36 36 36 / var(${backdropOpacity$1}, 5%))]`
  }
}), card$2 = css({
  position: "absolute",
  pointerEvents: "all",
  gap: "lg",
  justifyContent: "stretch",
  backgroundColor: "mantine.colors.body",
  backgroundImage: "linear-gradient(180deg, {colors.likec4.palette.fill}, {colors.likec4.palette.fill} 4px, transparent 4px)",
  borderTopColor: "likec4.palette.fill",
  _dark: {
    backgroundColor: "mantine.colors.dark[6]",
    backgroundImage: `
          linear-gradient(180deg, color-mix(in srgb, {colors.likec4.palette.fill} 15%, transparent), transparent 80px),
          linear-gradient(180deg, {colors.likec4.palette.fill}, {colors.likec4.palette.fill} 4px, transparent 4px)
        `
  },
  "& .react-flow__attribution": {
    display: "none"
  }
}), cardHeader = css({
  flex: 0,
  cursor: "move"
}), title$2 = css({
  display: "block",
  fontFamily: "likec4.element",
  fontOpticalSizing: "auto",
  fontStyle: "normal",
  fontWeight: 600,
  fontSize: "24px",
  // lineHeight: 1.15,
  lineHeight: "xs"
  // color: vars.element.hiContrast
}), iconSize$1 = "40px", elementIcon$1 = css({
  flex: `0 0 ${iconSize$1}`,
  height: iconSize$1,
  width: iconSize$1,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  alignSelf: "flex-start",
  cursor: "move",
  _dark: {
    mixBlendMode: "hard-light"
  },
  "& :where(svg, img)": {
    width: "100%",
    height: "auto",
    maxHeight: "100%",
    pointerEvents: "none",
    filter: `
    drop-shadow(0 0 3px rgb(0 0 0 / 10%))
    drop-shadow(0 1px 8px rgb(0 0 0 / 5%))
    drop-shadow(1px 1px 16px rgb(0 0 0 / 2%))
  `
  },
  "& img": {
    objectFit: "contain"
  }
}), viewTitleColor = "--view-title-color", iconColor = "--icon-color", viewButton$1 = css({
  // display: 'flex',
  width: "100%",
  background: "mantine.colors.body",
  borderRadius: "sm",
  padding: "10px 8px",
  // gap: 6,
  // alignItems: 'flex-start',
  transition: "fast",
  border: "1px dashed",
  borderColor: "mantine.colors.defaultBorder",
  [viewTitleColor]: "{colors.mantine.colors.dark[1]}",
  _hover: {
    background: "mantine.colors.defaultHover",
    [iconColor]: "{colors.mantine.colors.dark[1]}",
    [viewTitleColor]: "{colors.mantine.colors.defaultColor}"
  },
  _dark: {
    background: "mantine.colors.dark[6]"
  },
  _light: {
    [iconColor]: "{colors.mantine.colors.gray[6]}",
    [viewTitleColor]: "{colors.mantine.colors.gray[7]}",
    _hover: {
      [iconColor]: "{colors.mantine.colors.gray[7]}"
    }
  },
  "& .mantine-ThemeIcon-root": {
    transition: "fast",
    // color: fallbackVar(iconColor, 'mantine.colors.dark[2])',
    color: `[var(${iconColor}, {colors.mantine.colors.dark[2]})]`,
    "--ti-size": "22px",
    _hover: {
      color: "mantine.colors.defaultColor"
    }
  },
  "& > *": {
    transition: "all 130ms {easings.inOut}"
  },
  "&:hover > *": {
    transitionTimingFunction: "out",
    transform: "translateX(1.6px)"
  }
}), viewButtonTitle = css({
  transition: "fast",
  color: `[var(${viewTitleColor}, {colors.mantine.colors.gray[7]})]`,
  fontSize: "15px",
  fontWeight: 500,
  lineHeight: "1.4"
}), tabsRoot = css({
  flex: 1,
  display: "flex",
  flexDirection: "column",
  justifyContent: "stretch",
  overflow: "hidden",
  gap: "sm"
}), tabsList = css({
  // flex: '0',
  background: "mantine.colors.gray[1]",
  borderRadius: "sm",
  flexWrap: "nowrap",
  gap: "6px",
  padding: "4px",
  _dark: {
    background: "mantine.colors.dark[7]"
  }
}), tabsTab = css({
  fontSize: "xs",
  fontWeight: 500,
  flexGrow: 1,
  padding: "6px 8px",
  transition: "fast",
  borderRadius: "sm",
  color: "mantine.colors.gray[7]",
  _hover: {
    transitionTimingFunction: "out",
    color: "mantine.colors.defaultColor",
    background: "mantine.colors.gray[3]"
  },
  "&[data-active]": {
    transition: "none",
    background: "mantine.colors.white",
    shadow: "xs",
    color: "mantine.colors.defaultColor"
  },
  _dark: {
    color: "mantine.colors.dark[1]",
    _hover: {
      color: "mantine.colors.white",
      background: "mantine.colors.dark[6]"
    },
    "&:is([data-active])": {
      color: "mantine.colors.white",
      background: "mantine.colors.dark[5]"
    }
  }
}), tabsPanel = css({
  flex: 1,
  overflow: "hidden",
  position: "relative",
  "&:not(:has(.mantine-ScrollArea-root))": {
    paddingLeft: "4px",
    paddingRight: "4px"
  },
  "& .mantine-ScrollArea-root": {
    width: "100%",
    height: "100%",
    "& > div": {
      paddingLeft: "4px",
      paddingRight: "4px"
    }
  }
}), propertiesGrid = css({
  flex: 1,
  display: "grid",
  gridTemplateColumns: "min-content 1fr",
  gridAutoRows: "min-content max-content",
  gap: "[20px 16px]",
  alignItems: "baseline",
  justifyItems: "stretch"
}), propertyLabel = css({
  justifySelf: "end"
}), resizeHandle = css({
  position: "absolute",
  width: "14px",
  height: "14px",
  border: "3.5px solid",
  borderColor: "mantine.colors.dark[3]",
  borderTop: "none",
  borderLeft: "none",
  borderRadius: "2px",
  bottom: "2px",
  right: "2px",
  transition: "fast",
  cursor: "se-resize",
  _hover: {
    borderWidth: "4px",
    borderColor: "mantine.colors.dark[1]"
  }
}), treeNode$1 = css({
  "&[data-level='1']": {
    marginBottom: "sm"
  }
}), treeNodeLabel$1 = css({
  cursor: "default",
  marginTop: 0,
  marginBottom: 0
}), label$1 = css({
  transition: "fast",
  color: "mantine.colors.gray[7]",
  _dark: {
    color: "mantine.colors.dark[1]"
  },
  "& > *": {
    transition: "fast"
  },
  _hover: {
    transitionTimingFunction: "out",
    "& > :not([data-no-transform])": {
      transitionTimingFunction: "out",
      transform: "translateX(1px)"
    }
  }
  //   '.mantine-Button-root:hover & > :not([data-no-transform])': {
  // transitionTimingFunction: 'out',
  //   transform: 'translateX(1px)',
  //   },
}), nodeLabel = cx(label$1), instanceLabel = cx(
  label$1,
  css({
    cursor: "pointer",
    width: "100%",
    justifyContent: "stretch",
    flexWrap: "nowrap",
    height: "36px",
    paddingInlineStart: "16px",
    paddingInlineEnd: "10px",
    borderRadius: "sm",
    alignItems: "center",
    color: "mantine.colors.gray[7]",
    _dark: {
      color: "mantine.colors.gray.lightColor"
    },
    _hover: {
      background: "mantine.colors.gray.lightHover"
    },
    "& .tabler-icon": {
      transition: "fast",
      width: "90%",
      opacity: 0.65
    }
  })
), DeploymentNodeRenderer = ({
  node: node2
}) => /* @__PURE__ */ jsxs(Group, { className: nodeLabel, gap: 6, align: "baseline", wrap: "nowrap", children: [
  /* @__PURE__ */ jsxs(Text, { component: "div", fz: 11, c: "dimmed", children: [
    node2.kind,
    ":"
  ] }),
  /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", children: node2.title })
] }), DeployedInstanceRenderer = ({
  instance
}) => {
  const diagram = useDiagram(), currentViewId = diagram.currentView.id, views = [...instance.views()];
  return /* @__PURE__ */ jsxs(Group, { className: instanceLabel, gap: 4, children: [
    /* @__PURE__ */ jsx(ThemeIcon, { color: "gray", variant: "transparent", size: "xs", flex: 0, children: /* @__PURE__ */ jsx(IconTarget, { stroke: 1.2 }) }),
    /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", flex: "1 1 100%", children: instance.title }),
    /* @__PURE__ */ jsxs(Box$1, { onClick: stopPropagation$1, pos: "relative", "data-no-transform": !0, flex: 0, children: [
      views.length === 0 && /* @__PURE__ */ jsx(Button, { size: "compact-xs", variant: "transparent", color: "gray", disabled: !0, children: "no views" }),
      views.length > 0 && /* @__PURE__ */ jsxs(
        Menu,
        {
          shadow: "md",
          withinPortal: !1,
          position: "bottom-start",
          offset: 0,
          closeOnClickOutside: !0,
          clickOutsideEvents: ["pointerdown", "mousedown", "click"],
          closeOnEscape: !0,
          trapFocus: !0,
          children: [
            /* @__PURE__ */ jsx(Menu.Target, { children: /* @__PURE__ */ jsxs(Button, { size: "compact-xs", variant: "subtle", color: "gray", children: [
              views.length,
              " view",
              views.length > 1 ? "s" : ""
            ] }) }),
            /* @__PURE__ */ jsx(Menu.Dropdown, { children: views.map((view) => /* @__PURE__ */ jsx(
              Menu.Item,
              {
                px: "xs",
                py: 4,
                disabled: view.id === currentViewId,
                leftSection: /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "gray", children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8, opacity: 0.65 }) }),
                styles: {
                  itemSection: {
                    marginInlineEnd: rem(8)
                  }
                },
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.navigateTo(view.id);
                },
                children: view.title
              },
              view.id
            )) })
          ]
        }
      )
    ] })
  ] });
}, setHoveredNode$3 = () => {
}, TabPanelDeployments = memo$2(({ elementFqn }) => {
  const element = useLikeC4Model$1(!0).element(elementFqn), deployments = [...element.deployments()], tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode$3;
  const data = useMemo(() => {
    let roots = [], treeItems = /* @__PURE__ */ new Map();
    for (const instance of element.deployments()) {
      let instanceNode = {
        label: /* @__PURE__ */ jsx(DeployedInstanceRenderer, { instance }),
        value: instance.id,
        type: "instance",
        children: []
      };
      treeItems.set(instance.id, instanceNode);
      let ancestor = instance.parent;
      for (; ancestor; ) {
        let ancestorNode = treeItems.get(ancestor.id);
        if (ancestorNode) {
          ancestorNode.children.push(instanceNode);
          break;
        }
        ancestorNode = {
          label: /* @__PURE__ */ jsx(DeploymentNodeRenderer, { node: ancestor }),
          value: ancestor.id,
          type: "node",
          children: [instanceNode]
        }, treeItems.set(ancestor.id, ancestorNode), instanceNode = ancestorNode, ancestor = ancestor.parent;
      }
      !ancestor && !roots.includes(instanceNode) && roots.push(instanceNode);
    }
    return roots;
  }, [element]);
  return useEffect(() => {
    tree.expandAllNodes();
  }, [data]), deployments.length === 0 ? /* @__PURE__ */ jsx(Alert, { variant: "light", color: "gray", icon: /* @__PURE__ */ jsx(IconInfoCircle, {}), children: "This element does not have any deployments" }) : (
    // <Box></Box>
    /* @__PURE__ */ jsx(
      Tree,
      {
        levelOffset: "sm",
        allowRangeSelection: !1,
        classNames: {
          node: treeNode$1,
          label: treeNodeLabel$1
        },
        styles: {
          root: {
            position: "relative",
            width: "min-content",
            minWidth: 300
          }
        },
        data,
        tree,
        renderNode: ({ node: node2, selected: selected2, elementProps, hasChildren }) => /* @__PURE__ */ jsx(
          Box$1,
          {
            ...elementProps,
            style: {
              ...!hasChildren && {
                marginBottom: rem(4)
              }
            },
            children: hasChildren ? /* @__PURE__ */ jsx(
              Button,
              {
                fullWidth: !0,
                color: "gray",
                variant: selected2 ? "transparent" : "subtle",
                size: "xs",
                justify: "flex-start",
                styles: {
                  root: {
                    position: "unset",
                    paddingInlineStart: rem(16)
                  }
                },
                children: node2.label
              }
            ) : node2.label
          }
        )
      }
    )
  );
}), RelationshipsBrowserActorContext = createContext(null);
function useRelationshipsBrowserActor() {
  return nonNullable(useContext(RelationshipsBrowserActorContext), "No RelationshipsBrowserActorContext");
}
function useRelationshipsBrowserState(selector3, compare = shallowEqual) {
  const actor = useRelationshipsBrowserActor();
  return xstateReact_cjsExports.useSelector(actor, useCallbackRef(selector3), compare);
}
function useRelationshipsBrowser() {
  const actor = useRelationshipsBrowserActor();
  return useMemo(() => ({
    actor,
    get rootElementId() {
      return `relationships-browser-${actor.sessionId.replaceAll(":", "_")}`;
    },
    getState: () => actor.getSnapshot().context,
    send: actor.send,
    updateView: (layouted) => {
      actor.send({
        type: "update.view",
        layouted
      });
    },
    changeScope: (scope) => {
      actor.send({
        type: "change.scope",
        scope
      });
    },
    navigateTo: (subject, fromNode) => {
      actor.send({
        type: "navigate.to",
        subject,
        fromNode
      });
    },
    fitDiagram: () => {
      actor.send({ type: "fitDiagram" });
    },
    close: () => {
      actor._parent ? actor._parent?.send({ type: "close", actorId: actor.id }) : actor.send({ type: "close" });
    }
  }), [actor]);
}
const RelationshipEdge$1 = customEdge((props) => {
  const browser = useRelationshipsBrowser(), { enableNavigateTo } = useEnabledFeature("NavigateTo"), {
    id: id2,
    data: {
      navigateTo,
      relations,
      existsInCurrentView
    }
  } = props, [svgPath, labelX, labelY] = getBezierPath(props), diagram = useDiagram(), markOrange = relations.length > 1 || !existsInCurrentView, edgeProps = markOrange ? {
    ...props,
    data: {
      ...props.data,
      line: "solid",
      color: "amber"
    }
  } : props;
  let label2 = /* @__PURE__ */ jsx(
    EdgeLabel,
    {
      edgeProps,
      className: css({
        transition: "fast"
      }),
      children: enableNavigateTo && navigateTo && /* @__PURE__ */ jsx(
        EdgeActionButton,
        {
          ...props,
          onClick: (e2) => {
            e2.stopPropagation(), diagram.navigateTo(navigateTo);
          }
        }
      )
    }
  );
  return existsInCurrentView || (label2 = /* @__PURE__ */ jsx(
    Tooltip$5,
    {
      color: "orange",
      c: "black",
      label: "This relationship is not included in the current view",
      portalProps: {
        target: `#${browser.rootElementId}`
      },
      openDelay: 800,
      children: label2
    }
  )), /* @__PURE__ */ jsxs(EdgeContainer, { ...edgeProps, children: [
    /* @__PURE__ */ jsx(
      EdgePath,
      {
        edgeProps,
        svgPath,
        ...markOrange && {
          strokeWidth: 5
        }
      }
    ),
    /* @__PURE__ */ jsx(
      EdgeLabelContainer,
      {
        edgeProps,
        labelPosition: {
          x: labelX,
          y: labelY,
          translate: "translate(-50%, 0)"
        },
        style: {
          maxWidth: Math.min(Math.abs(props.targetX - props.sourceX - 70), 250)
        },
        children: label2
      }
    )
  ] });
}), selectViewId = (s2) => s2.context.view.id;
function useCurrentViewId() {
  const actorRef = useDiagramActorRef();
  return xstateReact_cjsExports.useSelector(actorRef, selectViewId);
}
const ElementActions$1 = (props) => {
  const { enableNavigateTo, enableVscode } = useEnabledFeatures(), diagram = useDiagram(), currentViewId = useCurrentViewId(), browser = useRelationshipsBrowser(), subject = useRelationshipsBrowserState((s2) => s2.context.subject), buttons2 = [], { navigateTo, fqn: fqn2 } = props.data;
  return navigateTo && enableNavigateTo && currentViewId !== navigateTo && buttons2.push({
    key: "navigate",
    icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.navigateTo(navigateTo);
    }
  }), fqn2 !== subject && buttons2.push({
    key: "relationships",
    icon: /* @__PURE__ */ jsx(IconTransform, {}),
    onClick: (e2) => {
      e2.stopPropagation(), browser.navigateTo(fqn2, props.id);
    }
  }), enableVscode && buttons2.push({
    key: "goToSource",
    icon: /* @__PURE__ */ jsx(IconFileSymlink, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openSource({ element: fqn2 });
    }
  }), /* @__PURE__ */ jsx(
    ElementActionButtons,
    {
      buttons: buttons2,
      ...props
    }
  );
}, emptyNode = css({
  width: "100%",
  height: "100%",
  border: "3px dashed",
  borderColor: "mantine.colors.defaultBorder",
  borderRadius: "md",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
function EmptyNode$1({
  data: {
    column
  }
}) {
  return /* @__PURE__ */ jsx(Box$1, { className: emptyNode, children: /* @__PURE__ */ jsxs(Text, { c: "dimmed", fz: "lg", fw: 500, children: [
    "No ",
    column === "incomers" ? "incoming" : "outgoing"
  ] }) });
}
const ElementDetailsButtonWithHandler$1 = (props) => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(props.data.fqn);
      }
    }
  );
}, ElementNode$1 = customNode((props) => /* @__PURE__ */ jsxs(ElementNodeContainer, { component: MotionDiv, layoutId: props.id, nodeProps: props, children: [
  /* @__PURE__ */ jsx(ElementShape, { ...props }),
  /* @__PURE__ */ jsx(ElementTitle, { ...props }),
  /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$1, { ...props }),
  /* @__PURE__ */ jsx(ElementActions$1, { ...props }),
  /* @__PURE__ */ jsx(ElementPorts$1, { ...props })
] }, props.id)), CompoundNode$1 = customNode((props) => /* @__PURE__ */ jsxs(CompoundNodeContainer, { layoutId: props.id, nodeProps: props, children: [
  /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$1, { ...props }),
  /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
  /* @__PURE__ */ jsx(CompoundPorts$1, { ...props })
] }, props.id)), EmptyNode = customNode((props) => /* @__PURE__ */ jsx(EmptyNode$1, { ...props })), ElementPorts$1 = ({ data: { ports, height: h } }) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
  ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${15 + (i2 + 1) * ((h - 30) / (ports.in.length + 1))}px`
      }
    },
    id2
  )),
  ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${15 + (i2 + 1) * ((h - 30) / (ports.out.length + 1))}px`
      }
    },
    id2
  ))
] }), CompoundPorts$1 = ({ data }) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
  data.ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${20 * (i2 + 1)}px`
      }
    },
    id2
  )),
  data.ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${20 * (i2 + 1)}px`
      }
    },
    id2
  ))
] });
var graph, hasRequiredGraph;
function requireGraph() {
  if (hasRequiredGraph) return graph;
  hasRequiredGraph = 1;
  var DEFAULT_EDGE_NAME = "\0", GRAPH_NODE = "\0", EDGE_KEY_DELIM = "";
  class Graph {
    _isDirected = !0;
    _isMultigraph = !1;
    _isCompound = !1;
    // Label for the graph itself
    _label;
    // Defaults to be set when creating a new node
    _defaultNodeLabelFn = () => {
    };
    // Defaults to be set when creating a new edge
    _defaultEdgeLabelFn = () => {
    };
    // v -> label
    _nodes = {};
    // v -> edgeObj
    _in = {};
    // u -> v -> Number
    _preds = {};
    // v -> edgeObj
    _out = {};
    // v -> w -> Number
    _sucs = {};
    // e -> edgeObj
    _edgeObjs = {};
    // e -> label
    _edgeLabels = {};
    /* Number of nodes in the graph. Should only be changed by the implementation. */
    _nodeCount = 0;
    /* Number of edges in the graph. Should only be changed by the implementation. */
    _edgeCount = 0;
    _parent;
    _children;
    constructor(opts) {
      opts && (this._isDirected = Object.hasOwn(opts, "directed") ? opts.directed : !0, this._isMultigraph = Object.hasOwn(opts, "multigraph") ? opts.multigraph : !1, this._isCompound = Object.hasOwn(opts, "compound") ? opts.compound : !1), this._isCompound && (this._parent = {}, this._children = {}, this._children[GRAPH_NODE] = {});
    }
    /* === Graph functions ========= */
    /**
     * Whether graph was created with 'directed' flag set to true or not.
     */
    isDirected() {
      return this._isDirected;
    }
    /**
     * Whether graph was created with 'multigraph' flag set to true or not.
     */
    isMultigraph() {
      return this._isMultigraph;
    }
    /**
     * Whether graph was created with 'compound' flag set to true or not.
     */
    isCompound() {
      return this._isCompound;
    }
    /**
     * Sets the label of the graph.
     */
    setGraph(label2) {
      return this._label = label2, this;
    }
    /**
     * Gets the graph label.
     */
    graph() {
      return this._label;
    }
    /* === Node functions ========== */
    /**
     * Sets the default node label. If newDefault is a function, it will be
     * invoked ach time when setting a label for a node. Otherwise, this label
     * will be assigned as default label in case if no label was specified while
     * setting a node.
     * Complexity: O(1).
     */
    setDefaultNodeLabel(newDefault) {
      return this._defaultNodeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultNodeLabelFn = () => newDefault), this;
    }
    /**
     * Gets the number of nodes in the graph.
     * Complexity: O(1).
     */
    nodeCount() {
      return this._nodeCount;
    }
    /**
     * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
     * not included in list.
     * Complexity: O(1).
     */
    nodes() {
      return Object.keys(this._nodes);
    }
    /**
     * Gets list of nodes without in-edges.
     * Complexity: O(|V|).
     */
    sources() {
      var self2 = this;
      return this.nodes().filter((v) => Object.keys(self2._in[v]).length === 0);
    }
    /**
     * Gets list of nodes without out-edges.
     * Complexity: O(|V|).
     */
    sinks() {
      var self2 = this;
      return this.nodes().filter((v) => Object.keys(self2._out[v]).length === 0);
    }
    /**
     * Invokes setNode method for each node in names list.
     * Complexity: O(|names|).
     */
    setNodes(vs, value) {
      var args = arguments, self2 = this;
      return vs.forEach(function(v) {
        args.length > 1 ? self2.setNode(v, value) : self2.setNode(v);
      }), this;
    }
    /**
     * Creates or updates the value for the node v in the graph. If label is supplied
     * it is set as the value for the node. If label is not supplied and the node was
     * created by this call then the default node label will be assigned.
     * Complexity: O(1).
     */
    setNode(v, value) {
      return Object.hasOwn(this._nodes, v) ? (arguments.length > 1 && (this._nodes[v] = value), this) : (this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v), this._isCompound && (this._parent[v] = GRAPH_NODE, this._children[v] = {}, this._children[GRAPH_NODE][v] = !0), this._in[v] = {}, this._preds[v] = {}, this._out[v] = {}, this._sucs[v] = {}, ++this._nodeCount, this);
    }
    /**
     * Gets the label of node with specified name.
     * Complexity: O(|V|).
     */
    node(v) {
      return this._nodes[v];
    }
    /**
     * Detects whether graph has a node with specified name or not.
     */
    hasNode(v) {
      return Object.hasOwn(this._nodes, v);
    }
    /**
     * Remove the node with the name from the graph or do nothing if the node is not in
     * the graph. If the node was removed this function also removes any incident
     * edges.
     * Complexity: O(1).
     */
    removeNode(v) {
      var self2 = this;
      if (Object.hasOwn(this._nodes, v)) {
        var removeEdge = (e2) => self2.removeEdge(self2._edgeObjs[e2]);
        delete this._nodes[v], this._isCompound && (this._removeFromParentsChildList(v), delete this._parent[v], this.children(v).forEach(function(child) {
          self2.setParent(child);
        }), delete this._children[v]), Object.keys(this._in[v]).forEach(removeEdge), delete this._in[v], delete this._preds[v], Object.keys(this._out[v]).forEach(removeEdge), delete this._out[v], delete this._sucs[v], --this._nodeCount;
      }
      return this;
    }
    /**
     * Sets node p as a parent for node v if it is defined, or removes the
     * parent for v if p is undefined. Method throws an exception in case of
     * invoking it in context of noncompound graph.
     * Average-case complexity: O(1).
     */
    setParent(v, parent) {
      if (!this._isCompound)
        throw new Error("Cannot set parent in a non-compound graph");
      if (parent === void 0)
        parent = GRAPH_NODE;
      else {
        parent += "";
        for (var ancestor = parent; ancestor !== void 0; ancestor = this.parent(ancestor))
          if (ancestor === v)
            throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
        this.setNode(parent);
      }
      return this.setNode(v), this._removeFromParentsChildList(v), this._parent[v] = parent, this._children[parent][v] = !0, this;
    }
    _removeFromParentsChildList(v) {
      delete this._children[this._parent[v]][v];
    }
    /**
     * Gets parent node for node v.
     * Complexity: O(1).
     */
    parent(v) {
      if (this._isCompound) {
        var parent = this._parent[v];
        if (parent !== GRAPH_NODE)
          return parent;
      }
    }
    /**
     * Gets list of direct children of node v.
     * Complexity: O(1).
     */
    children(v = GRAPH_NODE) {
      if (this._isCompound) {
        var children2 = this._children[v];
        if (children2)
          return Object.keys(children2);
      } else {
        if (v === GRAPH_NODE)
          return this.nodes();
        if (this.hasNode(v))
          return [];
      }
    }
    /**
     * Return all nodes that are predecessors of the specified node or undefined if node v is not in
     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
     * Complexity: O(|V|).
     */
    predecessors(v) {
      var predsV = this._preds[v];
      if (predsV)
        return Object.keys(predsV);
    }
    /**
     * Return all nodes that are successors of the specified node or undefined if node v is not in
     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
     * Complexity: O(|V|).
     */
    successors(v) {
      var sucsV = this._sucs[v];
      if (sucsV)
        return Object.keys(sucsV);
    }
    /**
     * Return all nodes that are predecessors or successors of the specified node or undefined if
     * node v is not in the graph.
     * Complexity: O(|V|).
     */
    neighbors(v) {
      var preds = this.predecessors(v);
      if (preds) {
        const union = new Set(preds);
        for (var succ of this.successors(v))
          union.add(succ);
        return Array.from(union.values());
      }
    }
    isLeaf(v) {
      var neighbors;
      return this.isDirected() ? neighbors = this.successors(v) : neighbors = this.neighbors(v), neighbors.length === 0;
    }
    /**
     * Creates new graph with nodes filtered via filter. Edges incident to rejected node
     * are also removed. In case of compound graph, if parent is rejected by filter,
     * than all its children are rejected too.
     * Average-case complexity: O(|E|+|V|).
     */
    filterNodes(filter2) {
      var copy = new this.constructor({
        directed: this._isDirected,
        multigraph: this._isMultigraph,
        compound: this._isCompound
      });
      copy.setGraph(this.graph());
      var self2 = this;
      Object.entries(this._nodes).forEach(function([v, value]) {
        filter2(v) && copy.setNode(v, value);
      }), Object.values(this._edgeObjs).forEach(function(e2) {
        copy.hasNode(e2.v) && copy.hasNode(e2.w) && copy.setEdge(e2, self2.edge(e2));
      });
      var parents = {};
      function findParent(v) {
        var parent = self2.parent(v);
        return parent === void 0 || copy.hasNode(parent) ? (parents[v] = parent, parent) : parent in parents ? parents[parent] : findParent(parent);
      }
      return this._isCompound && copy.nodes().forEach((v) => copy.setParent(v, findParent(v))), copy;
    }
    /* === Edge functions ========== */
    /**
     * Sets the default edge label or factory function. This label will be
     * assigned as default label in case if no label was specified while setting
     * an edge or this function will be invoked each time when setting an edge
     * with no label specified and returned value * will be used as a label for edge.
     * Complexity: O(1).
     */
    setDefaultEdgeLabel(newDefault) {
      return this._defaultEdgeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultEdgeLabelFn = () => newDefault), this;
    }
    /**
     * Gets the number of edges in the graph.
     * Complexity: O(1).
     */
    edgeCount() {
      return this._edgeCount;
    }
    /**
     * Gets edges of the graph. In case of compound graph subgraphs are not considered.
     * Complexity: O(|E|).
     */
    edges() {
      return Object.values(this._edgeObjs);
    }
    /**
     * Establish an edges path over the nodes in nodes list. If some edge is already
     * exists, it will update its label, otherwise it will create an edge between pair
     * of nodes with label provided or default label if no label provided.
     * Complexity: O(|nodes|).
     */
    setPath(vs, value) {
      var self2 = this, args = arguments;
      return vs.reduce(function(v, w) {
        return args.length > 1 ? self2.setEdge(v, w, value) : self2.setEdge(v, w), w;
      }), this;
    }
    /**
     * Creates or updates the label for the edge (v, w) with the optionally supplied
     * name. If label is supplied it is set as the value for the edge. If label is not
     * supplied and the edge was created by this call then the default edge label will
     * be assigned. The name parameter is only useful with multigraphs.
     */
    setEdge() {
      var v, w, name, value, valueSpecified = !1, arg0 = arguments[0];
      typeof arg0 == "object" && arg0 !== null && "v" in arg0 ? (v = arg0.v, w = arg0.w, name = arg0.name, arguments.length === 2 && (value = arguments[1], valueSpecified = !0)) : (v = arg0, w = arguments[1], name = arguments[3], arguments.length > 2 && (value = arguments[2], valueSpecified = !0)), v = "" + v, w = "" + w, name !== void 0 && (name = "" + name);
      var e2 = edgeArgsToId(this._isDirected, v, w, name);
      if (Object.hasOwn(this._edgeLabels, e2))
        return valueSpecified && (this._edgeLabels[e2] = value), this;
      if (name !== void 0 && !this._isMultigraph)
        throw new Error("Cannot set a named edge when isMultigraph = false");
      this.setNode(v), this.setNode(w), this._edgeLabels[e2] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
      var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
      return v = edgeObj.v, w = edgeObj.w, Object.freeze(edgeObj), this._edgeObjs[e2] = edgeObj, incrementOrInitEntry(this._preds[w], v), incrementOrInitEntry(this._sucs[v], w), this._in[w][e2] = edgeObj, this._out[v][e2] = edgeObj, this._edgeCount++, this;
    }
    /**
     * Gets the label for the specified edge.
     * Complexity: O(1).
     */
    edge(v, w, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
      return this._edgeLabels[e2];
    }
    /**
     * Gets the label for the specified edge and converts it to an object.
     * Complexity: O(1)
     */
    edgeAsObj() {
      const edge = this.edge(...arguments);
      return typeof edge != "object" ? { label: edge } : edge;
    }
    /**
     * Detects whether the graph contains specified edge or not. No subgraphs are considered.
     * Complexity: O(1).
     */
    hasEdge(v, w, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
      return Object.hasOwn(this._edgeLabels, e2);
    }
    /**
     * Removes the specified edge from the graph. No subgraphs are considered.
     * Complexity: O(1).
     */
    removeEdge(v, w, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name), edge = this._edgeObjs[e2];
      return edge && (v = edge.v, w = edge.w, delete this._edgeLabels[e2], delete this._edgeObjs[e2], decrementOrRemoveEntry(this._preds[w], v), decrementOrRemoveEntry(this._sucs[v], w), delete this._in[w][e2], delete this._out[v][e2], this._edgeCount--), this;
    }
    /**
     * Return all edges that point to the node v. Optionally filters those edges down to just those
     * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
     * Complexity: O(|E|).
     */
    inEdges(v, u2) {
      var inV = this._in[v];
      if (inV) {
        var edges = Object.values(inV);
        return u2 ? edges.filter((edge) => edge.v === u2) : edges;
      }
    }
    /**
     * Return all edges that are pointed at by node v. Optionally filters those edges down to just
     * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
     * Complexity: O(|E|).
     */
    outEdges(v, w) {
      var outV = this._out[v];
      if (outV) {
        var edges = Object.values(outV);
        return w ? edges.filter((edge) => edge.w === w) : edges;
      }
    }
    /**
     * Returns all edges to or from node v regardless of direction. Optionally filters those edges
     * down to just those between nodes v and w regardless of direction.
     * Complexity: O(|E|).
     */
    nodeEdges(v, w) {
      var inEdges = this.inEdges(v, w);
      if (inEdges)
        return inEdges.concat(this.outEdges(v, w));
    }
  }
  function incrementOrInitEntry(map, k2) {
    map[k2] ? map[k2]++ : map[k2] = 1;
  }
  function decrementOrRemoveEntry(map, k2) {
    --map[k2] || delete map[k2];
  }
  function edgeArgsToId(isDirected, v_, w_, name) {
    var v = "" + v_, w = "" + w_;
    if (!isDirected && v > w) {
      var tmp = v;
      v = w, w = tmp;
    }
    return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === void 0 ? DEFAULT_EDGE_NAME : name);
  }
  function edgeArgsToObj(isDirected, v_, w_, name) {
    var v = "" + v_, w = "" + w_;
    if (!isDirected && v > w) {
      var tmp = v;
      v = w, w = tmp;
    }
    var edgeObj = { v, w };
    return name && (edgeObj.name = name), edgeObj;
  }
  function edgeObjToId(isDirected, edgeObj) {
    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
  }
  return graph = Graph, graph;
}
var version$1, hasRequiredVersion$1;
function requireVersion$1() {
  return hasRequiredVersion$1 || (hasRequiredVersion$1 = 1, version$1 = "2.2.4"), version$1;
}
var lib, hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, lib = {
    Graph: requireGraph(),
    version: requireVersion$1()
  }), lib;
}
var json, hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  var Graph = requireGraph();
  json = {
    write,
    read
  };
  function write(g) {
    var json2 = {
      options: {
        directed: g.isDirected(),
        multigraph: g.isMultigraph(),
        compound: g.isCompound()
      },
      nodes: writeNodes(g),
      edges: writeEdges(g)
    };
    return g.graph() !== void 0 && (json2.value = structuredClone(g.graph())), json2;
  }
  function writeNodes(g) {
    return g.nodes().map(function(v) {
      var nodeValue = g.node(v), parent = g.parent(v), node2 = { v };
      return nodeValue !== void 0 && (node2.value = nodeValue), parent !== void 0 && (node2.parent = parent), node2;
    });
  }
  function writeEdges(g) {
    return g.edges().map(function(e2) {
      var edgeValue = g.edge(e2), edge = { v: e2.v, w: e2.w };
      return e2.name !== void 0 && (edge.name = e2.name), edgeValue !== void 0 && (edge.value = edgeValue), edge;
    });
  }
  function read(json2) {
    var g = new Graph(json2.options).setGraph(json2.value);
    return json2.nodes.forEach(function(entry) {
      g.setNode(entry.v, entry.value), entry.parent && g.setParent(entry.v, entry.parent);
    }), json2.edges.forEach(function(entry) {
      g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
    }), g;
  }
  return json;
}
var components_1, hasRequiredComponents;
function requireComponents() {
  if (hasRequiredComponents) return components_1;
  hasRequiredComponents = 1, components_1 = components;
  function components(g) {
    var visited = {}, cmpts = [], cmpt;
    function dfs(v) {
      Object.hasOwn(visited, v) || (visited[v] = !0, cmpt.push(v), g.successors(v).forEach(dfs), g.predecessors(v).forEach(dfs));
    }
    return g.nodes().forEach(function(v) {
      cmpt = [], dfs(v), cmpt.length && cmpts.push(cmpt);
    }), cmpts;
  }
  return components_1;
}
var priorityQueue, hasRequiredPriorityQueue;
function requirePriorityQueue() {
  if (hasRequiredPriorityQueue) return priorityQueue;
  hasRequiredPriorityQueue = 1;
  class PriorityQueue {
    _arr = [];
    _keyIndices = {};
    /**
     * Returns the number of elements in the queue. Takes `O(1)` time.
     */
    size() {
      return this._arr.length;
    }
    /**
     * Returns the keys that are in the queue. Takes `O(n)` time.
     */
    keys() {
      return this._arr.map(function(x2) {
        return x2.key;
      });
    }
    /**
     * Returns `true` if **key** is in the queue and `false` if not.
     */
    has(key2) {
      return Object.hasOwn(this._keyIndices, key2);
    }
    /**
     * Returns the priority for **key**. If **key** is not present in the queue
     * then this function returns `undefined`. Takes `O(1)` time.
     *
     * @param {Object} key
     */
    priority(key2) {
      var index2 = this._keyIndices[key2];
      if (index2 !== void 0)
        return this._arr[index2].priority;
    }
    /**
     * Returns the key for the minimum element in this queue. If the queue is
     * empty this function throws an Error. Takes `O(1)` time.
     */
    min() {
      if (this.size() === 0)
        throw new Error("Queue underflow");
      return this._arr[0].key;
    }
    /**
     * Inserts a new key into the priority queue. If the key already exists in
     * the queue this function returns `false`; otherwise it will return `true`.
     * Takes `O(n)` time.
     *
     * @param {Object} key the key to add
     * @param {Number} priority the initial priority for the key
     */
    add(key2, priority) {
      var keyIndices = this._keyIndices;
      if (key2 = String(key2), !Object.hasOwn(keyIndices, key2)) {
        var arr = this._arr, index2 = arr.length;
        return keyIndices[key2] = index2, arr.push({ key: key2, priority }), this._decrease(index2), !0;
      }
      return !1;
    }
    /**
     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
     */
    removeMin() {
      this._swap(0, this._arr.length - 1);
      var min2 = this._arr.pop();
      return delete this._keyIndices[min2.key], this._heapify(0), min2.key;
    }
    /**
     * Decreases the priority for **key** to **priority**. If the new priority is
     * greater than the previous priority, this function will throw an Error.
     *
     * @param {Object} key the key for which to raise priority
     * @param {Number} priority the new priority for the key
     */
    decrease(key2, priority) {
      var index2 = this._keyIndices[key2];
      if (priority > this._arr[index2].priority)
        throw new Error("New priority is greater than current priority. Key: " + key2 + " Old: " + this._arr[index2].priority + " New: " + priority);
      this._arr[index2].priority = priority, this._decrease(index2);
    }
    _heapify(i2) {
      var arr = this._arr, l2 = 2 * i2, r2 = l2 + 1, largest = i2;
      l2 < arr.length && (largest = arr[l2].priority < arr[largest].priority ? l2 : largest, r2 < arr.length && (largest = arr[r2].priority < arr[largest].priority ? r2 : largest), largest !== i2 && (this._swap(i2, largest), this._heapify(largest)));
    }
    _decrease(index2) {
      for (var arr = this._arr, priority = arr[index2].priority, parent; index2 !== 0 && (parent = index2 >> 1, !(arr[parent].priority < priority)); )
        this._swap(index2, parent), index2 = parent;
    }
    _swap(i2, j2) {
      var arr = this._arr, keyIndices = this._keyIndices, origArrI = arr[i2], origArrJ = arr[j2];
      arr[i2] = origArrJ, arr[j2] = origArrI, keyIndices[origArrJ.key] = i2, keyIndices[origArrI.key] = j2;
    }
  }
  return priorityQueue = PriorityQueue, priorityQueue;
}
var dijkstra_1, hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra) return dijkstra_1;
  hasRequiredDijkstra = 1;
  var PriorityQueue = requirePriorityQueue();
  dijkstra_1 = dijkstra;
  var DEFAULT_WEIGHT_FUNC = () => 1;
  function dijkstra(g, source, weightFn, edgeFn) {
    return runDijkstra(
      g,
      String(source),
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v) {
        return g.outEdges(v);
      }
    );
  }
  function runDijkstra(g, source, weightFn, edgeFn) {
    var results = {}, pq = new PriorityQueue(), v, vEntry, updateNeighbors = function(edge) {
      var w = edge.v !== v ? edge.v : edge.w, wEntry = results[w], weight = weightFn(edge), distance2 = vEntry.distance + weight;
      if (weight < 0)
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
      distance2 < wEntry.distance && (wEntry.distance = distance2, wEntry.predecessor = v, pq.decrease(w, distance2));
    };
    for (g.nodes().forEach(function(v2) {
      var distance2 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
      results[v2] = { distance: distance2 }, pq.add(v2, distance2);
    }); pq.size() > 0 && (v = pq.removeMin(), vEntry = results[v], vEntry.distance !== Number.POSITIVE_INFINITY); )
      edgeFn(v).forEach(updateNeighbors);
    return results;
  }
  return dijkstra_1;
}
var dijkstraAll_1, hasRequiredDijkstraAll;
function requireDijkstraAll() {
  if (hasRequiredDijkstraAll) return dijkstraAll_1;
  hasRequiredDijkstraAll = 1;
  var dijkstra = requireDijkstra();
  dijkstraAll_1 = dijkstraAll;
  function dijkstraAll(g, weightFunc, edgeFunc) {
    return g.nodes().reduce(function(acc, v) {
      return acc[v] = dijkstra(g, v, weightFunc, edgeFunc), acc;
    }, {});
  }
  return dijkstraAll_1;
}
var tarjan_1, hasRequiredTarjan;
function requireTarjan() {
  if (hasRequiredTarjan) return tarjan_1;
  hasRequiredTarjan = 1, tarjan_1 = tarjan;
  function tarjan(g) {
    var index2 = 0, stack = [], visited = {}, results = [];
    function dfs(v) {
      var entry = visited[v] = {
        onStack: !0,
        lowlink: index2,
        index: index2++
      };
      if (stack.push(v), g.successors(v).forEach(function(w2) {
        Object.hasOwn(visited, w2) ? visited[w2].onStack && (entry.lowlink = Math.min(entry.lowlink, visited[w2].index)) : (dfs(w2), entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink));
      }), entry.lowlink === entry.index) {
        var cmpt = [], w;
        do
          w = stack.pop(), visited[w].onStack = !1, cmpt.push(w);
        while (v !== w);
        results.push(cmpt);
      }
    }
    return g.nodes().forEach(function(v) {
      Object.hasOwn(visited, v) || dfs(v);
    }), results;
  }
  return tarjan_1;
}
var findCycles_1, hasRequiredFindCycles;
function requireFindCycles() {
  if (hasRequiredFindCycles) return findCycles_1;
  hasRequiredFindCycles = 1;
  var tarjan = requireTarjan();
  findCycles_1 = findCycles;
  function findCycles(g) {
    return tarjan(g).filter(function(cmpt) {
      return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
    });
  }
  return findCycles_1;
}
var floydWarshall_1, hasRequiredFloydWarshall;
function requireFloydWarshall() {
  if (hasRequiredFloydWarshall) return floydWarshall_1;
  hasRequiredFloydWarshall = 1, floydWarshall_1 = floydWarshall;
  var DEFAULT_WEIGHT_FUNC = () => 1;
  function floydWarshall(g, weightFn, edgeFn) {
    return runFloydWarshall(
      g,
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v) {
        return g.outEdges(v);
      }
    );
  }
  function runFloydWarshall(g, weightFn, edgeFn) {
    var results = {}, nodes = g.nodes();
    return nodes.forEach(function(v) {
      results[v] = {}, results[v][v] = { distance: 0 }, nodes.forEach(function(w) {
        v !== w && (results[v][w] = { distance: Number.POSITIVE_INFINITY });
      }), edgeFn(v).forEach(function(edge) {
        var w = edge.v === v ? edge.w : edge.v, d2 = weightFn(edge);
        results[v][w] = { distance: d2, predecessor: v };
      });
    }), nodes.forEach(function(k2) {
      var rowK = results[k2];
      nodes.forEach(function(i2) {
        var rowI = results[i2];
        nodes.forEach(function(j2) {
          var ik = rowI[k2], kj = rowK[j2], ij = rowI[j2], altDistance = ik.distance + kj.distance;
          altDistance < ij.distance && (ij.distance = altDistance, ij.predecessor = kj.predecessor);
        });
      });
    }), results;
  }
  return floydWarshall_1;
}
var topsort_1, hasRequiredTopsort;
function requireTopsort() {
  if (hasRequiredTopsort) return topsort_1;
  hasRequiredTopsort = 1;
  function topsort(g) {
    var visited = {}, stack = {}, results = [];
    function visit(node2) {
      if (Object.hasOwn(stack, node2))
        throw new CycleException();
      Object.hasOwn(visited, node2) || (stack[node2] = !0, visited[node2] = !0, g.predecessors(node2).forEach(visit), delete stack[node2], results.push(node2));
    }
    if (g.sinks().forEach(visit), Object.keys(visited).length !== g.nodeCount())
      throw new CycleException();
    return results;
  }
  class CycleException extends Error {
    constructor() {
      super(...arguments);
    }
  }
  return topsort_1 = topsort, topsort.CycleException = CycleException, topsort_1;
}
var isAcyclic_1, hasRequiredIsAcyclic;
function requireIsAcyclic() {
  if (hasRequiredIsAcyclic) return isAcyclic_1;
  hasRequiredIsAcyclic = 1;
  var topsort = requireTopsort();
  isAcyclic_1 = isAcyclic;
  function isAcyclic(g) {
    try {
      topsort(g);
    } catch (e2) {
      if (e2 instanceof topsort.CycleException)
        return !1;
      throw e2;
    }
    return !0;
  }
  return isAcyclic_1;
}
var dfs_1, hasRequiredDfs;
function requireDfs() {
  if (hasRequiredDfs) return dfs_1;
  hasRequiredDfs = 1, dfs_1 = dfs;
  function dfs(g, vs, order) {
    Array.isArray(vs) || (vs = [vs]);
    var navigation = g.isDirected() ? (v) => g.successors(v) : (v) => g.neighbors(v), orderFunc = order === "post" ? postOrderDfs : preOrderDfs, acc = [], visited = {};
    return vs.forEach((v) => {
      if (!g.hasNode(v))
        throw new Error("Graph does not have node: " + v);
      orderFunc(v, navigation, visited, acc);
    }), acc;
  }
  function postOrderDfs(v, navigation, visited, acc) {
    for (var stack = [[v, !1]]; stack.length > 0; ) {
      var curr = stack.pop();
      curr[1] ? acc.push(curr[0]) : Object.hasOwn(visited, curr[0]) || (visited[curr[0]] = !0, stack.push([curr[0], !0]), forEachRight(navigation(curr[0]), (w) => stack.push([w, !1])));
    }
  }
  function preOrderDfs(v, navigation, visited, acc) {
    for (var stack = [v]; stack.length > 0; ) {
      var curr = stack.pop();
      Object.hasOwn(visited, curr) || (visited[curr] = !0, acc.push(curr), forEachRight(navigation(curr), (w) => stack.push(w)));
    }
  }
  function forEachRight(array2, iteratee) {
    for (var length = array2.length; length--; )
      iteratee(array2[length], length, array2);
    return array2;
  }
  return dfs_1;
}
var postorder_1, hasRequiredPostorder;
function requirePostorder() {
  if (hasRequiredPostorder) return postorder_1;
  hasRequiredPostorder = 1;
  var dfs = requireDfs();
  postorder_1 = postorder;
  function postorder(g, vs) {
    return dfs(g, vs, "post");
  }
  return postorder_1;
}
var preorder_1, hasRequiredPreorder;
function requirePreorder() {
  if (hasRequiredPreorder) return preorder_1;
  hasRequiredPreorder = 1;
  var dfs = requireDfs();
  preorder_1 = preorder;
  function preorder(g, vs) {
    return dfs(g, vs, "pre");
  }
  return preorder_1;
}
var prim_1, hasRequiredPrim;
function requirePrim() {
  if (hasRequiredPrim) return prim_1;
  hasRequiredPrim = 1;
  var Graph = requireGraph(), PriorityQueue = requirePriorityQueue();
  prim_1 = prim;
  function prim(g, weightFunc) {
    var result = new Graph(), parents = {}, pq = new PriorityQueue(), v;
    function updateNeighbors(edge) {
      var w = edge.v === v ? edge.w : edge.v, pri = pq.priority(w);
      if (pri !== void 0) {
        var edgeWeight = weightFunc(edge);
        edgeWeight < pri && (parents[w] = v, pq.decrease(w, edgeWeight));
      }
    }
    if (g.nodeCount() === 0)
      return result;
    g.nodes().forEach(function(v2) {
      pq.add(v2, Number.POSITIVE_INFINITY), result.setNode(v2);
    }), pq.decrease(g.nodes()[0], 0);
    for (var init2 = !1; pq.size() > 0; ) {
      if (v = pq.removeMin(), Object.hasOwn(parents, v))
        result.setEdge(v, parents[v]);
      else {
        if (init2)
          throw new Error("Input graph is not connected: " + g);
        init2 = !0;
      }
      g.nodeEdges(v).forEach(updateNeighbors);
    }
    return result;
  }
  return prim_1;
}
var alg, hasRequiredAlg;
function requireAlg() {
  return hasRequiredAlg || (hasRequiredAlg = 1, alg = {
    components: requireComponents(),
    dijkstra: requireDijkstra(),
    dijkstraAll: requireDijkstraAll(),
    findCycles: requireFindCycles(),
    floydWarshall: requireFloydWarshall(),
    isAcyclic: requireIsAcyclic(),
    postorder: requirePostorder(),
    preorder: requirePreorder(),
    prim: requirePrim(),
    tarjan: requireTarjan(),
    topsort: requireTopsort()
  }), alg;
}
var graphlib, hasRequiredGraphlib;
function requireGraphlib() {
  if (hasRequiredGraphlib) return graphlib;
  hasRequiredGraphlib = 1;
  var lib2 = requireLib();
  return graphlib = {
    Graph: lib2.Graph,
    json: requireJson(),
    alg: requireAlg(),
    version: lib2.version
  }, graphlib;
}
var list, hasRequiredList;
function requireList() {
  if (hasRequiredList) return list;
  hasRequiredList = 1;
  class List {
    constructor() {
      let sentinel = {};
      sentinel._next = sentinel._prev = sentinel, this._sentinel = sentinel;
    }
    dequeue() {
      let sentinel = this._sentinel, entry = sentinel._prev;
      if (entry !== sentinel)
        return unlink(entry), entry;
    }
    enqueue(entry) {
      let sentinel = this._sentinel;
      entry._prev && entry._next && unlink(entry), entry._next = sentinel._next, sentinel._next._prev = entry, sentinel._next = entry, entry._prev = sentinel;
    }
    toString() {
      let strs = [], sentinel = this._sentinel, curr = sentinel._prev;
      for (; curr !== sentinel; )
        strs.push(JSON.stringify(curr, filterOutLinks)), curr = curr._prev;
      return "[" + strs.join(", ") + "]";
    }
  }
  function unlink(entry) {
    entry._prev._next = entry._next, entry._next._prev = entry._prev, delete entry._next, delete entry._prev;
  }
  function filterOutLinks(k2, v) {
    if (k2 !== "_next" && k2 !== "_prev")
      return v;
  }
  return list = List, list;
}
var greedyFas, hasRequiredGreedyFas;
function requireGreedyFas() {
  if (hasRequiredGreedyFas) return greedyFas;
  hasRequiredGreedyFas = 1;
  let Graph = requireGraphlib().Graph, List = requireList();
  greedyFas = greedyFAS;
  let DEFAULT_WEIGHT_FN = () => 1;
  function greedyFAS(g, weightFn) {
    if (g.nodeCount() <= 1)
      return [];
    let state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
    return doGreedyFAS(state.graph, state.buckets, state.zeroIdx).flatMap((e2) => g.outEdges(e2.v, e2.w));
  }
  function doGreedyFAS(g, buckets, zeroIdx) {
    let results = [], sources = buckets[buckets.length - 1], sinks = buckets[0], entry;
    for (; g.nodeCount(); ) {
      for (; entry = sinks.dequeue(); )
        removeNode(g, buckets, zeroIdx, entry);
      for (; entry = sources.dequeue(); )
        removeNode(g, buckets, zeroIdx, entry);
      if (g.nodeCount()) {
        for (let i2 = buckets.length - 2; i2 > 0; --i2)
          if (entry = buckets[i2].dequeue(), entry) {
            results = results.concat(removeNode(g, buckets, zeroIdx, entry, !0));
            break;
          }
      }
    }
    return results;
  }
  function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
    let results = collectPredecessors ? [] : void 0;
    return g.inEdges(entry.v).forEach((edge) => {
      let weight = g.edge(edge), uEntry = g.node(edge.v);
      collectPredecessors && results.push({ v: edge.v, w: edge.w }), uEntry.out -= weight, assignBucket(buckets, zeroIdx, uEntry);
    }), g.outEdges(entry.v).forEach((edge) => {
      let weight = g.edge(edge), w = edge.w, wEntry = g.node(w);
      wEntry.in -= weight, assignBucket(buckets, zeroIdx, wEntry);
    }), g.removeNode(entry.v), results;
  }
  function buildState(g, weightFn) {
    let fasGraph = new Graph(), maxIn = 0, maxOut = 0;
    g.nodes().forEach((v) => {
      fasGraph.setNode(v, { v, in: 0, out: 0 });
    }), g.edges().forEach((e2) => {
      let prevWeight = fasGraph.edge(e2.v, e2.w) || 0, weight = weightFn(e2), edgeWeight = prevWeight + weight;
      fasGraph.setEdge(e2.v, e2.w, edgeWeight), maxOut = Math.max(maxOut, fasGraph.node(e2.v).out += weight), maxIn = Math.max(maxIn, fasGraph.node(e2.w).in += weight);
    });
    let buckets = range(maxOut + maxIn + 3).map(() => new List()), zeroIdx = maxIn + 1;
    return fasGraph.nodes().forEach((v) => {
      assignBucket(buckets, zeroIdx, fasGraph.node(v));
    }), { graph: fasGraph, buckets, zeroIdx };
  }
  function assignBucket(buckets, zeroIdx, entry) {
    entry.out ? entry.in ? buckets[entry.out - entry.in + zeroIdx].enqueue(entry) : buckets[buckets.length - 1].enqueue(entry) : buckets[0].enqueue(entry);
  }
  function range(limit) {
    const range2 = [];
    for (let i2 = 0; i2 < limit; i2++)
      range2.push(i2);
    return range2;
  }
  return greedyFas;
}
var util$1, hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  let Graph = requireGraphlib().Graph;
  util$1 = {
    addBorderNode,
    addDummyNode,
    applyWithChunking,
    asNonCompoundGraph,
    buildLayerMatrix,
    intersectRect,
    mapValues,
    maxRank,
    normalizeRanks,
    notime,
    partition,
    pick: pick2,
    predecessorWeights,
    range,
    removeEmptyRanks,
    simplify,
    successorWeights,
    time: time2,
    uniqueId,
    zipObject
  };
  function addDummyNode(g, type, attrs, name) {
    let v;
    do
      v = uniqueId(name);
    while (g.hasNode(v));
    return attrs.dummy = type, g.setNode(v, attrs), v;
  }
  function simplify(g) {
    let simplified = new Graph().setGraph(g.graph());
    return g.nodes().forEach((v) => simplified.setNode(v, g.node(v))), g.edges().forEach((e2) => {
      let simpleLabel = simplified.edge(e2.v, e2.w) || { weight: 0, minlen: 1 }, label2 = g.edge(e2);
      simplified.setEdge(e2.v, e2.w, {
        weight: simpleLabel.weight + label2.weight,
        minlen: Math.max(simpleLabel.minlen, label2.minlen)
      });
    }), simplified;
  }
  function asNonCompoundGraph(g) {
    let simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
    return g.nodes().forEach((v) => {
      g.children(v).length || simplified.setNode(v, g.node(v));
    }), g.edges().forEach((e2) => {
      simplified.setEdge(e2, g.edge(e2));
    }), simplified;
  }
  function successorWeights(g) {
    let weightMap = g.nodes().map((v) => {
      let sucs = {};
      return g.outEdges(v).forEach((e2) => {
        sucs[e2.w] = (sucs[e2.w] || 0) + g.edge(e2).weight;
      }), sucs;
    });
    return zipObject(g.nodes(), weightMap);
  }
  function predecessorWeights(g) {
    let weightMap = g.nodes().map((v) => {
      let preds = {};
      return g.inEdges(v).forEach((e2) => {
        preds[e2.v] = (preds[e2.v] || 0) + g.edge(e2).weight;
      }), preds;
    });
    return zipObject(g.nodes(), weightMap);
  }
  function intersectRect(rect, point2) {
    let x2 = rect.x, y2 = rect.y, dx = point2.x - x2, dy = point2.y - y2, w = rect.width / 2, h = rect.height / 2;
    if (!dx && !dy)
      throw new Error("Not possible to find intersection inside of the rectangle");
    let sx, sy;
    return Math.abs(dy) * w > Math.abs(dx) * h ? (dy < 0 && (h = -h), sx = h * dx / dy, sy = h) : (dx < 0 && (w = -w), sx = w, sy = w * dy / dx), { x: x2 + sx, y: y2 + sy };
  }
  function buildLayerMatrix(g) {
    let layering = range(maxRank(g) + 1).map(() => []);
    return g.nodes().forEach((v) => {
      let node2 = g.node(v), rank = node2.rank;
      rank !== void 0 && (layering[rank][node2.order] = v);
    }), layering;
  }
  function normalizeRanks(g) {
    let nodeRanks = g.nodes().map((v) => {
      let rank = g.node(v).rank;
      return rank === void 0 ? Number.MAX_VALUE : rank;
    }), min2 = applyWithChunking(Math.min, nodeRanks);
    g.nodes().forEach((v) => {
      let node2 = g.node(v);
      Object.hasOwn(node2, "rank") && (node2.rank -= min2);
    });
  }
  function removeEmptyRanks(g) {
    let nodeRanks = g.nodes().map((v) => g.node(v).rank), offset2 = applyWithChunking(Math.min, nodeRanks), layers = [];
    g.nodes().forEach((v) => {
      let rank = g.node(v).rank - offset2;
      layers[rank] || (layers[rank] = []), layers[rank].push(v);
    });
    let delta = 0, nodeRankFactor = g.graph().nodeRankFactor;
    Array.from(layers).forEach((vs, i2) => {
      vs === void 0 && i2 % nodeRankFactor !== 0 ? --delta : vs !== void 0 && delta && vs.forEach((v) => g.node(v).rank += delta);
    });
  }
  function addBorderNode(g, prefix2, rank, order) {
    let node2 = {
      width: 0,
      height: 0
    };
    return arguments.length >= 4 && (node2.rank = rank, node2.order = order), addDummyNode(g, "border", node2, prefix2);
  }
  function splitToChunks(array2, chunkSize = CHUNKING_THRESHOLD) {
    const chunks = [];
    for (let i2 = 0; i2 < array2.length; i2 += chunkSize) {
      const chunk = array2.slice(i2, i2 + chunkSize);
      chunks.push(chunk);
    }
    return chunks;
  }
  const CHUNKING_THRESHOLD = 65535;
  function applyWithChunking(fn, argsArray) {
    if (argsArray.length > CHUNKING_THRESHOLD) {
      const chunks = splitToChunks(argsArray);
      return fn.apply(null, chunks.map((chunk) => fn.apply(null, chunk)));
    } else
      return fn.apply(null, argsArray);
  }
  function maxRank(g) {
    const nodeRanks = g.nodes().map((v) => {
      let rank = g.node(v).rank;
      return rank === void 0 ? Number.MIN_VALUE : rank;
    });
    return applyWithChunking(Math.max, nodeRanks);
  }
  function partition(collection, fn) {
    let result = { lhs: [], rhs: [] };
    return collection.forEach((value) => {
      fn(value) ? result.lhs.push(value) : result.rhs.push(value);
    }), result;
  }
  function time2(name, fn) {
    let start2 = Date.now();
    try {
      return fn();
    } finally {
      console.log(name + " time: " + (Date.now() - start2) + "ms");
    }
  }
  function notime(name, fn) {
    return fn();
  }
  let idCounter2 = 0;
  function uniqueId(prefix2) {
    var id2 = ++idCounter2;
    return toString(prefix2) + id2;
  }
  function range(start2, limit, step = 1) {
    limit == null && (limit = start2, start2 = 0);
    let endCon = (i2) => i2 < limit;
    step < 0 && (endCon = (i2) => limit < i2);
    const range2 = [];
    for (let i2 = start2; endCon(i2); i2 += step)
      range2.push(i2);
    return range2;
  }
  function pick2(source, keys2) {
    const dest = {};
    for (const key2 of keys2)
      source[key2] !== void 0 && (dest[key2] = source[key2]);
    return dest;
  }
  function mapValues(obj, funcOrProp) {
    let func = funcOrProp;
    return typeof funcOrProp == "string" && (func = (val) => val[funcOrProp]), Object.entries(obj).reduce((acc, [k2, v]) => (acc[k2] = func(v, k2), acc), {});
  }
  function zipObject(props, values2) {
    return props.reduce((acc, key2, i2) => (acc[key2] = values2[i2], acc), {});
  }
  return util$1;
}
var acyclic, hasRequiredAcyclic;
function requireAcyclic() {
  if (hasRequiredAcyclic) return acyclic;
  hasRequiredAcyclic = 1;
  let greedyFAS = requireGreedyFas(), uniqueId = requireUtil$1().uniqueId;
  acyclic = {
    run,
    undo
  };
  function run(g) {
    (g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g)).forEach((e2) => {
      let label2 = g.edge(e2);
      g.removeEdge(e2), label2.forwardName = e2.name, label2.reversed = !0, g.setEdge(e2.w, e2.v, label2, uniqueId("rev"));
    });
    function weightFn(g2) {
      return (e2) => g2.edge(e2).weight;
    }
  }
  function dfsFAS(g) {
    let fas = [], stack = {}, visited = {};
    function dfs(v) {
      Object.hasOwn(visited, v) || (visited[v] = !0, stack[v] = !0, g.outEdges(v).forEach((e2) => {
        Object.hasOwn(stack, e2.w) ? fas.push(e2) : dfs(e2.w);
      }), delete stack[v]);
    }
    return g.nodes().forEach(dfs), fas;
  }
  function undo(g) {
    g.edges().forEach((e2) => {
      let label2 = g.edge(e2);
      if (label2.reversed) {
        g.removeEdge(e2);
        let forwardName = label2.forwardName;
        delete label2.reversed, delete label2.forwardName, g.setEdge(e2.w, e2.v, label2, forwardName);
      }
    });
  }
  return acyclic;
}
var normalize, hasRequiredNormalize;
function requireNormalize() {
  if (hasRequiredNormalize) return normalize;
  hasRequiredNormalize = 1;
  let util2 = requireUtil$1();
  normalize = {
    run,
    undo
  };
  function run(g) {
    g.graph().dummyChains = [], g.edges().forEach((edge) => normalizeEdge(g, edge));
  }
  function normalizeEdge(g, e2) {
    let v = e2.v, vRank = g.node(v).rank, w = e2.w, wRank = g.node(w).rank, name = e2.name, edgeLabel2 = g.edge(e2), labelRank = edgeLabel2.labelRank;
    if (wRank === vRank + 1) return;
    g.removeEdge(e2);
    let dummy, attrs, i2;
    for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank)
      edgeLabel2.points = [], attrs = {
        width: 0,
        height: 0,
        edgeLabel: edgeLabel2,
        edgeObj: e2,
        rank: vRank
      }, dummy = util2.addDummyNode(g, "edge", attrs, "_d"), vRank === labelRank && (attrs.width = edgeLabel2.width, attrs.height = edgeLabel2.height, attrs.dummy = "edge-label", attrs.labelpos = edgeLabel2.labelpos), g.setEdge(v, dummy, { weight: edgeLabel2.weight }, name), i2 === 0 && g.graph().dummyChains.push(dummy), v = dummy;
    g.setEdge(v, w, { weight: edgeLabel2.weight }, name);
  }
  function undo(g) {
    g.graph().dummyChains.forEach((v) => {
      let node2 = g.node(v), origLabel = node2.edgeLabel, w;
      for (g.setEdge(node2.edgeObj, origLabel); node2.dummy; )
        w = g.successors(v)[0], g.removeNode(v), origLabel.points.push({ x: node2.x, y: node2.y }), node2.dummy === "edge-label" && (origLabel.x = node2.x, origLabel.y = node2.y, origLabel.width = node2.width, origLabel.height = node2.height), v = w, node2 = g.node(v);
    });
  }
  return normalize;
}
var util, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  const { applyWithChunking } = requireUtil$1();
  util = {
    longestPath,
    slack
  };
  function longestPath(g) {
    var visited = {};
    function dfs(v) {
      var label2 = g.node(v);
      if (Object.hasOwn(visited, v))
        return label2.rank;
      visited[v] = !0;
      let outEdgesMinLens = g.outEdges(v).map((e2) => e2 == null ? Number.POSITIVE_INFINITY : dfs(e2.w) - g.edge(e2).minlen);
      var rank = applyWithChunking(Math.min, outEdgesMinLens);
      return rank === Number.POSITIVE_INFINITY && (rank = 0), label2.rank = rank;
    }
    g.sources().forEach(dfs);
  }
  function slack(g, e2) {
    return g.node(e2.w).rank - g.node(e2.v).rank - g.edge(e2).minlen;
  }
  return util;
}
var feasibleTree_1, hasRequiredFeasibleTree;
function requireFeasibleTree() {
  if (hasRequiredFeasibleTree) return feasibleTree_1;
  hasRequiredFeasibleTree = 1;
  var Graph = requireGraphlib().Graph, slack = requireUtil().slack;
  feasibleTree_1 = feasibleTree;
  function feasibleTree(g) {
    var t2 = new Graph({ directed: !1 }), start2 = g.nodes()[0], size2 = g.nodeCount();
    t2.setNode(start2, {});
    for (var edge, delta; tightTree(t2, g) < size2; )
      edge = findMinSlackEdge(t2, g), delta = t2.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge), shiftRanks(t2, g, delta);
    return t2;
  }
  function tightTree(t2, g) {
    function dfs(v) {
      g.nodeEdges(v).forEach((e2) => {
        var edgeV = e2.v, w = v === edgeV ? e2.w : edgeV;
        !t2.hasNode(w) && !slack(g, e2) && (t2.setNode(w, {}), t2.setEdge(v, w, {}), dfs(w));
      });
    }
    return t2.nodes().forEach(dfs), t2.nodeCount();
  }
  function findMinSlackEdge(t2, g) {
    return g.edges().reduce((acc, edge) => {
      let edgeSlack = Number.POSITIVE_INFINITY;
      return t2.hasNode(edge.v) !== t2.hasNode(edge.w) && (edgeSlack = slack(g, edge)), edgeSlack < acc[0] ? [edgeSlack, edge] : acc;
    }, [Number.POSITIVE_INFINITY, null])[1];
  }
  function shiftRanks(t2, g, delta) {
    t2.nodes().forEach((v) => g.node(v).rank += delta);
  }
  return feasibleTree_1;
}
var networkSimplex_1, hasRequiredNetworkSimplex;
function requireNetworkSimplex() {
  if (hasRequiredNetworkSimplex) return networkSimplex_1;
  hasRequiredNetworkSimplex = 1;
  var feasibleTree = requireFeasibleTree(), slack = requireUtil().slack, initRank = requireUtil().longestPath, preorder = requireGraphlib().alg.preorder, postorder = requireGraphlib().alg.postorder, simplify = requireUtil$1().simplify;
  networkSimplex_1 = networkSimplex, networkSimplex.initLowLimValues = initLowLimValues, networkSimplex.initCutValues = initCutValues, networkSimplex.calcCutValue = calcCutValue, networkSimplex.leaveEdge = leaveEdge, networkSimplex.enterEdge = enterEdge, networkSimplex.exchangeEdges = exchangeEdges;
  function networkSimplex(g) {
    g = simplify(g), initRank(g);
    var t2 = feasibleTree(g);
    initLowLimValues(t2), initCutValues(t2, g);
    for (var e2, f2; e2 = leaveEdge(t2); )
      f2 = enterEdge(t2, g, e2), exchangeEdges(t2, g, e2, f2);
  }
  function initCutValues(t2, g) {
    var vs = postorder(t2, t2.nodes());
    vs = vs.slice(0, vs.length - 1), vs.forEach((v) => assignCutValue(t2, g, v));
  }
  function assignCutValue(t2, g, child) {
    var childLab = t2.node(child), parent = childLab.parent;
    t2.edge(child, parent).cutvalue = calcCutValue(t2, g, child);
  }
  function calcCutValue(t2, g, child) {
    var childLab = t2.node(child), parent = childLab.parent, childIsTail = !0, graphEdge = g.edge(child, parent), cutValue = 0;
    return graphEdge || (childIsTail = !1, graphEdge = g.edge(parent, child)), cutValue = graphEdge.weight, g.nodeEdges(child).forEach((e2) => {
      var isOutEdge = e2.v === child, other = isOutEdge ? e2.w : e2.v;
      if (other !== parent) {
        var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e2).weight;
        if (cutValue += pointsToHead ? otherWeight : -otherWeight, isTreeEdge(t2, child, other)) {
          var otherCutValue = t2.edge(child, other).cutvalue;
          cutValue += pointsToHead ? -otherCutValue : otherCutValue;
        }
      }
    }), cutValue;
  }
  function initLowLimValues(tree, root2) {
    arguments.length < 2 && (root2 = tree.nodes()[0]), dfsAssignLowLim(tree, {}, 1, root2);
  }
  function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
    var low = nextLim, label2 = tree.node(v);
    return visited[v] = !0, tree.neighbors(v).forEach((w) => {
      Object.hasOwn(visited, w) || (nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v));
    }), label2.low = low, label2.lim = nextLim++, parent ? label2.parent = parent : delete label2.parent, nextLim;
  }
  function leaveEdge(tree) {
    return tree.edges().find((e2) => tree.edge(e2).cutvalue < 0);
  }
  function enterEdge(t2, g, edge) {
    var v = edge.v, w = edge.w;
    g.hasEdge(v, w) || (v = edge.w, w = edge.v);
    var vLabel = t2.node(v), wLabel = t2.node(w), tailLabel = vLabel, flip2 = !1;
    vLabel.lim > wLabel.lim && (tailLabel = wLabel, flip2 = !0);
    var candidates = g.edges().filter((edge2) => flip2 === isDescendant(t2, t2.node(edge2.v), tailLabel) && flip2 !== isDescendant(t2, t2.node(edge2.w), tailLabel));
    return candidates.reduce((acc, edge2) => slack(g, edge2) < slack(g, acc) ? edge2 : acc);
  }
  function exchangeEdges(t2, g, e2, f2) {
    var v = e2.v, w = e2.w;
    t2.removeEdge(v, w), t2.setEdge(f2.v, f2.w, {}), initLowLimValues(t2), initCutValues(t2, g), updateRanks(t2, g);
  }
  function updateRanks(t2, g) {
    var root2 = t2.nodes().find((v) => !g.node(v).parent), vs = preorder(t2, root2);
    vs = vs.slice(1), vs.forEach((v) => {
      var parent = t2.node(v).parent, edge = g.edge(v, parent), flipped = !1;
      edge || (edge = g.edge(parent, v), flipped = !0), g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
    });
  }
  function isTreeEdge(tree, u2, v) {
    return tree.hasEdge(u2, v);
  }
  function isDescendant(tree, vLabel, rootLabel) {
    return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
  }
  return networkSimplex_1;
}
var rank_1, hasRequiredRank;
function requireRank() {
  if (hasRequiredRank) return rank_1;
  hasRequiredRank = 1;
  var rankUtil = requireUtil(), longestPath = rankUtil.longestPath, feasibleTree = requireFeasibleTree(), networkSimplex = requireNetworkSimplex();
  rank_1 = rank;
  function rank(g) {
    switch (g.graph().ranker) {
      case "network-simplex":
        networkSimplexRanker(g);
        break;
      case "tight-tree":
        tightTreeRanker(g);
        break;
      case "longest-path":
        longestPathRanker(g);
        break;
      default:
        networkSimplexRanker(g);
    }
  }
  var longestPathRanker = longestPath;
  function tightTreeRanker(g) {
    longestPath(g), feasibleTree(g);
  }
  function networkSimplexRanker(g) {
    networkSimplex(g);
  }
  return rank_1;
}
var parentDummyChains_1, hasRequiredParentDummyChains;
function requireParentDummyChains() {
  if (hasRequiredParentDummyChains) return parentDummyChains_1;
  hasRequiredParentDummyChains = 1, parentDummyChains_1 = parentDummyChains;
  function parentDummyChains(g) {
    let postorderNums = postorder(g);
    g.graph().dummyChains.forEach((v) => {
      let node2 = g.node(v), edgeObj = node2.edgeObj, pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w), path = pathData.path, lca = pathData.lca, pathIdx = 0, pathV = path[pathIdx], ascending2 = !0;
      for (; v !== edgeObj.w; ) {
        if (node2 = g.node(v), ascending2) {
          for (; (pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node2.rank; )
            pathIdx++;
          pathV === lca && (ascending2 = !1);
        }
        if (!ascending2) {
          for (; pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node2.rank; )
            pathIdx++;
          pathV = path[pathIdx];
        }
        g.setParent(v, pathV), v = g.successors(v)[0];
      }
    });
  }
  function findPath(g, postorderNums, v, w) {
    let vPath = [], wPath = [], low = Math.min(postorderNums[v].low, postorderNums[w].low), lim = Math.max(postorderNums[v].lim, postorderNums[w].lim), parent, lca;
    parent = v;
    do
      parent = g.parent(parent), vPath.push(parent);
    while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
    for (lca = parent, parent = w; (parent = g.parent(parent)) !== lca; )
      wPath.push(parent);
    return { path: vPath.concat(wPath.reverse()), lca };
  }
  function postorder(g) {
    let result = {}, lim = 0;
    function dfs(v) {
      let low = lim;
      g.children(v).forEach(dfs), result[v] = { low, lim: lim++ };
    }
    return g.children().forEach(dfs), result;
  }
  return parentDummyChains_1;
}
var nestingGraph, hasRequiredNestingGraph;
function requireNestingGraph() {
  if (hasRequiredNestingGraph) return nestingGraph;
  hasRequiredNestingGraph = 1;
  let util2 = requireUtil$1();
  nestingGraph = {
    run,
    cleanup
  };
  function run(g) {
    let root2 = util2.addDummyNode(g, "root", {}, "_root"), depths = treeDepths(g), depthsArr = Object.values(depths), height = util2.applyWithChunking(Math.max, depthsArr) - 1, nodeSep = 2 * height + 1;
    g.graph().nestingRoot = root2, g.edges().forEach((e2) => g.edge(e2).minlen *= nodeSep);
    let weight = sumWeights(g) + 1;
    g.children().forEach((child) => dfs(g, root2, nodeSep, weight, height, depths, child)), g.graph().nodeRankFactor = nodeSep;
  }
  function dfs(g, root2, nodeSep, weight, height, depths, v) {
    let children2 = g.children(v);
    if (!children2.length) {
      v !== root2 && g.setEdge(root2, v, { weight: 0, minlen: nodeSep });
      return;
    }
    let top = util2.addBorderNode(g, "_bt"), bottom = util2.addBorderNode(g, "_bb"), label2 = g.node(v);
    g.setParent(top, v), label2.borderTop = top, g.setParent(bottom, v), label2.borderBottom = bottom, children2.forEach((child) => {
      dfs(g, root2, nodeSep, weight, height, depths, child);
      let childNode = g.node(child), childTop = childNode.borderTop ? childNode.borderTop : child, childBottom = childNode.borderBottom ? childNode.borderBottom : child, thisWeight = childNode.borderTop ? weight : 2 * weight, minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
      g.setEdge(top, childTop, {
        weight: thisWeight,
        minlen,
        nestingEdge: !0
      }), g.setEdge(childBottom, bottom, {
        weight: thisWeight,
        minlen,
        nestingEdge: !0
      });
    }), g.parent(v) || g.setEdge(root2, top, { weight: 0, minlen: height + depths[v] });
  }
  function treeDepths(g) {
    var depths = {};
    function dfs2(v, depth) {
      var children2 = g.children(v);
      children2 && children2.length && children2.forEach((child) => dfs2(child, depth + 1)), depths[v] = depth;
    }
    return g.children().forEach((v) => dfs2(v, 1)), depths;
  }
  function sumWeights(g) {
    return g.edges().reduce((acc, e2) => acc + g.edge(e2).weight, 0);
  }
  function cleanup(g) {
    var graphLabel = g.graph();
    g.removeNode(graphLabel.nestingRoot), delete graphLabel.nestingRoot, g.edges().forEach((e2) => {
      var edge = g.edge(e2);
      edge.nestingEdge && g.removeEdge(e2);
    });
  }
  return nestingGraph;
}
var addBorderSegments_1, hasRequiredAddBorderSegments;
function requireAddBorderSegments() {
  if (hasRequiredAddBorderSegments) return addBorderSegments_1;
  hasRequiredAddBorderSegments = 1;
  let util2 = requireUtil$1();
  addBorderSegments_1 = addBorderSegments;
  function addBorderSegments(g) {
    function dfs(v) {
      let children2 = g.children(v), node2 = g.node(v);
      if (children2.length && children2.forEach(dfs), Object.hasOwn(node2, "minRank")) {
        node2.borderLeft = [], node2.borderRight = [];
        for (let rank = node2.minRank, maxRank = node2.maxRank + 1; rank < maxRank; ++rank)
          addBorderNode(g, "borderLeft", "_bl", v, node2, rank), addBorderNode(g, "borderRight", "_br", v, node2, rank);
      }
    }
    g.children().forEach(dfs);
  }
  function addBorderNode(g, prop, prefix2, sg, sgNode, rank) {
    let label2 = { width: 0, height: 0, rank, borderType: prop }, prev = sgNode[prop][rank - 1], curr = util2.addDummyNode(g, "border", label2, prefix2);
    sgNode[prop][rank] = curr, g.setParent(curr, sg), prev && g.setEdge(prev, curr, { weight: 1 });
  }
  return addBorderSegments_1;
}
var coordinateSystem, hasRequiredCoordinateSystem;
function requireCoordinateSystem() {
  if (hasRequiredCoordinateSystem) return coordinateSystem;
  hasRequiredCoordinateSystem = 1, coordinateSystem = {
    adjust,
    undo
  };
  function adjust(g) {
    let rankDir = g.graph().rankdir.toLowerCase();
    (rankDir === "lr" || rankDir === "rl") && swapWidthHeight(g);
  }
  function undo(g) {
    let rankDir = g.graph().rankdir.toLowerCase();
    (rankDir === "bt" || rankDir === "rl") && reverseY(g), (rankDir === "lr" || rankDir === "rl") && (swapXY(g), swapWidthHeight(g));
  }
  function swapWidthHeight(g) {
    g.nodes().forEach((v) => swapWidthHeightOne(g.node(v))), g.edges().forEach((e2) => swapWidthHeightOne(g.edge(e2)));
  }
  function swapWidthHeightOne(attrs) {
    let w = attrs.width;
    attrs.width = attrs.height, attrs.height = w;
  }
  function reverseY(g) {
    g.nodes().forEach((v) => reverseYOne(g.node(v))), g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.points.forEach(reverseYOne), Object.hasOwn(edge, "y") && reverseYOne(edge);
    });
  }
  function reverseYOne(attrs) {
    attrs.y = -attrs.y;
  }
  function swapXY(g) {
    g.nodes().forEach((v) => swapXYOne(g.node(v))), g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.points.forEach(swapXYOne), Object.hasOwn(edge, "x") && swapXYOne(edge);
    });
  }
  function swapXYOne(attrs) {
    let x2 = attrs.x;
    attrs.x = attrs.y, attrs.y = x2;
  }
  return coordinateSystem;
}
var initOrder_1, hasRequiredInitOrder;
function requireInitOrder() {
  if (hasRequiredInitOrder) return initOrder_1;
  hasRequiredInitOrder = 1;
  let util2 = requireUtil$1();
  initOrder_1 = initOrder;
  function initOrder(g) {
    let visited = {}, simpleNodes = g.nodes().filter((v) => !g.children(v).length), simpleNodesRanks = simpleNodes.map((v) => g.node(v).rank), maxRank = util2.applyWithChunking(Math.max, simpleNodesRanks), layers = util2.range(maxRank + 1).map(() => []);
    function dfs(v) {
      if (visited[v]) return;
      visited[v] = !0;
      let node2 = g.node(v);
      layers[node2.rank].push(v), g.successors(v).forEach(dfs);
    }
    return simpleNodes.sort((a2, b2) => g.node(a2).rank - g.node(b2).rank).forEach(dfs), layers;
  }
  return initOrder_1;
}
var crossCount_1, hasRequiredCrossCount;
function requireCrossCount() {
  if (hasRequiredCrossCount) return crossCount_1;
  hasRequiredCrossCount = 1;
  let zipObject = requireUtil$1().zipObject;
  crossCount_1 = crossCount;
  function crossCount(g, layering) {
    let cc2 = 0;
    for (let i2 = 1; i2 < layering.length; ++i2)
      cc2 += twoLayerCrossCount(g, layering[i2 - 1], layering[i2]);
    return cc2;
  }
  function twoLayerCrossCount(g, northLayer, southLayer) {
    let southPos = zipObject(southLayer, southLayer.map((v, i2) => i2)), southEntries = northLayer.flatMap((v) => g.outEdges(v).map((e2) => ({ pos: southPos[e2.w], weight: g.edge(e2).weight })).sort((a2, b2) => a2.pos - b2.pos)), firstIndex = 1;
    for (; firstIndex < southLayer.length; ) firstIndex <<= 1;
    let treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    let tree = new Array(treeSize).fill(0), cc2 = 0;
    return southEntries.forEach((entry) => {
      let index2 = entry.pos + firstIndex;
      tree[index2] += entry.weight;
      let weightSum = 0;
      for (; index2 > 0; )
        index2 % 2 && (weightSum += tree[index2 + 1]), index2 = index2 - 1 >> 1, tree[index2] += entry.weight;
      cc2 += entry.weight * weightSum;
    }), cc2;
  }
  return crossCount_1;
}
var barycenter_1, hasRequiredBarycenter;
function requireBarycenter() {
  if (hasRequiredBarycenter) return barycenter_1;
  hasRequiredBarycenter = 1, barycenter_1 = barycenter;
  function barycenter(g, movable = []) {
    return movable.map((v) => {
      let inV = g.inEdges(v);
      if (inV.length) {
        let result = inV.reduce((acc, e2) => {
          let edge = g.edge(e2), nodeU = g.node(e2.v);
          return {
            sum: acc.sum + edge.weight * nodeU.order,
            weight: acc.weight + edge.weight
          };
        }, { sum: 0, weight: 0 });
        return {
          v,
          barycenter: result.sum / result.weight,
          weight: result.weight
        };
      } else
        return { v };
    });
  }
  return barycenter_1;
}
var resolveConflicts_1, hasRequiredResolveConflicts;
function requireResolveConflicts() {
  if (hasRequiredResolveConflicts) return resolveConflicts_1;
  hasRequiredResolveConflicts = 1;
  let util2 = requireUtil$1();
  resolveConflicts_1 = resolveConflicts;
  function resolveConflicts(entries, cg) {
    let mappedEntries = {};
    entries.forEach((entry, i2) => {
      let tmp = mappedEntries[entry.v] = {
        indegree: 0,
        in: [],
        out: [],
        vs: [entry.v],
        i: i2
      };
      entry.barycenter !== void 0 && (tmp.barycenter = entry.barycenter, tmp.weight = entry.weight);
    }), cg.edges().forEach((e2) => {
      let entryV = mappedEntries[e2.v], entryW = mappedEntries[e2.w];
      entryV !== void 0 && entryW !== void 0 && (entryW.indegree++, entryV.out.push(mappedEntries[e2.w]));
    });
    let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
    return doResolveConflicts(sourceSet);
  }
  function doResolveConflicts(sourceSet) {
    let entries = [];
    function handleIn(vEntry) {
      return (uEntry) => {
        uEntry.merged || (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) && mergeEntries(vEntry, uEntry);
      };
    }
    function handleOut(vEntry) {
      return (wEntry) => {
        wEntry.in.push(vEntry), --wEntry.indegree === 0 && sourceSet.push(wEntry);
      };
    }
    for (; sourceSet.length; ) {
      let entry = sourceSet.pop();
      entries.push(entry), entry.in.reverse().forEach(handleIn(entry)), entry.out.forEach(handleOut(entry));
    }
    return entries.filter((entry) => !entry.merged).map((entry) => util2.pick(entry, ["vs", "i", "barycenter", "weight"]));
  }
  function mergeEntries(target, source) {
    let sum = 0, weight = 0;
    target.weight && (sum += target.barycenter * target.weight, weight += target.weight), source.weight && (sum += source.barycenter * source.weight, weight += source.weight), target.vs = source.vs.concat(target.vs), target.barycenter = sum / weight, target.weight = weight, target.i = Math.min(source.i, target.i), source.merged = !0;
  }
  return resolveConflicts_1;
}
var sort_1, hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  let util2 = requireUtil$1();
  sort_1 = sort;
  function sort(entries, biasRight) {
    let parts = util2.partition(entries, (entry) => Object.hasOwn(entry, "barycenter")), sortable = parts.lhs, unsortable = parts.rhs.sort((a2, b2) => b2.i - a2.i), vs = [], sum = 0, weight = 0, vsIndex = 0;
    sortable.sort(compareWithBias(!!biasRight)), vsIndex = consumeUnsortable(vs, unsortable, vsIndex), sortable.forEach((entry) => {
      vsIndex += entry.vs.length, vs.push(entry.vs), sum += entry.barycenter * entry.weight, weight += entry.weight, vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    });
    let result = { vs: vs.flat(!0) };
    return weight && (result.barycenter = sum / weight, result.weight = weight), result;
  }
  function consumeUnsortable(vs, unsortable, index2) {
    let last2;
    for (; unsortable.length && (last2 = unsortable[unsortable.length - 1]).i <= index2; )
      unsortable.pop(), vs.push(last2.vs), index2++;
    return index2;
  }
  function compareWithBias(bias) {
    return (entryV, entryW) => entryV.barycenter < entryW.barycenter ? -1 : entryV.barycenter > entryW.barycenter ? 1 : bias ? entryW.i - entryV.i : entryV.i - entryW.i;
  }
  return sort_1;
}
var sortSubgraph_1, hasRequiredSortSubgraph;
function requireSortSubgraph() {
  if (hasRequiredSortSubgraph) return sortSubgraph_1;
  hasRequiredSortSubgraph = 1;
  let barycenter = requireBarycenter(), resolveConflicts = requireResolveConflicts(), sort = requireSort();
  sortSubgraph_1 = sortSubgraph;
  function sortSubgraph(g, v, cg, biasRight) {
    let movable = g.children(v), node2 = g.node(v), bl = node2 ? node2.borderLeft : void 0, br = node2 ? node2.borderRight : void 0, subgraphs = {};
    bl && (movable = movable.filter((w) => w !== bl && w !== br));
    let barycenters = barycenter(g, movable);
    barycenters.forEach((entry) => {
      if (g.children(entry.v).length) {
        let subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
        subgraphs[entry.v] = subgraphResult, Object.hasOwn(subgraphResult, "barycenter") && mergeBarycenters(entry, subgraphResult);
      }
    });
    let entries = resolveConflicts(barycenters, cg);
    expandSubgraphs(entries, subgraphs);
    let result = sort(entries, biasRight);
    if (bl && (result.vs = [bl, result.vs, br].flat(!0), g.predecessors(bl).length)) {
      let blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
      Object.hasOwn(result, "barycenter") || (result.barycenter = 0, result.weight = 0), result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2), result.weight += 2;
    }
    return result;
  }
  function expandSubgraphs(entries, subgraphs) {
    entries.forEach((entry) => {
      entry.vs = entry.vs.flatMap((v) => subgraphs[v] ? subgraphs[v].vs : v);
    });
  }
  function mergeBarycenters(target, other) {
    target.barycenter !== void 0 ? (target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight), target.weight += other.weight) : (target.barycenter = other.barycenter, target.weight = other.weight);
  }
  return sortSubgraph_1;
}
var buildLayerGraph_1, hasRequiredBuildLayerGraph;
function requireBuildLayerGraph() {
  if (hasRequiredBuildLayerGraph) return buildLayerGraph_1;
  hasRequiredBuildLayerGraph = 1;
  let Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  buildLayerGraph_1 = buildLayerGraph;
  function buildLayerGraph(g, rank, relationship) {
    let root2 = createRootNode(g), result = new Graph({ compound: !0 }).setGraph({ root: root2 }).setDefaultNodeLabel((v) => g.node(v));
    return g.nodes().forEach((v) => {
      let node2 = g.node(v), parent = g.parent(v);
      (node2.rank === rank || node2.minRank <= rank && rank <= node2.maxRank) && (result.setNode(v), result.setParent(v, parent || root2), g[relationship](v).forEach((e2) => {
        let u2 = e2.v === v ? e2.w : e2.v, edge = result.edge(u2, v), weight = edge !== void 0 ? edge.weight : 0;
        result.setEdge(u2, v, { weight: g.edge(e2).weight + weight });
      }), Object.hasOwn(node2, "minRank") && result.setNode(v, {
        borderLeft: node2.borderLeft[rank],
        borderRight: node2.borderRight[rank]
      }));
    }), result;
  }
  function createRootNode(g) {
    for (var v; g.hasNode(v = util2.uniqueId("_root")); ) ;
    return v;
  }
  return buildLayerGraph_1;
}
var addSubgraphConstraints_1, hasRequiredAddSubgraphConstraints;
function requireAddSubgraphConstraints() {
  if (hasRequiredAddSubgraphConstraints) return addSubgraphConstraints_1;
  hasRequiredAddSubgraphConstraints = 1, addSubgraphConstraints_1 = addSubgraphConstraints;
  function addSubgraphConstraints(g, cg, vs) {
    let prev = {}, rootPrev;
    vs.forEach((v) => {
      let child = g.parent(v), parent, prevChild;
      for (; child; ) {
        if (parent = g.parent(child), parent ? (prevChild = prev[parent], prev[parent] = child) : (prevChild = rootPrev, rootPrev = child), prevChild && prevChild !== child) {
          cg.setEdge(prevChild, child);
          return;
        }
        child = parent;
      }
    });
  }
  return addSubgraphConstraints_1;
}
var order_1, hasRequiredOrder;
function requireOrder() {
  if (hasRequiredOrder) return order_1;
  hasRequiredOrder = 1;
  let initOrder = requireInitOrder(), crossCount = requireCrossCount(), sortSubgraph = requireSortSubgraph(), buildLayerGraph = requireBuildLayerGraph(), addSubgraphConstraints = requireAddSubgraphConstraints(), Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  order_1 = order;
  function order(g, opts) {
    if (opts && typeof opts.customOrder == "function") {
      opts.customOrder(g, order);
      return;
    }
    let maxRank = util2.maxRank(g), downLayerGraphs = buildLayerGraphs(g, util2.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, util2.range(maxRank - 1, -1, -1), "outEdges"), layering = initOrder(g);
    if (assignOrder(g, layering), opts && opts.disableOptimalOrderHeuristic)
      return;
    let bestCC = Number.POSITIVE_INFINITY, best;
    for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
      sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2), layering = util2.buildLayerMatrix(g);
      let cc2 = crossCount(g, layering);
      cc2 < bestCC && (lastBest = 0, best = Object.assign({}, layering), bestCC = cc2);
    }
    assignOrder(g, best);
  }
  function buildLayerGraphs(g, ranks, relationship) {
    return ranks.map(function(rank) {
      return buildLayerGraph(g, rank, relationship);
    });
  }
  function sweepLayerGraphs(layerGraphs, biasRight) {
    let cg = new Graph();
    layerGraphs.forEach(function(lg) {
      let root2 = lg.graph().root, sorted = sortSubgraph(lg, root2, cg, biasRight);
      sorted.vs.forEach((v, i2) => lg.node(v).order = i2), addSubgraphConstraints(lg, cg, sorted.vs);
    });
  }
  function assignOrder(g, layering) {
    Object.values(layering).forEach((layer) => layer.forEach((v, i2) => g.node(v).order = i2));
  }
  return order_1;
}
var bk, hasRequiredBk;
function requireBk() {
  if (hasRequiredBk) return bk;
  hasRequiredBk = 1;
  let Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  bk = {
    positionX,
    findType1Conflicts,
    findType2Conflicts,
    addConflict,
    hasConflict,
    verticalAlignment,
    horizontalCompaction,
    alignCoordinates,
    findSmallestWidthAlignment,
    balance
  };
  function findType1Conflicts(g, layering) {
    let conflicts = {};
    function visitLayer(prevLayer, layer) {
      let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
      return layer.forEach((v, i2) => {
        let w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;
        (w || v === lastNode) && (layer.slice(scanPos, i2 + 1).forEach((scanNode) => {
          g.predecessors(scanNode).forEach((u2) => {
            let uLabel = g.node(u2), uPos = uLabel.order;
            (uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy) && addConflict(conflicts, u2, scanNode);
          });
        }), scanPos = i2 + 1, k0 = k1);
      }), layer;
    }
    return layering.length && layering.reduce(visitLayer), conflicts;
  }
  function findType2Conflicts(g, layering) {
    let conflicts = {};
    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
      let v;
      util2.range(southPos, southEnd).forEach((i2) => {
        v = south[i2], g.node(v).dummy && g.predecessors(v).forEach((u2) => {
          let uNode = g.node(u2);
          uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder) && addConflict(conflicts, u2, v);
        });
      });
    }
    function visitLayer(north, south) {
      let prevNorthPos = -1, nextNorthPos, southPos = 0;
      return south.forEach((v, southLookahead) => {
        if (g.node(v).dummy === "border") {
          let predecessors = g.predecessors(v);
          predecessors.length && (nextNorthPos = g.node(predecessors[0]).order, scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos), southPos = southLookahead, prevNorthPos = nextNorthPos);
        }
        scan(south, southPos, south.length, nextNorthPos, north.length);
      }), south;
    }
    return layering.length && layering.reduce(visitLayer), conflicts;
  }
  function findOtherInnerSegmentNode(g, v) {
    if (g.node(v).dummy)
      return g.predecessors(v).find((u2) => g.node(u2).dummy);
  }
  function addConflict(conflicts, v, w) {
    if (v > w) {
      let tmp = v;
      v = w, w = tmp;
    }
    let conflictsV = conflicts[v];
    conflictsV || (conflicts[v] = conflictsV = {}), conflictsV[w] = !0;
  }
  function hasConflict(conflicts, v, w) {
    if (v > w) {
      let tmp = v;
      v = w, w = tmp;
    }
    return !!conflicts[v] && Object.hasOwn(conflicts[v], w);
  }
  function verticalAlignment(g, layering, conflicts, neighborFn) {
    let root2 = {}, align = {}, pos = {};
    return layering.forEach((layer) => {
      layer.forEach((v, order) => {
        root2[v] = v, align[v] = v, pos[v] = order;
      });
    }), layering.forEach((layer) => {
      let prevIdx = -1;
      layer.forEach((v) => {
        let ws = neighborFn(v);
        if (ws.length) {
          ws = ws.sort((a2, b2) => pos[a2] - pos[b2]);
          let mp = (ws.length - 1) / 2;
          for (let i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
            let w = ws[i2];
            align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w) && (align[w] = v, align[v] = root2[v] = root2[w], prevIdx = pos[w]);
          }
        }
      });
    }), { root: root2, align };
  }
  function horizontalCompaction(g, layering, root2, align, reverseSep) {
    let xs = {}, blockG = buildBlockGraph(g, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
    function iterate(setXsFunc, nextNodesFunc) {
      let stack = blockG.nodes(), elem = stack.pop(), visited = {};
      for (; elem; )
        visited[elem] ? setXsFunc(elem) : (visited[elem] = !0, stack.push(elem), stack = stack.concat(nextNodesFunc(elem))), elem = stack.pop();
    }
    function pass1(elem) {
      xs[elem] = blockG.inEdges(elem).reduce((acc, e2) => Math.max(acc, xs[e2.v] + blockG.edge(e2)), 0);
    }
    function pass2(elem) {
      let min2 = blockG.outEdges(elem).reduce((acc, e2) => Math.min(acc, xs[e2.w] - blockG.edge(e2)), Number.POSITIVE_INFINITY), node2 = g.node(elem);
      min2 !== Number.POSITIVE_INFINITY && node2.borderType !== borderType && (xs[elem] = Math.max(xs[elem], min2));
    }
    return iterate(pass1, blockG.predecessors.bind(blockG)), iterate(pass2, blockG.successors.bind(blockG)), Object.keys(align).forEach((v) => xs[v] = xs[root2[v]]), xs;
  }
  function buildBlockGraph(g, layering, root2, reverseSep) {
    let blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
    return layering.forEach((layer) => {
      let u2;
      layer.forEach((v) => {
        let vRoot = root2[v];
        if (blockGraph.setNode(vRoot), u2) {
          var uRoot = root2[u2], prevMax = blockGraph.edge(uRoot, vRoot);
          blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u2), prevMax || 0));
        }
        u2 = v;
      });
    }), blockGraph;
  }
  function findSmallestWidthAlignment(g, xss) {
    return Object.values(xss).reduce((currentMinAndXs, xs) => {
      let max2 = Number.NEGATIVE_INFINITY, min2 = Number.POSITIVE_INFINITY;
      Object.entries(xs).forEach(([v, x2]) => {
        let halfWidth = width(g, v) / 2;
        max2 = Math.max(x2 + halfWidth, max2), min2 = Math.min(x2 - halfWidth, min2);
      });
      const newMin = max2 - min2;
      return newMin < currentMinAndXs[0] && (currentMinAndXs = [newMin, xs]), currentMinAndXs;
    }, [Number.POSITIVE_INFINITY, null])[1];
  }
  function alignCoordinates(xss, alignTo) {
    let alignToVals = Object.values(alignTo), alignToMin = util2.applyWithChunking(Math.min, alignToVals), alignToMax = util2.applyWithChunking(Math.max, alignToVals);
    ["u", "d"].forEach((vert) => {
      ["l", "r"].forEach((horiz) => {
        let alignment = vert + horiz, xs = xss[alignment];
        if (xs === alignTo) return;
        let xsVals = Object.values(xs), delta = alignToMin - util2.applyWithChunking(Math.min, xsVals);
        horiz !== "l" && (delta = alignToMax - util2.applyWithChunking(Math.max, xsVals)), delta && (xss[alignment] = util2.mapValues(xs, (x2) => x2 + delta));
      });
    });
  }
  function balance(xss, align) {
    return util2.mapValues(xss.ul, (num, v) => {
      if (align)
        return xss[align.toLowerCase()][v];
      {
        let xs = Object.values(xss).map((xs2) => xs2[v]).sort((a2, b2) => a2 - b2);
        return (xs[1] + xs[2]) / 2;
      }
    });
  }
  function positionX(g) {
    let layering = util2.buildLayerMatrix(g), conflicts = Object.assign(
      findType1Conflicts(g, layering),
      findType2Conflicts(g, layering)
    ), xss = {}, adjustedLayering;
    ["u", "d"].forEach((vert) => {
      adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse(), ["l", "r"].forEach((horiz) => {
        horiz === "r" && (adjustedLayering = adjustedLayering.map((inner2) => Object.values(inner2).reverse()));
        let neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g), align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn), xs = horizontalCompaction(
          g,
          adjustedLayering,
          align.root,
          align.align,
          horiz === "r"
        );
        horiz === "r" && (xs = util2.mapValues(xs, (x2) => -x2)), xss[vert + horiz] = xs;
      });
    });
    let smallestWidth = findSmallestWidthAlignment(g, xss);
    return alignCoordinates(xss, smallestWidth), balance(xss, g.graph().align);
  }
  function sep(nodeSep, edgeSep, reverseSep) {
    return (g, v, w) => {
      let vLabel = g.node(v), wLabel = g.node(w), sum = 0, delta;
      if (sum += vLabel.width / 2, Object.hasOwn(vLabel, "labelpos"))
        switch (vLabel.labelpos.toLowerCase()) {
          case "l":
            delta = -vLabel.width / 2;
            break;
          case "r":
            delta = vLabel.width / 2;
            break;
        }
      if (delta && (sum += reverseSep ? delta : -delta), delta = 0, sum += (vLabel.dummy ? edgeSep : nodeSep) / 2, sum += (wLabel.dummy ? edgeSep : nodeSep) / 2, sum += wLabel.width / 2, Object.hasOwn(wLabel, "labelpos"))
        switch (wLabel.labelpos.toLowerCase()) {
          case "l":
            delta = wLabel.width / 2;
            break;
          case "r":
            delta = -wLabel.width / 2;
            break;
        }
      return delta && (sum += reverseSep ? delta : -delta), delta = 0, sum;
    };
  }
  function width(g, v) {
    return g.node(v).width;
  }
  return bk;
}
var position_1, hasRequiredPosition;
function requirePosition() {
  if (hasRequiredPosition) return position_1;
  hasRequiredPosition = 1;
  let util2 = requireUtil$1(), positionX = requireBk().positionX;
  position_1 = position;
  function position(g) {
    g = util2.asNonCompoundGraph(g), positionY(g), Object.entries(positionX(g)).forEach(([v, x2]) => g.node(v).x = x2);
  }
  function positionY(g) {
    let layering = util2.buildLayerMatrix(g), rankSep = g.graph().ranksep, prevY = 0;
    layering.forEach((layer) => {
      const maxHeight = layer.reduce((acc, v) => {
        const height = g.node(v).height;
        return acc > height ? acc : height;
      }, 0);
      layer.forEach((v) => g.node(v).y = prevY + maxHeight / 2), prevY += maxHeight + rankSep;
    });
  }
  return position_1;
}
var layout_1, hasRequiredLayout;
function requireLayout() {
  if (hasRequiredLayout) return layout_1;
  hasRequiredLayout = 1;
  let acyclic2 = requireAcyclic(), normalize2 = requireNormalize(), rank = requireRank(), normalizeRanks = requireUtil$1().normalizeRanks, parentDummyChains = requireParentDummyChains(), removeEmptyRanks = requireUtil$1().removeEmptyRanks, nestingGraph2 = requireNestingGraph(), addBorderSegments = requireAddBorderSegments(), coordinateSystem2 = requireCoordinateSystem(), order = requireOrder(), position = requirePosition(), util2 = requireUtil$1(), Graph = requireGraphlib().Graph;
  layout_1 = layout2;
  function layout2(g, opts) {
    let time2 = opts && opts.debugTiming ? util2.time : util2.notime;
    time2("layout", () => {
      let layoutGraph = time2("  buildLayoutGraph", () => buildLayoutGraph(g));
      time2("  runLayout", () => runLayout(layoutGraph, time2, opts)), time2("  updateInputGraph", () => updateInputGraph(g, layoutGraph));
    });
  }
  function runLayout(g, time2, opts) {
    time2("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g)), time2("    removeSelfEdges", () => removeSelfEdges(g)), time2("    acyclic", () => acyclic2.run(g)), time2("    nestingGraph.run", () => nestingGraph2.run(g)), time2("    rank", () => rank(util2.asNonCompoundGraph(g))), time2("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g)), time2("    removeEmptyRanks", () => removeEmptyRanks(g)), time2("    nestingGraph.cleanup", () => nestingGraph2.cleanup(g)), time2("    normalizeRanks", () => normalizeRanks(g)), time2("    assignRankMinMax", () => assignRankMinMax(g)), time2("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g)), time2("    normalize.run", () => normalize2.run(g)), time2("    parentDummyChains", () => parentDummyChains(g)), time2("    addBorderSegments", () => addBorderSegments(g)), time2("    order", () => order(g, opts)), time2("    insertSelfEdges", () => insertSelfEdges(g)), time2("    adjustCoordinateSystem", () => coordinateSystem2.adjust(g)), time2("    position", () => position(g)), time2("    positionSelfEdges", () => positionSelfEdges(g)), time2("    removeBorderNodes", () => removeBorderNodes(g)), time2("    normalize.undo", () => normalize2.undo(g)), time2("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g)), time2("    undoCoordinateSystem", () => coordinateSystem2.undo(g)), time2("    translateGraph", () => translateGraph(g)), time2("    assignNodeIntersects", () => assignNodeIntersects(g)), time2("    reversePoints", () => reversePointsForReversedEdges(g)), time2("    acyclic.undo", () => acyclic2.undo(g));
  }
  function updateInputGraph(inputGraph, layoutGraph) {
    inputGraph.nodes().forEach((v) => {
      let inputLabel = inputGraph.node(v), layoutLabel = layoutGraph.node(v);
      inputLabel && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y, inputLabel.rank = layoutLabel.rank, layoutGraph.children(v).length && (inputLabel.width = layoutLabel.width, inputLabel.height = layoutLabel.height));
    }), inputGraph.edges().forEach((e2) => {
      let inputLabel = inputGraph.edge(e2), layoutLabel = layoutGraph.edge(e2);
      inputLabel.points = layoutLabel.points, Object.hasOwn(layoutLabel, "x") && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y);
    }), inputGraph.graph().width = layoutGraph.graph().width, inputGraph.graph().height = layoutGraph.graph().height;
  }
  let graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, graphAttrs = ["acyclicer", "ranker", "rankdir", "align"], nodeNumAttrs = ["width", "height"], nodeDefaults = { width: 0, height: 0 }, edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"], edgeDefaults = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: "r"
  }, edgeAttrs = ["labelpos"];
  function buildLayoutGraph(inputGraph) {
    let g = new Graph({ multigraph: !0, compound: !0 }), graph2 = canonicalize(inputGraph.graph());
    return g.setGraph(Object.assign(
      {},
      graphDefaults,
      selectNumberAttrs(graph2, graphNumAttrs),
      util2.pick(graph2, graphAttrs)
    )), inputGraph.nodes().forEach((v) => {
      let node2 = canonicalize(inputGraph.node(v));
      const newNode = selectNumberAttrs(node2, nodeNumAttrs);
      Object.keys(nodeDefaults).forEach((k2) => {
        newNode[k2] === void 0 && (newNode[k2] = nodeDefaults[k2]);
      }), g.setNode(v, newNode), g.setParent(v, inputGraph.parent(v));
    }), inputGraph.edges().forEach((e2) => {
      let edge = canonicalize(inputGraph.edge(e2));
      g.setEdge(e2, Object.assign(
        {},
        edgeDefaults,
        selectNumberAttrs(edge, edgeNumAttrs),
        util2.pick(edge, edgeAttrs)
      ));
    }), g;
  }
  function makeSpaceForEdgeLabels(g) {
    let graph2 = g.graph();
    graph2.ranksep /= 2, g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.minlen *= 2, edge.labelpos.toLowerCase() !== "c" && (graph2.rankdir === "TB" || graph2.rankdir === "BT" ? edge.width += edge.labeloffset : edge.height += edge.labeloffset);
    });
  }
  function injectEdgeLabelProxies(g) {
    g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      if (edge.width && edge.height) {
        let v = g.node(e2.v), label2 = { rank: (g.node(e2.w).rank - v.rank) / 2 + v.rank, e: e2 };
        util2.addDummyNode(g, "edge-proxy", label2, "_ep");
      }
    });
  }
  function assignRankMinMax(g) {
    let maxRank = 0;
    g.nodes().forEach((v) => {
      let node2 = g.node(v);
      node2.borderTop && (node2.minRank = g.node(node2.borderTop).rank, node2.maxRank = g.node(node2.borderBottom).rank, maxRank = Math.max(maxRank, node2.maxRank));
    }), g.graph().maxRank = maxRank;
  }
  function removeEdgeLabelProxies(g) {
    g.nodes().forEach((v) => {
      let node2 = g.node(v);
      node2.dummy === "edge-proxy" && (g.edge(node2.e).labelRank = node2.rank, g.removeNode(v));
    });
  }
  function translateGraph(g) {
    let minX = Number.POSITIVE_INFINITY, maxX = 0, minY = Number.POSITIVE_INFINITY, maxY = 0, graphLabel = g.graph(), marginX = graphLabel.marginx || 0, marginY = graphLabel.marginy || 0;
    function getExtremes(attrs) {
      let x2 = attrs.x, y2 = attrs.y, w = attrs.width, h = attrs.height;
      minX = Math.min(minX, x2 - w / 2), maxX = Math.max(maxX, x2 + w / 2), minY = Math.min(minY, y2 - h / 2), maxY = Math.max(maxY, y2 + h / 2);
    }
    g.nodes().forEach((v) => getExtremes(g.node(v))), g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      Object.hasOwn(edge, "x") && getExtremes(edge);
    }), minX -= marginX, minY -= marginY, g.nodes().forEach((v) => {
      let node2 = g.node(v);
      node2.x -= minX, node2.y -= minY;
    }), g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.points.forEach((p2) => {
        p2.x -= minX, p2.y -= minY;
      }), Object.hasOwn(edge, "x") && (edge.x -= minX), Object.hasOwn(edge, "y") && (edge.y -= minY);
    }), graphLabel.width = maxX - minX + marginX, graphLabel.height = maxY - minY + marginY;
  }
  function assignNodeIntersects(g) {
    g.edges().forEach((e2) => {
      let edge = g.edge(e2), nodeV = g.node(e2.v), nodeW = g.node(e2.w), p1, p2;
      edge.points ? (p1 = edge.points[0], p2 = edge.points[edge.points.length - 1]) : (edge.points = [], p1 = nodeW, p2 = nodeV), edge.points.unshift(util2.intersectRect(nodeV, p1)), edge.points.push(util2.intersectRect(nodeW, p2));
    });
  }
  function fixupEdgeLabelCoords(g) {
    g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      if (Object.hasOwn(edge, "x"))
        switch ((edge.labelpos === "l" || edge.labelpos === "r") && (edge.width -= edge.labeloffset), edge.labelpos) {
          case "l":
            edge.x -= edge.width / 2 + edge.labeloffset;
            break;
          case "r":
            edge.x += edge.width / 2 + edge.labeloffset;
            break;
        }
    });
  }
  function reversePointsForReversedEdges(g) {
    g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.reversed && edge.points.reverse();
    });
  }
  function removeBorderNodes(g) {
    g.nodes().forEach((v) => {
      if (g.children(v).length) {
        let node2 = g.node(v), t2 = g.node(node2.borderTop), b2 = g.node(node2.borderBottom), l2 = g.node(node2.borderLeft[node2.borderLeft.length - 1]), r2 = g.node(node2.borderRight[node2.borderRight.length - 1]);
        node2.width = Math.abs(r2.x - l2.x), node2.height = Math.abs(b2.y - t2.y), node2.x = l2.x + node2.width / 2, node2.y = t2.y + node2.height / 2;
      }
    }), g.nodes().forEach((v) => {
      g.node(v).dummy === "border" && g.removeNode(v);
    });
  }
  function removeSelfEdges(g) {
    g.edges().forEach((e2) => {
      if (e2.v === e2.w) {
        var node2 = g.node(e2.v);
        node2.selfEdges || (node2.selfEdges = []), node2.selfEdges.push({ e: e2, label: g.edge(e2) }), g.removeEdge(e2);
      }
    });
  }
  function insertSelfEdges(g) {
    var layers = util2.buildLayerMatrix(g);
    layers.forEach((layer) => {
      var orderShift = 0;
      layer.forEach((v, i2) => {
        var node2 = g.node(v);
        node2.order = i2 + orderShift, (node2.selfEdges || []).forEach((selfEdge) => {
          util2.addDummyNode(g, "selfedge", {
            width: selfEdge.label.width,
            height: selfEdge.label.height,
            rank: node2.rank,
            order: i2 + ++orderShift,
            e: selfEdge.e,
            label: selfEdge.label
          }, "_se");
        }), delete node2.selfEdges;
      });
    });
  }
  function positionSelfEdges(g) {
    g.nodes().forEach((v) => {
      var node2 = g.node(v);
      if (node2.dummy === "selfedge") {
        var selfNode = g.node(node2.e.v), x2 = selfNode.x + selfNode.width / 2, y2 = selfNode.y, dx = node2.x - x2, dy = selfNode.height / 2;
        g.setEdge(node2.e, node2.label), g.removeNode(v), node2.label.points = [
          { x: x2 + 2 * dx / 3, y: y2 - dy },
          { x: x2 + 5 * dx / 6, y: y2 - dy },
          { x: x2 + dx, y: y2 },
          { x: x2 + 5 * dx / 6, y: y2 + dy },
          { x: x2 + 2 * dx / 3, y: y2 + dy }
        ], node2.label.x = node2.x, node2.label.y = node2.y;
      }
    });
  }
  function selectNumberAttrs(obj, attrs) {
    return util2.mapValues(util2.pick(obj, attrs), Number);
  }
  function canonicalize(attrs) {
    var newAttrs = {};
    return attrs && Object.entries(attrs).forEach(([k2, v]) => {
      typeof k2 == "string" && (k2 = k2.toLowerCase()), newAttrs[k2] = v;
    }), newAttrs;
  }
  return layout_1;
}
var debug, hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug;
  hasRequiredDebug = 1;
  let util2 = requireUtil$1(), Graph = requireGraphlib().Graph;
  debug = {
    debugOrdering
  };
  function debugOrdering(g) {
    let layerMatrix = util2.buildLayerMatrix(g), h = new Graph({ compound: !0, multigraph: !0 }).setGraph({});
    return g.nodes().forEach((v) => {
      h.setNode(v, { label: v }), h.setParent(v, "layer" + g.node(v).rank);
    }), g.edges().forEach((e2) => h.setEdge(e2.v, e2.w, {}, e2.name)), layerMatrix.forEach((layer, i2) => {
      let layerV = "layer" + i2;
      h.setNode(layerV, { rank: "same" }), layer.reduce((u2, v) => (h.setEdge(u2, v, { style: "invis" }), v));
    }), h;
  }
  return debug;
}
var version, hasRequiredVersion;
function requireVersion() {
  return hasRequiredVersion || (hasRequiredVersion = 1, version = "1.1.4"), version;
}
var dagre$1, hasRequiredDagre;
function requireDagre() {
  return hasRequiredDagre || (hasRequiredDagre = 1, dagre$1 = {
    graphlib: requireGraphlib(),
    layout: requireLayout(),
    debug: requireDebug(),
    util: {
      time: requireUtil$1().time,
      notime: requireUtil$1().notime
    },
    version: requireVersion()
  }), dagre$1;
}
var dagreExports = requireDagre();
const dagre = /* @__PURE__ */ getDefaultExportFromCjs(dagreExports), Sizes$2 = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 140,
    height: 10,
    minlen: 1,
    weight: 1
  },
  emptyNodeOffset: 120,
  nodeWidth: 330,
  nodeHeight: 180,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function createGraph$2() {
  const g = new dagre.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return g.setGraph({
    ...Sizes$2.dagre,
    rankdir: "LR"
  }), g.setDefaultEdgeLabel(() => ({ ...Sizes$2.edgeLabel })), g.setDefaultNodeLabel(() => ({})), g;
}
const PortSuffix$2 = "-port";
function createNodes$2(column, elements, g) {
  const graphNodes = new DefaultMap((key2) => ({
    id: `${column}-${key2}`,
    portId: `${column}-${key2}`
  })), tree = treeFromElements$1(elements);
  for (const element of tree.sorted) {
    const isCompound = tree.children(element).length > 0, fqn2 = element.id, id2 = `${column}-${fqn2}`, portId = isCompound ? `${id2}${PortSuffix$2}` : id2;
    graphNodes.set(fqn2, {
      id: id2,
      portId
    }), g.setNode(id2, {
      column,
      element,
      isCompound,
      portId,
      inPorts: [],
      outPorts: [],
      width: Sizes$2.nodeWidth,
      height: Sizes$2.nodeHeight
    }), isCompound && (g.setNode(portId, {
      element,
      portId,
      isCompound,
      inPorts: [],
      outPorts: [],
      width: Sizes$2.nodeWidth - Sizes$2.dagre.ranksep,
      height: Sizes$2.compound.labelHeight
    }), g.setParent(portId, id2));
    const parent = tree.parent(element);
    parent && g.setParent(id2, `${column}-${parent.id}`);
  }
  return {
    ...tree,
    byId: (id2) => {
      const element = tree.byId(id2), graph2 = graphNodes.get(element.id);
      return {
        element,
        graph: graph2
      };
    },
    graphNodes
  };
}
function applyDagreLayout$2(g) {
  return dagre.layout(g, {
    // disableOptimalOrderHeuristic: true,
  }), (nodeId) => {
    const node2 = g.node(nodeId), { x: x2, y: y2, width, height } = node2;
    return {
      position: {
        x: x2 - Math.round(width / 2),
        y: y2 - Math.round(height / 2)
      },
      width,
      height
    };
  };
}
var LayoutRelationshipsViewResult;
((LayoutRelationshipsViewResult2) => {
  LayoutRelationshipsViewResult2.Empty = "@empty";
})(LayoutRelationshipsViewResult || (LayoutRelationshipsViewResult = {}));
function layoutRelationshipsView$1(data, scope) {
  const g = createGraph$2(), incomers = createNodes$2("incomers", data.incomers, g), subjects = createNodes$2("subjects", data.subjects, g), outgoers = createNodes$2("outgoers", data.outgoers, g), edges = [];
  C(
    a(
      C(
        toArray(data.incoming),
        m((r2) => ({
          id: r2.source.id,
          sourceFqn: r2.source.id,
          targetFqn: r2.target.id,
          source: incomers.byId(r2.source.id).graph,
          target: subjects.byId(r2.target.id).graph,
          relation: r2
        }))
      ),
      C(
        toArray(data.outgoing),
        m((r2) => ({
          id: r2.target.id,
          sourceFqn: r2.source.id,
          targetFqn: r2.target.id,
          source: subjects.byId(r2.source.id).graph,
          target: outgoers.byId(r2.target.id).graph,
          relation: r2
        }))
      )
    ),
    m((r2) => ({
      ...r2,
      expr: `${r2.source.id}->${r2.target.id}`
    })),
    // Group if same source and target
    i$3(p$2("expr")),
    i$2((grouped) => {
      const source = grouped[0].source, target = grouped[0].target, name = grouped[0].expr;
      g.node(source.id).outPorts.push(target.id), g.node(target.id).inPorts.push(source.id), g.setEdge(source.portId, target.portId, {
        ...Sizes$2.edgeLabel
      }, name), edges.push({
        name,
        sourceFqn: grouped[0].sourceFqn,
        targetFqn: grouped[0].targetFqn,
        source: source.id,
        sourceHandle: source.id + "_out" + (g.node(source.id).outPorts.length - 1),
        target: target.id,
        targetHandle: target.id + "_in" + (g.node(target.id).inPorts.length - 1),
        relations: m(grouped, p$2("relation"))
      });
    })
  );
  for (const subjectNode of subjects.graphNodes.values()) {
    const nodeId = subjectNode.id, node2 = g.node(nodeId);
    if (node2.isCompound)
      continue;
    const edgeCount2 = Math.max(g.inEdges(nodeId)?.length ?? 0, g.outEdges(nodeId)?.length ?? 0);
    edgeCount2 > 2 && (node2.height = node2.height + (edgeCount2 - 3) * 14);
  }
  const nodeIds = [
    ...incomers.graphNodes.values(),
    ...subjects.graphNodes.values(),
    ...outgoers.graphNodes.values()
  ];
  if (incomers.graphNodes.size == 0) {
    const id2 = "incomers-empty";
    g.setNode(id2, {
      column: "incomers",
      element: null,
      isCompound: !1,
      portId: id2,
      inPorts: [],
      outPorts: [],
      width: Sizes$2.nodeWidth,
      height: Sizes$2.nodeHeight
    });
    for (const subjectNode of subjects.graphNodes.values())
      g.setEdge(id2, subjectNode.portId);
    nodeIds.push({
      id: id2,
      portId: id2
    });
  }
  if (outgoers.graphNodes.size == 0) {
    const id2 = "outgoers-empty";
    g.setNode(id2, {
      column: "outgoers",
      element: null,
      isCompound: !1,
      portId: id2,
      inPorts: [],
      outPorts: [],
      width: Sizes$2.nodeWidth,
      height: Sizes$2.nodeHeight
    });
    for (const subjectNode of subjects.graphNodes.values())
      g.setEdge(subjectNode.portId, id2);
    nodeIds.push({
      id: id2,
      portId: id2
    });
  }
  const edgeCount = g.edgeCount();
  if (edgeCount > 10)
    for (const edge of g.edges())
      g.setEdge(edge, {
        ...Sizes$2.edgeLabel,
        width: edgeCount > 25 ? 800 : 400
      });
  const dagreBounds = applyDagreLayout$2(g), _calculatedNodeBounds = C(
    nodeIds,
    // Compound nodes have different portId
    T((n2) => n2.id === n2.portId),
    l$3((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ??= C(
      g.children(nodeId) ?? [],
      T((id2) => !id2.endsWith(PortSuffix$2)),
      m((id2) => nodeBounds(id2)),
      r$4((bounds) => {
        invariant$2(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      l$4((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: minY2, maxY }) => {
        const {
          position: { x: x2 },
          width
        } = dagreBounds(nodeId);
        return minY2 = minY2 - Sizes$2.compound.paddingTop, maxY = maxY + Sizes$2.compound.paddingBottom, {
          position: {
            x: x2,
            y: minY2
          },
          width,
          height: maxY - minY2
        };
      }
    );
  }
  function nodeLevel(nodeId) {
    const parent = g.parent(nodeId);
    return parent ? nodeLevel(parent) + 1 : 0;
  }
  function nodeDepth(nodeId) {
    const children2 = g.children(nodeId) ?? [];
    return children2.length === 0 ? 0 : 1 + Math.max(...children2.map(nodeDepth));
  }
  const sortedPorts = (nodeId, type, ports) => C(
    ports,
    m((port, index2) => ({
      port: nodeId + "_" + type + index2,
      topY: nodeBounds(port).position.y
    })),
    a$5(p$2("topY")),
    m(p$2("port"))
  );
  let minX = 0, minY = 0;
  const [subject] = [...subjects.root];
  invariant$2(subject, "Subjects should not be empty");
  let subjectBounds = nodeBounds(subjects.graphNodes.get(subject.id).id);
  const nodes = nodeIds.map(({ id: id2 }) => {
    const { element, inPorts, outPorts, column } = g.node(id2);
    let { position, width, height } = nodeBounds(id2);
    if (!element) {
      if (height = Math.min(subjectBounds.height, 300), position.y = subjectBounds.position.y + subjectBounds.height / 2 - height / 2, column === "incomers")
        width = subjectBounds.position.x - Sizes$2.emptyNodeOffset - position.x;
      else {
        const rightX = position.x + width;
        position.x = subjectBounds.position.x + subjectBounds.width + Sizes$2.emptyNodeOffset, width = rightX - position.x;
      }
      return {
        id: id2,
        parent: null,
        position: [position.x, position.y],
        title: "empty node",
        description: null,
        technology: null,
        tags: null,
        links: null,
        color: "muted",
        shape: "rectangle",
        style: {
          border: "dashed",
          opacity: 50
        },
        kind: LayoutRelationshipsViewResult.Empty,
        level: 0,
        labelBBox: {
          x: position.x,
          y: position.y,
          width,
          height
        },
        children: [],
        width,
        height,
        column,
        ports: {
          in: [],
          out: []
        },
        existsInCurrentView: !1
      };
    }
    const parentId = g.parent(id2), children2 = (g.children(id2) ?? []).filter((c2) => !c2.endsWith(PortSuffix$2));
    minX = Math.min(minX, position.x), minY = Math.min(minY, position.y);
    const navigateTo = scope ? ifind(element.scopedViews(), (v) => v.id !== scope.id)?.id ?? null : null, inheritFromNode = scope?.findNodeWithElement(element.id), scopedAncestor = scope && !inheritFromNode ? ifind(element.ancestors(), (a2) => !!scope.findNodeWithElement(a2.id))?.id : null, inheritFromNodeOrAncestor = inheritFromNode ?? (scopedAncestor && scope?.findNodeWithElement(scopedAncestor));
    return {
      id: id2,
      parent: parentId ?? null,
      position: [position.x, position.y],
      title: element.title,
      description: element.description,
      technology: element.technology,
      tags: null,
      links: null,
      color: inheritFromNodeOrAncestor?.color ?? element.color,
      shape: inheritFromNode?.shape ?? element.shape,
      icon: inheritFromNode?.icon ?? element.icon ?? "none",
      modelRef: element.id,
      kind: element.kind,
      level: nodeLevel(id2),
      labelBBox: {
        x: position.x,
        y: position.y,
        width,
        height
      },
      style: {
        ...(inheritFromNode ?? inheritFromNodeOrAncestor)?.style,
        ...element.$element.style
      },
      navigateTo,
      ...children2.length > 0 && { depth: nodeDepth(id2) },
      children: children2,
      width,
      height,
      column,
      ports: {
        in: sortedPorts(id2, "in", inPorts),
        out: sortedPorts(id2, "out", outPorts)
      },
      existsInCurrentView: !!inheritFromNode
    };
  });
  return {
    subjectExistsInScope: !scope || scope.includesElement(subject.id),
    bounds: {
      x: Math.min(minX, 0),
      y: Math.min(minY, 0),
      width: g.graph().width ?? 100,
      height: g.graph().height ?? 100
    },
    nodes,
    edges: g.edges().reduce((acc, e2) => {
      const edge = g.edge(e2), ename = e2.name;
      if (!ename)
        return acc;
      const {
        name,
        source,
        sourceFqn,
        target,
        targetFqn,
        relations,
        sourceHandle,
        targetHandle
      } = f(edges, (e22) => e22.name === ename), onlyRelation = t$5(relations), label2 = onlyRelation?.title ?? "untitled", isMultiple = relations.length > 1, navigateTo = t$5(i$8(relations.flatMap((r2) => r2.navigateTo?.id ? r2.navigateTo.id : [])));
      return acc.push({
        id: name,
        sourceFqn,
        source,
        sourceHandle,
        targetFqn,
        target,
        targetHandle,
        label: isMultiple ? `${relations.length} relationships` : label2,
        ...navigateTo && { navigateTo },
        existsInCurrentView: !scope || relations.every((r2) => scope.includesRelation(r2.id)),
        points: edge.points.map((p2) => [p2.x, p2.y]),
        line: onlyRelation?.$relationship.line ?? "dashed",
        relations: relations.map((r2) => r2.id),
        parent: null
      }), acc;
    }, [])
  };
}
function useRelationshipsView$1(subject, viewId, scope) {
  const model = useLikeC4Model$1(!0);
  return useMemo(() => {
    const view = viewId ? model.findView(viewId) : null, data = layoutRelationshipsView$1(
      computeRelationshipsView(subject, model, viewId, scope),
      scope === "view" ? view : null
    );
    return view && (scope === "global" || !data.subjectExistsInScope) && (data.edges = data.edges.map((edge) => (edge.existsInCurrentView = edge.relations.every((r2) => view.includesRelation(r2)), edge))), Object.assign(data, { subject });
  }, [model, subject, viewId, scope, computeRelationshipsView]);
}
const node = css({
  margin: 0
}), label = css({
  _hover: {
    backgroundColor: "mantine.colors.gray[0]",
    _dark: {
      backgroundColor: "mantine.colors.defaultHover",
      color: "mantine.colors.white"
    }
  }
}), scrollArea$2 = css({
  maxHeight: [
    "70vh",
    "calc(100cqh - 70px)"
  ]
}), classes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  label,
  node,
  scrollArea: scrollArea$2
}, Symbol.toStringTag, { value: "Module" })), selector2$1 = (state) => {
  const subjectExistsInScope = state.context.layouted?.subjectExistsInScope ?? !1;
  return {
    subjectId: state.context.subject,
    viewId: state.context.viewId,
    scope: state.context.scope,
    subjectExistsInScope,
    enableSelectSubject: state.context.enableSelectSubject,
    enableChangeScope: state.context.enableChangeScope
  };
}, setHoveredNode$2 = () => {
}, SelectElement = memo$2(() => {
  const browser = useRelationshipsBrowser(), {
    subjectId,
    viewId,
    scope,
    subjectExistsInScope,
    enableSelectSubject,
    enableChangeScope
  } = useRelationshipsBrowserState(selector2$1), root2 = useRef(null), viewport = useRef(null), subject = useLikeC4Model$1(!0).findElement(subjectId), data = useLikeC4ElementsTree(scope === "view" && viewId ? viewId : void 0), tree = useTree({
    multiple: !1
  });
  return tree.setHoveredNode = setHoveredNode$2, useEffect(() => {
    ancestorsFqn(subjectId).reverse().forEach((id2) => {
      tree.expand(id2);
    }), tree.select(subjectId);
  }, [subjectId]), /* @__PURE__ */ jsxs(Group, { ref: root2, gap: "xs", pos: "relative", children: [
    enableSelectSubject && /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
      /* @__PURE__ */ jsx(
        Box$1,
        {
          fz: "xs",
          fw: "500",
          style: { whiteSpace: "nowrap", userSelect: "none" },
          children: "Relationships of"
        }
      ),
      /* @__PURE__ */ jsx(Box$1, { pos: "relative", children: /* @__PURE__ */ jsxs(
        Popover,
        {
          position: "bottom-start",
          shadow: "md",
          keepMounted: !1,
          withinPortal: !1,
          closeOnClickOutside: !0,
          clickOutsideEvents: ["pointerdown", "mousedown", "click"],
          offset: 4,
          onOpen: () => {
            setTimeout(() => {
              viewport.current?.querySelector(`[data-value="${subjectId}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
            }, 100);
          },
          children: [
            /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(
              Button,
              {
                size: "xs",
                variant: "default",
                maw: 250,
                rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
                children: /* @__PURE__ */ jsx(Text, { fz: "xs", fw: "500", truncate: !0, children: subject?.title ?? "???" })
              }
            ) }),
            /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { scrollbars: "y", type: "never", viewportRef: viewport, className: scrollArea$2, children: /* @__PURE__ */ jsx(
              Tree,
              {
                allowRangeSelection: !1,
                selectOnClick: !1,
                tree,
                data,
                classNames: classes,
                levelOffset: 8,
                styles: {
                  root: {
                    maxWidth: 400,
                    overflow: "hidden"
                  },
                  label: {
                    paddingTop: 5,
                    paddingBottom: 6
                  }
                },
                renderNode: ({ node: node2, selected: selected2, expanded, elementProps, hasChildren }) => /* @__PURE__ */ jsxs(Group, { gap: 2, wrap: "nowrap", ...elementProps, py: "3", children: [
                  /* @__PURE__ */ jsx(
                    ActionIcon$1,
                    {
                      variant: "subtle",
                      size: 18,
                      c: "dimmed",
                      style: {
                        visibility: hasChildren ? "visible" : "hidden"
                      },
                      children: /* @__PURE__ */ jsx(
                        IconChevronRight,
                        {
                          stroke: 3.5,
                          style: {
                            transition: "transform 150ms ease",
                            transform: `rotate(${expanded ? "90deg" : "0"})`,
                            width: "80%"
                          }
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    Box$1,
                    {
                      flex: "1 1 100%",
                      w: "100%",
                      onClick: (e2) => {
                        e2.stopPropagation(), tree.select(node2.value), tree.expand(node2.value), browser.navigateTo(node2.value);
                      },
                      children: /* @__PURE__ */ jsx(
                        Text,
                        {
                          fz: "sm",
                          fw: selected2 ? "600" : "400",
                          truncate: "end",
                          children: node2.label
                        }
                      )
                    }
                  )
                ] })
              }
            ) }) })
          ]
        }
      ) })
    ] }),
    enableChangeScope && /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
      enableSelectSubject && /* @__PURE__ */ jsx(
        Box$1,
        {
          fz: "xs",
          fw: "500",
          ...!subjectExistsInScope && {
            c: "dimmed"
          },
          style: { whiteSpace: "nowrap", userSelect: "none" },
          children: "Scope"
        }
      ),
      /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
        Tooltip$5,
        {
          color: "orange",
          label: /* @__PURE__ */ jsxs(Fragment$1, { children: [
            "This element does not exist in the current view",
            scope === "view" && /* @__PURE__ */ jsxs(Fragment$1, { children: [
              /* @__PURE__ */ jsx("br", {}),
              "Scope is set to global"
            ] })
          ] }),
          position: "bottom-start",
          disabled: subjectExistsInScope,
          portalProps: {
            target: root2.current
          },
          children: /* @__PURE__ */ jsx(
            SegmentedControl,
            {
              flex: "1 0 auto",
              size: "xs",
              withItemsBorders: !1,
              value: scope,
              styles: {
                label: {
                  paddingLeft: 8,
                  paddingRight: 8
                }
              },
              onChange: (value) => {
                browser.changeScope(value);
              },
              data: [
                { label: "Global", value: "global" },
                {
                  label: /* @__PURE__ */ jsx("span", { children: "Current view" }),
                  value: "view",
                  disabled: !subjectExistsInScope
                }
              ]
            }
          )
        }
      ) })
    ] })
  ] });
}), nodeTypes$1 = {
  element: ElementNode$1,
  compound: CompoundNode$1,
  empty: EmptyNode
}, edgeTypes$1 = {
  relationship: RelationshipEdge$1
};
function RelationshipsBrowser({ actorRef }) {
  const initialRef = useRef(null);
  return initialRef.current == null && (initialRef.current = {
    initialNodes: [],
    initialEdges: []
  }), /* @__PURE__ */ jsx(RelationshipsBrowserActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(ReactFlowProvider, { ...initialRef.current, children: /* @__PURE__ */ jsx(LayoutGroup, { id: actorRef.sessionId, inherit: !1, children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(RelationshipsBrowserXYFlow, {}) }) }) }) });
}
const selector$4 = (state) => ({
  isActive: state.hasTag("active"),
  nodes: state.context.xynodes,
  edges: state.context.xyedges
}), selectorEq = (a2, b2) => a2.isActive === b2.isActive && shallowEqual(a2.nodes, b2.nodes) && shallowEqual(a2.edges, b2.edges), RelationshipsBrowserXYFlow = memo$2(() => {
  const browser = useRelationshipsBrowser(), {
    isActive,
    nodes,
    edges
  } = useRelationshipsBrowserState(
    selector$4,
    selectorEq
  );
  return /* @__PURE__ */ jsx(
    BaseXYFlow,
    {
      id: browser.rootElementId,
      nodes,
      edges,
      className: cx(
        isActive ? "initialized" : "not-initialized",
        "relationships-browser"
      ),
      nodeTypes: nodeTypes$1,
      edgeTypes: edgeTypes$1,
      fitView: !1,
      onNodeClick: useCallbackRef((e2, node2) => {
        browser.send({ type: "xyflow.nodeClick", node: node2 });
      }),
      onEdgeClick: useCallbackRef((e2, edge) => {
        browser.send({ type: "xyflow.edgeClick", edge });
      }),
      onPaneClick: useCallbackRef((e2) => {
        browser.send({ type: "xyflow.paneClick" });
      }),
      onDoubleClick: useCallbackRef((e2) => {
        browser.send({ type: "xyflow.paneDblClick" });
      }),
      onViewportResize: useCallbackRef(() => {
        browser.send({ type: "xyflow.resized" });
      }),
      onNodesChange: useCallbackRef((changes) => {
        browser.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        browser.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      onEdgeMouseEnter: useCallbackRef((_event, edge) => {
        edge.data.hovered || browser.send({ type: "xyflow.edgeMouseEnter", edge });
      }),
      onEdgeMouseLeave: useCallbackRef((_event, edge) => {
        edge.data.hovered && browser.send({ type: "xyflow.edgeMouseLeave", edge });
      }),
      onSelectionChange: useCallbackRef((params) => {
        browser.send({ type: "xyflow.selectionChange", ...params });
      }),
      nodesDraggable: !1,
      pannable: !0,
      zoomable: !0,
      children: /* @__PURE__ */ jsx(RelationshipsBrowserInner, {})
    }
  );
}), selector2 = (state) => ({
  subjectId: state.context.subject,
  viewId: state.context.viewId,
  scope: state.context.scope,
  closeable: state.context.closeable
}), RelationshipsBrowserInner = memo$2(() => {
  const browser = useRelationshipsBrowser(), {
    subjectId,
    viewId,
    scope,
    closeable
  } = useRelationshipsBrowserState(selector2), store = useStoreApi(), instance = useReactFlow();
  useEffect(() => {
    instance.viewportInitialized && browser.send({ type: "xyflow.init", instance, store });
  }, [store, instance.viewportInitialized, browser]);
  const layouted = useRelationshipsView$1(subjectId, viewId, scope), [historySubjectId, historyOps, { history, current }] = useStateHistory(subjectId);
  useEffect(() => {
    historySubjectId !== subjectId && historyOps.set(subjectId);
  }, [subjectId]), useEffect(() => {
    historySubjectId !== subjectId && browser.navigateTo(historySubjectId);
  }, [historySubjectId, browser]), useEffect(() => {
    browser.updateView(layouted);
  }, [layouted, browser]);
  const hasStepBack = current > 0, hasStepForward = current + 1 < history.length;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      TopLeftPanel$1,
      {
        hasStepBack,
        hasStepForward,
        onStepBack: () => historyOps.back(),
        onStepForward: () => historyOps.forward()
      }
    ),
    closeable && /* @__PURE__ */ jsx(Panel, { position: "top-right", children: /* @__PURE__ */ jsx(
      ActionIcon$1,
      {
        variant: "default",
        color: "gray",
        onClick: (e2) => {
          e2.stopPropagation(), browser.close();
        },
        children: /* @__PURE__ */ jsx(IconX, {})
      }
    ) })
  ] });
}), TopLeftPanel$1 = ({
  hasStepBack,
  hasStepForward,
  onStepBack,
  onStepForward
}) => /* @__PURE__ */ jsx(Panel, { position: "top-left", children: /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
  /* @__PURE__ */ jsxs(AnimatePresence, { mode: "popLayout", children: [
    hasStepBack && /* @__PURE__ */ jsx(
      m$2.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), onStepBack();
            },
            children: /* @__PURE__ */ jsx(IconChevronLeft, {})
          }
        )
      },
      "back"
    ),
    hasStepForward && /* @__PURE__ */ jsx(
      m$2.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(5px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), onStepForward();
            },
            children: /* @__PURE__ */ jsx(IconChevronRight, {})
          }
        )
      },
      "forward"
    )
  ] }),
  /* @__PURE__ */ jsx(SelectElement, {})
] }) }), fqn = css({
  display: "inline-block",
  fontSize: "sm",
  fontWeight: 500,
  whiteSpace: "nowrap",
  padding: "3px 6px",
  borderRadius: 3,
  background: "likec4.palette.fill/75",
  lineHeight: 1.2,
  color: "likec4.palette.hiContrast"
  // selectors: {
  //   [`${whereDark} &`]: {
  //   }
  // }
}), relationshipStat = css({
  _light: {
    background: "mantine.colors.gray[1]",
    "&[data-missing": {}
  },
  // [`&[data-zero]`]: {
  //   color: mantine.colors.dimmed
  // },
  // [`${whereLight} &[data-zero]`]: {
  //   background: mantine.colors.gray[3]
  // },
  "&[data-missing]": {
    color: "mantine.colors.orange[4]",
    background: "mantine.colors.orange[8]/15",
    borderColor: "mantine.colors.orange[5]/20",
    _light: {
      color: "mantine.colors.orange[8]"
    }
  }
}), xyflow = css({
  flex: "1 1 100%",
  position: "relative",
  width: "100%",
  height: "100%",
  background: "mantine.colors.body",
  border: "1px solid {colors.mantine.colors.defaultBorder}",
  borderRadius: "sm",
  _light: {
    borderColor: "mantine.colors.gray[3]",
    background: "mantine.colors.gray[1]"
  }
});
css({
  _before: {
    content: '"scope:"',
    position: "absolute",
    top: 0,
    left: 8,
    fontSize: "2xs",
    fontWeight: 500,
    lineHeight: "1",
    color: "mantine.colors.dimmed",
    opacity: 0.85,
    transform: "translateY(-100%) translateY(-2px)"
  },
  _light: {
    "& .mantine-SegmentedControl-root": {
      background: "mantine.colors.gray[3]"
    }
  }
});
css({
  display: "inline-block",
  fontSize: "xl",
  fontWeight: 600,
  padding: "1px 5px",
  minWidth: 24,
  textAlign: "center",
  borderRadius: "sm",
  background: "mantine.colors.dark[7]",
  color: "mantine.colors.defaultColor",
  "&[data-zero]": {
    color: "mantine.colors.dimmed"
  },
  "&[data-missing]": {
    color: "mantine.colors.orange[4]",
    background: "mantine.colors.orange[8]/20"
  }
  // _light: {
  //   background: 'mantine.colors.gray[4]',
  //   color: 'mantine.colors.dark[6]',
  //   [`&[data-zero]`]: {
  //     background: 'mantine.colors.gray[3]',
  //   },
  //   [`&[data-missing]`]: {
  //     color: 'mantine.colors.orange[8]',
  //   },
  // },
});
const Tooltip$2 = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function TabPanelRelationships({
  node: node2,
  element
}) {
  const overlaysActor = useOverlaysActorRef(), delailsActor = useElementDetailsActorRef(), relationshipsBrowserActor = xstateReact_cjsExports.useSelector(delailsActor, (s2) => s2.children[`${delailsActor.id}-relationships`]), [scope, setScope] = useState("view"), incoming = [...element.incoming()].map((r2) => r2.id), outgoing = [...element.outgoing()].map((r2) => r2.id), incomingInView = node2 ? i$8([...node2.incoming()].flatMap((e2) => e2.$edge.relations)) : [], outgoingInView = node2 ? i$8([...node2.outgoing()].flatMap((e2) => e2.$edge.relations)) : [], notIncludedRelations = [
    ...incoming,
    ...outgoing
  ].filter((r2) => !incomingInView.includes(r2) && !outgoingInView.includes(r2)).length;
  return /* @__PURE__ */ jsxs(Stack, { gap: "xs", pos: "relative", w: "100%", h: "100%", children: [
    incoming.length + outgoing.length > 0 && /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", children: [
      /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsxs(Group, { gap: 8, mb: 4, wrap: "nowrap", children: [
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "incoming",
            total: incoming.length,
            included: incomingInView.length
          }
        ),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(Text, { className: fqn, children: nameFromFqn(element.id) }),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "outgoing",
            total: outgoing.length,
            included: outgoingInView.length
          }
        )
      ] }) }),
      notIncludedRelations > 0 && /* @__PURE__ */ jsx(Tooltip$2, { label: "Current view does not include some relationships", children: /* @__PURE__ */ jsxs(
        Group,
        {
          mt: "xs",
          gap: 6,
          c: "orange",
          style: { cursor: "pointer" },
          children: [
            /* @__PURE__ */ jsx(IconInfoCircle, { style: { width: 14 } }),
            /* @__PURE__ */ jsxs(Text, { fz: "sm", children: [
              notIncludedRelations,
              " relationship",
              notIncludedRelations > 1 ? "s are" : " is",
              " hidden"
            ] })
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ jsx(Box$1, { className: xyflow, children: relationshipsBrowserActor && /* @__PURE__ */ jsxs(Fragment$1, { children: [
      /* @__PURE__ */ jsx(RelationshipsBrowser, { actorRef: relationshipsBrowserActor }),
      /* @__PURE__ */ jsx(Box$1, { pos: "absolute", top: 12, right: 12, children: /* @__PURE__ */ jsx(
        ActionIcon$1,
        {
          size: "md",
          variant: "default",
          radius: "sm",
          onClick: (e2) => {
            e2.stopPropagation();
            const {
              subject,
              scope: scope2,
              viewId
            } = relationshipsBrowserActor.getSnapshot().context;
            overlaysActor.send({
              type: "open.relationshipsBrowser",
              subject,
              scope: scope2,
              viewId
            });
          },
          children: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: "70%" } })
        }
      ) })
    ] }) })
  ] });
}
function RelationshipsStat({
  title: title2,
  total,
  included
}) {
  return /* @__PURE__ */ jsx(
    Paper,
    {
      withBorder: !0,
      shadow: "none",
      className: relationshipStat,
      px: "md",
      py: "xs",
      radius: "md",
      mod: {
        zero: total === 0,
        missing: total !== included
      },
      children: /* @__PURE__ */ jsxs(Stack, { gap: 4, align: "flex-end", children: [
        /* @__PURE__ */ jsx(Text, { component: "div", c: total !== included ? "orange" : "dimmed", tt: "uppercase", fw: 600, fz: 10, lh: 1, children: title2 }),
        /* @__PURE__ */ jsx(Text, { fw: 600, fz: "xl", component: "div", lh: 1, children: total !== included ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
          included,
          " / ",
          total
        ] }) : /* @__PURE__ */ jsx(Fragment$1, { children: total }) })
      ] })
    }
  );
}
const treeNodeLabel = css({
  marginTop: "sm",
  marginBottom: "sm"
}), elementLabel = css({
  display: "inline-flex",
  transition: "fast",
  border: "1px dashed",
  borderColor: "mantine.colors.defaultBorder",
  borderRadius: "sm",
  px: "md",
  py: "xs",
  alignItems: "center",
  cursor: "pointer",
  color: "mantine.colors.gray[7]",
  _dark: {
    color: "mantine.colors.dark[1]"
  },
  "& > *": {
    transition: "fast"
  },
  _hover: {
    transitionTimingFunction: "out",
    borderStyle: "solid",
    color: "mantine.colors.defaultColor",
    background: "mantine.colors.defaultHover",
    "& > *": {
      transitionTimingFunction: "out",
      transform: "translateX(1px)"
    }
  }
}), ElementLabel = ({
  element
}) => /* @__PURE__ */ jsx(Box$1, { className: elementLabel, children: /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", children: element.title }) }), setHoveredNode$1 = () => {
};
function TabPanelStructure({
  element
}) {
  const tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode$1;
  const data = useMemo(() => {
    let seq = 1;
    const messageNode = (label2) => ({
      label: label2,
      value: `msg${seq++}`,
      type: "message",
      children: []
    }), current = {
      label: /* @__PURE__ */ jsx(ElementLabel, { type: "current", element }),
      value: element.id,
      element,
      type: "current",
      children: [...element.children()].map((child) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "descedant", element: child }),
        value: child.id,
        element: child,
        type: "descedant",
        children: []
      }))
    };
    return current.children.length === 0 && current.children.push(
      messageNode(/* @__PURE__ */ jsx(Pill, { radius: "sm", children: "no nested" }))
    ), [
      [...element.ancestors()].reduce((acc, parent) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "ancestor", element: parent }),
        value: parent.id,
        element: parent,
        type: "ancestor",
        children: [acc]
      }), current)
    ];
  }, [element]);
  return useEffect(() => {
    tree.expandAllNodes();
  }, [data]), /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(Alert, { variant: "light", color: "orange", title: "In development", icon: /* @__PURE__ */ jsx(IconInfoCircle, {}), children: [
      "We need your feedback. Share your thoughts and ideas -",
      " ",
      /* @__PURE__ */ jsx(
        Anchor,
        {
          fz: "sm",
          fw: 500,
          underline: "hover",
          c: "orange",
          href: "https://github.com/likec4/likec4/discussions/",
          target: "_blank",
          children: "GitHub discussions"
        }
      )
    ] }),
    /* @__PURE__ */ jsx(
      Tree,
      {
        levelOffset: "xl",
        allowRangeSelection: !1,
        expandOnClick: !1,
        expandOnSpace: !1,
        classNames: {
          label: treeNodeLabel
        },
        data,
        tree
      }
    )
  ] });
}
const Divider = Divider$1.withProps({
  mb: 8,
  labelPosition: "left",
  variant: "dashed"
}), Tooltip$1 = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4
}), SmallLabel = Text.withProps({
  component: "div",
  fz: 11,
  fw: 500,
  c: "dimmed",
  lh: 1
}), PropertyLabel = Text.withProps({
  component: "div",
  fz: "xs",
  c: "dimmed",
  className: propertyLabel
}), MIN_PADDING = 24, TABS = ["Properties", "Relationships", "Views", "Structure", "Deployments"];
function ElementDetailsCard({
  viewId,
  fromNode,
  rectFromNode,
  fqn: fqn2,
  onClose
}) {
  const [opened, setOpened] = useState(!1), windowSize = useViewportSize(), windowWidth = windowSize.width || window.innerWidth || 1200, windowHeight = windowSize.height || window.innerHeight || 800, [activeTab, setActiveTab] = useSessionStorage({
    key: "likec4:element-details:active-tab",
    defaultValue: "Properties"
  }), diagram = useDiagram(), viewModel = useLikeC4Model$1(!0).view(viewId), nodeModel = fromNode ? viewModel.findNode(fromNode) : viewModel.findNodeWithElement(fqn2), elementModel = viewModel.$model.element(fqn2), [viewsOf, otherViews] = C(
    [...elementModel.views()],
    m((v) => v.$view),
    d$3((view) => {
      const v = view;
      return isScopedElementView(v) && v.viewOf === fqn2;
    })
  );
  let defaultView2 = nodeModel?.navigateTo?.$view ?? elementModel.defaultView?.$view ?? null;
  defaultView2?.id === viewId && (defaultView2 = null);
  const defaultLink = t$5(elementModel.links), controls = useDragControls(), isCompound = (nodeModel?.$node.children?.length ?? 0) > 0, _width = Math.min(700, windowWidth - MIN_PADDING * 2), _height = Math.min(650, windowHeight - MIN_PADDING * 2), fromPositon = rectFromNode ? {
    x: rectFromNode.x + (isCompound ? rectFromNode.width - _width / 2 : rectFromNode.width / 2),
    y: rectFromNode.y + (isCompound ? 0 : rectFromNode.height / 2)
  } : {
    x: windowWidth / 2,
    y: windowHeight / 2
  }, fromScale = rectFromNode ? Math.min(rectFromNode.width / _width, rectFromNode.height / _height, 0.9) : 1, left = Math.round(
    u(fromPositon.x - _width / 2, {
      min: MIN_PADDING,
      max: windowWidth - _width - MIN_PADDING
    })
  ), top = Math.round(
    u(fromPositon.y - (isCompound ? 0 : 60), {
      min: MIN_PADDING,
      max: windowHeight - _height - MIN_PADDING
    })
  ), originX = u((fromPositon.x - left) / _width, {
    min: 0.1,
    max: 0.9
  }), originY = u((fromPositon.y - top) / _height, {
    min: 0.1,
    max: 0.9
  }), width = useMotionValue(_width), height = useMotionValue(_height);
  useUpdateEffect(() => {
    width.set(_width), height.set(_height);
  }, [_width, _height]);
  const handleDrag = useCallback((_, info) => {
    width.set(Math.max(width.get() + info.delta.x, 320)), height.set(Math.max(height.get() + info.delta.y, 300));
  }, []), ref = useRef(null), onCloseRef = useSyncedRef(onClose), close = useDebouncedCallback(
    () => {
      onCloseRef.current();
    },
    [],
    50
  ), notation = nodeModel?.$node.notation ?? null, elementIcon2 = IconRenderer({
    element: {
      id: fqn2,
      title: elementModel.title,
      icon: nodeModel?.icon ?? elementModel.icon
    },
    className: elementIcon$1
  });
  return useTimeoutEffect(() => {
    ref.current?.open || ref.current?.showModal();
  }, 20), useTimeoutEffect(() => {
    setOpened(!0);
  }, 150), /* @__PURE__ */ jsx(
    m$2.dialog,
    {
      ref,
      className: cx(dialog$1, RemoveScroll.classNames.fullWidth),
      layout: !0,
      layoutRoot: !0,
      initial: {
        [backdropBlur$1]: "0px",
        [backdropOpacity$1]: "5%"
      },
      animate: {
        [backdropBlur$1]: "3px",
        [backdropOpacity$1]: "60%"
      },
      exit: {
        [backdropBlur$1]: "0px",
        [backdropOpacity$1]: "0%",
        transition: {
          duration: 0.1
        }
      },
      onClick: (e2) => {
        e2.stopPropagation(), e2.target?.nodeName?.toUpperCase() === "DIALOG" && ref.current?.close();
      },
      onDoubleClick: stopPropagation$1,
      onPointerDown: stopPropagation$1,
      onClose: (e2) => {
        e2.stopPropagation(), close();
      },
      children: /* @__PURE__ */ jsx(RemoveScroll, { forwardProps: !0, removeScrollBar: !1, children: /* @__PURE__ */ jsxs(
        Card,
        {
          drag: !0,
          dragElastic: 0,
          dragMomentum: !1,
          dragListener: !1,
          dragControls: controls,
          withBorder: !0,
          shadow: "md",
          component: m$2.div,
          className: cx(
            css({
              likec4Palette: nodeModel?.color ?? elementModel.color
            }),
            card$2
          ),
          initial: {
            top,
            left,
            width: _width,
            height: _height,
            opacity: 0,
            originX,
            originY,
            scale: Math.max(fromScale, 0.65)
          },
          animate: {
            opacity: 1,
            scale: 1
          },
          exit: {
            opacity: 0,
            scale: 0.9,
            translateY: -10,
            transition: {
              duration: 0.1
            }
          },
          style: {
            // `style` prop in Mantine doesn't accept motion values
            width,
            height
          },
          children: [
            /* @__PURE__ */ jsxs(
              Box$1,
              {
                className: cardHeader,
                onPointerDown: (e2) => controls.start(e2),
                children: [
                  /* @__PURE__ */ jsxs(Group, { align: "start", justify: "space-between", gap: "sm", mb: "sm", wrap: "nowrap", children: [
                    /* @__PURE__ */ jsxs(Group, { align: "start", gap: "sm", style: { cursor: "default" }, wrap: "nowrap", children: [
                      elementIcon2,
                      /* @__PURE__ */ jsxs(Box$1, { children: [
                        /* @__PURE__ */ jsx(
                          Text,
                          {
                            component: "div",
                            className: title$2,
                            children: elementModel.title
                          }
                        ),
                        notation && /* @__PURE__ */ jsx(Text, { component: "div", c: "dimmed", fz: "sm", fw: 500, lh: 1.3, lineClamp: 1, children: notation })
                      ] })
                    ] }),
                    /* @__PURE__ */ jsx(
                      CloseButton,
                      {
                        size: "lg",
                        onClick: (e2) => {
                          e2.stopPropagation(), close();
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxs(Group, { align: "baseline", gap: "sm", wrap: "nowrap", children: [
                    /* @__PURE__ */ jsxs(Box$1, { children: [
                      /* @__PURE__ */ jsx(SmallLabel, { children: "kind" }),
                      /* @__PURE__ */ jsx(Badge, { radius: "sm", size: "sm", fw: 600, color: "gray", children: elementModel.kind })
                    ] }),
                    /* @__PURE__ */ jsxs(Box$1, { flex: 1, children: [
                      /* @__PURE__ */ jsx(SmallLabel, { children: "tags" }),
                      /* @__PURE__ */ jsxs(Flex, { gap: 4, flex: 1, mt: 6, children: [
                        elementModel.tags.map((tag) => /* @__PURE__ */ jsxs(Badge, { radius: "sm", size: "sm", fw: 600, variant: "gradient", children: [
                          "#",
                          tag
                        ] }, tag)),
                        elementModel.tags.length === 0 && /* @__PURE__ */ jsx(Badge, { radius: "sm", size: "sm", fw: 600, color: "gray", children: "" })
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxs(
                      ActionIconGroup,
                      {
                        style: {
                          alignSelf: "flex-end"
                        },
                        children: [
                          defaultLink && /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              component: "a",
                              href: defaultLink.url,
                              target: "_blank",
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              children: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: "65%" } })
                            }
                          ),
                          /* @__PURE__ */ jsx(IfEnabled, { feature: "Vscode", children: /* @__PURE__ */ jsx(Tooltip$1, { label: "Open source", children: /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              onClick: (e2) => {
                                e2.stopPropagation();
                              },
                              children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "62%" } })
                            }
                          ) }) }),
                          defaultView2 && /* @__PURE__ */ jsx(Tooltip$1, { label: "Open default view", children: /* @__PURE__ */ jsx(
                            ActionIcon$1,
                            {
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              onClick: (e2) => {
                                e2.stopPropagation(), diagram.navigateTo(defaultView2.id, fromNode ?? void 0);
                              },
                              children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "70%" } })
                            }
                          ) })
                        ]
                      }
                    )
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxs(
              Tabs,
              {
                value: activeTab,
                onChange: (v) => setActiveTab(v),
                variant: "none",
                classNames: {
                  root: tabsRoot,
                  list: tabsList,
                  tab: tabsTab,
                  panel: tabsPanel
                },
                children: [
                  /* @__PURE__ */ jsx(TabsList, { children: TABS.map((tab) => /* @__PURE__ */ jsx(TabsTab, { value: tab, children: tab }, tab)) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Properties", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsxs(Box$1, { className: propertiesGrid, pt: "xs", children: [
                    /* @__PURE__ */ jsx(ElementProperty, { title: "description", emptyValue: "no description", children: elementModel.description }),
                    elementModel.technology && /* @__PURE__ */ jsx(ElementProperty, { title: "technology", children: elementModel.technology }),
                    elementModel.links.length > 0 && /* @__PURE__ */ jsxs(Fragment$1, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "links" }),
                      /* @__PURE__ */ jsx(Stack, { gap: "xs", align: "flex-start", children: elementModel.links.map((link2, i2) => /* @__PURE__ */ jsx(Link, { value: link2 }, i2)) })
                    ] }),
                    elementModel.$element.metadata && /* @__PURE__ */ jsx(ElementMetata, { value: elementModel.$element.metadata })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Relationships", children: /* @__PURE__ */ jsx(
                    DiagramFeatures,
                    {
                      overrides: {
                        enableRelationshipBrowser: !1,
                        enableNavigateTo: !1
                      },
                      children: opened && activeTab === "Relationships" && /* @__PURE__ */ jsx(
                        TabPanelRelationships,
                        {
                          element: elementModel,
                          node: nodeModel ?? null
                        }
                      )
                    }
                  ) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Views", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsxs(Stack, { gap: "lg", children: [
                    viewsOf.length > 0 && /* @__PURE__ */ jsxs(Box$1, { children: [
                      /* @__PURE__ */ jsx(Divider, { label: "views of the element (scoped)" }),
                      /* @__PURE__ */ jsx(Stack, { gap: "sm", children: viewsOf.map((view) => /* @__PURE__ */ jsx(
                        ViewButton$1,
                        {
                          view,
                          onNavigateTo: (to) => diagram.navigateTo(to, fromNode ?? void 0)
                        },
                        view.id
                      )) })
                    ] }),
                    otherViews.length > 0 && /* @__PURE__ */ jsxs(Box$1, { children: [
                      /* @__PURE__ */ jsx(Divider, { label: "views including this element" }),
                      /* @__PURE__ */ jsx(Stack, { gap: "sm", children: otherViews.map((view) => /* @__PURE__ */ jsx(
                        ViewButton$1,
                        {
                          view,
                          onNavigateTo: (to) => diagram.navigateTo(to, fromNode ?? void 0)
                        },
                        view.id
                      )) })
                    ] })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Structure", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsx(TabPanelStructure, { element: elementModel }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Deployments", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsx(TabPanelDeployments, { elementFqn: elementModel.id }) }) })
                ]
              }
            ),
            /* @__PURE__ */ jsx(
              m$2.div,
              {
                className: resizeHandle,
                drag: !0,
                dragElastic: 0,
                dragMomentum: !1,
                onDrag: handleDrag,
                dragConstraints: { top: 0, left: 0, right: 0, bottom: 0 }
              }
            )
          ]
        }
      ) })
    }
  );
}
const ViewButton$1 = ({
  view,
  onNavigateTo
}) => /* @__PURE__ */ jsx(UnstyledButton, { className: viewButton$1, onClick: (e2) => onNavigateTo(view.id, e2), children: /* @__PURE__ */ jsxs(Group, { gap: 6, align: "start", wrap: "nowrap", children: [
  /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", children: isDeploymentView(view) ? /* @__PURE__ */ jsx(IconStack2, { stroke: 1.8 }) : /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8 }) }),
  /* @__PURE__ */ jsxs(Box$1, { children: [
    /* @__PURE__ */ jsx(Text, { component: "div", className: viewButtonTitle, lineClamp: 1, children: view.title || "untitled" }),
    view.description && /* @__PURE__ */ jsx(Text, { component: "div", mt: 2, fz: "xs", c: "dimmed", lh: 1.4, lineClamp: 1, children: view.description })
  ] })
] }) });
function ElementProperty({
  title: title2,
  emptyValue = "undefined",
  children: children2,
  style: style2,
  ...props
}) {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { children: title2 }),
    /* @__PURE__ */ jsx(
      Text,
      {
        component: "div",
        ...n$1(children2) && { c: "dimmed" },
        fz: "md",
        style: {
          whiteSpace: "preserve-breaks",
          ...style2
        },
        ...props,
        children: children2 || emptyValue
      }
    )
  ] });
}
function ElementMetata({
  value
}) {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { children: "metadata" }),
    /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(Code, { block: !0, children: JSON.stringify(value, null, 2) }) })
  ] });
}
function ElementDetails({
  actorRef,
  onClose
}) {
  const props = xstateReact_cjsExports.useSelector(
    actorRef,
    useCallbackRef((s2) => ({
      viewId: s2.context.currentView.id,
      fromNode: s2.context.initiatedFrom.node,
      rectFromNode: s2.context.initiatedFrom.clientRect,
      fqn: s2.context.subject
    })),
    shallowEqual
  );
  return /* @__PURE__ */ jsx(ElementDetailsActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(
    ElementDetailsCard,
    {
      onClose,
      ...props
    }
  ) });
}
const backdropBlur = "--_blur", backdropOpacity = "--_opacity", level = "--_level", offset = "--_offset", inset = "--_inset", borderRadius = "--_border-radius", dialog = css.raw({
  boxSizing: "border-box",
  margin: 0,
  position: "fixed",
  width: "auto",
  height: "auto",
  maxWidth: "100vw",
  maxHeight: "100vh",
  background: "mantine.colors.defaultBorder/50",
  shadow: "xl",
  border: "transparent",
  outline: "none",
  borderRadius: `var(${borderRadius})`,
  [backdropBlur]: "0px",
  [level]: "0",
  [offset]: "0px",
  [inset]: "calc((1 + var(--_level) * 0.75) * var(--_offset))",
  [backdropOpacity]: "0%",
  _backdrop: {
    cursor: "zoom-out",
    backdropFilter: `blur(var(${backdropBlur}))`,
    backgroundColor: {
      _dark: `[rgb(34 34 34 / var(${backdropOpacity}))]`,
      _light: `[rgb(15 15 15/ var(${backdropOpacity}))]`
    }
  },
  smDown: {
    [borderRadius]: "0px",
    border: "none",
    inset: 0,
    padding: 0,
    // [offset]: '0px',
    // [inset]: '0px',
    width: "100vw",
    height: "100vh"
  },
  sm: {
    inset: "[var(--_inset) var(--_inset) var(--_offset) var(--_inset)]",
    width: "calc(100vw - 2 * var(--_inset))",
    height: "calc(100vh - var(--_offset) - var(--_inset))",
    [borderRadius]: "6px",
    padding: "6px",
    [offset]: "1rem"
  },
  md: {
    [offset]: "1rem"
  },
  lg: {
    [offset]: "2rem"
  },
  xl: {
    [offset]: "4rem"
  }
}), body = css.raw({
  position: "relative",
  containerName: "overlay-dialog",
  containerType: "size",
  border: "0 solid transparent",
  background: "mantine.colors.body",
  overflow: "hidden",
  width: "100%",
  height: "100%",
  sm: {
    borderRadius: `calc(var(${borderRadius}) - 2px)`
  }
}), overlay = sva({
  slots: ["dialog", "body"],
  base: {
    dialog,
    body
  }
}), Overlay = forwardRef(({
  onClose,
  className,
  classes: classes2,
  overlayLevel = 0,
  children: children2,
  ...rest
}, ref) => {
  const [opened, setOpened] = useState(!1), dialogRef = useRef(null), isClosingRef = useRef(!1), motionNotReduced = useReducedMotionConfig() !== !0, onCloseRef = useSyncedRef(onClose), close = useDebouncedCallback(
    () => {
      isClosingRef.current || (isClosingRef.current = !0, onCloseRef.current());
    },
    [],
    50
  );
  useEffect(() => {
    const cancel = (e2) => {
      e2.preventDefault(), e2.stopPropagation(), close();
    };
    return dialogRef.current?.addEventListener("cancel", cancel, { capture: !0 }), () => {
      dialogRef.current?.removeEventListener("cancel", cancel, { capture: !0 });
    };
  }, []), useTimeoutEffect(() => {
    dialogRef.current?.open || dialogRef.current?.showModal();
  }, 30), useTimeoutEffect(() => {
    setOpened(!0);
  }, 120);
  const styles = overlay({
    level: overlayLevel
  });
  return /* @__PURE__ */ jsx(
    m$2.dialog,
    {
      ref: useMergedRef(dialogRef, ref),
      className: cx(RemoveScroll.classNames.fullWidth, styles.dialog, classes2?.dialog, className),
      layout: !0,
      style: {
        // @ts-ignore
        [level]: overlayLevel
      },
      ...motionNotReduced ? {
        initial: {
          [backdropBlur]: "0px",
          [backdropOpacity]: "0%",
          scale: overlayLevel > 0 ? 0.9 : 1.075,
          opacity: 0
        },
        animate: {
          [backdropBlur]: overlayLevel > 0 ? "4px" : "8px",
          [backdropOpacity]: overlayLevel > 0 ? "50%" : "60%",
          scale: 1,
          opacity: 1,
          transition: {
            delay: 0.075
          }
        },
        exit: {
          scale: 1.2,
          opacity: 0,
          [backdropBlur]: "0px",
          [backdropOpacity]: "0%"
        }
      } : {
        initial: {
          [backdropBlur]: "8px",
          [backdropOpacity]: "60%"
        }
      },
      onClick: (e2) => {
        if (e2.stopPropagation(), e2.target?.nodeName?.toUpperCase() === "DIALOG") {
          dialogRef.current?.close();
          return;
        }
      },
      onDoubleClick: stopPropagation$1,
      onPointerDown: stopPropagation$1,
      onClose: (e2) => {
        e2.stopPropagation(), close();
      },
      ...rest,
      children: /* @__PURE__ */ jsx(RemoveScroll, { forwardProps: !0, removeScrollBar: !1, children: /* @__PURE__ */ jsx(Box$1, { className: cx(styles.body, "overlay-body", classes2?.body), children: opened && /* @__PURE__ */ jsx(Fragment$1, { children: children2 }) }) })
    }
  );
});
Overlay.displayName = "Overlay";
var xstate_cjsExports = /* @__PURE__ */ requireXstate_cjs();
function _update$1(current, update) {
  return update.map((next) => {
    const existing = current.find((n2) => n2.id === next.id);
    return existing && deepEqual(existing.type, next.type) ? deepEqual(existing.hidden ?? !1, next.hidden ?? !1) && deepEqual(existing.source, next.source) && deepEqual(existing.sourceHandle ?? null, next.sourceHandle ?? null) && deepEqual(existing.target, next.target) && deepEqual(existing.targetHandle ?? null, next.targetHandle ?? null) && deepEqual(existing.zIndex ?? 0, next.zIndex ?? 0) && deepEqual(existing.data, next.data) ? existing : {
      ...y$2(existing, ["hidden", "zIndex"]),
      ...next,
      data: next.data
    } : next;
  });
}
function updateEdges(current, update) {
  return n(update) ? _update$1(current, update) : (update = current, (current2) => _update$1(current2, update));
}
function _update(current, updated) {
  return updated.map((update) => {
    const existing = current.find((n2) => n2.id === update.id);
    if (existing && deepEqual(existing.type, update.type)) {
      const { width: existingWidth, height: existingHeight } = getNodeDimensions(existing);
      return deepEqual(existingWidth, update.initialWidth) && deepEqual(existingHeight, update.initialHeight) && deepEqual(existing.parentId ?? null, update.parentId ?? null) && deepEqual(existing.hidden ?? !1, update.hidden ?? !1) && deepEqual(existing.zIndex ?? 0, update.zIndex ?? 0) && deepEqual(existing.position, update.position) && deepEqual(existing.data, update.data) ? existing : {
        ...y$2(existing, ["measured", "parentId", "hidden", "zIndex"]),
        ...update,
        // Force dimensions from update
        width: update.initialWidth,
        height: update.initialHeight,
        data: update.data
      };
    }
    return update;
  });
}
function updateNodes(current, update) {
  return n(update) ? _update(current, update) : (update = current, (current2) => _update(current2, update));
}
const ViewPadding = {
  top: "40px",
  bottom: "16px",
  left: "16px",
  right: "16px"
};
function viewToNodesEdge$1(view) {
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(view.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  )), ns = "", nodeById = (id2) => nonNullable(nodeLookup.get(id2), `Node not found: ${id2}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = i$7(node2.children, 1) || node2.kind == ElementKind.Group;
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.position[0],
      y: node2.position[1]
    };
    parent && (position.x -= parent.position[0], position.y -= parent.position[1]);
    const base = {
      id: ns + node2.id,
      draggable: !1,
      selectable: !0,
      focusable: !0,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      ...parent && {
        parentId: ns + parent.id
      }
    }, fqn2 = DiagramNode.modelRef(node2), navigateTo = { navigateTo: node2.navigateTo ?? null };
    switch (!0) {
      case node2.kind === LayoutRelationshipsViewResult.Empty: {
        xynodes.push(
          {
            ...base,
            type: "empty",
            data: {
              column: node2.column
            }
          }
        );
        break;
      }
      case (isCompound && !!fqn2): {
        xynodes.push(
          {
            ...base,
            type: "compound",
            data: {
              column: node2.column,
              title: node2.title,
              color: node2.color,
              shape: node2.shape,
              style: node2.style,
              depth: node2.depth ?? 0,
              icon: node2.icon ?? "none",
              ports: node2.ports,
              existsInCurrentView: node2.existsInCurrentView,
              fqn: fqn2,
              ...navigateTo
            }
          }
        );
        break;
      }
      default:
        invariant$2(fqn2, "Element should have either modelRef or deploymentRef"), xynodes.push(
          {
            ...base,
            type: "element",
            data: {
              column: node2.column,
              fqn: fqn2,
              title: node2.title,
              technology: node2.technology,
              description: node2.description,
              height: node2.height,
              width: node2.width,
              color: node2.color,
              shape: node2.shape,
              icon: node2.icon ?? "none",
              ports: node2.ports,
              style: node2.style,
              existsInCurrentView: node2.existsInCurrentView,
              ...navigateTo
            }
          }
        );
    }
  }
  for (const edge of view.edges) {
    const source = edge.source, target = edge.target, id2 = ns + edge.id;
    if (!i$7(edge.points, 2)) {
      console.error("edge should have at least 2 points", edge);
      continue;
    }
    if (!i$7(edge.relations, 1)) {
      console.error("edge should have at least 1 relation", edge);
      continue;
    }
    xyedges.push({
      id: id2,
      type: "relationship",
      source: ns + source,
      target: ns + target,
      sourceHandle: edge.sourceHandle,
      targetHandle: edge.targetHandle,
      zIndex: ZIndexes.Edge,
      // selectable: selectable,
      // hidden: !visiblePredicate(edge),
      // deletable: false,
      data: {
        sourceFqn: edge.sourceFqn,
        targetFqn: edge.targetFqn,
        relations: edge.relations,
        color: edge.color ?? "gray",
        label: edge.label,
        navigateTo: edge.navigateTo ?? null,
        line: edge.line ?? "dashed",
        existsInCurrentView: edge.existsInCurrentView
      },
      interactionWidth: 20
    });
  }
  return {
    xynodes,
    xyedges
  };
}
const findRootSubject = (nodes) => nodes.find(
  (n2) => n2.data.column === "subjects" && n$1(n2.parentId)
), layouter = xstate_cjsExports.fromPromise(async ({ input: input2, self: self2, signal }) => {
  const {
    subjectId,
    navigateFromNode,
    xyflow: xyflow2,
    xystore,
    update
  } = input2;
  let {
    nodes: currentNodes,
    width,
    height
  } = xystore.getState();
  const next = viewToNodesEdge$1(update), updateXYData = () => {
    const { nodes, edges } = xystore.getState();
    return {
      xynodes: updateNodes(nodes, next.xynodes),
      xyedges: updateEdges(edges, next.xyedges)
    };
  }, parent = nonNullable(self2._parent);
  let zoom2 = xyflow2.getZoom();
  const maxZoom = Math.max(zoom2, 1), nextviewport = getViewportForBounds(update.bounds, width, height, MinZoom, maxZoom, ViewPadding), nextSubjectNode = next.xynodes.find(
    (n2) => n2.type !== "empty" && n2.data.column === "subjects" && n2.data.fqn === subjectId
  ) ?? findRootSubject(next.xynodes), currentSubjectNode = findRootSubject(currentNodes), existingNode = navigateFromNode ? currentNodes.find((n2) => n2.id === navigateFromNode) : currentNodes.find((n2) => n2.type !== "empty" && n2.data.column !== "subjects" && n2.data.fqn === subjectId);
  if (!nextSubjectNode || !existingNode || nextSubjectNode.type === "empty" || !currentSubjectNode || nextSubjectNode.data.fqn === currentSubjectNode.data.fqn)
    return await xyflow2.setViewport(nextviewport), updateXYData();
  const nextSubjectCenter = {
    x: nextSubjectNode.position.x + (nextSubjectNode.initialWidth ?? 0) / 2,
    y: nextSubjectNode.position.y + (nextSubjectNode.initialHeight ?? 0) / 2
  }, currentSubjectInternalNode = xyflow2.getInternalNode(currentSubjectNode.id), currentSubjectCenter = centerXYInternalNode(currentSubjectInternalNode), nested = /* @__PURE__ */ new Set();
  return currentNodes.forEach((n2) => {
    if (n2.id !== existingNode.id) {
      if (n2.data.column === "subjects") {
        nested.add(n2.id);
        return;
      }
      n2.parentId && (n2.parentId === existingNode.id || nested.has(n2.parentId)) && nested.add(n2.id);
    }
  }), currentNodes = updateNodes(
    currentNodes,
    currentNodes.flatMap((n2) => nested.has(n2.id) ? [] : n2.id !== existingNode.id ? {
      ...n2,
      data: {
        ...n2.data,
        dimmed: n2.data.column === "subjects" ? "immediate" : !0
      }
    } : {
      ...y$2(n2, ["parentId"]),
      position: {
        x: currentSubjectCenter.x - n2.initialWidth / 2,
        y: currentSubjectCenter.y - n2.initialHeight / 2
      },
      zIndex: ZIndexes.Max,
      hidden: !1,
      data: {
        ...n2.data,
        dimmed: !1
      }
    })
  ), parent.send({
    type: "update.xydata",
    xynodes: currentNodes,
    xyedges: []
  }), await delay$1(120), next.xynodes = next.xynodes.map(Base.setDimmed(!1)), signal.aborted || (await xyflow2.setCenter(currentSubjectCenter.x, currentSubjectCenter.y, { zoom: zoom2, duration: 300 }), await xyflow2.setCenter(nextSubjectCenter.x, nextSubjectCenter.y, { zoom: zoom2 })), updateXYData();
}), relationshipsBrowserLogic = xstate_cjsExports.setup({
  types: {
    context: {},
    tags: "",
    children: {},
    input: {},
    events: {}
  },
  actors: {
    layouter
  },
  guards: {
    hasViewId: ({ context: context2 }) => context2.viewId !== null,
    isReady: ({ context: context2 }) => context2.xyflow !== null && context2.xystore !== null && context2.layouted !== null,
    anotherSubject: ({ context: context2, event }) => event.type === "update.view" ? context2.layouted?.subject !== event.layouted.subject : !1
  },
  actions: {
    "xyflow.init": xstate_cjsExports.assign(({ event }) => (xstate_cjsExports.assertEvent(event, "xyflow.init"), {
      xyflow: event.instance,
      xystore: event.store
    })),
    "update.view": xstate_cjsExports.assign(({ event }) => (xstate_cjsExports.assertEvent(event, "update.view"), {
      layouted: event.layouted,
      ...viewToNodesEdge$1(event.layouted)
    })),
    "xyflow:updateNodeInternals": ({ context: context2 }) => {
      invariant$2(context2.xystore, "xystore is not initialized");
      const { domNode, updateNodeInternals: updateNodeInternals2 } = context2.xystore.getState(), nodeIds = new Set(context2.xyedges.flatMap((e2) => [e2.source, e2.target]));
      if (nodeIds.size === 0 || !domNode)
        return;
      const updates = /* @__PURE__ */ new Map();
      for (const updateId of nodeIds) {
        const nodeElement = domNode.querySelector(`.react-flow__node[data-id="${updateId}"]`);
        nodeElement && updates.set(updateId, { id: updateId, nodeElement, force: !0 });
      }
      updateNodeInternals2(updates, { triggerFitView: !1 });
    },
    "xyflow:fitDiagram": ({ context: context2 }, params) => {
      let { duration, bounds } = params ?? {};
      duration ??= 450;
      const { xyflow: xyflow2, xystore } = context2;
      invariant$2(xyflow2, "xyflow is not initialized"), invariant$2(xystore, "xystore is not initialized"), bounds ??= context2.layouted?.bounds;
      const maxZoom = Math.max(xyflow2.getZoom(), 1);
      if (bounds) {
        const { width, height } = xystore.getState(), viewport = getViewportForBounds(bounds, width, height, MinZoom, maxZoom, ViewPadding);
        xyflow2.setViewport(viewport, duration > 0 ? { duration } : void 0);
      } else
        xyflow2.fitView({
          minZoom: MinZoom,
          maxZoom,
          padding: ViewPadding,
          ...duration > 0 && { duration }
        });
    },
    "xyflow.applyNodeChanges": xstate_cjsExports.assign(({ context: context2, event }) => (xstate_cjsExports.assertEvent(event, "xyflow.applyNodeChanges"), {
      xynodes: applyNodeChanges(event.changes, context2.xynodes)
    })),
    "xyflow.applyEdgeChanges": xstate_cjsExports.assign(({ context: context2, event }) => (xstate_cjsExports.assertEvent(event, "xyflow.applyEdgeChanges"), {
      xyedges: applyEdgeChanges(event.changes, context2.xyedges)
    }))
  }
}).createMachine({
  id: "relationships-browser",
  context: ({ input: input2 }) => ({
    subject: input2.subject,
    viewId: input2.viewId,
    scope: input2.viewId ? input2.scope : "global",
    closeable: input2.closeable ?? !0,
    enableSelectSubject: input2.enableSelectSubject ?? !0,
    enableChangeScope: input2.enableChangeScope ?? !0,
    xyflow: null,
    xystore: null,
    layouted: null,
    navigateFromNode: null,
    xynodes: [],
    xyedges: []
  }),
  initial: "initializing",
  on: {
    "xyflow.applyNodeChanges": {
      actions: "xyflow.applyNodeChanges"
    },
    "xyflow.applyEdgeChanges": {
      actions: "xyflow.applyEdgeChanges"
    }
  },
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: "xyflow.init",
          target: "isReady"
        },
        "update.view": {
          actions: "update.view",
          target: "isReady"
        },
        stop: "closed",
        close: "closed"
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        actions: [
          { type: "xyflow:fitDiagram", params: { duration: 0 } },
          xstate_cjsExports.raise({ type: "xyflow.updateNodeInternals" }, { delay: 150 })
        ],
        target: "active"
      }, {
        target: "initializing"
      }]
    },
    active: {
      initial: "idle",
      tags: ["active"],
      on: {
        "xyflow.nodeClick": {
          actions: xstate_cjsExports.enqueueActions(({ event, enqueue }) => {
            if ("fqn" in event.node.data) {
              const fqn2 = event.node.data.fqn;
              enqueue.raise({
                type: "navigate.to",
                subject: fqn2,
                fromNode: event.node.id
              });
            }
          })
        },
        "xyflow.edgeClick": {
          guard: "hasViewId",
          actions: xstate_cjsExports.enqueueActions(({ event, context: context2, system, enqueue }) => {
            (event.edge.selected || event.edge.data.relations.length > 1) && enqueue.sendTo(typedSystem(system).overlaysActorRef, {
              type: "open.relationshipDetails",
              viewId: context2.viewId,
              source: event.edge.data.sourceFqn,
              target: event.edge.data.targetFqn
            });
          })
        },
        "navigate.to": {
          actions: [
            xstate_cjsExports.assign({
              subject: ({ event }) => event.subject,
              viewId: ({ event, context: context2 }) => event.viewId ?? context2.viewId ?? null,
              navigateFromNode: ({ event }) => event.fromNode ?? null
            })
          ]
        },
        "xyflow.paneDblClick": {
          actions: "xyflow:fitDiagram"
        },
        "update.view": {
          actions: "update.view",
          target: ".layouting"
        },
        "change.scope": {
          actions: xstate_cjsExports.assign({
            scope: ({ event }) => event.scope
          })
        },
        "xyflow.updateNodeInternals": {
          actions: "xyflow:updateNodeInternals"
        },
        fitDiagram: {
          actions: {
            type: "xyflow:fitDiagram",
            params: p$2("event")
          }
        },
        "xyflow.resized": {
          actions: [
            xstate_cjsExports.cancel("fitDiagram"),
            xstate_cjsExports.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 300 })
          ]
        },
        "xyflow.init": {
          actions: "xyflow.init"
        },
        "xyflow.unmount": {
          target: "initializing"
        },
        close: "closed"
      },
      states: {
        idle: {
          on: {
            "xyflow.edgeMouseEnter": {
              actions: [
                xstate_cjsExports.assign({
                  xyedges: ({ context: context2, event }) => {
                    const hasDimmed = context2.xyedges.some((edge) => edge.data.dimmed !== !1 || edge.selected);
                    return context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setData(edge, {
                      hovered: !0,
                      dimmed: !1
                    }) : hasDimmed && !edge.selected ? Base.setDimmed(edge, "immediate") : edge);
                  }
                }),
                xstate_cjsExports.cancel("undim.edges"),
                xstate_cjsExports.cancel("dim.nonhovered.edges"),
                xstate_cjsExports.raise({ type: "dim.nonhovered.edges" }, { id: "dim.nonhovered.edges", delay: 200 })
              ]
            },
            "xyflow.edgeMouseLeave": {
              actions: [
                xstate_cjsExports.assign({
                  xyedges: ({ context: context2, event }) => context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setHovered(edge, !1) : edge)
                }),
                xstate_cjsExports.cancel("dim.nonhovered.edges"),
                xstate_cjsExports.raise({ type: "undim.edges" }, { id: "undim.edges", delay: 400 })
              ]
            },
            "dim.nonhovered.edges": {
              actions: xstate_cjsExports.assign({
                xyedges: ({ context: context2 }) => context2.xyedges.map(
                  (edge) => edge.data.hovered ? edge : Base.setDimmed(edge, edge.data.dimmed === "immediate" ? "immediate" : !0)
                )
              })
            },
            "undim.edges": {
              actions: xstate_cjsExports.assign({
                xyedges: ({ context: context2 }) => context2.xyedges.map(Base.setDimmed(!1))
              })
            },
            "xyflow.selectionChange": {
              actions: xstate_cjsExports.enqueueActions(({ event, context: context2, enqueue }) => {
                event.edges.length === 0 && context2.xyedges.some((e2) => e2.data.dimmed) && !context2.xyedges.some((e2) => e2.data.hovered) && enqueue.raise({ type: "undim.edges" });
              })
            }
          }
        },
        layouting: {
          invoke: {
            id: "layouter",
            src: "layouter",
            input: ({ context: context2 }) => ({
              subjectId: context2.subject,
              navigateFromNode: context2.navigateFromNode,
              xyflow: nonNullable(context2.xyflow),
              xystore: nonNullable(context2.xystore),
              update: nonNullable(context2.layouted)
            }),
            onDone: {
              target: "idle",
              actions: xstate_cjsExports.enqueueActions(({ enqueue, event }) => {
                enqueue.assign({
                  xynodes: event.output.xynodes,
                  xyedges: event.output.xyedges,
                  navigateFromNode: null
                }), enqueue.raise({ type: "fitDiagram", duration: 200 }, { id: "fitDiagram", delay: 50 });
                for (let i2 = 0; i2 < 6; i2++)
                  enqueue.raise({ type: "xyflow.updateNodeInternals" }, { delay: 100 + i2 * 100 });
              })
            }
          },
          on: {
            "update.xydata": {
              actions: xstate_cjsExports.assign({
                xynodes: ({ event }) => event.xynodes,
                xyedges: ({ event }) => event.xyedges
              })
            },
            "xyflow.applyEdgeChanges": {
              // actions: log('layouting: ignore xyflow.applyEdgeChanges'),
            },
            "xyflow.applyNodeChanges": {
              // actions: log('layouting: ignore xyflow.applyNodeChanges'),
            }
          }
        }
      }
    },
    closed: {
      id: "closed",
      type: "final"
    }
  },
  exit: xstate_cjsExports.assign({
    xyflow: null,
    layouted: null,
    xystore: null,
    xyedges: [],
    xynodes: []
  })
}), elementDetailsLogic = xstate_cjsExports.setup({
  types: {
    context: {},
    input: {},
    events: {},
    children: {}
  },
  actors: {
    relationshipsBrowserLogic
  }
}).createMachine({
  id: "element-details",
  context: ({ input: input2 }) => ({
    ...input2,
    initiatedFrom: {
      node: input2.initiatedFrom?.node ?? null,
      clientRect: input2.initiatedFrom?.clientRect ?? null
    }
  }),
  initial: "active",
  states: {
    active: {
      entry: xstate_cjsExports.spawnChild("relationshipsBrowserLogic", {
        id: ({ self: self2 }) => `${self2.id}-relationships`,
        input: ({ context: context2 }) => ({
          subject: context2.subject,
          viewId: context2.currentView.id,
          scope: "view",
          enableSelectSubject: !1,
          enableChangeScope: !0,
          closeable: !1
        })
      }),
      exit: [
        xstate_cjsExports.sendTo(({ self: self2 }) => `${self2.id}-relationships`, { type: "close" }),
        xstate_cjsExports.stopChild(({ self: self2 }) => `${self2.id}-relationships`)
      ],
      on: {
        "change.subject": {
          actions: xstate_cjsExports.assign({
            subject: ({ event }) => event.subject
          })
        },
        close: "closed"
      }
    },
    closed: {
      id: "closed",
      type: "final"
    }
  }
  // exit: assign({
  //   initialized: false,
  //   xyflow: null,
  //   layouted: null,
  //   xystore: null,
  //   xyedges: [],
  //   xynodes: [],
  // }),
}), Sizes$1 = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 220,
    height: 14
    // minlen: 1,
  },
  nodeWidth: 330,
  nodeHeight: 180,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function createGraph$1() {
  const g = new dagre.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return g.setGraph({
    ...Sizes$1.dagre,
    rankdir: "LR"
  }), g.setDefaultEdgeLabel(() => ({ ...Sizes$1.edgeLabel })), g.setDefaultNodeLabel(() => ({})), g;
}
const PortSuffix$1 = "-port";
function createNodes$1(column, elements, g) {
  const graphNodes = new DefaultMap$1((key2) => ({
    id: `${column}-${key2}`,
    portId: `${column}-${key2}`
  })), tree = treeFromElements$1(elements);
  for (const element of tree.sorted) {
    const isCompound = tree.children(element).length > 0, fqn2 = element.id, id2 = `${column}-${fqn2}`, portId = isCompound ? `${id2}${PortSuffix$1}` : id2;
    graphNodes.set(fqn2, {
      id: id2,
      portId
    }), g.setNode(id2, {
      column,
      element,
      isCompound,
      portId,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth,
      height: Sizes$1.nodeHeight
    }), isCompound && (g.setNode(portId, {
      element,
      portId,
      isCompound,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth - Sizes$1.dagre.ranksep,
      height: Sizes$1.compound.labelHeight
    }), g.setParent(portId, id2));
    const parent = tree.parent(element);
    parent && g.setParent(id2, `${column}-${parent.id}`);
  }
  return {
    ...tree,
    byId: (id2) => {
      const element = tree.byId(id2), graph2 = graphNodes.get(element.id);
      return {
        element,
        graph: graph2
      };
    },
    graphNodes
  };
}
function applyDagreLayout$1(g) {
  return dagre.layout(g, {
    // disableOptimalOrderHeuristic: true,
  }), (nodeId) => {
    const node2 = g.node(nodeId), { x: x2, y: y2, width, height } = node2;
    return {
      position: {
        x: x2 - Math.round(width / 2),
        y: y2 - Math.round(height / 2)
      },
      width,
      height
    };
  };
}
function layoutRelationshipDetails(data, scope) {
  const g = createGraph$1(), sources = createNodes$1("sources", data.sources, g), targets = createNodes$1("targets", data.targets, g), edges = Array.from(data.relationships).map((r2) => {
    const source = sources.byId(r2.source.id).graph, target = targets.byId(r2.target.id).graph, name = r2.id;
    return g.node(source.id).outPorts.push(target.id), g.node(target.id).inPorts.push(source.id), g.setEdge(source.portId, target.portId, {
      ...Sizes$1.edgeLabel
    }, name), {
      name,
      source: source.id,
      sourceHandle: source.id + "_out" + (g.node(source.id).outPorts.length - 1),
      target: target.id,
      targetHandle: target.id + "_in" + (g.node(target.id).inPorts.length - 1),
      relationship: r2
    };
  }), nodeIds = [
    ...sources.graphNodes.values(),
    ...targets.graphNodes.values()
  ];
  for (const { id: nodeId } of nodeIds) {
    const node2 = g.node(nodeId);
    if (node2.isCompound)
      continue;
    const edgeCount2 = Math.max(g.inEdges(nodeId)?.length ?? 0, g.outEdges(nodeId)?.length ?? 0);
    edgeCount2 > 3 && (node2.height = node2.height + (edgeCount2 - 4) * 14);
  }
  const edgeCount = g.edgeCount();
  if (edgeCount > 5)
    for (const edge of g.edges())
      g.setEdge(edge, {
        ...Sizes$1.edgeLabel,
        width: edgeCount > 10 ? 800 : 400
      });
  const dagreBounds = applyDagreLayout$1(g), _calculatedNodeBounds = C(
    nodeIds,
    // Compound nodes have different portId
    T((n2) => n2.id === n2.portId),
    l$3((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ??= C(
      g.children(nodeId) ?? [],
      T((id2) => !id2.endsWith(PortSuffix$1)),
      m((id2) => nodeBounds(id2)),
      r$4((bounds) => {
        invariant$2(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      l$4((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: minY2, maxY }) => {
        const {
          position: { x: x2 },
          width
        } = dagreBounds(nodeId);
        return minY2 = minY2 - Sizes$1.compound.paddingTop, maxY = maxY + Sizes$1.compound.paddingBottom, {
          position: {
            x: x2,
            y: minY2
          },
          width,
          height: maxY - minY2
        };
      }
    );
  }
  function nodeLevel(nodeId) {
    const parent = g.parent(nodeId);
    return parent ? nodeLevel(parent) + 1 : 0;
  }
  function nodeDepth(nodeId) {
    const children2 = g.children(nodeId) ?? [];
    return children2.length === 0 ? 0 : 1 + Math.max(...children2.map(nodeDepth));
  }
  const sortedPorts = (nodeId, type, ports) => C(
    ports,
    m((port, index2) => ({
      port: nodeId + "_" + type + index2,
      topY: nodeBounds(port).position.y
    })),
    a$5(p$2("topY")),
    m(p$2("port"))
  );
  let minX = 0, minY = 0;
  const nodes = nodeIds.map(({ id: id2 }) => {
    const { element, inPorts, outPorts, column } = g.node(id2);
    let { position, width, height } = nodeBounds(id2);
    const parentId = g.parent(id2), children2 = (g.children(id2) ?? []).filter((c2) => !c2.endsWith(PortSuffix$1));
    minX = Math.min(minX, position.x), minY = Math.min(minY, position.y);
    const navigateTo = scope ? ifind$1(element.scopedViews(), (v) => v.id !== scope.id)?.id ?? null : null, inheritFromNode = scope?.findNodeWithElement(element.id), scopedAncestor = scope && !inheritFromNode ? ifind$1(element.ancestors(), (a2) => !!scope.findNodeWithElement(a2.id))?.id : null, inheritFromNodeOrAncestor = inheritFromNode ?? (scopedAncestor && scope?.findNodeWithElement(scopedAncestor));
    return {
      id: id2,
      parent: parentId ?? null,
      position: [position.x, position.y],
      title: element.title,
      description: element.description,
      technology: element.technology,
      tags: null,
      links: null,
      color: inheritFromNodeOrAncestor?.color ?? element.color,
      shape: inheritFromNode?.shape ?? element.shape,
      icon: inheritFromNode?.icon ?? element.icon ?? "none",
      modelRef: element.id,
      kind: element.kind,
      level: nodeLevel(id2),
      labelBBox: {
        x: position.x,
        y: position.y,
        width,
        height
      },
      style: {
        ...(inheritFromNode ?? inheritFromNodeOrAncestor)?.style,
        ...element.$element.style
      },
      navigateTo,
      ...children2.length > 0 && { depth: nodeDepth(id2) },
      children: children2,
      width,
      height,
      column,
      ports: {
        in: sortedPorts(id2, "in", inPorts),
        out: sortedPorts(id2, "out", outPorts)
      }
    };
  });
  return {
    bounds: {
      x: Math.min(minX, 0),
      y: Math.min(minY, 0),
      width: g.graph().width ?? 100,
      height: g.graph().height ?? 100
    },
    nodes,
    edges: g.edges().reduce((acc, e2) => {
      const edge = g.edge(e2), ename = e2.name;
      if (!ename)
        return acc;
      const { name, source, target, relationship, sourceHandle, targetHandle } = f(edges, (e22) => e22.name === ename), label2 = relationship.title ?? "untitled", navigateTo = relationship.navigateTo?.id ?? null, description2 = relationship.description ?? null, technology2 = relationship.technology ?? null;
      return acc.push({
        id: name,
        source,
        sourceHandle,
        target,
        targetHandle,
        label: label2,
        color: relationship.color,
        ...navigateTo && { navigateTo },
        ...description2 && { description: description2 },
        ...technology2 && { technology: technology2 },
        points: edge.points.map((p2) => [p2.x, p2.y]),
        line: relationship.line,
        relationId: relationship.id,
        parent: null
      }), acc;
    }, [])
  };
}
function layoutResultToXYFlow(layout2) {
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(layout2.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  )), ns = "", nodeById = (id2) => nonNullable(nodeLookup.get(id2), `Node not found: ${id2}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = i$7(node2.children, 1);
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.position[0],
      y: node2.position[1]
    };
    parent && (position.x -= parent.position[0], position.y -= parent.position[1]);
    const base = {
      id: ns + node2.id,
      draggable: !1,
      selectable: !0,
      focusable: !0,
      deletable: !1,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      ...parent && {
        parentId: ns + parent.id
      }
    }, fqn2 = node2.modelRef, navigateTo = { navigateTo: node2.navigateTo ?? null };
    switch (!0) {
      case isCompound: {
        xynodes.push(
          {
            ...base,
            type: "compound",
            data: {
              column: node2.column,
              title: node2.title,
              color: node2.color,
              style: node2.style,
              depth: node2.depth ?? 0,
              icon: node2.icon ?? "none",
              ports: node2.ports,
              fqn: fqn2,
              ...navigateTo
            }
          }
        );
        break;
      }
      default:
        xynodes.push(
          {
            ...base,
            type: "element",
            data: {
              column: node2.column,
              fqn: fqn2,
              title: node2.title,
              technology: node2.technology,
              description: node2.description,
              height: node2.height,
              width: node2.width,
              color: node2.color,
              shape: node2.shape,
              icon: node2.icon ?? "none",
              ports: node2.ports,
              style: node2.style,
              ...navigateTo
            }
          }
        );
    }
  }
  for (const {
    source,
    target,
    relationId,
    label: label2,
    technology: technology2,
    description: description2,
    navigateTo = null,
    color: color2 = "gray",
    line = "dashed",
    ...edge
  } of layout2.edges) {
    const id2 = ns + edge.id;
    xyedges.push({
      id: id2,
      type: "relationship",
      source: ns + source,
      target: ns + target,
      sourceHandle: edge.sourceHandle,
      targetHandle: edge.targetHandle,
      zIndex: ZIndexes.Edge,
      // selectable: selectable,
      // hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        relationId,
        label: label2,
        color: color2,
        navigateTo,
        line,
        ...technology2 && { technology: technology2 },
        ...description2 && { description: description2 }
      }
    });
  }
  return {
    xynodes,
    xyedges,
    bounds: layout2.bounds
  };
}
function inputToSubject(input2) {
  return "edgeId" in input2 ? (invariant$2(t$3(input2.edgeId), "edgeId is required"), {
    edgeId: input2.edgeId
  }) : {
    source: input2.source,
    target: input2.target
  };
}
const relationshipDetailsLogic = xstate_cjsExports.setup({
  types: {
    context: {},
    input: {},
    events: {}
  },
  actions: {
    "xyflow:fitDiagram": ({ context: context2 }, params) => {
      let { duration, bounds } = params ?? {};
      duration ??= 450;
      const { xyflow: xyflow2, xystore } = context2;
      invariant$2(xyflow2, "xyflow is not initialized"), invariant$2(xystore, "xystore is not initialized"), bounds ??= context2.bounds;
      const maxZoom = Math.max(xyflow2.getZoom(), 1);
      if (bounds) {
        const { width, height } = xystore.getState(), viewport = getViewportForBounds(bounds, width, height, MinZoom, maxZoom, 0.1);
        xyflow2.setViewport(viewport, duration > 0 ? { duration } : void 0);
      } else
        xyflow2.fitView({
          minZoom: MinZoom,
          maxZoom,
          padding: 0.1,
          ...duration > 0 && { duration }
        });
    },
    "xyflow:updateNodeInternals": ({ context: context2 }) => {
      invariant$2(context2.xystore, "xystore is not initialized");
      const { domNode, updateNodeInternals: updateNodeInternals2 } = context2.xystore.getState(), nodeIds = new Set(context2.xyedges.flatMap((e2) => [e2.source, e2.target]));
      if (nodeIds.size === 0 || !domNode)
        return;
      const updates = /* @__PURE__ */ new Map();
      for (const updateId of nodeIds) {
        const nodeElement = domNode.querySelector(`.react-flow__node[data-id="${updateId}"]`);
        nodeElement && updates.set(updateId, { id: updateId, nodeElement, force: !0 });
      }
      updateNodeInternals2(updates, { triggerFitView: !1 });
    },
    updateXYFlow: xstate_cjsExports.assign(({ context: context2, event }) => {
      xstate_cjsExports.assertEvent(event, "xyflow.init");
      let initialized = context2.initialized;
      return initialized.xyflow || (initialized = {
        ...initialized,
        xyflow: !0
      }), {
        initialized,
        xyflow: event.instance,
        xystore: event.store
      };
    }),
    updateLayoutData: xstate_cjsExports.assign(({ context: context2, event }) => {
      xstate_cjsExports.assertEvent(event, "update.layoutData");
      const { xynodes, xyedges, bounds } = layoutResultToXYFlow(event.data);
      let initialized = context2.initialized;
      return initialized.xydata || (initialized = {
        ...initialized,
        xydata: !0
      }), {
        initialized,
        xynodes: updateNodes(context2.xynodes, xynodes),
        xyedges: updateEdges(context2.xyedges, xyedges),
        bounds: shallowEqual(context2.bounds, bounds) ? context2.bounds : bounds
      };
    })
  },
  guards: {
    isReady: ({ context: context2 }) => context2.initialized.xydata && context2.initialized.xyflow,
    "enable: navigate.to": () => !0
  }
}).createMachine({
  initial: "initializing",
  context: ({ input: input2 }) => ({
    subject: inputToSubject(input2),
    viewId: input2.viewId,
    bounds: {
      x: 0,
      y: 0,
      width: 200,
      height: 200
    },
    initialized: {
      xydata: !1,
      xyflow: !1
    },
    xyflow: null,
    xystore: null,
    xynodes: [],
    xyedges: []
  }),
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: "updateXYFlow",
          target: "isReady"
        },
        "update.layoutData": {
          actions: "updateLayoutData",
          target: "isReady"
        },
        close: {
          target: "closed"
        }
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        actions: [
          { type: "xyflow:fitDiagram", params: { duration: 0 } },
          xstate_cjsExports.raise({ type: "xyflow.updateNodeInternals" }, { delay: 50 })
        ],
        target: "ready"
      }, {
        target: "initializing"
      }]
    },
    ready: {
      on: {
        "xyflow.edgeMouseEnter": {
          actions: [
            xstate_cjsExports.assign({
              xyedges: ({ context: context2, event }) => {
                const hasDimmed = context2.xyedges.some(
                  (edge) => edge.data.dimmed === !0 || edge.data.dimmed === "immediate"
                );
                return context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setData(edge, {
                  hovered: !0,
                  dimmed: !1
                }) : hasDimmed && !edge.selected ? Base.setDimmed(edge, "immediate") : edge);
              }
            }),
            xstate_cjsExports.cancel("undim.edges"),
            xstate_cjsExports.cancel("dim.nonhovered.edges"),
            xstate_cjsExports.raise({ type: "dim.nonhovered.edges" }, { id: "dim.nonhovered.edges", delay: 100 })
          ]
        },
        "xyflow.edgeMouseLeave": {
          actions: [
            xstate_cjsExports.assign({
              xyedges: ({ context: context2, event }) => context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setHovered(edge, !1) : edge)
            }),
            xstate_cjsExports.cancel("dim.nonhovered.edges"),
            xstate_cjsExports.raise({ type: "undim.edges" }, { id: "undim.edges", delay: 400 })
          ]
        },
        "dim.nonhovered.edges": {
          actions: xstate_cjsExports.assign({
            xyedges: ({ context: context2 }) => context2.xyedges.map((edge) => Base.setDimmed(edge, edge.data.hovered !== !0))
          })
        },
        "undim.edges": {
          actions: xstate_cjsExports.assign({
            xyedges: ({ context: context2 }) => context2.xyedges.some((edge) => edge.selected === !0) ? context2.xyedges.map(
              (edge) => Base.setDimmed(edge, edge.selected !== !0 ? edge.data.dimmed || "immediate" : !1)
            ) : context2.xyedges.map(Base.setDimmed(!1))
          })
        },
        "xyflow.selectionChange": {
          actions: xstate_cjsExports.enqueueActions(({ event, context: context2, enqueue }) => {
            event.edges.length === 0 && context2.xyedges.some((e2) => e2.data.dimmed) && !context2.xyedges.some((e2) => e2.data.hovered) && enqueue.raise({ type: "undim.edges" });
          })
        },
        "update.layoutData": {
          actions: [
            "updateLayoutData",
            xstate_cjsExports.cancel("fitDiagram"),
            xstate_cjsExports.raise({ type: "fitDiagram", duration: 0 }, { id: "fitDiagram", delay: 50 }),
            xstate_cjsExports.raise({ type: "xyflow.updateNodeInternals" }, { delay: 75 })
          ]
        },
        "xyflow.init": {
          actions: "updateXYFlow"
        },
        "xyflow.applyNodeChanges": {
          actions: xstate_cjsExports.assign({
            xynodes: ({ context: context2, event }) => applyNodeChanges(event.changes, context2.xynodes)
          })
        },
        "xyflow.applyEdgeChanges": {
          actions: xstate_cjsExports.assign({
            xyedges: ({ context: context2, event }) => applyEdgeChanges(event.changes, context2.xyedges)
          })
        },
        "xyflow.paneDblClick": {
          actions: "xyflow:fitDiagram"
        },
        "navigate.to": {
          actions: xstate_cjsExports.assign({
            subject: ({ event }) => inputToSubject(event.params),
            viewId: ({ context: context2, event }) => event.params.viewId ?? context2.viewId
          })
        },
        close: {
          target: "closed"
        }
      },
      exit: xstate_cjsExports.assign({
        xyedges: [],
        xynodes: [],
        initialized: {
          xydata: !1,
          xyflow: !1
        },
        xyflow: null,
        xystore: null
      })
    },
    closed: {
      type: "final"
    }
  },
  on: {
    fitDiagram: {
      actions: {
        type: "xyflow:fitDiagram",
        params: p$2("event")
      }
    },
    "xyflow.resized": {
      actions: [
        xstate_cjsExports.cancel("fitDiagram"),
        xstate_cjsExports.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 200 })
      ]
    },
    "xyflow.updateNodeInternals": {
      actions: "xyflow:updateNodeInternals"
    }
  }
}), hotkeyLogic = xstate_cjsExports.fromCallback(({ sendBack }) => {
  const handler = getHotkeyHandler([
    ["Escape", (event) => {
      event.stopPropagation(), sendBack({ type: "close" });
    }, {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", handler, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", handler, { capture: !0 });
  };
}), overlaysActorLogic = xstate_cjsExports.setup({
  types: {
    context: {},
    events: {},
    emitted: {},
    children: {}
  },
  actors: {
    relationshipDetails: relationshipDetailsLogic,
    elementDetails: elementDetailsLogic,
    relationshipsBrowser: relationshipsBrowserLogic,
    hotkey: hotkeyLogic
  },
  actions: {
    closeLastOverlay: xstate_cjsExports.enqueueActions(({ context: context2, enqueue }) => {
      if (context2.overlays.length === 0)
        return;
      const lastOverlay = a$4(context2.overlays)?.id;
      lastOverlay && (enqueue.sendTo(lastOverlay, { type: "close" }), enqueue.stopChild(lastOverlay), enqueue.assign({
        overlays: context2.overlays.filter((o2) => o2.id !== lastOverlay)
      }));
    }),
    closeSpecificOverlay: xstate_cjsExports.enqueueActions(({ context: context2, enqueue }, params) => {
      const toClose = context2.overlays.find((o2) => o2.id === params.actorId)?.id;
      toClose && (enqueue.sendTo(toClose, { type: "close" }), enqueue.stopChild(toClose), enqueue.assign({
        overlays: context2.overlays.filter((o2) => o2.id !== toClose)
      }));
    }),
    closeAllOverlays: xstate_cjsExports.enqueueActions(({ context: context2, enqueue }) => {
      for (const { id: id2 } of t$7(context2.overlays))
        enqueue.sendTo(id2, { type: "close" }), enqueue.stopChild(id2);
      enqueue.assign({ overlays: [] });
    }),
    openElementDetails: xstate_cjsExports.enqueueActions(({ context: context2, enqueue, event }) => {
      if (xstate_cjsExports.assertEvent(event, "open.elementDetails"), context2.overlays.some((o2) => o2.type === "elementDetails" && o2.subject === event.subject))
        return;
      const id2 = `elementDetails-${context2.seq}`;
      enqueue.spawnChild("elementDetails", {
        id: id2,
        input: event
      }), enqueue.assign({
        seq: context2.seq + 1,
        overlays: [
          ...context2.overlays,
          {
            type: "elementDetails",
            id: id2,
            subject: event.subject
          }
        ]
      });
    }),
    openRelationshipDetails: xstate_cjsExports.enqueueActions(({ context: context2, enqueue, event }) => {
      xstate_cjsExports.assertEvent(event, "open.relationshipDetails");
      const currentOverlay = a$4(context2.overlays);
      if (currentOverlay?.type === "relationshipDetails") {
        enqueue.sendTo(currentOverlay.id, {
          ...event,
          type: "navigate.to"
        });
        return;
      }
      const id2 = `relationshipDetails-${context2.seq}`;
      enqueue.spawnChild("relationshipDetails", {
        id: id2,
        input: event
      }), enqueue.assign({
        seq: context2.seq + 1,
        overlays: [
          ...context2.overlays,
          {
            type: "relationshipDetails",
            id: id2
          }
        ]
      });
    }),
    openRelationshipsBrowser: xstate_cjsExports.enqueueActions(({ context: context2, enqueue, event }) => {
      xstate_cjsExports.assertEvent(event, "open.relationshipsBrowser");
      const currentOverlay = a$4(context2.overlays);
      if (currentOverlay?.type === "relationshipsBrowser") {
        enqueue.sendTo(currentOverlay.id, {
          type: "navigate.to",
          subject: event.subject,
          viewId: event.viewId
        });
        return;
      }
      const id2 = `relationshipsBrowser-${context2.seq}`;
      enqueue.spawnChild("relationshipsBrowser", {
        id: id2,
        input: event
      }), enqueue.assign({
        seq: context2.seq + 1,
        overlays: [
          ...context2.overlays,
          {
            type: "relationshipsBrowser",
            id: id2,
            subject: event.subject
          }
        ]
      });
    }),
    listenToEsc: xstate_cjsExports.spawnChild("hotkey", {
      id: "hotkey"
    }),
    stopListeningToEsc: xstate_cjsExports.stopChild("hotkey")
  },
  guards: {
    "has overlays?": ({ context: context2 }) => context2.overlays.length > 0,
    "close specific overlay?": ({ context: context2, event }) => (xstate_cjsExports.assertEvent(event, "close"), t$3(event.actorId) && context2.overlays.some((o2) => o2.id === event.actorId)),
    "last: is relationshipDetails?": ({ context: context2 }) => a$4(context2.overlays)?.type === "relationshipDetails",
    "last: is relationshipsBrowser?": ({ context: context2 }) => a$4(context2.overlays)?.type === "relationshipsBrowser"
  }
}).createMachine({
  id: "overlays",
  context: () => ({
    seq: 1,
    overlays: []
  }),
  initial: "idle",
  on: {
    "open.elementDetails": {
      actions: "openElementDetails",
      target: ".active",
      reenter: !1
    },
    "open.relationshipDetails": {
      actions: "openRelationshipDetails",
      target: ".active",
      reenter: !1
    },
    "open.relationshipsBrowser": {
      actions: "openRelationshipsBrowser",
      target: ".active",
      reenter: !1
    }
  },
  states: {
    idle: {},
    active: {
      entry: "listenToEsc",
      exit: "stopListeningToEsc",
      on: {
        close: [
          {
            guard: "close specific overlay?",
            actions: {
              type: "closeSpecificOverlay",
              params: ({ event }) => ({ actorId: event.actorId })
            },
            target: "closing"
          },
          {
            actions: "closeLastOverlay",
            target: "closing"
          }
        ],
        "close.all": {
          actions: [
            "closeAllOverlays",
            "stopListeningToEsc"
          ],
          target: "idle"
        }
      }
    },
    closing: {
      always: [
        {
          guard: "has overlays?",
          target: "active"
        },
        {
          actions: "stopListeningToEsc",
          target: "idle"
        }
      ]
    }
  },
  exit: [
    "stopListeningToEsc",
    "closeAllOverlays"
  ]
}), finalize = (elements, explicits) => elements.size > 2 && explicits.size !== elements.size ? new Set(sortParentsFirst([
  ...treeFromElements$1(elements).flatten(),
  ...explicits
])) : elements.size > 1 ? new Set(sortParentsFirst([...elements])) : elements;
function computeEdgeDetailsViewData(edges, view) {
  const sources = /* @__PURE__ */ new Set(), relationships = /* @__PURE__ */ new Set(), targets = /* @__PURE__ */ new Set(), explicit = {
    sources: /* @__PURE__ */ new Set(),
    targets: /* @__PURE__ */ new Set()
  }, addExplicit = (el, type) => {
    type === "source" ? (sources.add(el), explicit.sources.add(el)) : (targets.add(el), explicit.targets.add(el));
  };
  for (const edgeId of edges) {
    const edge = view.findEdge(edgeId), _relationships = edge ? [...edge.relationships("model")] : [];
    if (!edge || !hasAtLeast(_relationships, 1) || !edge.source.hasElement() || !edge.target.hasElement())
      continue;
    const source = edge.source.element, target = edge.target.element;
    addExplicit(source, "source"), addExplicit(target, "target");
    for (const relationship of _relationships) {
      if (relationships.add(relationship), relationship.source !== source) {
        addExplicit(relationship.source, "source");
        for (const parent of relationship.source.ancestors()) {
          if (parent === source)
            break;
          sources.add(parent);
        }
      }
      if (relationship.target !== target) {
        addExplicit(relationship.target, "target");
        for (const parent of relationship.target.ancestors()) {
          if (parent === target)
            break;
          targets.add(parent);
        }
      }
    }
  }
  return {
    sources: finalize(sources, explicit.sources),
    targets: finalize(targets, explicit.targets),
    relationships
  };
}
function computeRelationshipDetailsViewData({
  // relationships: _relationships,
  source,
  target
}) {
  const sources = /* @__PURE__ */ new Set(), relationships = /* @__PURE__ */ new Set(), targets = /* @__PURE__ */ new Set(), explicit = {
    sources: /* @__PURE__ */ new Set(),
    targets: /* @__PURE__ */ new Set()
  }, addExplicit = (el, type) => {
    type === "source" ? (sources.add(el), explicit.sources.add(el)) : (targets.add(el), explicit.targets.add(el));
  };
  source && addExplicit(source, "source"), target && addExplicit(target, "target");
  const [connection] = modelConnection.findConnection(source, target, "directed");
  if (!connection)
    return {
      sources,
      targets,
      relationships
    };
  for (const relationship of connection.relations) {
    const relationSource = relationship.source, relationTarget = relationship.target;
    if (addExplicit(relationSource, "source"), addExplicit(relationTarget, "target"), relationships.add(relationship), source !== relationSource) {
      invariant$2(isAncestor(source, relationSource), `${source.id} is not an ancestor of ${relationSource.id}`);
      for (const parent of relationSource.ancestors()) {
        if (parent === source)
          break;
        sources.add(parent);
      }
    }
    if (target !== relationTarget) {
      invariant$2(isAncestor(target, relationTarget), `${target.id} is not an ancestor of ${relationTarget.id}`);
      for (const parent of relationTarget.ancestors()) {
        if (parent === target)
          break;
        targets.add(parent);
      }
    }
  }
  return {
    sources: finalize(sources, explicit.sources),
    targets: finalize(targets, explicit.targets),
    relationships
  };
}
const RelationshipEdge = customEdge((props) => {
  const { enableNavigateTo } = useEnabledFeature("NavigateTo"), {
    sourceX,
    targetY,
    data: { navigateTo }
  } = props, [svgPath, labelX, labelY] = getBezierPath(props), diagram = useDiagram();
  return /* @__PURE__ */ jsxs(EdgeContainer, { ...props, children: [
    /* @__PURE__ */ jsx(EdgePath, { edgeProps: props, svgPath }),
    /* @__PURE__ */ jsx(
      EdgeLabelContainer,
      {
        edgeProps: props,
        labelPosition: {
          x: labelX,
          y: labelY,
          translate: "translate(-50%, 0)"
        },
        style: {
          maxWidth: Math.abs(props.targetX - props.sourceX - 100)
        },
        children: /* @__PURE__ */ jsx(EdgeLabel, { edgeProps: props, children: enableNavigateTo && navigateTo && /* @__PURE__ */ jsx(
          EdgeActionButton,
          {
            ...props,
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigateTo(navigateTo);
            }
          }
        ) })
      }
    )
  ] });
}), ElementActions = (props) => {
  const { enableNavigateTo, enableVscode } = useEnabledFeatures(), diagram = useDiagram(), currentViewId = useCurrentViewId(), buttons2 = [], { navigateTo, fqn: fqn2 } = props.data;
  return navigateTo && enableNavigateTo && currentViewId !== navigateTo && buttons2.push({
    key: "navigate",
    icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.navigateTo(navigateTo);
    }
  }), fqn2 && buttons2.push({
    key: "relationships",
    icon: /* @__PURE__ */ jsx(IconTransform, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openRelationshipsBrowser(fqn2);
    }
  }), fqn2 && enableVscode && buttons2.push({
    key: "goToSource",
    icon: /* @__PURE__ */ jsx(IconFileSymlink, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openSource({ element: fqn2 });
    }
  }), /* @__PURE__ */ jsx(
    ElementActionButtons,
    {
      buttons: buttons2,
      ...props
    }
  );
}, ElementDetailsButtonWithHandler = (props) => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(props.data.fqn);
      }
    }
  );
}, ElementNode = customNode((props) => /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
  /* @__PURE__ */ jsx(ElementShape, { ...props }),
  /* @__PURE__ */ jsx(ElementTitle, { ...props }),
  /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler, { ...props }),
  /* @__PURE__ */ jsx(ElementActions, { ...props }),
  /* @__PURE__ */ jsx(ElementPorts, { ...props })
] })), CompoundNode = customNode((props) => /* @__PURE__ */ jsxs(CompoundNodeContainer, { nodeProps: props, children: [
  /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler, { ...props }),
  /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
  /* @__PURE__ */ jsx(CompoundPorts, { ...props })
] })), ElementPorts = ({ data: { ports, height: h } }) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
  ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${15 + (i2 + 1) * ((h - 30) / (ports.in.length + 1))}px`
      }
    },
    id2
  )),
  ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${15 + (i2 + 1) * ((h - 30) / (ports.out.length + 1))}px`
      }
    },
    id2
  ))
] }), CompoundPorts = ({ data }) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
  data.ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${20 * (i2 + 1)}px`
      }
    },
    id2
  )),
  data.ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${20 * (i2 + 1)}px`
      }
    },
    id2
  ))
] }), RelationshipDetailsActorContext = createContext(null);
function useRelationshipDetailsActor() {
  return nonNullable(useContext(RelationshipDetailsActorContext), "No RelationshipDetailsActorContext");
}
function useRelationshipDetailsState(selector3, compare = shallowEqual) {
  const select2 = useCallbackRef(selector3), actor = useRelationshipDetailsActor();
  return xstateReact_cjsExports.useSelector(actor, select2, compare);
}
function useRelationshipDetails() {
  const actor = useRelationshipDetailsActor();
  return useMemo(() => ({
    actor,
    get rootElementId() {
      return `relationship-details-${actor.sessionId.replaceAll(":", "_")}`;
    },
    getState: () => actor.getSnapshot().context,
    send: actor.send,
    navigateTo: (...params) => {
      params.length === 1 ? actor.send({ type: "navigate.to", params: { edgeId: params[0] } }) : actor.send({ type: "navigate.to", params: { source: params[0], target: params[1] } });
    },
    fitDiagram: () => {
      actor.send({ type: "fitDiagram" });
    },
    close: () => {
      actor._parent ? actor._parent?.send({ type: "close", actorId: actor.id }) : actor.send({ type: "close" });
    }
  }), [actor]);
}
const edgeEnpoint = css.raw({
  display: "inline-flex",
  alignItems: "center",
  padding: "6px 2px 0 2px",
  "& .mantine-Text-root": {
    color: "mantine.colors.text/90",
    fontSize: "xs",
    fontWeight: 500,
    lineHeight: "1.2"
  }
}), edgeSource = css({
  paddingLeft: 4,
  gridColumn: 1
}, edgeEnpoint), edgeArrow = css({
  gridColumn: 2
}, edgeEnpoint), edgeTarget = css({
  gridColumn: 3,
  paddingRight: 4
}, edgeEnpoint), edgeLabelclass = "likec4-edge-label", edgeLabel = cx(
  edgeLabelclass,
  css({
    display: "grid",
    gridColumnStart: 1,
    gridColumnEnd: 4,
    borderBottom: "1px solid",
    borderBottomColor: "mantine.colors.defaultBorder",
    marginBottom: "0px",
    padding: "0 4px 5px 4px",
    width: "100%",
    "& .mantine-Text-root": {
      fontSize: "xxs",
      fontWeight: 400,
      lineHeight: "xs",
      color: "mantine.colors.dimmed"
    }
  })
), edgeRow = css({
  display: "contents",
  [`&:last-child .${edgeLabelclass}`]: {
    borderBottom: "none",
    marginBottom: 0
  },
  "& > *": {
    transition: "all 0.15s ease-in"
  },
  "&:is(:hover, [data-selected=true]) > *": {
    transition: "all 0.15s ease-out",
    cursor: "pointer",
    backgroundColor: "mantine.colors.defaultHover"
  }
}), edgeGrid = css({
  display: "grid",
  gridTemplateColumns: "1fr 30px 1fr",
  gridAutoRows: "min-content max-content",
  gap: 0,
  alignItems: "stretch"
});
css({
  display: "grid",
  gridTemplateColumns: "min-content 1fr",
  gridAutoRows: "min-content max-content",
  gap: "10px 12px",
  alignItems: "baseline",
  justifyItems: "start"
});
const scrollArea$1 = css({
  maxHeight: [
    "70vh",
    "calc(100cqh - 70px)"
  ]
}), SelectEdge = ({
  edge,
  view
}) => {
  const browser = useRelationshipDetails(), viewport = useRef(null), edgeSource$1 = view.nodes.find((n2) => n2.id === edge.source), edgeTarget$1 = view.nodes.find((n2) => n2.id === edge.target), edges = view.edges.flatMap((edge2) => {
    const source = view.nodes.find((n2) => n2.id === edge2.source), target = view.nodes.find((n2) => n2.id === edge2.target);
    return source && target ? {
      id: edge2.id,
      source,
      target,
      label: edge2.label
    } : [];
  });
  return !edgeSource$1 || !edgeTarget$1 || edges.length === 0 ? null : /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom-start",
      shadow: "md",
      keepMounted: !0,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          viewport.current?.querySelector(`[data-edge-id="${edge.id}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsxs(
          Button,
          {
            size: "xs",
            variant: "default",
            fw: "500",
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
            children: [
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeSource,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeSource$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: edgeSource$1.title })
                }
              ),
              /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }),
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeTarget,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeTarget$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: edgeTarget$1.title })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { className: scrollArea$1, scrollbars: "y", type: "never", viewportRef: viewport, children: /* @__PURE__ */ jsx(Box$1, { className: edgeGrid, p: "xs", maw: 400, children: edges.map((e2) => /* @__PURE__ */ jsxs(
          "div",
          {
            className: edgeRow,
            "data-selected": e2.id === edge.id,
            onClick: (event) => {
              event.stopPropagation(), browser.navigateTo(e2.id);
            },
            children: [
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeSource,
                  mod: {
                    "edge-id": e2.id,
                    "likec4-color": e2.source.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.source.title })
                }
              ),
              /* @__PURE__ */ jsx(Box$1, { className: edgeArrow, children: /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }) }),
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeTarget,
                  mod: {
                    "likec4-color": e2.target.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.target.title })
                }
              ),
              /* @__PURE__ */ jsx(Box$1, { className: edgeLabel, children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.label || "untitled" }) })
            ]
          },
          e2.id
        )) }) }) })
      ]
    }
  );
}, nodeTypes = {
  element: ElementNode,
  compound: CompoundNode
}, edgeTypes = {
  relationship: RelationshipEdge
};
function RelationshipDetails({ actorRef }) {
  const initialRef = useRef(null);
  return initialRef.current == null && (initialRef.current = {
    defaultNodes: [],
    defaultEdges: []
  }), /* @__PURE__ */ jsx(RelationshipDetailsActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(ReactFlowProvider, { ...initialRef.current, children: /* @__PURE__ */ jsx(LayoutGroup, { id: actorRef.sessionId, inherit: !1, children: /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    /* @__PURE__ */ jsx(RelationshipDetailsInner, {}, "xyflow"),
    /* @__PURE__ */ jsx(SyncRelationshipDetailsXYFlow, {}, "sync")
  ] }) }) }) });
}
const selectSubject = (state) => ({
  ...state.context.subject,
  viewId: state.context.viewId
}), SyncRelationshipDetailsXYFlow = memo$2(() => {
  const actor = useRelationshipDetailsActor(), subject = xstateReact_cjsExports.useSelector(actor, selectSubject, deepEqual), likec4model = useLikeC4Model$1(!0), view = likec4model.findView(subject.viewId) ?? null, data = useMemo(() => {
    let data2;
    if ("edgeId" in subject && n$5(subject.edgeId)) {
      invariant$2(view, `view ${subject.viewId} not found`);
      const edge = nonNullable(view.findEdge(subject.edgeId), `edge ${subject.edgeId} not found in ${subject.viewId}`);
      data2 = computeEdgeDetailsViewData([edge.id], view);
    } else if (subject.source && subject.target)
      data2 = computeRelationshipDetailsViewData({
        source: likec4model.element(subject.source),
        target: likec4model.element(subject.target)
      });
    else
      return null;
    return layoutRelationshipDetails(data2, view);
  }, [
    subject,
    view,
    likec4model
  ]), store = useStoreApi(), instance = useReactFlow();
  return useEffect(() => {
    instance.viewportInitialized && actor.send({ type: "xyflow.init", instance, store });
  }, [store, instance.viewportInitialized, actor]), useEffect(() => {
    data !== null && actor.send({ type: "update.layoutData", data });
  }, [data, actor]), null;
}), selector$3 = ({ context: context2 }) => ({
  // subject: context.subject,
  // view: state.context.view,
  initialized: context2.initialized.xydata && context2.initialized.xyflow,
  nodes: context2.xynodes,
  edges: context2.xyedges
}), RelationshipDetailsInner = memo$2(() => {
  const browser = useRelationshipDetails(), {
    initialized,
    nodes,
    edges
  } = useRelationshipDetailsState(selector$3, deepEqual);
  return /* @__PURE__ */ jsxs(
    BaseXYFlow,
    {
      id: browser.rootElementId,
      nodes,
      edges,
      className: clsx(initialized ? "initialized" : "not-initialized"),
      nodeTypes,
      edgeTypes,
      onNodesChange: useCallbackRef((changes) => {
        browser.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        browser.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      fitViewPadding: 0.05,
      onNodeClick: useCallbackRef((e2, node2) => {
        e2.stopPropagation(), browser.send({ type: "xyflow.nodeClick", node: node2 });
      }),
      onEdgeClick: useCallbackRef((e2, edge) => {
        e2.stopPropagation(), browser.send({ type: "xyflow.edgeClick", edge });
      }),
      onPaneClick: useCallbackRef((e2) => {
        browser.send({ type: "xyflow.paneClick" });
      }),
      onDoubleClick: useCallbackRef((e2) => {
        browser.send({ type: "xyflow.paneDblClick" });
      }),
      onViewportResize: useCallbackRef(() => {
        browser.send({ type: "xyflow.resized" });
      }),
      onEdgeMouseEnter: useCallbackRef((_event, edge) => {
        edge.data.hovered || browser.send({ type: "xyflow.edgeMouseEnter", edge });
      }),
      onEdgeMouseLeave: useCallbackRef((_event, edge) => {
        edge.data.hovered && browser.send({ type: "xyflow.edgeMouseLeave", edge });
      }),
      onSelectionChange: useCallbackRef((params) => {
        browser.send({ type: "xyflow.selectionChange", ...params });
      }),
      nodesDraggable: !1,
      fitView: !1,
      pannable: !0,
      zoomable: !0,
      children: [
        /* @__PURE__ */ jsx(TopLeftPanel, {}),
        /* @__PURE__ */ jsx(Panel, { position: "top-right", children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), browser.close();
            },
            children: /* @__PURE__ */ jsx(IconX, {})
          }
        ) })
      ]
    }
  );
}), topLeftPanelselector = ({ context: context2 }) => ({
  subject: context2.subject,
  viewId: context2.viewId
}), TopLeftPanel = memo$2(() => {
  const { subject, viewId } = useRelationshipDetailsState(topLeftPanelselector, deepEqual), view = useLikeC4Model$1(!0).findView(viewId);
  if (!view || !view.isDiagram())
    return null;
  const edges = [...view.edges()];
  let edge = "edgeId" in subject && n$5(subject.edgeId) ? edges.find((e2) => e2.id === subject.edgeId) : f(edges, (e2) => e2.source.element?.id === subject.source && e2.target.element?.id === subject.target) || f(edges, (e2) => (e2.source.element?.id === subject.source || isAncestor(e2.source.element?.id ?? "--", subject.source ?? "__")) && (e2.target.element?.id === subject.target || isAncestor(e2.target.element?.id ?? "", subject.target ?? "__")));
  return edge ? /* @__PURE__ */ jsx(TopLeftPanelInner, { edge: edge.$edge, view: view.$view }) : null;
}), TopLeftPanelInner = ({ edge, view }) => {
  const browser = useRelationshipDetails(), edgeId = edge.id, [historyEdgeId, historyOps, { history, current }] = useStateHistory(edge.id);
  useEffect(() => {
    historyEdgeId !== edgeId && historyOps.set(edgeId);
  }, [edgeId]), useEffect(() => {
    historyEdgeId !== edgeId && browser.navigateTo(historyEdgeId);
  }, [historyEdgeId]);
  const hasStepBack = current > 0, hasStepForward = current + 1 < history.length;
  return /* @__PURE__ */ jsx(Panel, { position: "top-left", children: /* @__PURE__ */ jsx(Group, { gap: 4, wrap: "nowrap", children: /* @__PURE__ */ jsxs(AnimatePresence, { mode: "popLayout", children: [
    hasStepBack && /* @__PURE__ */ jsx(
      m$2.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.back();
            },
            children: /* @__PURE__ */ jsx(IconChevronLeft, {})
          }
        )
      },
      "back"
    ),
    hasStepForward && /* @__PURE__ */ jsx(
      m$2.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(5px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.forward();
            },
            children: /* @__PURE__ */ jsx(IconChevronRight, {})
          }
        )
      },
      "forward"
    ),
    /* @__PURE__ */ jsx(Group, { gap: "xs", wrap: "nowrap", ml: "sm", children: /* @__PURE__ */ jsx(SelectEdge, { edge, view }) })
  ] }) }) });
};
function Fallback$2({ error, resetErrorBoundary }) {
  const errorString = error instanceof Error ? error.message : "Unknown error";
  return /* @__PURE__ */ jsx(Box$1, { pos: "fixed", top: 0, left: 0, w: "100%", p: 0, style: { zIndex: 1e3 }, children: /* @__PURE__ */ jsxs(
    Notification,
    {
      icon: /* @__PURE__ */ jsx(IconX, { style: { width: 16, height: 16 } }),
      styles: {
        icon: {
          alignSelf: "flex-start"
        }
      },
      color: "red",
      title: "Oops, something went wrong",
      p: "xl",
      withCloseButton: !1,
      children: [
        /* @__PURE__ */ jsx(ScrollAreaAutosize, { maw: "100%", mah: 400, children: /* @__PURE__ */ jsx(Code, { block: !0, children: errorString }) }),
        /* @__PURE__ */ jsx(Group, { gap: "xs", mt: "xl", children: /* @__PURE__ */ jsx(Button, { color: "gray", size: "xs", variant: "light", onClick: () => resetErrorBoundary(), children: "Reset" }) })
      ]
    }
  ) });
}
const selectOverlays = (s2) => s2.context.overlays.map((overlay2) => {
  switch (overlay2.type) {
    case "relationshipsBrowser":
      return s2.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s2.children[overlay2.id]
      } : null;
    case "relationshipDetails":
      return s2.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s2.children[overlay2.id]
      } : null;
    case "elementDetails":
      return s2.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s2.children[overlay2.id]
      } : null;
    default:
      nonexhaustive(overlay2);
  }
}).filter(l$2), compareSelectOverlays = (a2, b2) => a2.length === b2.length && a2.every((overlay2, i2) => overlay2.actorRef === b2[i2].actorRef), Overlays = memo$2(({ overlaysActorRef }) => {
  const xyflowDomNode = useXYStore((s2) => s2.domNode), xyflowRendererDom = useMemo(() => xyflowDomNode?.querySelector(".react-flow__renderer") ?? null, [
    xyflowDomNode
  ]), overlays = xstateReact_cjsExports.useSelector(overlaysActorRef, selectOverlays, compareSelectOverlays), isMotionReduced = useReducedMotionConfig() ?? !1, isActiveOverlay = overlays.length > 0;
  useEffect(() => {
    !xyflowRendererDom || isMotionReduced || animate(xyflowRendererDom, {
      opacity: isActiveOverlay ? 0.7 : 1,
      filter: isActiveOverlay ? "grayscale(1)" : "grayscale(0)",
      transform: isActiveOverlay ? "perspective(400px) translateZ(-12px) translateY(3px)" : "translateY(0)"
    }, {
      duration: isActiveOverlay ? 0.35 : 0.17
    });
  }, [isActiveOverlay, xyflowRendererDom]);
  const close = (actorRef) => {
    overlaysActorRef.send({ type: "close", actorId: actorRef.id });
  }, overlaysReact = overlays.map((overlay2, index2) => {
    switch (overlay2.type) {
      case "relationshipsBrowser":
        return /* @__PURE__ */ jsx(
          Overlay,
          {
            overlayLevel: index2,
            onClose: () => close(overlay2.actorRef),
            children: /* @__PURE__ */ jsx(RelationshipsBrowser, { actorRef: overlay2.actorRef })
          },
          overlay2.actorRef.sessionId
        );
      case "relationshipDetails":
        return /* @__PURE__ */ jsx(
          Overlay,
          {
            overlayLevel: index2,
            onClose: () => close(overlay2.actorRef),
            children: /* @__PURE__ */ jsx(RelationshipDetails, { actorRef: overlay2.actorRef })
          },
          overlay2.actorRef.sessionId
        );
      case "elementDetails":
        return /* @__PURE__ */ jsx(
          ElementDetails,
          {
            actorRef: overlay2.actorRef,
            onClose: () => close(overlay2.actorRef)
          },
          overlay2.actorRef.sessionId
        );
      default:
        nonexhaustive(overlay2);
    }
  });
  return /* @__PURE__ */ jsx(DiagramFeatures.Overlays, { children: /* @__PURE__ */ jsx(reactErrorBoundary_cjsExports.ErrorBoundary, { FallbackComponent: Fallback$2, onReset: () => overlaysActorRef.send({ type: "close.all" }), children: /* @__PURE__ */ jsx(LayoutGroup, { children: /* @__PURE__ */ jsx(AnimatePresence, { children: overlaysReact }) }) }) });
});
Overlays.displayName = "Overlays";
const root$1 = css({
  height: "30px",
  paddingLeft: "sm",
  paddingRight: "4px",
  borderRadius: "sm",
  // TODO
  // color: fallbackVar('var(--search-color)', 'mantine.colors.placeholder)',
  border: "1px solid",
  borderColor: {
    base: "mantine.colors.defaultBorder",
    _light: "mantine.colors.gray[4]",
    _dark: "mantine.colors.dark[4]",
    _hover: "mantine.colors.defaultBorder"
  },
  cursor: "pointer",
  background: {
    base: "mantine.colors.default",
    _light: "mantine.colors.white",
    _dark: "mantine.colors.dark[6]",
    _hover: "mantine.colors.defaultHover"
  },
  width: "100%",
  "& .tabler-icon": {
    color: "mantine.colors.text"
  },
  transition: {
    base: "fast",
    _whenPanning: "none !important"
  },
  boxShadow: {
    base: "xs",
    _hover: "sm",
    _whenPanning: "none !important"
  }
}), placeholder = css({
  fontSize: "sm",
  // mantine.fontSizes.sm,
  fontWeight: 500,
  paddingRight: "10px",
  color: "mantine.colors.placeholder",
  flex: "1",
  sm: {
    paddingRight: "30px"
  },
  md: {
    paddingRight: "50px"
  }
}), shortcut = css({
  fontSize: "11px",
  fontWeight: 600,
  lineHeight: 1,
  padding: "4px 7px",
  borderRadius: "sm",
  border: "1px solid",
  transition: "fast",
  _light: {
    color: "mantine.colors.gray[7]",
    borderColor: "mantine.colors.gray[2]"
  },
  _dark: {
    color: "mantine.colors.dark[0]",
    borderColor: "mantine.colors.dark[7]"
  },
  backgroundColor: {
    _light: "mantine.colors.gray[2]/70",
    _dark: "mantine.colors.dark[8]/70",
    _groupHover: {
      _light: "mantine.colors.gray[2]",
      _dark: "mantine.colors.dark[8]"
    }
  }
});
function SearchControl({ className, ...others }) {
  const isMac2 = isMacOs();
  return /* @__PURE__ */ jsx(UnstyledButton, { ...others, className: clsx("group", root$1, className), children: /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
    /* @__PURE__ */ jsx(IconSearch, { style: { width: "15px", height: "15px" }, stroke: 2 }),
    /* @__PURE__ */ jsx(Text, { component: "div", className: placeholder, children: "Search" }),
    /* @__PURE__ */ jsx(Text, { component: "div", className: shortcut, children: isMac2 ? " + K" : "Ctrl + K" })
  ] }) });
}
const buttonFocused = css.raw({
  outline: "none",
  background: "mantine.colors.primary[8]",
  borderColor: "mantine.colors.primary[9]"
}), _treenodefocus = ".mantine-Tree-node:focus > .mantine-Tree-label &";
function colors(color2, hover2) {
  return {
    color: color2,
    _groupHover: {
      color: hover2
    },
    _groupFocus: {
      color: hover2
    },
    [_treenodefocus]: {
      color: hover2
    }
  };
}
const button = css.raw({
  display: "flex",
  width: "100%",
  background: "mantine.colors.body",
  rounded: "sm",
  padding: "12px 8px 12px 14px",
  minHeight: "60px",
  gap: "8",
  // alignItems: 'flex-start',
  // transition: `all 50ms ${easings.inOut}`,
  border: "1px solid",
  borderColor: "mantine.colors.defaultBorder",
  // [titleColor]: '{colors.mantine.colors.dark[1]}',
  // [iconColor]: '{colors.mantine.colors.dimmed}',
  // [descriptionColor]: '{colors.mantine.colors.dimmed}',
  _hover: {
    ...buttonFocused,
    borderColor: "mantine.colors.primary[9]",
    background: "mantine.colors.primary[8]/60"
  },
  _focus: buttonFocused,
  [_treenodefocus]: buttonFocused,
  _dark: {
    borderColor: "transparent",
    background: "mantine.colors.dark[6]/80"
    // background: 'mantine.colors.dark[6]',
  },
  _light: {
    background: "mantine.colors.white/80",
    // [iconColor]: '{colors.mantine.colors.gray[6]}',
    // [titleColor]: '{colors.mantine.colors.gray[7]}',
    _hover: {
      borderColor: "mantine.colors.primary[6]",
      backgroundColor: "mantine.colors.primary[5]"
      // [iconColor]: '{colors.mantine.colors.primary[3])',
      // [titleColor]: '{colors.mantine.colors.primary[0])',
      // [descriptionColor]: '{colors.mantine.colors.primary[1]}',
    }
  }
}), focusable = "likec4-focusable", iconSize = {
  ref: "var(--likec4-icon-size, 24px)"
}, icon$1 = css.raw({
  ...colors("mantine.colors.dimmed", "mantine.colors.primary[0]"),
  _light: {
    ...colors("mantine.colors.gray[6]", "mantine.colors.primary[3]")
  },
  flex: `0 0 ${iconSize.ref}`,
  height: iconSize.ref,
  width: iconSize.ref,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  alignSelf: "flex-start",
  "--ti-size": iconSize.ref,
  "& svg, & img": {
    width: "100%",
    height: "auto",
    maxHeight: "100%",
    pointerEvents: "none"
  },
  "& img": {
    objectFit: "contain"
  },
  "&.likec4-shape-icon svg": {
    // color: `[var(${iconColor})]`,
    strokeWidth: 1.5
  }
  // [iconSize]: '24px',
  // [whenContainerIsNarrow]: {
  //   [iconSize]: '18px',
  // },
}), title$1 = css.raw({
  fontSize: "16px",
  fontWeight: 500,
  lineHeight: "1.1",
  ":where([data-disabled]) &": {
    opacity: 0.4
  },
  // color: 'mantine.colors.dark[1]',
  // _groupHover: {
  //   color: 'mantine.colors.primary[1]',
  // },
  // _groupFocus: {
  //   color: 'mantine.colors.primary[1]',
  // },
  ...colors("mantine.colors.dark[1]", "mantine.colors.primary[1]"),
  _light: {
    ...colors("mantine.colors.gray[6]", "mantine.colors.primary[3]")
    // color: `mantine.colors.gray[6]`,
    // _groupHover: {
    //   color: 'mantine.colors.primary[3]',
    // },
    // _groupFocus: {
    //   color: 'mantine.colors.primary[3]',
    // },
  }
}), descriptionColor = css.raw({
  color: {
    base: "mantine.colors.dimmed",
    _groupHover: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.primary[0]"
    },
    _groupFocus: "mantine.colors.primary[0]"
  },
  [_treenodefocus]: {
    color: "mantine.colors.primary[0]"
  }
}), description$1 = css.raw(descriptionColor, {
  marginTop: "4px",
  fontSize: "12px",
  lineHeight: "1.4",
  ":where([data-disabled]) &": {
    opacity: 0.85
  }
}), emptyBoX = css({
  width: "100%",
  height: "100%",
  border: "2px dashed",
  borderColor: "mantine.colors.defaultBorder",
  rounded: "md",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  fontSize: "md",
  color: "mantine.colors.dimmed",
  padding: "md",
  paddingBlock: "xl"
}), buttonsva = sva({
  slots: ["root", "icon", "title", "description", "descriptionColor"],
  className: "search-button",
  base: {
    root: button,
    icon: icon$1,
    title: title$1,
    description: description$1,
    descriptionColor
  }
}), whenContainerIsNarrow = "@container likec4-tree (max-width: 450px)", treeNode = css({
  outline: "none",
  marginBottom: "8px"
}), treeRoot = css(
  container$5.raw({
    containerName: "likec4-tree"
  }),
  {
    overflow: "hidden",
    containerType: "inline-size",
    height: "100%"
  }
), treeLabel = css({
  display: "flex",
  alignItems: "baseline",
  outline: "none !important",
  gap: "4px"
}), treeSubtree = css({
  marginTop: "8px"
}), elementExpandIcon = css({
  color: "mantine.colors.dimmed"
}), elementTitleAndId = css({
  [whenContainerIsNarrow]: {
    flexDirection: "column-reverse",
    alignItems: "flex-start",
    gap: 2
  }
}), elementId = css({
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "10px",
  lineHeight: "1.3",
  display: "block",
  fontWeight: 500,
  whiteSpace: "nowrap",
  padding: "1px 5px",
  borderRadius: "4px",
  background: "mantine.colors.dark[9]/30",
  _light: {
    background: "mantine.colors.gray[3]/20"
  }
}), elementIcon = css({
  "--likec4-icon-size": "24px",
  [whenContainerIsNarrow]: {
    "--likec4-icon-size": "18px"
  }
}), elementViewsCount = css({
  flex: 0,
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "10px",
  fontWeight: 500,
  whiteSpace: "nowrap",
  lineHeight: "1.1",
  [whenContainerIsNarrow]: {
    display: "none"
  }
}), $search = atom("");
function setSearch(term) {
  $search.set(term);
}
function useSearch() {
  return useStore($search);
}
const $normalizedSearch = computed($search, (search) => {
  const v = search.trim().toLowerCase();
  return v.length > 1 ? v : "";
});
function useNormalizedSearch() {
  return useDeferredValue(useStore($normalizedSearch));
}
const [LikeC4SearchContext, useCloseSearch] = createSafeContext("LikeC4Search"), $pickView = atom(null);
onMount($search, () => {
  $pickView.set(null);
});
function usePickView() {
  return useStore($pickView);
}
function setPickView(data) {
  $pickView.set(data);
}
function wasResetPickView() {
  return $pickView.get() !== null ? ($pickView.set(null), !0) : !1;
}
const $pickViewActive = computed($pickView, (pickView) => pickView !== null);
function useIsPickViewActive() {
  return useStore($pickViewActive);
}
function useCloseSearchAndNavigateTo() {
  const diagram = useDiagram(), close = useCloseSearch();
  return useCallback((viewId, fromElementFqn) => {
    close(() => {
      fromElementFqn ??= $pickView.get()?.elementFqn, setPickView(null);
      const fromNode = fromElementFqn ? diagram.getContext().view.nodes.find((n2) => DiagramNode.modelRef(n2) === fromElementFqn)?.id : void 0;
      if (diagram.currentView.id !== viewId) {
        diagram.navigateTo(viewId, fromNode);
        return;
      }
      fromNode && diagram.focusNode(fromNode);
    });
  }, [close, diagram]);
}
function stopAndPrevent(e2) {
  e2.stopPropagation(), e2.preventDefault();
}
function centerY(element) {
  const rect = element.getBoundingClientRect();
  return rect.y + Math.floor(rect.height / 2);
}
function moveFocusToSearchInput() {
  const input2 = document.getElementById("likec4searchinput");
  if (input2) {
    const length = input2.value.length;
    input2.focus(), input2.setSelectionRange(length, length);
  }
}
const _viewBtn = "likec4-view-btn", viewButton = cx(
  css({
    flexWrap: "nowrap",
    display: "flex",
    // '& .mantine-ThemeIcon-root': {
    //   color: `[var(${iconColor}, {colors.mantine.colors.dark[2]})]`,
    //   '--ti-size': '24px',
    // },
    "&[data-disabled] .mantine-ThemeIcon-root": {
      opacity: 0.45
    }
  }),
  _viewBtn
);
css({
  marginTop: "4px",
  // transition: transitions.fast,
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "13px",
  lineHeight: "1.4",
  ":where(.likec4-view-btn[data-disabled]) &": {
    opacity: 0.85
  }
});
const NothingFound = () => /* @__PURE__ */ jsx(Box, { className: emptyBoX, children: "Nothing found" });
function ViewsColumn() {
  const search = useNormalizedSearch();
  let views = [...useLikeC4Model$1(!0).views()];
  return search && (search.startsWith("kind:") ? views = [] : views = views.filter((view) => search.startsWith("#") ? view.tags.some((tag) => tag.toLocaleLowerCase().includes(search.slice(1))) : (view.title ?? "" + view.$view.description ?? "").toLocaleLowerCase().includes(search))), /* @__PURE__ */ jsxs(
    Stack,
    {
      renderRoot: (props) => /* @__PURE__ */ jsx(MotionDiv, { layout: !0, ...props }),
      gap: 8,
      "data-likec4-search-views": !0,
      onKeyDown: (e2) => {
        if (e2.key === "ArrowLeft" || e2.key === "ArrowRight") {
          const maxY = e2.target.getBoundingClientRect().y, elementButtons = [...document.querySelectorAll(
            "[data-likec4-search-elements] .likec4-element-button"
          )];
          let elementButton = elementButtons.length > 1 ? elementButtons.find((el, i2, all) => centerY(el) > maxY || i2 === all.length - 1) : null;
          elementButton ??= d(elementButtons), elementButton && (e2.stopPropagation(), elementButton.focus());
          return;
        }
      },
      children: [
        views.length === 0 && /* @__PURE__ */ jsx(NothingFound, {}),
        views.length > 0 && /* @__PURE__ */ jsx(VisuallyHidden, { children: /* @__PURE__ */ jsx(
          UnstyledButton,
          {
            "data-likec4-view": !0,
            tabIndex: -1,
            onFocus: (e2) => {
              e2.stopPropagation(), moveFocusToSearchInput();
            }
          }
        ) }),
        views.map((view, i2) => /* @__PURE__ */ jsx(MotionDiv, { layoutId: `@view${view.id}`, children: /* @__PURE__ */ jsx(
          ViewButton,
          {
            view,
            search,
            tabIndex: i2 === 0 ? 0 : -1
          }
        ) }, view.id))
      ]
    }
  );
}
const btn$2 = buttonsva();
function ViewButton({ className, view, loop = !1, search, ...props }) {
  const navigateTo = useCloseSearchAndNavigateTo(), currentViewId = useCurrentViewId(), isCurrentView = view.id === currentViewId;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...props,
      className: cx(btn$2.root, "group", focusable, viewButton, className),
      "data-likec4-view": view.id,
      ...isCurrentView && { "data-disabled": !0 },
      onClick: (e2) => {
        e2.stopPropagation(), navigateTo(view.id);
      },
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-likec4-view]",
        parentSelector: "[data-likec4-search-views]",
        activateOnFocus: !1,
        loop,
        orientation: "vertical",
        onKeyDown: (e2) => {
          e2.nativeEvent.code === "Space" && (e2.stopPropagation(), navigateTo(view.id));
        }
      }),
      children: [
        /* @__PURE__ */ jsx(ThemeIcon, { variant: "transparent", className: btn$2.icon, children: isDeploymentView(view) ? /* @__PURE__ */ jsx(IconStack2, { stroke: 1.8 }) : /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8 }) }),
        /* @__PURE__ */ jsxs(Box, { style: { flexGrow: 1 }, children: [
          /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", children: [
            /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: search, className: btn$2.title, children: view.title || "untitled" }),
            isCurrentView && /* @__PURE__ */ jsx(Badge, { size: "xs", fz: 9, radius: "sm", children: "current" })
          ] }),
          /* @__PURE__ */ jsx(
            Highlight,
            {
              highlight: view.$view.description ? search : "",
              component: "div",
              className: btn$2.description,
              lineClamp: 1,
              children: view.$view.description || "No description"
            }
          )
        ] })
      ]
    }
  );
}
const btn$1 = buttonsva();
function ElementsColumn() {
  const search = useNormalizedSearch(), model = useLikeC4Model$1(!0), data = useMemo(() => {
    const searchTerms = search.split(".");
    let elements;
    n$3(search) || search === "kind:" ? elements = model.elements() : elements = ifilter(model.elements(), (element) => search.startsWith("kind:") ? element.kind.toLocaleLowerCase().startsWith(search.slice(5)) : search.startsWith("#") ? element.tags.some((tag) => tag.toLocaleLowerCase().includes(search.slice(1))) : (element.title + " " + element.id + " " + (element.description ?? "")).toLocaleLowerCase().includes(search));
    const byid = {}, { all, roots } = C(
      [...elements],
      sortParentsFirst,
      l$4((acc, element) => {
        const treeItem = {
          label: element.title,
          value: element.id,
          element,
          searchTerms,
          children: []
        };
        byid[treeItem.value] = treeItem;
        const parent = acc.all.findLast((root2) => isAncestor(root2.value, treeItem.value));
        return parent ? (parent.children.push(treeItem), parent.children.length > 1 && parent.children.sort(sortByLabel)) : acc.roots.push(treeItem), acc.all.push(treeItem), acc;
      }, {
        all: [],
        roots: []
      })
    );
    return {
      all,
      byid,
      roots: roots.sort(sortByLabel)
    };
  }, [model, search]), handleClick = useHandleElementSelection();
  return data.all.length === 0 ? /* @__PURE__ */ jsx(NothingFound, {}) : /* @__PURE__ */ jsx(ElementsTree, { data, handleClick });
}
const setHoveredNode = () => {
};
function ElementsTree({
  data: {
    all,
    byid,
    roots
  },
  handleClick
}) {
  const tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode, useEffect(() => {
    tree.collapseAllNodes();
    for (const nd of all)
      nd.children.length > 0 && tree.expand(nd.value);
  }, [all]);
  const onKeyDownCapture = useCallbackRef((e2) => {
    const target = e2.target, id2 = target.getAttribute("data-value"), node2 = !!id2 && byid[id2];
    if (node2) {
      if (e2.key === "ArrowUp") {
        id2 === roots[0]?.value && (stopAndPrevent(e2), moveFocusToSearchInput());
        return;
      }
      if (e2.key === "ArrowRight") {
        if (node2.children.length > 0 && tree.expandedState[id2] === !1)
          return;
        const maxY = (e2.target.querySelector(".mantine-Tree-label") ?? target).getBoundingClientRect().y, viewButtons = [...document.querySelectorAll(
          `[data-likec4-search-views] .${focusable}`
        )];
        let view = viewButtons.length > 1 ? viewButtons.find((el, i2, all2) => centerY(el) > maxY || i2 === all2.length - 1) : null;
        view ??= d(viewButtons), view && (stopAndPrevent(e2), view.focus());
        return;
      }
      if (e2.key === " " || e2.key === "Enter") {
        stopAndPrevent(e2), handleClick(node2.element);
        return;
      }
    }
  });
  return /* @__PURE__ */ jsx(
    Tree,
    {
      "data-likec4-search-elements": !0,
      allowRangeSelection: !1,
      clearSelectionOnOutsideClick: !0,
      selectOnClick: !1,
      tree,
      data: roots,
      levelOffset: "lg",
      classNames: {
        root: treeRoot,
        node: cx(focusable, treeNode),
        label: treeLabel,
        subtree: treeSubtree
      },
      onKeyDownCapture,
      renderNode: ElementTreeNode
    }
  );
}
function ElementTreeNode({ node: node2, elementProps, hasChildren, expanded }) {
  const { element, searchTerms } = node2, elementIcon$12 = IconOrShapeRenderer({
    element: {
      id: element.id,
      title: element.title,
      shape: element.shape,
      icon: element.icon
    },
    className: cx(btn$1.icon, elementIcon)
  }), views = [...element.views()], handleClick = useHandleElementSelection(), key2 = `@tree.${node2.value}`;
  return /* @__PURE__ */ jsxs(MotionDiv, { layoutId: key2, ...elementProps, children: [
    /* @__PURE__ */ jsx(
      ActionIcon$1,
      {
        variant: "transparent",
        size: 16,
        tabIndex: -1,
        className: clsx(elementExpandIcon),
        style: {
          visibility: hasChildren ? "visible" : "hidden"
        },
        children: /* @__PURE__ */ jsx(
          IconChevronRight,
          {
            stroke: 3.5,
            style: {
              transition: "transform 150ms ease",
              transform: `rotate(${expanded ? "90deg" : "0"})`,
              width: "100%"
            }
          }
        )
      }
    ),
    /* @__PURE__ */ jsxs(
      UnstyledButton,
      {
        component: MotionButton,
        layout: !0,
        tabIndex: -1,
        className: clsx(btn$1.root, "group", "likec4-element-button"),
        ...views.length > 0 && {
          onClick: (e2) => {
            (!hasChildren || expanded) && (e2.stopPropagation(), handleClick(element));
          }
        },
        children: [
          elementIcon$12,
          /* @__PURE__ */ jsxs(Box$1, { style: { flexGrow: 1 }, children: [
            /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", className: elementTitleAndId, children: [
              /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: searchTerms, className: btn$1.title, children: node2.label }),
              /* @__PURE__ */ jsx(Tooltip$5, { label: element.id, withinPortal: !1, fz: "xs", disabled: !element.id.includes("."), children: /* @__PURE__ */ jsx(
                Highlight,
                {
                  component: "div",
                  highlight: searchTerms,
                  className: cx(elementId, btn$1.descriptionColor),
                  children: nameFromFqn(element.id)
                }
              ) })
            ] }),
            /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: searchTerms, className: btn$1.description, lineClamp: 1, children: element.description || "No description" })
          ] }),
          /* @__PURE__ */ jsx(Text, { component: "div", className: cx(elementViewsCount, btn$1.descriptionColor), fz: "xs", children: views.length === 0 ? "No views" : /* @__PURE__ */ jsxs(Fragment$1, { children: [
            views.length,
            " view",
            views.length > 1 ? "s" : ""
          ] }) })
        ]
      }
    )
  ] });
}
function useHandleElementSelection() {
  const navigateTo = useCloseSearchAndNavigateTo();
  return useCallback((element) => {
    const views = [...element.views()];
    if (views.length === 0)
      return;
    const singleView = t$5(views);
    if (singleView) {
      navigateTo(singleView.id, element.id);
      return;
    }
    const [scoped, others] = d$3(views, (v) => v.viewOf?.id === element.id);
    setPickView({
      elementFqn: element.id,
      scoped,
      others
    });
  }, [setPickView, navigateTo]);
}
const backdrop = css({
  position: "fixed",
  zIndex: 900,
  inset: "0px",
  backgroundColor: "[rgb(34 34 34 / 0.95)]",
  backdropFilter: "auto",
  backdropBlur: "10px",
  _light: {
    backgroundColor: "[rgb(255 255 255 / 0.92 )]"
  }
}), root = css({
  containerName: "likec4-search",
  containerType: "size",
  position: "fixed",
  zIndex: 901,
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  maxHeight: "100vh",
  overflow: "hidden",
  display: "flex",
  flexDirection: "column",
  justifyContent: "stretch",
  gap: "md",
  paddingTop: "32px",
  paddingLeft: "16px",
  paddingRight: "16px",
  paddingBottom: 0
}), input = css({
  border: "transparent",
  background: "transparent",
  _focusWithin: {
    background: "mantine.colors.gray[3]/55",
    _dark: {
      background: "mantine.colors.dark[4]/55"
    }
  }
}), pickviewBackdrop = css({
  position: "absolute",
  inset: 0,
  width: "100%",
  height: "100%",
  backgroundColor: "[rgb(34 34 34 / 0.7)]",
  zIndex: 902,
  backdropFilter: "auto",
  backdropBlur: "10px",
  _light: {
    backgroundColor: "[rgb(255 255 255 / 0.6)]"
  }
}), pickview = css({
  position: "absolute",
  top: "2rem",
  left: "50%",
  width: "100%",
  maxWidth: "600px",
  minWidth: "200px",
  transform: "translateX(-50%)",
  zIndex: 903
}), pickviewGroup = css({
  marginTop: "8px",
  "& + &": {
    marginTop: "32px"
  }
}), scrollArea = css({
  height: [
    "100%",
    "100cqh"
  ],
  "& .mantine-ScrollArea-viewport": {
    minHeight: "100%",
    "& > div": {
      minHeight: "100%",
      height: "100%"
    }
  }
});
function startingWithKind(search) {
  return search.match(/^(k|ki|kin|kind|kind:)$/) != null;
}
const SEARCH_PREFIXES = ["#", "kind:"];
function LikeC4SearchInput() {
  const isPickViewActive = useIsPickViewActive(), likec4model = useLikeC4Model$1(!0), combobox = useCombobox({
    scrollBehavior: "smooth"
  }), { ref, focused } = useFocusWithin(), search = useSearch(), previous = usePreviousDistinct(search), isFirstRender = useIsFirstRender(), [isEmptyForSomeTime] = useDebouncedValue(search === "" && !isFirstRender, t$3(previous) ? 500 : 2e3);
  useWindowEvent(
    "keydown",
    (event) => {
      try {
        !focused && !isPickViewActive && (event.key === "Backspace" || event.key.startsWith("Arrow") || event.key.match(/^\p{L}$/u)) && moveFocusToSearchInput();
      } catch (e2) {
        console.warn(e2);
      }
    }
  );
  let options = [], isExactMatch = !1;
  switch (!0) {
    case (search === "" && (isEmptyForSomeTime || SEARCH_PREFIXES.includes(previous ?? ""))): {
      options = SEARCH_PREFIXES.map((prefix2) => /* @__PURE__ */ jsxs(ComboboxOption, { value: prefix2, children: [
        /* @__PURE__ */ jsx(Text, { component: "span", opacity: 0.5, mr: 4, fz: "sm", children: "Search by" }),
        prefix2
      ] }, prefix2));
      break;
    }
    case search.startsWith("#"): {
      const searchTag = search.toLocaleLowerCase().slice(1), alloptions = likec4model.allTags().filter((tag) => tag.toLocaleLowerCase().includes(searchTag)).sort(
        compareNatural
      );
      isExactMatch = t$5(alloptions)?.toLocaleLowerCase() === searchTag, alloptions.length === 0 ? options = [
        /* @__PURE__ */ jsx(ComboboxEmpty, { children: "No tags found" }, "empty-tags")
      ] : options = alloptions.map((tag) => /* @__PURE__ */ jsxs(ComboboxOption, { value: `#${tag}`, children: [
        /* @__PURE__ */ jsx(Text, { component: "span", opacity: 0.5, mr: 1, fz: "sm", children: "#" }),
        tag
      ] }, tag));
      break;
    }
    case search.startsWith("kind:"):
    case startingWithKind(search): {
      const term = search.length > 5 ? search.slice(5).toLocaleLowerCase() : "";
      let alloptions = t$4(likec4model.$model.specification.elements);
      term && (alloptions = alloptions.filter((kind) => kind.toLocaleLowerCase().includes(term)), isExactMatch = t$5(alloptions)?.toLocaleLowerCase() === term), alloptions.length === 0 ? options = [
        /* @__PURE__ */ jsx(ComboboxEmpty, { children: "No kinds found" }, "empty-kinds")
      ] : options = alloptions.map((kind) => /* @__PURE__ */ jsxs(ComboboxOption, { value: `kind:${kind}`, children: [
        /* @__PURE__ */ jsx(Text, { component: "span", opacity: 0.5, mr: 1, fz: "sm", children: "kind:" }),
        kind
      ] }, kind));
      break;
    }
  }
  return /* @__PURE__ */ jsxs(
    Combobox,
    {
      onOptionSubmit: (optionValue) => {
        setSearch(optionValue), combobox.resetSelectedOption(), SEARCH_PREFIXES.includes(optionValue) || (combobox.closeDropdown(), setTimeout(() => {
          document.querySelector(`[data-likec4-search] .${focusable}`)?.focus();
        }, 50));
      },
      width: "max-content",
      position: "bottom-start",
      shadow: "md",
      offset: {
        mainAxis: 4,
        crossAxis: 50
      },
      store: combobox,
      withinPortal: !1,
      children: [
        /* @__PURE__ */ jsx(ComboboxTarget, { children: /* @__PURE__ */ jsx(
          Input,
          {
            ref,
            id: "likec4searchinput",
            placeholder: "Search by title, description or start with # or kind:",
            tabIndex: 0,
            classNames: {
              input
            },
            size: "xl",
            value: search,
            leftSection: /* @__PURE__ */ jsx(IconSearch, { style: { width: rem(20) }, stroke: 2 }),
            onChange: (event) => {
              setSearch(event.currentTarget.value), combobox.openDropdown(), combobox.updateSelectedOptionIndex();
            },
            onClick: () => combobox.openDropdown(),
            onFocus: () => combobox.openDropdown(),
            onBlur: () => combobox.closeDropdown(),
            onKeyDownCapture: (e2) => {
              if (e2.key === "Tab") {
                switch (!0) {
                  case combobox.getSelectedOptionIndex() >= 0:
                    return combobox.clickSelectedOption(), stopAndPrevent(e2);
                  case options.length === 1:
                    return combobox.selectFirstOption() && combobox.clickSelectedOption(), stopAndPrevent(e2);
                  case startingWithKind(search):
                    return setSearch("kind:"), stopAndPrevent(e2);
                }
                return;
              }
              if (e2.key === "Backspace" && combobox.dropdownOpened) {
                if (search === "kind:")
                  return setSearch(""), combobox.resetSelectedOption(), stopAndPrevent(e2);
                if (search.startsWith("kind:") && isExactMatch)
                  return setSearch("kind:"), combobox.resetSelectedOption(), stopAndPrevent(e2);
                if (search.startsWith("#") && isExactMatch)
                  return setSearch("#"), combobox.resetSelectedOption(), stopAndPrevent(e2);
              }
              if (e2.key === "Escape" && combobox.dropdownOpened && options.length > 0) {
                stopAndPrevent(e2), combobox.closeDropdown();
                return;
              }
              if (e2.key === "ArrowDown" && (!combobox.dropdownOpened || options.length === 0 || isExactMatch || // reached the last option and the search is empty
              search === "" && combobox.getSelectedOptionIndex() === options.length - 1)) {
                combobox.closeDropdown(), stopAndPrevent(e2), document.querySelector(`[data-likec4-search] .${focusable}`)?.focus();
                return;
              }
            }
          }
        ) }),
        /* @__PURE__ */ jsx(ComboboxDropdown, { hidden: options.length === 0, style: { minWidth: 300 }, children: /* @__PURE__ */ jsx(ComboboxOptions, { children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { mah: "min(322px, calc(100cqh - 50px))", type: "scroll", children: options }) }) })
      ]
    }
  );
}
const LikeC4Search = memo$2(() => {
  const [searchOpened, searchOps] = useDisclosure(!1);
  useHotkeys([
    ["mod+k", () => searchOps.toggle(), {
      preventDefault: !0
    }],
    ["mod+f", () => searchOps.toggle(), {
      preventDefault: !0
    }]
  ]);
  const afterCloseCbRef = useRef(null), close = useCallbackRef((cb) => {
    afterCloseCbRef.current = cb ?? null, searchOps.close();
  }), onExitComplete = useCallbackRef(() => {
    afterCloseCbRef.current && (afterCloseCbRef.current(), afterCloseCbRef.current = null);
  }), { portalProps } = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(LikeC4SearchContext, { value: close, children: [
    /* @__PURE__ */ jsx(
      SearchControl,
      {
        onClick: (e2) => {
          e2.stopPropagation(), searchOps.toggle();
        }
      }
    ),
    /* @__PURE__ */ jsx(Portal, { ...portalProps, reuseTargetNode: !0, children: /* @__PURE__ */ jsxs(AnimatePresence, { onExitComplete, children: [
      searchOpened && /* @__PURE__ */ jsx(
        m$2.div,
        {
          className: backdrop,
          initial: { opacity: 0.7 },
          animate: {
            opacity: 1,
            transition: {
              duration: 0.13
            }
          },
          exit: {
            opacity: 0,
            transition: {
              duration: 0.13
            }
          }
        },
        "backdrop"
      ),
      searchOpened && /* @__PURE__ */ jsx(LikeC4SearchOverlay, {}, "overlay")
    ] }) })
  ] });
});
LikeC4Search.displayName = "LikeC4Search";
const LikeC4SearchOverlay = () => {
  const close = useCloseSearch(), pickViewActive = useIsPickViewActive();
  return useWindowEvent(
    "keydown",
    (event) => {
      if (event.key === "Escape") {
        stopAndPrevent(event), wasResetPickView() || close();
        return;
      }
    }
  ), /* @__PURE__ */ jsxs(
    m$2.div,
    {
      className: root,
      "data-likec4-search": "true",
      initial: !1,
      animate: {
        opacity: 1,
        scale: 1,
        translateY: 0
      },
      exit: {
        opacity: 0,
        scale: 0.9,
        translateY: -30,
        transition: {
          duration: 0.13
        }
      },
      children: [
        /* @__PURE__ */ jsxs(Group, { wrap: "nowrap", children: [
          /* @__PURE__ */ jsx(Box, { flex: 1, px: "sm", children: /* @__PURE__ */ jsx(LikeC4SearchInput, {}) }),
          /* @__PURE__ */ jsx(Box, { flex: "0 0 auto", children: /* @__PURE__ */ jsx(
            ActionIcon$1,
            {
              size: "lg",
              variant: "default",
              onClick: (e2) => {
                e2.stopPropagation(), close();
              },
              children: /* @__PURE__ */ jsx(IconX, {})
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxs(Grid, { children: [
          /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(Title, { component: "div", order: 6, c: "dimmed", pl: "sm", children: "Elements" }) }),
          /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(Title, { component: "div", order: 6, c: "dimmed", pl: "sm", children: "Views" }) })
        ] }),
        /* @__PURE__ */ jsxs(
          Grid,
          {
            className: css({
              containerName: "likec4-search-elements",
              containerType: "size",
              overflow: "hidden",
              flexGrow: 1
            }),
            children: [
              /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(
                ScrollArea,
                {
                  type: "hover",
                  className: scrollArea,
                  pr: "xs",
                  scrollbars: "y",
                  children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(LayoutGroup, { id: "likec4-search-elements", children: /* @__PURE__ */ jsx(ElementsColumn, {}) }) })
                }
              ) }),
              /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(
                ScrollArea,
                {
                  type: "hover",
                  className: scrollArea,
                  pr: "xs",
                  scrollbars: "y",
                  children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(LayoutGroup, { id: "likec4-search-views", children: /* @__PURE__ */ jsx(ViewsColumn, {}) }) })
                }
              ) })
            ]
          }
        ),
        pickViewActive && /* @__PURE__ */ jsx(PickView, {})
      ]
    }
  );
};
function PickView() {
  const pickview$1 = usePickView(), focusTrapRef = useFocusTrap(!!pickview$1);
  return useFocusReturn({
    opened: !!pickview$1
  }), /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(LayoutGroup, { id: "likec4-search-pickview", children: pickview$1 && /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      m$2.div,
      {
        className: pickviewBackdrop,
        onClick: (e2) => {
          e2.stopPropagation(), setPickView(null);
        }
      },
      "backdrop"
    ),
    /* @__PURE__ */ jsxs(
      m$2.div,
      {
        initial: {
          opacity: 0,
          scale: 0.95,
          originY: 0,
          translateX: "-50%",
          translateY: -20
        },
        animate: {
          opacity: 1,
          scale: 1,
          translateY: 0
        },
        exit: {
          opacity: 0,
          scale: 0.98,
          translateY: -20,
          transition: {
            duration: 0.1
          }
        },
        className: pickview,
        "data-likec4-search-views": !0,
        ref: focusTrapRef,
        children: [
          /* @__PURE__ */ jsxs(Group, { px: "sm", py: "md", justify: "space-between", children: [
            /* @__PURE__ */ jsx(Title, { order: 2, lh: 1, children: "Select view" }),
            /* @__PURE__ */ jsx(
              ActionIcon$1,
              {
                size: "md",
                variant: "default",
                onClick: (e2) => {
                  e2.stopPropagation(), setPickView(null);
                },
                children: /* @__PURE__ */ jsx(IconX, {})
              }
            )
          ] }),
          /* @__PURE__ */ jsxs(ScrollAreaAutosize, { mah: "calc(100vh - 8rem - 50px)", type: "never", children: [
            pickview$1.scoped.length > 0 && /* @__PURE__ */ jsxs(Stack, { gap: "sm", px: "sm", className: pickviewGroup, children: [
              /* @__PURE__ */ jsx(Title, { order: 6, c: "dimmed", children: "scoped views of the element" }),
              pickview$1.scoped.map((view, i2) => /* @__PURE__ */ jsx(
                ViewButton,
                {
                  view,
                  search: "",
                  loop: !0,
                  mod: {
                    autofocus: i2 === 0
                  }
                },
                view.id
              ))
            ] }),
            pickview$1.others.length > 0 && /* @__PURE__ */ jsxs(Stack, { gap: "sm", px: "sm", className: pickviewGroup, children: [
              /* @__PURE__ */ jsx(Title, { order: 6, c: "dimmed", children: "views including this element" }),
              pickview$1.others.map((view, i2) => /* @__PURE__ */ jsx(
                ViewButton,
                {
                  view,
                  search: "",
                  loop: !0,
                  mod: {
                    autofocus: i2 === 0 && pickview$1.scoped.length === 0
                  }
                },
                view.id
              ))
            ] })
          ] })
        ]
      },
      "pickview"
    )
  ] }) }) });
}
const Tooltip = Tooltip$5.withProps({
  color: "dark",
  fz: "xs",
  position: "right",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
}), ActionIcon = ActionIcon$1.withProps({
  classNames: {
    root: "action-icon"
  },
  variant: "default",
  color: "gray"
}), navigationButtons = css({
  gap: "micro",
  _empty: {
    display: "none"
  }
}), panel = css({
  top: "1rem",
  left: "1rem",
  margin: 0,
  pointerEvents: "none",
  "& :where(button, .action-icon, [role='dialog'])": {
    pointerEvents: "all"
  },
  "& .action-icon": {
    "--ai-size": "2rem"
  },
  "& .tabler-icon": {
    width: "65%",
    height: "65%"
  },
  _reduceGraphics: {
    "& .action-icon": {
      "--ai-radius": "0px"
    }
  }
}), actionIconGroup = css({
  shadow: {
    base: "md",
    _whenPanning: "none"
  }
});
css({
  "& .tabler-icon": {
    width: "65%",
    height: "65%"
  }
});
const autolayoutButton = css({
  flex: "1 1 40%",
  textAlign: "center",
  fontWeight: 500,
  padding: "4px 6px",
  fontSize: "11px",
  zIndex: 1
}), autolayoutIndicator = css({
  background: "mantine.colors.gray[2]",
  borderRadius: "sm",
  border: "1px solid",
  borderColor: "mantine.colors.gray[4]",
  _dark: {
    background: "mantine.colors.dark[5]",
    borderColor: "mantine.colors.dark[4]"
  }
}), spacingSliderBody = css({
  position: "relative",
  borderRadius: "sm",
  background: "mantine.colors.gray[3]",
  boxShadow: "inset 1px 1px 3px 0px #00000024",
  _dark: {
    background: "mantine.colors.dark[7]"
  }
}), spacingSliderThumb = css({
  position: "absolute",
  width: 8,
  height: 8,
  border: "2px solid",
  borderColor: "mantine.colors.gray[5]",
  borderRadius: 3,
  transform: "translate(-50%, -50%)"
}), selector$2 = (state) => ({
  viewId: state.view.id,
  autoLayout: state.view.autoLayout
}), ChangeAutoLayoutButton = (props) => {
  const {
    onChange
  } = useDiagramEventHandlers(), diagram = useDiagram(), [rootRef, setRootRef] = useState(null), [controlsRefs, setControlsRefs] = useState({}), {
    autoLayout,
    viewId
  } = useDiagramContext(selector$2), { ref, hovered: isSpacingHovered } = useHover$1(), setControlRef = (name) => (node2) => {
    controlsRefs[name] = node2, setControlsRefs(controlsRefs);
  }, setAutoLayout = (direction) => (event) => {
    event.stopPropagation(), onChange?.({
      change: {
        op: "change-autolayout",
        layout: {
          ...autoLayout,
          direction
        }
      }
    });
  }, setSpacing = (nodeSep, rankSep) => {
    diagram.fitDiagram(), onChange?.({
      change: {
        op: "change-autolayout",
        layout: {
          ...autoLayout,
          nodeSep,
          rankSep
        }
      }
    });
  };
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      ...props,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip, { label: "Change Auto Layout", children: /* @__PURE__ */ jsx(ActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutDashboard, {}) }) }) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { className: "likec4-top-left-panel", p: 8, pt: 6, opacity: isSpacingHovered ? 0.6 : 1, children: /* @__PURE__ */ jsxs(Box$1, { pos: "relative", ref: setRootRef, children: [
          /* @__PURE__ */ jsx(
            FloatingIndicator,
            {
              target: controlsRefs[autoLayout.direction],
              parent: rootRef,
              className: autolayoutIndicator
            }
          ),
          /* @__PURE__ */ jsx(Box$1, { mb: 10, children: /* @__PURE__ */ jsx(Text, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Auto layout:" }) }),
          /* @__PURE__ */ jsxs(Flex, { gap: 2, wrap: "wrap", justify: "stretch", maw: 160, children: [
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("TB"), onClick: setAutoLayout("TB"), children: "Top-Bottom" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("BT"), onClick: setAutoLayout("BT"), children: "Bottom-Top" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("LR"), onClick: setAutoLayout("LR"), children: "Left-Right" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("RL"), onClick: setAutoLayout("RL"), children: "Right-Left" })
          ] }),
          /* @__PURE__ */ jsx(Box$1, { my: 10, children: /* @__PURE__ */ jsx(Text, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Spacing:" }) }),
          /* @__PURE__ */ jsx(
            SpacingSliders,
            {
              ref,
              isVertical: autoLayout.direction === "TB" || autoLayout.direction === "BT",
              nodeSep: autoLayout.nodeSep,
              rankSep: autoLayout.rankSep,
              onChange: setSpacing
            },
            viewId
          )
        ] }) })
      ]
    }
  );
}, MAX_SPACING = 400, SpacingSliders = forwardRef(({
  isVertical,
  nodeSep,
  rankSep,
  onChange
}, _ref) => {
  isVertical || ([nodeSep, rankSep] = [rankSep, nodeSep]);
  const propagateChange = useDebouncedCallback(
    ({ x: x2, y: y2 }) => {
      isVertical || ([x2, y2] = [y2, x2]), onChange(Math.round(x2 * MAX_SPACING), Math.round(y2 * MAX_SPACING));
    },
    [onChange, isVertical],
    250,
    2e3
  ), [value, setValue] = useUncontrolled({
    defaultValue: clampUseMovePosition({
      x: (nodeSep ?? 100) / MAX_SPACING,
      y: (rankSep ?? 120) / MAX_SPACING
    }),
    onChange: propagateChange
  }), { ref } = useMove(setValue);
  let nodeSepValue = Math.round(value.x * MAX_SPACING), rankSepValue = Math.round(value.y * MAX_SPACING);
  isVertical || ([nodeSepValue, rankSepValue] = [rankSepValue, nodeSepValue]);
  const mergedRef = useMergedRef(ref, _ref);
  return /* @__PURE__ */ jsxs(Box$1, { ref: mergedRef, className: spacingSliderBody, pt: "100%", children: [
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: spacingSliderThumb,
        style: {
          left: `${value.x * 100}%`,
          top: `${value.y * 100}%`
        }
      }
    ),
    /* @__PURE__ */ jsx(Box$1, { pos: "absolute", left: 2, bottom: 2, children: /* @__PURE__ */ jsxs(Text, { component: "div", fz: 8, c: "dimmed", fw: 500, children: [
      rankSepValue,
      ", ",
      nodeSepValue
    ] }) })
  ] });
}), LayoutDriftNotification = (props) => /* @__PURE__ */ jsxs(
  HoverCard,
  {
    position: "right-start",
    openDelay: 200,
    closeDelay: 100,
    ...props,
    children: [
      /* @__PURE__ */ jsx(HoverCardTarget, { children: /* @__PURE__ */ jsx(
        ActionIcon,
        {
          color: "orange",
          c: "orange",
          className: css({
            bg: "mantine.colors.orange.light"
          }),
          children: /* @__PURE__ */ jsx(IconAlertTriangle, {})
        }
      ) }),
      /* @__PURE__ */ jsx(HoverCardDropdown, { p: "0", children: /* @__PURE__ */ jsxs(
        Notification,
        {
          color: "orange",
          withBorder: !1,
          withCloseButton: !1,
          title: "Manual layout issues",
          children: [
            /* @__PURE__ */ jsxs(Text, { mt: 2, size: "sm", lh: "xs", children: [
              "View contains new elements or their sizes have changed,",
              /* @__PURE__ */ jsx("br", {}),
              "last manual layout can not be applied."
            ] }),
            /* @__PURE__ */ jsxs(Text, { mt: "xs", size: "sm", lh: "xs", children: [
              "Update view predicates or remove ",
              /* @__PURE__ */ jsx(Code, { children: "@likec4-generated" })
            ] })
          ]
        }
      ) })
    ]
  }
), Action = ({
  label: label2,
  icon: icon2,
  onClick
}) => /* @__PURE__ */ jsx(Tooltip, { label: label2, withinPortal: !1, position: "top", children: /* @__PURE__ */ jsx(ActionIcon, { onClick, children: icon2 }) }), ManualLayoutToolsButton = (props) => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      ...props,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip, { label: "Manual layouting tools", withinPortal: !1, position: "top-end", children: /* @__PURE__ */ jsx(ActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutCollage, {}) }) }) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, children: /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
          /* @__PURE__ */ jsxs(ActionIconGroup, { pos: "relative", children: [
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align in columns",
                icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.align("Column");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align left",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignLeft, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.align("Left");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align center",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignCenter, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.align("Center");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align right",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignRight, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.align("Right");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align in rows",
                icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, { style: { transform: "rotate(90deg)" } }),
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.align("Row");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align top",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignTop, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.align("Top");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align middle",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignMiddle, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.align("Middle");
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Action,
              {
                label: "Align bottom",
                icon: /* @__PURE__ */ jsx(IconLayoutAlignBottom, {}),
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.align("Bottom");
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsx(
            Action,
            {
              label: "Reset all control points",
              icon: /* @__PURE__ */ jsx(IconRouteOff, {}),
              onClick: (e2) => {
                e2.stopPropagation(), diagram.resetEdgeControlPoints();
              }
            }
          )
        ] }) })
      ]
    }
  );
}, NavigationButtons = () => {
  const diagram = useDiagram(), {
    hasStepBack,
    hasStepForward
  } = useDiagramContext((s2) => ({
    hasStepBack: s2.navigationHistory.currentIndex > 0,
    hasStepForward: s2.navigationHistory.currentIndex < s2.navigationHistory.history.length - 1
  }));
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    hasStepBack && /* @__PURE__ */ jsx(
      ActionIcon,
      {
        component: m$2.button,
        onClick: (e2) => {
          e2.stopPropagation(), diagram.navigate("back");
        },
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-10px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ jsx(IconChevronLeft, {})
      },
      "back"
    ),
    hasStepForward && /* @__PURE__ */ jsx(
      ActionIcon,
      {
        component: m$2.button,
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(10px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(10px)"
        },
        onClick: (e2) => {
          e2.stopPropagation(), diagram.navigate("forward");
        },
        children: /* @__PURE__ */ jsx(IconChevronRight, {})
      },
      "forward"
    )
  ] });
}, selector$1 = (state) => ({
  visible: state.features.enableReadOnly !== !0,
  isReadOnly: state.toggledFeatures.enableReadOnly ?? state.features.enableReadOnly
}), ToggleReadonly = () => {
  const { visible: visible2, isReadOnly } = useDiagramContext(selector$1), diagram = useDiagram();
  return visible2 ? /* @__PURE__ */ jsx(Tooltip, { label: isReadOnly ? "Enable editing" : "Disable editing", children: /* @__PURE__ */ jsx(
    ActionIcon,
    {
      onClick: (e2) => {
        e2.stopPropagation(), diagram.toggleFeature("ReadOnly");
      },
      children: isReadOnly ? /* @__PURE__ */ jsx(IconLock, {}) : /* @__PURE__ */ jsx(IconLockOpen2, {})
    }
  ) }) : null;
}, ControlsDefaultLayout = ({
  burgerMenu,
  navigationButtons: navigationButtons$1,
  search,
  actionsGroup
}) => /* @__PURE__ */ jsxs(
  Group,
  {
    component: m$2.div,
    initial: {
      opacity: 0.05,
      translateX: -30,
      translateY: -16
    },
    animate: {
      opacity: 1,
      translateX: 0,
      translateY: 0
    },
    exit: {
      opacity: 0.05,
      translateX: -30,
      translateY: -10
    },
    align: "flex-start",
    className: cx(
      "react-flow__panel",
      panel,
      "likec4-top-left-panel"
    ),
    gap: "xs",
    onClick: stopPropagation$1,
    children: [
      /* @__PURE__ */ jsxs(Stack, { align: "flex-start", gap: "xs", children: [
        /* @__PURE__ */ jsx(LayoutGroup, { children: /* @__PURE__ */ jsxs(
          Group,
          {
            className: cx(navigationButtons, "likec4-navigation-webview"),
            gap: "xs",
            children: [
              burgerMenu,
              navigationButtons$1
            ]
          }
        ) }),
        actionsGroup
      ] }),
      /* @__PURE__ */ jsx(Box$1, { children: search })
    ]
  }
), Controls = memo$2(() => {
  const { viewId, hasLayoutDrift, viewportChanged, isNotActiveWalkthrough } = useDiagramContext((c2) => ({
    viewId: c2.view.id,
    hasLayoutDrift: c2.view.hasLayoutDrift ?? !1,
    viewportChanged: c2.viewportChangedManually,
    isNotActiveWalkthrough: c2.activeWalkthrough === null
  })), diagram = useDiagram(), {
    onOpenSource,
    onBurgerMenuClick
  } = useDiagramEventHandlers(), {
    enableControls,
    enableSearch,
    enableNavigationButtons,
    enableReadOnly,
    enableVscode
  } = useEnabledFeatures(), notReadOnly = !enableReadOnly, portalProps = useMantinePortalProps(), ControlsLayout = useControlsCustomLayout() ?? ControlsDefaultLayout;
  return /* @__PURE__ */ jsx(Fragment$1, { children: isNotActiveWalkthrough && /* @__PURE__ */ jsx(
    ControlsLayout,
    {
      burgerMenu: onBurgerMenuClick && /* @__PURE__ */ jsx(
        ActionIcon,
        {
          onClick: (e2) => {
            e2.stopPropagation(), onBurgerMenuClick();
          },
          children: /* @__PURE__ */ jsx(IconMenu2, {})
        }
      ),
      navigationButtons: enableNavigationButtons && /* @__PURE__ */ jsx(NavigationButtons, {}),
      search: enableSearch && /* @__PURE__ */ jsx(LikeC4Search, {}),
      syncInProgressBadge: /* @__PURE__ */ jsx(SyncLayoutBadge, {}),
      actionsGroup: /* @__PURE__ */ jsxs(ActionIconGroup, { className: actionIconGroup, orientation: "vertical", children: [
        enableVscode && /* @__PURE__ */ jsx(Tooltip, { label: "Open source", ...portalProps, children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            onClick: (e2) => {
              e2.stopPropagation(), onOpenSource?.({ view: viewId });
            },
            children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.5 })
          }
        ) }),
        enableControls && /* @__PURE__ */ jsx(ToggleReadonly, {}),
        enableControls && hasLayoutDrift && /* @__PURE__ */ jsx(LayoutDriftNotification, { ...portalProps }),
        enableControls && notReadOnly && /* @__PURE__ */ jsxs(Fragment$1, { children: [
          /* @__PURE__ */ jsx(ChangeAutoLayoutButton, { ...portalProps }),
          /* @__PURE__ */ jsx(ManualLayoutToolsButton, { ...portalProps })
        ] }),
        enableControls && /* @__PURE__ */ jsx(Tooltip, { label: viewportChanged ? "Center camera" : "Camera is centered", ...portalProps, children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            onClick: (e2) => {
              e2.stopPropagation(), diagram.fitDiagram();
            },
            children: /* @__PURE__ */ jsx(IconFocusCentered, {})
          }
        ) })
      ] })
    }
  ) });
}), SyncLayoutBadge = () => useDiagramSyncLayoutState((s2) => s2.hasTag("pending")) ? /* @__PURE__ */ jsx(Badge, { color: "pink", radius: "xs", size: "xs", variant: "light", leftSection: /* @__PURE__ */ jsx(Loader, { color: "orange", size: 8 }), children: "Pending..." }) : null, card$1 = css({
  cursor: "default",
  minWidth: 200,
  maxWidth: "calc(100vw - 16px)",
  width: "auto",
  // backgroundColor: 'mantine.colors.body',
  borderRadius: "sm",
  sm: {
    minWidth: 250,
    maxWidth: "90vw"
  },
  md: {
    minWidth: 350,
    maxWidth: "70vw"
  },
  shadow: {
    base: "xs",
    _whenPanning: "none"
  },
  backgroundColor: {
    base: "mantine.colors.body/80",
    _dark: "mantine.colors.dark[6]/80",
    _whenPanning: "mantine.colors.body"
  }
  // _dark: {
  //   backgroundColor: 'mantine.colors.dark[6]',
  // },
  // _noReduceGraphics: {
  //   borderRadius: 'sm',
  //   backgroundColor: `mantine.colors.body/80`,
  //   // WebkitBackdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  //   // backdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  //   _dark: {
  //     backgroundColor: `mantine.colors.dark[6]/80`,
  //   },
  // },
}), title = css({}), description = css({
  whiteSpaceCollapse: "preserve-breaks",
  color: "mantine.colors.gray[7]",
  _dark: {
    color: "mantine.colors.gray[5]"
  }
});
function DiagramTitlePanel() {
  const { id: id2, title: title$12, description: description$12, links, isNotActiveWalkthrough } = useDiagramContext((s2) => ({
    id: s2.view.id,
    title: s2.view.title ?? "untitled",
    description: s2.view.description,
    links: s2.view.links,
    isNotActiveWalkthrough: s2.activeWalkthrough === null
  })), [isCollapsed, setCollapsed] = useLocalStorage({
    key: "diagram-title-webview-collapsed",
    defaultValue: !1
  }), toggle = () => setCollapsed((v) => !v);
  return /* @__PURE__ */ jsx(AnimatePresence, { mode: "wait", children: isNotActiveWalkthrough && /* @__PURE__ */ jsx(
    m$2.div,
    {
      initial: { opacity: 0.05, scale: 0.7 },
      animate: { opacity: 1, scale: 1 },
      exit: {
        opacity: 0.05,
        scale: 0.6
      },
      className: clsx("react-flow__panel", "left", "bottom"),
      style: {
        transformOrigin: "left center"
      },
      children: /* @__PURE__ */ jsxs(
        Card,
        {
          className: card$1,
          withBorder: !isCollapsed,
          p: isCollapsed ? "sm" : "md",
          onDoubleClick: (e2) => e2.stopPropagation(),
          children: [
            isCollapsed && /* @__PURE__ */ jsx(CardSection, { children: /* @__PURE__ */ jsx(
              Button,
              {
                fullWidth: !0,
                justify: "stretch",
                size: "md",
                radius: "0",
                variant: "subtle",
                color: "gray",
                onClick: toggle,
                fw: 500,
                fz: "sm",
                tabIndex: -1,
                children: title$12
              }
            ) }),
            !isCollapsed && /* @__PURE__ */ jsxs(Fragment$1, { children: [
              /* @__PURE__ */ jsx(CardSection, { mb: "xs", children: /* @__PURE__ */ jsx(
                Button,
                {
                  fullWidth: !0,
                  size: "xs",
                  h: "sm",
                  py: 2,
                  radius: "0",
                  variant: "subtle",
                  color: "gray",
                  onClick: toggle,
                  tabIndex: -1,
                  children: /* @__PURE__ */ jsx(IconMenu, { size: 11, opacity: 0.7 })
                }
              ) }),
              /* @__PURE__ */ jsxs(Group, { justify: "stretch", wrap: "nowrap", mb: "sm", children: [
                /* @__PURE__ */ jsx(
                  Text,
                  {
                    component: "div",
                    flex: "1",
                    size: "md",
                    fw: 500,
                    lh: 1.1,
                    className: title,
                    children: title$12
                  }
                ),
                /* @__PURE__ */ jsxs(
                  Text,
                  {
                    hidden: isCollapsed,
                    component: "div",
                    flex: "0 0 auto",
                    inline: !0,
                    size: "xs",
                    fz: 9,
                    fw: 500,
                    c: "dimmed",
                    style: {
                      userSelect: "all"
                    },
                    children: [
                      /* @__PURE__ */ jsxs("span", { style: { userSelect: "none" }, children: [
                        "id:",
                        " "
                      ] }),
                      id2
                    ]
                  }
                )
              ] }),
              description$12 && /* @__PURE__ */ jsx(
                Spoiler,
                {
                  maxHeight: 42,
                  showLabel: /* @__PURE__ */ jsx(Button, { component: "div", color: "gray", variant: "light", fz: "10", size: "compact-xs", tabIndex: -1, children: "show more" }),
                  hideLabel: /* @__PURE__ */ jsx(Button, { component: "div", color: "gray", variant: "light", fz: "10", size: "compact-xs", tabIndex: -1, children: "hide" }),
                  children: /* @__PURE__ */ jsx(
                    Text,
                    {
                      component: "div",
                      size: "sm",
                      className: description,
                      children: description$12 || "no description"
                    }
                  )
                }
              ),
              !description$12 && /* @__PURE__ */ jsx(
                Text,
                {
                  component: "div",
                  size: "xs",
                  c: "dimmed",
                  children: "no description"
                }
              ),
              links && /* @__PURE__ */ jsx(
                Stack,
                {
                  mt: "xs",
                  gap: 4,
                  justify: "stretch",
                  align: "stretch",
                  children: links.map((link2) => /* @__PURE__ */ jsx(Link, { value: link2 }, link2.url))
                }
              )
            ] })
          ]
        }
      )
    }
  ) });
}
const container$1 = css({
  bottom: 0,
  right: 0,
  padding: 8,
  margin: 0
}), icon = css({
  "--ai-radius": "0px",
  _noReduceGraphics: {
    "--ai-radius": "{radii.md}"
  }
}), card = css({
  cursor: "default",
  userSelect: "none",
  minWidth: 200,
  maxWidth: "calc(100vw - 20px)",
  backgroundColor: "mantine.colors.body/80",
  // WebkitBackdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // backdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  sm: {
    minWidth: 300,
    maxWidth: "65vw"
  },
  md: {
    maxWidth: "40vw"
  },
  _dark: {
    backgroundColor: "mantine.colors.dark[6]/80"
  }
}), tabPanel = css({
  padding: "2xs"
}), elementNotation = css({
  backgroundColor: "transparent",
  transition: "all 100ms ease-in",
  // WebkitBackdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // backdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // vars: {
  //   // [stokeFillMix]: `color-mix(in srgb, ${vars.element.stroke} 90%, ${vars.element.fill})`
  // },
  _hover: {
    transition: "all 120ms ease-out",
    // backgroundColor:
    backgroundColor: "mantine.colors.primary[2]/50"
  },
  _dark: {
    _hover: {
      backgroundColor: "mantine.colors.dark[3]/40"
    }
  }
});
css({
  fill: "likec4.palette.fill",
  stroke: "likec4.palette.stroke",
  strokeWidth: 1,
  overflow: "visible",
  width: "100%",
  height: "auto",
  filter: `
    drop-shadow(0 2px 3px rgb(0 0 0 / 22%))
    drop-shadow(0 1px 8px rgb(0 0 0 / 10%))
  `
});
const shapeBadge = css({
  fontWeight: 500,
  letterSpacing: "0.2px",
  paddingTop: 0,
  paddingBottom: 0,
  textTransform: "lowercase",
  transition: "all 150ms ease-in-out",
  cursor: "pointer",
  "--badge-radius": "2px",
  "--badge-fz": "9.5px",
  "--badge-padding-x": "3px",
  "--badge-height": "13.5px",
  "--badge-lh": "1",
  "--badge-bg": "{colors.likec4.palette.fill}",
  "--badge-color": "{colors.likec4.palette.hiContrast}"
}), ElementNotation = ({ value }) => {
  const {
    title: title2,
    color: color2 = "primary",
    shape = "rectangle"
  } = value, [onlyKind, setOnlyKind] = useState(null), diagram = useDiagram(), w = 300, h = 200;
  return /* @__PURE__ */ jsx(
    Card,
    {
      shadow: "none",
      px: "xs",
      py: "sm",
      className: cx(
        elementNotation,
        css({
          likec4Palette: color2
        })
      ),
      "data-likec4-color": color2,
      onMouseEnter: () => {
        setOnlyKind(null), diagram.highlightNotation(value);
      },
      onMouseLeave: () => {
        setOnlyKind(null), diagram.unhighlightNotation();
      },
      children: /* @__PURE__ */ jsxs(
        Group,
        {
          gap: "sm",
          align: "stretch",
          wrap: "nowrap",
          children: [
            /* @__PURE__ */ jsx(
              Box$1,
              {
                flex: "0 0 70px",
                style: {
                  position: "relative",
                  width: 70,
                  height: u$1(70 * (h / w), 0)
                },
                children: /* @__PURE__ */ jsx(
                  ElementShape,
                  {
                    data: {
                      shape,
                      width: w,
                      height: h
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxs(Stack, { gap: 4, flex: 1, children: [
              /* @__PURE__ */ jsx(Group, { gap: 4, flex: "0 0 auto", children: value.kinds.map((kind) => /* @__PURE__ */ jsx(
                Badge,
                {
                  className: cx(
                    shapeBadge
                  ),
                  onMouseEnter: () => {
                    setOnlyKind(kind), diagram.highlightNotation(value, kind);
                  },
                  onMouseLeave: () => {
                    setOnlyKind(null), diagram.highlightNotation(value);
                  },
                  opacity: l$2(onlyKind) && onlyKind !== kind ? 0.25 : 1,
                  children: kind
                },
                kind
              )) }),
              /* @__PURE__ */ jsx(
                Text,
                {
                  component: "div",
                  fz: "sm",
                  fw: 500,
                  lh: "1.25",
                  style: {
                    textWrap: "pretty"
                  },
                  children: title2
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, selector = (s2) => ({
  id: s2.view.id,
  notations: s2.view.notation?.elements ?? [],
  isVisible: !0
  // isVisible: isNullish(s.focusedNodeId ?? s.activeWalkthrough),
}), NotationPanel = memo$2(() => {
  const height = useXYStore((s2) => s2.height), {
    id: id2,
    notations,
    isVisible
  } = useDiagramContext(selector), [isCollapsed, setCollapsed] = useLocalStorage({
    key: "notation-webview-collapsed",
    defaultValue: !0
  }), hasNotations = notations.length > 0, portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    !hasNotations && isVisible && /* @__PURE__ */ jsx(
      m$2.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: clsx("react-flow__panel", container$1),
        children: /* @__PURE__ */ jsx(Tooltip$5, { label: "View has no notations", color: "orange", ...portalProps, children: /* @__PURE__ */ jsx(
          ThemeIcon,
          {
            size: "lg",
            variant: "light",
            color: "orange",
            radius: "md",
            children: /* @__PURE__ */ jsx(IconAlertTriangle, {})
          }
        ) })
      },
      "empty"
    ),
    hasNotations && isVisible && isCollapsed && /* @__PURE__ */ jsx(
      m$2.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: clsx("react-flow__panel", container$1),
        children: /* @__PURE__ */ jsx(Tooltip$5, { label: "Show notation", color: "dark", fz: "xs", ...portalProps, children: /* @__PURE__ */ jsx(
          ActionIcon$1,
          {
            size: "lg",
            variant: "default",
            color: "gray",
            className: icon,
            onClick: () => setCollapsed(!1),
            children: /* @__PURE__ */ jsx(IconHelpCircle, { stroke: 1.5 })
          }
        ) })
      },
      "collapsed"
    ),
    hasNotations && isVisible && !isCollapsed && /* @__PURE__ */ jsx(
      m$2.div,
      {
        initial: {
          opacity: 0.75,
          // translateX: '50%',
          scale: 0.2
        },
        animate: { opacity: 1, scale: 1 },
        exit: {
          opacity: 0,
          scale: 0.25
        },
        className: clsx("react-flow__panel", container$1),
        style: {
          transformOrigin: "bottom right"
        },
        children: /* @__PURE__ */ jsx(
          Paper,
          {
            radius: "sm",
            withBorder: !0,
            shadow: "lg",
            className: card,
            children: /* @__PURE__ */ jsxs(Tabs, { defaultValue: "first", radius: "xs", children: [
              /* @__PURE__ */ jsxs(TabsList, { children: [
                /* @__PURE__ */ jsx(
                  ActionIcon$1,
                  {
                    size: "md",
                    variant: "subtle",
                    color: "gray",
                    ml: 2,
                    style: {
                      alignSelf: "center"
                    },
                    onClick: () => setCollapsed(!0),
                    children: /* @__PURE__ */ jsx(IconArrowDownRight, { stroke: 2 })
                  }
                ),
                /* @__PURE__ */ jsx(TabsTab, { value: "first", fz: "xs", children: "Elements" }),
                /* @__PURE__ */ jsx(TabsTab, { value: "second", fz: "xs", disabled: !0, children: "Relationships" })
              ] }),
              /* @__PURE__ */ jsx(TabsPanel, { value: "first", className: tabPanel, hidden: isCollapsed, children: /* @__PURE__ */ jsx(
                ScrollAreaAutosize,
                {
                  viewportProps: {
                    style: {
                      maxHeight: `min(40vh, ${Math.max(height - 60, 50)}px)`
                    }
                  },
                  children: /* @__PURE__ */ jsx(Stack, { gap: 0, children: notations.map((n2, i2) => /* @__PURE__ */ jsx(ElementNotation, { value: n2 }, i2)) })
                }
              ) })
            ] })
          }
        )
      },
      id2
    )
  ] });
}), container = css({
  position: "absolute",
  bottom: "0.5rem",
  left: "50%",
  transform: "translateX(-50%)",
  padding: 0,
  margin: 0,
  display: "flex",
  flexDirection: "column",
  gap: "0.4rem",
  alignItems: "center",
  md: {
    gap: "0.6rem"
  }
}), tablerIcons = {
  "& .tabler-icon": {
    width: "0.85em",
    height: "0.85em"
  }
}, buttons = css({
  backdropFilter: "blur(8px)",
  transition: "all 175ms ease-in",
  _hover: {
    transitionTimingFunction: "out",
    transform: "scale(1.1)"
  },
  _active: {
    transitionDuration: "100ms",
    transform: "scale(0.98) translateY(3px)"
  },
  ...tablerIcons
}), btn = css({
  transition: "all 175ms ease-in",
  background: "mantine.colors.primary.filled/65",
  _hover: {
    background: "mantine.colors.primary.filledHover/65"
  },
  _light: {
    background: "mantine.colors.primary.filled/85",
    _hover: {
      background: "mantine.colors.primary.filledHover/85"
    }
  },
  ...tablerIcons
}), parallelStateFrame = css({
  position: "absolute",
  margin: 0,
  padding: 0,
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  border: "2px solid",
  borderColor: "mantine.colors.orange[6]",
  pointerEvents: "none",
  md: {
    borderWidth: 4
  }
});
function DynamicViewWalkthrough() {
  const isMobile = useXYStore((s2) => s2.width <= 750), {
    isActive,
    isParallel,
    hasNext,
    hasPrevious
  } = useDiagramContext((s2) => ({
    isActive: n$2(s2.activeWalkthrough),
    isParallel: n$5(s2.activeWalkthrough?.parallelPrefix),
    hasNext: s2.xyedges.findIndex((e2) => e2.id === s2.activeWalkthrough?.stepId) < s2.xyedges.length - 1,
    hasPrevious: s2.xyedges.findIndex((e2) => e2.id === s2.activeWalkthrough?.stepId) > 0
  })), diagram = useDiagram(), buttonProps = {
    className: btn,
    size: isMobile ? "compact-md" : "lg",
    radius: isMobile ? "lg" : "xl"
  };
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    isParallel && /* @__PURE__ */ jsx(
      Box$1,
      {
        layout: !0,
        component: m$2.div,
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        className: clsx("react-flow__panel", parallelStateFrame)
      },
      "parallel-frame"
    ),
    /* @__PURE__ */ jsxs(
      Box$1,
      {
        className: clsx("react-flow__panel", container),
        onClick: (e2) => e2.stopPropagation(),
        onDoubleClick: (e2) => e2.stopPropagation(),
        children: [
          !isActive && /* @__PURE__ */ jsx(
            Button,
            {
              ...buttonProps,
              className: clsx(buttons, btn),
              rightSection: /* @__PURE__ */ jsx(IconPlayerPlayFilled, {}),
              onClick: () => diagram.startWalkthrough(),
              px: "xl",
              children: "Start"
            }
          ),
          isParallel && /* @__PURE__ */ jsx(
            Badge,
            {
              component: m$2.div,
              initial: { opacity: 0.05, transform: "translateY(20px)" },
              animate: { opacity: 1, transform: "translateY(0)" },
              exit: {
                opacity: 0,
                transform: "translateY(20px)"
              },
              variant: "gradient",
              size: isMobile ? "xs" : "md",
              gradient: { from: "red", to: "orange", deg: 90 },
              radius: "sm",
              children: "parallel"
            },
            "parallel-badge"
          ),
          isActive && /* @__PURE__ */ jsxs(ButtonGroup, { className: buttons, children: [
            /* @__PURE__ */ jsx(
              Button,
              {
                ...buttonProps,
                pl: "lg",
                disabled: !hasPrevious,
                onClick: () => diagram.walkthroughStep("previous"),
                children: /* @__PURE__ */ jsx(IconPlayerSkipBackFilled, {})
              }
            ),
            /* @__PURE__ */ jsxs(
              Button,
              {
                ...buttonProps,
                px: hasNext ? "md" : "xl",
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.stopWalkthrough();
                },
                children: [
                  hasNext && /* @__PURE__ */ jsx(IconPlayerStopFilled, {}),
                  !hasNext && "End"
                ]
              }
            ),
            hasNext && /* @__PURE__ */ jsx(
              Button,
              {
                ...buttonProps,
                pr: "lg",
                onClick: () => diagram.walkthroughStep("next"),
                children: /* @__PURE__ */ jsx(IconPlayerSkipForwardFilled, {})
              }
            )
          ] })
        ]
      }
    )
  ] });
}
const DiagramUI = memo$2(() => {
  const {
    enableViewTitle,
    enableNotations,
    enableDynamicViewWalkthrough
  } = useEnabledFeatures(), overlaysActorRef = useOverlaysActorRef();
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(Controls, {}),
    overlaysActorRef && /* @__PURE__ */ jsx(Overlays, { overlaysActorRef }),
    enableViewTitle && /* @__PURE__ */ jsx(DiagramTitlePanel, {}),
    enableNotations && /* @__PURE__ */ jsx(NotationPanel, {}),
    enableDynamicViewWalkthrough && /* @__PURE__ */ jsx(DynamicViewWalkthrough, {})
  ] });
});
DiagramUI.displayName = "DiagramUI";
class Rect {
  static LeftPadding = 40;
  static RightPadding = 40;
  static TopPadding = 55;
  static BottomPadding = 40;
  id;
  minX = 1 / 0;
  minY = 1 / 0;
  maxX = -1 / 0;
  maxY = -1 / 0;
  get positionAbsolute() {
    return {
      x: this.minX,
      y: this.minY
    };
  }
  set positionAbsolute(pos) {
    const x2 = Math.round(pos.x), y2 = Math.round(pos.y);
    this.maxX += x2 - this.minX, this.maxY += y2 - this.minY, this.minX = x2, this.minY = y2;
  }
  get dimensions() {
    return {
      width: this.maxX - this.minX,
      height: this.maxY - this.minY
    };
  }
  // Position relative to parent
  get position() {
    const positionAbsolute = this.positionAbsolute;
    if (!this.parent)
      return positionAbsolute;
    const parentPosition = this.parent.positionAbsolute;
    return {
      x: positionAbsolute.x - parentPosition.x,
      y: positionAbsolute.y - parentPosition.y
    };
  }
  constructor(xynode, parent = null) {
    this.id = xynode.id, this.positionAbsolute = parent ? {
      x: xynode.position.x + parent.minX,
      y: xynode.position.y + parent.minY
    } : xynode.position;
    const { width, height } = getNodeDimensions(xynode);
    this.maxX = this.minX + Math.ceil(width), this.maxY = this.minY + Math.ceil(height), parent && parent.children.push(this);
  }
}
class CompoundRect extends Rect {
  constructor(xynode, parent = null) {
    super(xynode, parent), this.parent = parent;
  }
  children = [];
}
class Leaf extends Rect {
  constructor(xynode, parent = null) {
    super(xynode, parent), this.parent = parent;
  }
}
function createLayoutConstraints(xyflowApi, editingNodeIds) {
  const { parentLookup, nodeLookup } = xyflowApi.getState(), rects = /* @__PURE__ */ new Map(), ancestorsOf = (nodeId) => {
    const ancestors = [];
    let parent = nodeLookup.get(nodeId)?.parentId, parentNode;
    for (; parent && (parentNode = nodeLookup.get(parent)); )
      ancestors.push(parentNode.id), parent = parentNode.parentId;
    return ancestors;
  }, ancestorsOfDraggingNodes = new Set(
    editingNodeIds.flatMap(ancestorsOf)
  ), traverse = [...nodeLookup.values()].flatMap(
    (x2) => x2.parentId ? [] : { xynode: x2, parent: null }
  );
  for (; traverse.length > 0; ) {
    const { xynode, parent } = traverse.shift();
    if (!editingNodeIds.includes(xynode.id) && xynode.type !== "element" && xynode.type !== "deployment" && ancestorsOfDraggingNodes.has(xynode.id)) {
      const rect = new CompoundRect(xynode, parent);
      rects.set(xynode.id, rect), parentLookup.get(xynode.id)?.forEach((child) => {
        traverse.push({
          xynode: child,
          parent: rect
        });
      });
    } else
      rects.set(xynode.id, new Leaf(xynode, parent));
  }
  const rectsToUpdate = [...rects.values()];
  applyConstraints2(rectsToUpdate);
  function applyConstraints2(targets) {
    for (const r2 of targets) {
      if (!(r2 instanceof CompoundRect))
        continue;
      applyConstraints2(r2.children);
      const childrenBB = {
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      };
      for (const child of r2.children)
        childrenBB.minX = Math.min(childrenBB.minX, child.minX), childrenBB.minY = Math.min(childrenBB.minY, child.minY), childrenBB.maxX = Math.max(childrenBB.maxX, child.maxX), childrenBB.maxY = Math.max(childrenBB.maxY, child.maxY);
      r2.minX = childrenBB.minX - Rect.LeftPadding, r2.minY = childrenBB.minY - Rect.TopPadding, r2.maxX = childrenBB.maxX + Rect.RightPadding, r2.maxY = childrenBB.maxY + Rect.BottomPadding;
    }
  }
  function updateXYFlowNodes() {
    applyConstraints2(rectsToUpdate), xyflowApi.getState().triggerNodeChanges(
      rectsToUpdate.reduce((acc, r2) => (acc.push({
        id: r2.id,
        type: "position",
        dragging: !1,
        position: r2.position,
        positionAbsolute: r2.positionAbsolute
      }), r2 instanceof CompoundRect && acc.push({
        id: r2.id,
        type: "dimensions",
        setAttributes: !0,
        dimensions: r2.dimensions
      }), acc), [])
    );
  }
  let animationFrameId = null;
  function onMove() {
    rectsToUpdate.length !== 0 && (animationFrameId ??= requestAnimationFrame(() => {
      animationFrameId = null;
      const { nodeLookup: nodeLookup2 } = xyflowApi.getState();
      for (const id2 of editingNodeIds) {
        const rect = nonNullable(rects.get(id2)), node2 = nonNullable(nodeLookup2.get(id2));
        rect.positionAbsolute = node2.internals.positionAbsolute;
      }
      updateXYFlowNodes();
    }));
  }
  return {
    rects,
    updateXYFlowNodes,
    onMove
  };
}
function useLayoutConstraints() {
  const xystore = useXYStoreApi(), diagram = useDiagram(), solverRef = useRef(void 0);
  return useMemo(() => {
    let wasPending = !1;
    const initial = { x: 0, y: 0 };
    let moved = !1;
    return {
      onNodeDragStart: (_event, xynode) => {
        wasPending = diagram.cancelSaveManualLayout();
        const { nodeLookup } = xystore.getState(), draggingNodes = C(
          Array.from(nodeLookup.values()),
          T((n2) => n2.draggable !== !1 && (n2.dragging === !0 || n2.id === xynode.id || n2.selected === !0))
        );
        i$7(draggingNodes, 1) && (solverRef.current = createLayoutConstraints(xystore, m(draggingNodes, (x2) => x2.id))), initial.x = _event.clientX, initial.y = _event.clientY, moved = !1;
      },
      onNodeDrag: (_event) => {
        moved = Math.abs(_event.clientX - initial.x) > 4 || Math.abs(_event.clientY - initial.y) > 4, solverRef.current?.onMove();
      },
      onNodeDragStop: (_event) => {
        moved = Math.abs(_event.clientX - initial.x) > 4 || Math.abs(_event.clientY - initial.y) > 4, console.log("moved", moved), (wasPending || moved) && diagram.scheduleSaveManualLayout(), solverRef.current = void 0;
      }
    };
  }, [xystore, diagram]);
}
const selectXYProps = (ctx) => ({
  initialized: ctx.initialized.xydata && ctx.initialized.xyflow,
  nodes: ctx.xynodes,
  edges: ctx.xyedges,
  pannable: ctx.pannable,
  zoomable: ctx.zoomable,
  fitViewPadding: ctx.fitViewPadding,
  enableFitView: ctx.features.enableFitView,
  enableReadOnly: ctx.features.enableReadOnly || ctx.toggledFeatures.enableReadOnly,
  ...!ctx.features.enableFitView && {
    viewport: {
      x: -Math.min(ctx.view.bounds.x, 0),
      y: -Math.min(ctx.view.bounds.y, 0),
      zoom: 1
    }
  }
}), equalsXYProps = (a2, b2) => a2.initialized === b2.initialized && a2.pannable === b2.pannable && a2.zoomable === b2.zoomable && a2.fitViewPadding === b2.fitViewPadding && a2.enableFitView === b2.enableFitView && a2.enableReadOnly === b2.enableReadOnly && shallowEqual(a2.nodes, b2.nodes) && shallowEqual(a2.edges, b2.edges) && shallowEqual(a2.viewport ?? null, b2.viewport ?? null), compareProps = (a2, b2) => a2.nodesDraggable === b2.nodesDraggable && a2.nodesSelectable === b2.nodesSelectable && deepEqual(a2.background, b2.background) && deepEqual(a2.reactFlowProps ?? {}, b2.reactFlowProps ?? {}), LikeC4DiagramXYFlow = memo$2(({
  background = "dots",
  nodesDraggable = !1,
  nodesSelectable = !1,
  reactFlowProps = {},
  children: children2
}) => {
  const diagram = useDiagram(), {
    initialized,
    nodes,
    edges,
    enableReadOnly,
    enableFitView,
    ...props
  } = useDiagramContext(selectXYProps, equalsXYProps), {
    onNodeContextMenu,
    onCanvasContextMenu,
    onEdgeContextMenu,
    onNodeClick,
    onEdgeClick,
    onCanvasClick,
    onCanvasDblClick
  } = useDiagramEventHandlers(), notReadOnly = !enableReadOnly, isReducedGraphics = useIsReducedGraphics(), layoutConstraints = useLayoutConstraints(), $isPanning = usePanningAtom(), isPanning = useTimeout(() => {
    $isPanning.set(!0);
  }, isReducedGraphics ? 100 : 200), notPanning = useDebouncedCallback$1(() => {
    isPanning.clear(), $isPanning.get() && $isPanning.set(!1);
  }, 200), onMove = useCallbackRef((event) => {
    event && ($isPanning.get() || isPanning.start(), notPanning());
  }), onMoveEnd = useCallbackRef((event, viewport) => {
    event && notPanning.flush(), diagram.send({ type: "xyflow.viewportMoved", viewport, manually: !!event });
  }), onViewportResize = useCallbackRef(() => {
    diagram.send({ type: "xyflow.resized" });
  });
  return /* @__PURE__ */ jsxs(
    BaseXYFlow,
    {
      nodes,
      edges,
      className: cx(initialized ? "initialized" : "not-initialized"),
      nodeTypes: nodeTypes$2,
      edgeTypes: edgeTypes$2,
      onNodesChange: useCallbackRef((changes) => {
        diagram.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        diagram.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      background: initialized ? background : "transparent",
      fitView: !1,
      onNodeClick: useCallbackRef((e2, node2) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.nodeClick", node: node2 }), onNodeClick?.(diagram.findDiagramNode(node2.id), e2);
      }),
      onEdgeClick: useCallbackRef((e2, edge) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.edgeClick", edge }), onEdgeClick?.(diagram.findDiagramEdge(edge.id), e2);
      }),
      onPaneClick: useCallbackRef((e2) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.paneClick" }), onCanvasClick?.(e2);
      }),
      onDoubleClick: useCallbackRef((e2) => {
        e2.stopPropagation(), e2.preventDefault(), diagram.send({ type: "xyflow.paneDblClick" }), onCanvasDblClick?.(e2);
      }),
      onNodeMouseEnter: useCallbackRef((_event, node2) => {
        _event.stopPropagation(), node2.data.hovered || diagram.send({ type: "xyflow.nodeMouseEnter", node: node2 });
      }),
      onNodeMouseLeave: useCallbackRef((_event, node2) => {
        _event.stopPropagation(), node2.data.hovered && diagram.send({ type: "xyflow.nodeMouseLeave", node: node2 });
      }),
      onEdgeMouseEnter: useCallbackRef((_event, edge) => {
        _event.stopPropagation(), edge.data.hovered || diagram.send({ type: "xyflow.edgeMouseEnter", edge });
      }),
      onEdgeMouseLeave: useCallbackRef((_event, edge) => {
        _event.stopPropagation(), edge.data.hovered && diagram.send({ type: "xyflow.edgeMouseLeave", edge });
      }),
      ...props.pannable && {
        onMove
      },
      onMoveEnd,
      onInit: useCallbackRef((instance) => {
        diagram.send({ type: "xyflow.init", instance });
      }),
      onNodeContextMenu: useCallbackRef((event, node2) => {
        const diagramNode = nonNullable(
          diagram.findDiagramNode(node2.id),
          `diagramNode ${node2.id} not found`
        );
        onNodeContextMenu?.(diagramNode, event);
      }),
      onEdgeContextMenu: useCallbackRef((event, edge) => {
        const diagramEdge = nonNullable(
          diagram.findDiagramEdge(edge.id),
          `diagramEdge ${edge.id} not found`
        );
        onEdgeContextMenu?.(diagramEdge, event);
      }),
      onPaneContextMenu: useCallbackRef((event) => {
        onCanvasContextMenu?.(event);
      }),
      ...enableFitView && {
        onViewportResize
      },
      nodesDraggable: notReadOnly && nodesDraggable,
      nodesSelectable,
      ...notReadOnly && nodesDraggable && layoutConstraints,
      ...props,
      ...reactFlowProps,
      children: [
        /* @__PURE__ */ jsx(DiagramUI, {}, "DiagramUI"),
        children2
      ]
    }
  );
}, compareProps);
LikeC4DiagramXYFlow.displayName = "LikeC4DiagramXYFlow";
function viewToNodesEdge(opts) {
  const {
    view,
    nodesSelectable: selectable
  } = opts;
  view.__;
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(view.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  ));
  let visiblePredicate = (_nodeOrEdge) => !0;
  if (opts.where)
    try {
      const filterablePredicate = whereOperatorAsPredicate(opts.where);
      visiblePredicate = (i2) => filterablePredicate({
        ...i$5(i2, ["tags", "kind"]),
        ..."source" in i2 ? { source: nodeById(i2.source) } : i2,
        ..."target" in i2 ? { target: nodeById(i2.target) } : i2
      });
    } catch (e2) {
      console.error("Error in where filter:", e2);
    }
  const ns = "", nodeById = (id2) => nonNullable(nodeLookup.get(id2), `Node not found: ${id2}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = i$7(node2.children, 1) || node2.kind == ElementKind.Group;
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.position[0],
      y: node2.position[1]
    };
    parent && (position.x -= parent.position[0], position.y -= parent.position[1]);
    const base = {
      id: ns + node2.id,
      selectable: selectable && node2.kind !== ElementKind.Group,
      focusable: selectable && node2.kind !== ElementKind.Group,
      deletable: !1,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      hidden: node2.kind !== ElementKind.Group && !visiblePredicate(node2),
      ...parent && {
        parentId: ns + parent.id
      }
    }, compoundData = {
      id: node2.id,
      title: node2.title,
      color: node2.color,
      shape: node2.shape,
      style: node2.style,
      depth: node2.depth ?? 0,
      icon: node2.icon ?? "none",
      position: node2.position
    }, leafNodeData = {
      id: node2.id,
      title: node2.title,
      technology: node2.technology,
      description: node2.description,
      height: node2.height,
      width: node2.width,
      level: node2.level,
      color: node2.color,
      shape: node2.shape,
      style: node2.style,
      icon: node2.icon ?? null,
      position: node2.position,
      isMultiple: node2.style?.multiple ?? !1
    };
    if (node2.kind === ElementKind.Group) {
      xynodes.push({
        ...base,
        type: "view-group",
        data: {
          isViewGroup: !0,
          ...compoundData
        },
        dragHandle: ".likec4-compound-title"
      });
      continue;
    }
    const modelFqn = DiagramNode.modelRef(node2), deploymentFqn = DiagramNode.deploymentRef(node2);
    if (!modelFqn && !deploymentFqn)
      throw console.error("Invalid node", node2), new Error("Element should have either modelRef or deploymentRef");
    const navigateTo = { navigateTo: node2.navigateTo ?? null };
    switch (!0) {
      case (isCompound && !!deploymentFqn): {
        xynodes.push(
          {
            ...base,
            type: "compound-deployment",
            data: {
              ...compoundData,
              ...navigateTo,
              deploymentFqn,
              modelFqn
            },
            dragHandle: ".likec4-compound-title"
          }
        );
        break;
      }
      case isCompound: {
        invariant$2(!!modelFqn, "ModelRef expected"), xynodes.push(
          {
            ...base,
            type: "compound-element",
            data: {
              ...compoundData,
              ...navigateTo,
              modelFqn
            },
            dragHandle: ".likec4-compound-title"
          }
        );
        break;
      }
      case !!deploymentFqn: {
        xynodes.push(
          {
            ...base,
            type: "deployment",
            data: {
              ...leafNodeData,
              ...navigateTo,
              deploymentFqn,
              modelFqn
            }
          }
        );
        break;
      }
      default:
        invariant$2(!!modelFqn, "ModelRef expected"), xynodes.push(
          {
            ...base,
            type: "element",
            data: {
              ...leafNodeData,
              ...navigateTo,
              modelFqn
            }
          }
        );
    }
  }
  for (const edge of view.edges) {
    const source = edge.source, target = edge.target, id2 = ns + edge.id;
    if (!i$7(edge.points, 2)) {
      console.error("edge should have at least 2 points", edge);
      continue;
    }
    xyedges.push({
      id: id2,
      type: "relationship",
      source: ns + source,
      target: ns + target,
      zIndex: ZIndexes.Edge,
      selectable,
      hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        id: edge.id,
        label: edge.label,
        technology: edge.technology,
        notes: edge.notes,
        navigateTo: edge.navigateTo,
        controlPoints: edge.controlPoints ?? null,
        labelBBox: edge.labelBBox ?? null,
        labelXY: edge.labelBBox ? { x: edge.labelBBox.x, y: edge.labelBBox.y } : null,
        points: edge.points,
        color: edge.color ?? "gray",
        line: edge.line ?? "dashed",
        dir: edge.dir ?? "forward",
        head: edge.head ?? "normal",
        tail: edge.tail ?? "none"
      },
      interactionWidth: 20
    });
  }
  return {
    xynodes,
    xyedges
  };
}
function useViewToNodesEdges({
  view: {
    id: id2,
    nodes,
    edges,
    __ = "element"
  },
  ...opts
}) {
  return useDeepCompareMemo(() => viewToNodesEdge({
    view: {
      id: id2,
      nodes,
      edges,
      __
    },
    ...opts
  }), [id2, __, nodes, edges, opts]);
}
class Aligner {
}
class LinearAligner extends Aligner {
  constructor(getEdgePosition2, computePosition2, propertyToEdit) {
    super(), this.getEdgePosition = getEdgePosition2, this.computePosition = computePosition2, this.propertyToEdit = propertyToEdit;
  }
  alignTo;
  computeLayout(nodes) {
    this.alignTo = this.getEdgePosition(nodes);
  }
  applyPosition(node2) {
    return {
      [this.propertyToEdit]: this.computePosition(this.alignTo, node2)
    };
  }
}
class GridAligner extends Aligner {
  layout = /* @__PURE__ */ new Map();
  axisPreset;
  get primaryAxisCoord() {
    return this.axisPreset.primaryAxisCoord;
  }
  get secondaryAxisCoord() {
    return this.axisPreset.secondaryAxisCoord;
  }
  get primaryAxisDimension() {
    return this.axisPreset.primaryAxisDimension;
  }
  get secondaryAxisDimension() {
    return this.axisPreset.secondaryAxisDimension;
  }
  constructor(alignmentMode) {
    super(), this.axisPreset = alignmentMode === "Column" ? {
      primaryAxisDimension: "width",
      secondaryAxisDimension: "height",
      primaryAxisCoord: "x",
      secondaryAxisCoord: "y"
    } : {
      primaryAxisDimension: "height",
      secondaryAxisDimension: "width",
      primaryAxisCoord: "y",
      secondaryAxisCoord: "x"
    };
  }
  applyPosition(node2) {
    return this.layout?.get(node2.id) ?? {};
  }
  computeLayout(nodes) {
    const sortedNodeRects = C(
      nodes,
      a$5((r2) => r2[this.primaryAxisCoord])
    ), layoutRect = this.getLayoutRect(sortedNodeRects), layers = this.getLayers(sortedNodeRects);
    this.layout = this.buildLayout(layers, layoutRect, sortedNodeRects);
  }
  getLayoutRect(nodeRects) {
    const x2 = Math.min(...nodeRects.map((n2) => n2.x)), y2 = Math.min(...nodeRects.map((n2) => n2.y)), right = Math.max(...nodeRects.map((n2) => n2.x + n2.width)), bottom = Math.max(...nodeRects.map((n2) => n2.y + n2.height));
    return {
      x: x2,
      y: y2,
      width: right - x2,
      height: bottom - y2
    };
  }
  getLayers(sortedNodeRects) {
    const layers = [];
    let layerEnd = 0, layer = null;
    for (let node2 of sortedNodeRects)
      if (layer && node2[this.primaryAxisCoord] < layerEnd)
        layer.nodes.push(node2), layer.primaryAxisSize = Math.max(layer.primaryAxisSize, node2[this.primaryAxisDimension]), layer.occupiedSpace += node2[this.secondaryAxisDimension], layerEnd = Math.max(
          node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension],
          layerEnd
        );
      else {
        layer = {
          primaryAxisSize: node2[this.primaryAxisDimension],
          nodes: [node2],
          occupiedSpace: node2[this.secondaryAxisDimension],
          layout: null
        }, layers.push(layer), layerEnd = node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension];
        continue;
      }
    return layers.forEach((l2) => l2.nodes.sort((a2, b2) => a2[this.secondaryAxisCoord] - b2[this.secondaryAxisCoord])), layers;
  }
  buildLayout(layers, layoutRect, nodeRects) {
    const nodeMap = new Map(nodeRects.map((n2) => [n2.id, n2])), layout2 = [], occupiedSpace = layers.reduce((a2, b2) => a2 + b2.primaryAxisSize, 0), rowMargin = layers.length > 1 ? (layoutRect[this.primaryAxisDimension] - occupiedSpace) / (layers.length - 1) : 0, baseLayerIndex = layers.reduce(
      (widestLayerIndex, layer, i2) => layers[widestLayerIndex].occupiedSpace < layer.occupiedSpace ? i2 : widestLayerIndex,
      0
    ), baseLayer = layers[baseLayerIndex], baseLayerPosition = layers.slice(0, baseLayerIndex).reduce(
      (a2, layer) => a2 + layer.primaryAxisSize + rowMargin,
      layoutRect[this.primaryAxisCoord]
    ), baseLayerLayout = this.buildLayerLayout(
      baseLayer,
      layoutRect,
      baseLayerPosition,
      nodeMap,
      null
    );
    baseLayer.layout = baseLayerLayout, layout2.push(...baseLayerLayout.nodePositions);
    let placeNextLayerAt = baseLayerPosition + baseLayer.primaryAxisSize + rowMargin, refLayer = baseLayer;
    for (let i2 = baseLayerIndex + 1; i2 < layers.length; i2++) {
      const layer = layers[i2];
      layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout2.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer, placeNextLayerAt += layer.primaryAxisSize + rowMargin;
    }
    placeNextLayerAt = baseLayerPosition, refLayer = baseLayer;
    for (let i2 = baseLayerIndex - 1; i2 >= 0; i2--) {
      const layer = layers[i2];
      placeNextLayerAt -= layer.primaryAxisSize + rowMargin, layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout2.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer;
    }
    return new Map(layout2);
  }
  buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer) {
    let bestLayerLayout = this.scoreLayout(
      this.spaceAround(layer, layoutRect, placeNextLayerAt),
      nodeMap
    );
    if (layer.nodes.length != 1) {
      const currentlayerLayout = this.scoreLayout(
        this.spaceBetween(layer, layoutRect, placeNextLayerAt),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length - 1 >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInGaps(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInCells(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    return bestLayerLayout[1];
  }
  spaceBetween(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length - 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord];
    const result = /* @__PURE__ */ new Map();
    for (let node2 of layer.nodes)
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  spaceAround(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length + 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord] + margin;
    const result = /* @__PURE__ */ new Map();
    for (let node2 of a$5(layer.nodes, (n2) => n2[this.secondaryAxisCoord]))
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  placeInGaps(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getGapsPositions(refLayer);
    let optionIndex = 0;
    for (let i2 = 0, node2 = nodes[i2]; i2 < nodes.length; i2++, node2 = nodes[i2]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i2 <= placementOptions.length - nodes.length; ) {
        const offset2 = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset2) < Math.abs(bestOffset))
          bestOffset = offset2, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  placeInCells(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getNodePositions(refLayer);
    let optionIndex = 0;
    for (let i2 = 0, node2 = nodes[i2]; i2 < nodes.length; i2++, node2 = nodes[i2]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i2 <= placementOptions.length - nodes.length; ) {
        const offset2 = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset2) < Math.abs(bestOffset))
          bestOffset = offset2, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  scoreLayout(layout2, originalRects) {
    return [
      C(
        Array.from(layout2.nodePositions),
        m(([id2, position]) => {
          const originalRect = originalRects.get(id2);
          return invariant$2(originalRect, `Could not find original rect for node ${id2}`), [i$5(originalRect, ["x", "y"]), position];
        }),
        m(
          ([original, suggested]) => Math.abs(original[this.secondaryAxisCoord] - suggested[this.secondaryAxisCoord])
        ),
        l$4((a2, b2) => a2 + b2, 0)
      ),
      layout2
    ];
  }
  getGapsPositions(layer) {
    const result = [], { layout: layout2, nodes } = layer;
    invariant$2(layout2, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i2 = 1; i2 < nodes.length; i2++) {
      const previousNode = nodes[i2 - 1], currentNode = nodes[i2], previousNodePosition = layout2.nodePositions.get(previousNode.id), currentNodePosition = layout2.nodePositions.get(currentNode.id);
      result.push(
        (currentNodePosition[this.secondaryAxisCoord] + previousNodePosition[this.secondaryAxisCoord] + previousNode[this.secondaryAxisDimension]) / 2
      );
    }
    return result;
  }
  getNodePositions(layer) {
    const result = [], { layout: layout2, nodes } = layer;
    invariant$2(layout2, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node2 = nodes[i2], nodePosition = layout2.nodePositions.get(node2.id);
      result.push(
        nodePosition[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2
      );
    }
    return result;
  }
}
function getLinearAligner(mode) {
  switch (mode) {
    case "Left":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x)),
        (alignTo, _) => Math.floor(alignTo),
        "x"
      );
    case "Top":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y)),
        (alignTo, _) => Math.floor(alignTo),
        "y"
      );
    case "Right":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.x + n2.width)),
        (alignTo, node2) => Math.floor(alignTo - node2.width),
        "x"
      );
    case "Bottom":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.y + n2.height)),
        (alignTo, node2) => Math.floor(alignTo - node2.height),
        "y"
      );
    case "Center":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x + n2.width / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.width / 2),
        "x"
      );
    case "Middle":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y + n2.height / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.height / 2),
        "y"
      );
  }
}
function toNodeRect(node2) {
  const { width, height } = getNodeDimensions(node2);
  return {
    ...node2.internals.positionAbsolute,
    id: node2.id,
    width,
    height
  };
}
function getAligner(mode) {
  switch (mode) {
    case "Left":
    case "Right":
    case "Top":
    case "Bottom":
    case "Center":
    case "Middle":
      return getLinearAligner(mode);
    case "Column":
    case "Row":
      return new GridAligner(mode);
    default:
      nonexhaustive(mode);
  }
}
function lastClickedNode(params) {
  const { lastClickedNode: lastClickedNode2 } = params.context;
  return !lastClickedNode2 || lastClickedNode2.id !== params.event.node.id ? {
    id: params.event.node.id,
    clicks: 1,
    timestamp: Date.now()
  } : {
    id: lastClickedNode2.id,
    clicks: lastClickedNode2.clicks + 1,
    timestamp: Date.now()
  };
}
function mergeXYNodesEdges({ context: context2, event }) {
  xstate_cjsExports.assertEvent(event, "update.view");
  const nextView = event.view, isSameView = context2.view.id === nextView.id, currentNodes = context2.xynodes, xynodes = event.xynodes.map((update) => {
    const existing = currentNodes.find((n2) => n2.id === update.id);
    if (existing) {
      const { width: existingWidth, height: existingHeight } = getNodeDimensions(existing);
      return deepEqual(existing.type, update.type) && deepEqual(existingWidth, update.initialWidth) && deepEqual(existingHeight, update.initialHeight) && deepEqual(existing.hidden ?? !1, update.hidden ?? !1) && deepEqual(existing.position, update.position) && deepEqual(existing.data, update.data) && deepEqual(existing.parentId ?? null, update.parentId ?? null) ? existing : {
        ...y$2(existing, ["measured", "parentId"]),
        ...update,
        // Force dimensions from update
        width: update.initialWidth,
        height: update.initialHeight,
        data: {
          ...existing.data,
          ...update.data
        }
      };
    }
    return update;
  });
  let xyedges = event.xyedges;
  if (isSameView && !nextView.hasLayoutDrift) {
    const currentEdges = context2.xyedges;
    xyedges = event.xyedges.map((update) => {
      const existing = currentEdges.find((n2) => n2.id === update.id);
      return existing ? deepEqual(existing.hidden ?? !1, update.hidden ?? !1) && deepEqual(existing.data, update.data) ? existing : {
        ...existing,
        ...update,
        data: {
          ...existing.data,
          ...update.data
        }
      } : update;
    });
  }
  if (!isSameView) {
    for (const node2 of xynodes)
      node2.data = {
        ...node2.data,
        dimmed: !1,
        hovered: !1
      };
    for (const edge of xyedges)
      edge.data = {
        ...edge.data,
        dimmed: !1,
        hovered: !1,
        active: !1
      };
  }
  return {
    xynodes,
    xyedges,
    view: nextView
  };
}
function focusNodesEdges(params) {
  const { xynodes: _xynodes, xyedges: _xyedges, focusedNode } = params.context;
  if (!focusedNode)
    return {};
  const focused = /* @__PURE__ */ new Set([focusedNode]), xyedges = _xyedges.map((edge) => edge.source === focusedNode || edge.target === focusedNode ? (focused.add(edge.source), focused.add(edge.target), Base.setData(edge, {
    dimmed: !1,
    active: !0
  })) : Base.setData(edge, {
    dimmed: !0,
    active: !1
  }));
  return {
    xynodes: _xynodes.map((n2) => Base.setDimmed(n2, !focused.has(n2.id))),
    xyedges
  };
}
function unfocusNodesEdges({ context: context2 }) {
  const { xynodes, xyedges } = context2;
  return {
    xynodes: xynodes.map(Base.setDimmed(!1)),
    xyedges: xyedges.map(Base.setData({
      dimmed: !1,
      active: !1
    }))
  };
}
function updateNavigationHistory({ context: context2, event }) {
  xstate_cjsExports.assertEvent(event, "update.view");
  let {
    view,
    navigationHistory: {
      currentIndex,
      history
    },
    lastOnNavigate,
    viewport
  } = context2;
  const stepCurrent = history[currentIndex];
  if (!stepCurrent)
    return {
      navigationHistory: {
        currentIndex: 0,
        history: [
          {
            viewId: event.view.id,
            fromNode: null,
            viewport: { ...viewport }
          }
        ]
      }
    };
  if (stepCurrent.viewId !== event.view.id) {
    if (!lastOnNavigate) {
      const stepBack = currentIndex > 0 ? nonNullable(history[currentIndex - 1]) : null;
      if (stepBack && stepBack.viewId === event.view.id)
        return {
          navigationHistory: {
            currentIndex: currentIndex - 1,
            history
          },
          lastOnNavigate: {
            fromView: stepCurrent.viewId,
            toView: stepBack.viewId,
            fromNode: stepCurrent.fromNode
          }
        };
      const stepForward = currentIndex < history.length - 1 ? nonNullable(history[currentIndex + 1]) : null;
      if (stepForward && stepForward.viewId === event.view.id)
        return {
          navigationHistory: {
            currentIndex: currentIndex + 1,
            history
          },
          lastOnNavigate: {
            fromView: stepCurrent.viewId,
            toView: stepForward.viewId,
            fromNode: stepForward.fromNode
          }
        };
    }
    return history = [
      ...history.slice(0, currentIndex + 1),
      {
        viewId: event.view.id,
        fromNode: lastOnNavigate?.fromNode ?? null,
        viewport: { ...viewport }
      }
    ], currentIndex = history.length - 1, {
      navigationHistory: {
        currentIndex,
        history
      }
    };
  }
  return {};
}
function navigateBack({ context: context2 }) {
  const {
    navigationHistory: {
      currentIndex,
      history
    }
  } = context2;
  invariant$2(currentIndex > 0, "Cannot navigate back");
  const stepCurrent = history[currentIndex], stepBack = history[currentIndex - 1];
  return {
    navigationHistory: {
      currentIndex: currentIndex - 1,
      history
    },
    lastOnNavigate: {
      fromView: stepCurrent.viewId,
      toView: stepBack.viewId,
      fromNode: stepCurrent.fromNode
    }
  };
}
function navigateForward({ context: context2 }) {
  const {
    navigationHistory: {
      currentIndex,
      history
    }
  } = context2;
  invariant$2(currentIndex < history.length - 1, "Cannot navigate forward");
  const stepCurrent = history[currentIndex], stepForward = history[currentIndex + 1];
  return {
    navigationHistory: {
      currentIndex: currentIndex + 1,
      history
    },
    lastOnNavigate: {
      fromView: stepCurrent.viewId,
      toView: stepForward.viewId,
      fromNode: stepForward.fromNode
    }
  };
}
function updateNodeData({ context: context2, event }) {
  return xstate_cjsExports.assertEvent(event, "update.nodeData"), { xynodes: context2.xynodes.map(
    (node2) => node2.id !== event.nodeId ? node2 : {
      ...node2,
      data: D(node2.data, event.data)
    }
  ) };
}
function updateEdgeData({ context: context2, event }) {
  return xstate_cjsExports.assertEvent(event, "update.edgeData"), { xyedges: context2.xyedges.map(
    (edge) => edge.id !== event.edgeId ? edge : {
      ...edge,
      data: D(edge.data, event.data)
    }
  ) };
}
function resetEdgeControlPoints({ context: context2 }) {
  const { xynodes } = context2;
  function getNodeCenter2(node2, nodes) {
    const dimensions = vector({ x: node2.width || 0, y: node2.height || 0 });
    let position = vector(node2.position).add(dimensions.mul(0.5)), currentNode = node2;
    do {
      const parent = currentNode.parentId && nodes.find((x2) => x2.id == currentNode.parentId);
      if (!parent)
        break;
      currentNode = parent, position = position.add(parent.position);
    } while (!0);
    return position;
  }
  function getControlPointForEdge(edge) {
    const source = xynodes.find((x2) => x2.id == edge.source), target = xynodes.find((x2) => x2.id == edge.target);
    if (!source || !target)
      return [];
    const sourceCenter = getNodeCenter2(source, xynodes), targetCenter = getNodeCenter2(target, xynodes);
    if (!sourceCenter || !targetCenter)
      return [];
    if (source === target) {
      const centerOfTopBoundary = new VectorImpl(0, source.height || 0).mul(-0.5).add(sourceCenter);
      return [
        centerOfTopBoundary.add(new VectorImpl(-80 / 2.5, -80)),
        centerOfTopBoundary.add(new VectorImpl(80 / 2.5, -80))
      ];
    }
    const sourceToTargetVector = targetCenter.sub(sourceCenter), sourceBorderPoint = getBorderPointOnVector(source, sourceCenter, sourceToTargetVector), targetBorderPoint = getBorderPointOnVector(target, targetCenter, sourceToTargetVector.mul(-1));
    return [sourceBorderPoint.add(targetBorderPoint.sub(sourceBorderPoint).mul(0.3))];
  }
  function getBorderPointOnVector(node2, nodeCenter, v) {
    const xScale = (node2.width || 0) / 2 / v.x, yScale = (node2.height || 0) / 2 / v.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
    return vector(v).mul(scale2).add(nodeCenter);
  }
  return {
    xyedges: context2.xyedges.map((edge) => !edge.data.controlPoints || n$3(edge.data.controlPoints) ? edge : {
      ...edge,
      data: {
        ...edge.data,
        controlPoints: getControlPointForEdge(edge)
      }
    })
  };
}
function updateActiveWalkthrough({ context: context2 }) {
  const { stepId, parallelPrefix } = nonNullable(context2.activeWalkthrough, "activeWalkthrough is null"), step = nonNullable(context2.xyedges.find((x2) => x2.id === stepId));
  return {
    xyedges: context2.xyedges.map((edge) => {
      const active = stepId === edge.id || !!parallelPrefix && edge.id.startsWith(parallelPrefix);
      return Base.setData(edge, {
        active,
        dimmed: !active
      });
    }),
    xynodes: context2.xynodes.map((node2) => {
      const dimmed = step.source !== node2.id && step.target !== node2.id;
      return Base.setDimmed(node2, dimmed);
    })
  };
}
const hotkeyActorLogic = xstate_cjsExports.fromCallback(({ sendBack }) => {
  const escHandler = getHotkeyHandler([
    ["Escape", (event) => {
      event.stopPropagation(), sendBack({ type: "key.esc" });
    }, {
      preventDefault: !0
    }]
  ]), arrowshandler = getHotkeyHandler([
    ["ArrowLeft", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.left" });
    }, {
      preventDefault: !0
    }],
    ["ArrowRight", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.right" });
    }, {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", escHandler), document.body.addEventListener("keydown", arrowshandler, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", escHandler), document.body.removeEventListener("keydown", arrowshandler, { capture: !0 });
  };
}), key = "likec4:diagram:toggledFeatures", DiagramToggledFeaturesPersistence = {
  read() {
    try {
      let fromStorage = sessionStorage.getItem(key);
      return fromStorage ? JSON.parse(fromStorage) : null;
    } catch (e2) {
      return console.error(`Error reading fromStorage ${key}:`, e2), null;
    }
  },
  write(toggledFeatures) {
    return sessionStorage.setItem(key, JSON.stringify(d$2(toggledFeatures, e$1))), toggledFeatures;
  }
}, syncManualLayoutActorLogic = xstate_cjsExports.setup({
  types: {
    context: {},
    input: {},
    events: {},
    tags: ""
  },
  delays: {
    timeout: 2e3
  },
  actions: {
    "trigger:OnChange": (_, _params) => {
    }
  },
  guards: {
    "same view": ({ context: context2 }) => context2.parent.getSnapshot().context.view.id === context2.viewId
  }
}).createMachine({
  initial: "idle",
  context: ({ input: input2 }) => ({
    ...input2
  }),
  states: {
    idle: {
      tags: "ready",
      on: {
        sync: {
          target: "pending"
        }
      }
    },
    paused: {
      tags: "pending",
      on: {
        sync: {
          target: "pending"
        }
      }
    },
    pending: {
      tags: "pending",
      on: {
        sync: {
          target: "pending",
          reenter: !0
        },
        cancel: {
          target: "paused"
        }
      },
      after: {
        timeout: [{
          guard: "same view",
          actions: {
            type: "trigger:OnChange",
            params: ({ context: context2 }) => ({ change: createViewChange(context2.parent.getSnapshot().context) })
          },
          target: "synced"
        }, {
          target: "stopped"
        }]
      }
    },
    synced: {
      tags: "ready",
      on: {
        sync: {
          target: "pending"
        }
      }
    },
    stopped: {
      entry: xstate_cjsExports.assign({
        parent: null
      }),
      type: "final"
    }
  },
  on: {
    synced: {
      target: ".synced"
    },
    stop: {
      target: ".stopped"
    }
  }
});
function createViewChange(parentContext) {
  const { view, xystore, xyflow: xyflow2 } = parentContext, { nodeLookup } = xystore.getState(), movedNodes = /* @__PURE__ */ new Set();
  let bounds;
  const nodes = l$4([...nodeLookup.values()], (acc, node2) => {
    const dimensions = getNodeDimensions(node2);
    (!isSamePoint(node2.internals.positionAbsolute, node2.data.position) || node2.initialWidth !== dimensions.width || node2.initialHeight !== dimensions.height) && movedNodes.add(node2.id);
    const rect = acc[node2.id] = {
      isCompound: node2.type !== "element" && node2.type !== "deployment",
      x: Math.floor(node2.internals.positionAbsolute.x),
      y: Math.floor(node2.internals.positionAbsolute.y),
      width: Math.ceil(dimensions.width),
      height: Math.ceil(dimensions.height)
    };
    return bounds = bounds ? getBoundsOfRects(bounds, rect) : rect, acc;
  }, {}), edges = l$4(xyflow2?.getEdges() ?? [], (acc, { source, target, data }) => {
    let controlPoints = data.controlPoints ?? [];
    const sourceOrTargetMoved = movedNodes.has(source) || movedNodes.has(target);
    if (controlPoints.length === 0 && sourceOrTargetMoved && (controlPoints = bezierControlPoints(data)), data.points.length === 0 && controlPoints.length === 0)
      return acc;
    const _updated = acc[data.id] = {
      points: data.points
    };
    data.labelXY && data.labelBBox && (_updated.labelBBox = {
      ...data.labelBBox,
      ...data.labelXY
    }), data.labelBBox && (_updated.labelBBox ??= data.labelBBox), i$7(controlPoints, 1) && (_updated.controlPoints = controlPoints);
    const allX = [
      ...data.points.map((p2) => p2[0]),
      ...controlPoints.map((p2) => p2.x),
      ..._updated.labelBBox ? [_updated.labelBBox.x, _updated.labelBBox.x + _updated.labelBBox.width] : []
    ], allY = [
      ...data.points.map((p2) => p2[1]),
      ...controlPoints.map((p2) => p2.y),
      ..._updated.labelBBox ? [_updated.labelBBox.y, _updated.labelBBox.y + _updated.labelBBox.height] : []
    ], rect = boxToRect({
      x: Math.floor(Math.min(...allX)),
      y: Math.floor(Math.min(...allY)),
      x2: Math.ceil(Math.max(...allX)),
      y2: Math.ceil(Math.max(...allY))
    });
    return bounds = bounds ? getBoundsOfRects(bounds, rect) : rect, acc;
  }, {});
  return bounds ??= view.bounds, {
    op: "save-manual-layout",
    layout: {
      hash: view.hash,
      autoLayout: view.autoLayout,
      nodes,
      edges,
      ...bounds
    }
  };
}
const diagramMachine = xstate_cjsExports.setup({
  types: {
    context: {},
    input: {},
    children: {},
    events: {}
  },
  actors: {
    syncManualLayoutActorLogic,
    hotkeyActorLogic,
    overlaysActorLogic
  },
  guards: {
    isReady: ({ context: context2 }) => context2.initialized.xydata && context2.initialized.xyflow,
    "enabled: FitView": ({ context: context2 }) => context2.features.enableFitView,
    "enabled: FocusMode": ({ context: context2 }) => context2.features.enableFocusMode,
    "enabled: Readonly": ({ context: context2 }) => context2.features.enableReadOnly,
    "enabled: RelationshipDetails": ({ context: context2 }) => context2.features.enableRelationshipDetails,
    "not readonly": ({ context: context2 }) => !context2.features.enableReadOnly,
    "is dynamic view": ({ context: context2 }) => context2.view.__ === "dynamic",
    "is another view": ({ context: context2, event }) => {
      if (xstate_cjsExports.assertEvent(event, ["update.view", "navigate.to"]), event.type === "update.view")
        return context2.view.id !== event.view.id;
      if (event.type === "navigate.to")
        return context2.view.id !== event.viewId;
      nonexhaustive(event.type);
    },
    "click: selected node": ({ event }) => (xstate_cjsExports.assertEvent(event, "xyflow.nodeClick"), event.node.selected === !0),
    "click: same node": ({ context: context2, event }) => (xstate_cjsExports.assertEvent(event, "xyflow.nodeClick"), context2.lastClickedNode?.id === event.node.id),
    "click: focused node": ({ context: context2, event }) => (xstate_cjsExports.assertEvent(event, "xyflow.nodeClick"), context2.focusedNode === event.node.id),
    "click: node has connections": ({ context: context2, event }) => (xstate_cjsExports.assertEvent(event, "xyflow.nodeClick"), context2.xyedges.some((e2) => e2.source === event.node.id || e2.target === event.node.id)),
    "click: selected edge": ({ event }) => (xstate_cjsExports.assertEvent(event, "xyflow.edgeClick"), event.edge.selected === !0 || event.edge.data.active === !0)
  },
  actions: {
    "trigger:NavigateTo": (_, _params) => {
    },
    "trigger:OnChange": (_, _params) => {
    },
    "trigger:OpenSource": (_, _params) => {
    },
    "assign lastClickedNode": xstate_cjsExports.assign(({ context: context2, event }) => (xstate_cjsExports.assertEvent(event, "xyflow.nodeClick"), {
      lastClickedNode: lastClickedNode({ context: context2, event })
    })),
    "open source of focused or last clicked node": xstate_cjsExports.enqueueActions(({ context: context2, enqueue }) => {
      const nodeId = context2.focusedNode ?? context2.lastClickedNode?.id;
      if (!nodeId || !context2.features.enableVscode) return;
      const diagramNode = findDiagramNode(context2, nodeId);
      diagramNode && (DiagramNode.deploymentRef(diagramNode) ? enqueue.raise({ type: "open.source", deployment: DiagramNode.deploymentRef(diagramNode) }) : DiagramNode.modelRef(diagramNode) && enqueue.raise({ type: "open.source", element: DiagramNode.modelRef(diagramNode) }));
    }),
    "xyflow:fitDiagram": ({ context: context2 }, params) => {
      const {
        bounds = context2.view.bounds,
        duration = 450
      } = params ?? {}, { width, height, panZoom, transform: transform2 } = context2.xystore.getState(), maxZoom = Math.max(1, transform2[2]), viewport = getViewportForBounds(
        bounds,
        width,
        height,
        MinZoom,
        maxZoom,
        context2.fitViewPadding
      );
      viewport.x = Math.round(viewport.x), viewport.y = Math.round(viewport.y), panZoom?.setViewport(viewport, duration > 0 ? { duration } : void 0);
    },
    "xyflow:fitFocusedBounds": ({ context: context2 }) => {
      const { bounds, duration = 450 } = focusedBounds({ context: context2 }), { width, height, panZoom, transform: transform2 } = context2.xystore.getState(), maxZoom = Math.max(1, transform2[2]), viewport = getViewportForBounds(
        bounds,
        width,
        height,
        MinZoom,
        maxZoom,
        context2.fitViewPadding
      );
      viewport.x = Math.round(viewport.x), viewport.y = Math.round(viewport.y), panZoom?.setViewport(viewport, duration > 0 ? { duration } : void 0);
    },
    "xyflow:setViewportCenter": ({ context: context2 }, params) => {
      const { x: x2, y: y2 } = params;
      invariant$2(context2.xyflow, "xyflow is not initialized");
      const zoom2 = context2.xyflow.getZoom();
      context2.xyflow.setCenter(Math.round(x2), Math.round(y2), { zoom: zoom2 });
    },
    "xyflow:setViewport": ({ context: context2 }, params) => {
      const {
        viewport,
        duration = 350
      } = params, { panZoom } = context2.xystore.getState();
      panZoom?.setViewport(viewport, duration > 0 ? { duration } : void 0);
    },
    "xyflow:alignNodeFromToAfterNavigate": ({ context: context2 }, params) => {
      const xyflow2 = nonNullable(context2.xyflow, "xyflow is not initialized"), elFrom = xyflow2.getInternalNode(params.fromNode);
      if (!elFrom) return;
      const fromPos = xyflow2.flowToScreenPosition({
        x: elFrom.internals.positionAbsolute.x,
        // + dimensions.width / 2,
        y: elFrom.internals.positionAbsolute.y
        // + dimensions.height / 2
      }), toPos = xyflow2.flowToScreenPosition(params.toPosition), diff = {
        x: Math.round(fromPos.x - toPos.x),
        y: Math.round(fromPos.y - toPos.y)
      };
      context2.xystore.getState().panBy(diff);
    },
    "layout.align": ({ context: context2 }, params) => {
      const { mode } = params, { xystore } = context2, { nodeLookup, parentLookup } = xystore.getState(), nodesToAlign = [...new Set(nodeLookup.values().filter((n2) => n2.selected).map((n2) => n2.id)).difference(new Set(parentLookup.keys()))];
      if (!i$7(nodesToAlign, 2)) {
        console.warn("At least 2 nodes must be selected to align");
        return;
      }
      const constraints = createLayoutConstraints(xystore, nodesToAlign), aligner = getAligner(mode), nodes = nodesToAlign.map((id2) => ({
        node: nonNullable(nodeLookup.get(id2)),
        rect: nonNullable(constraints.rects.get(id2))
      }));
      aligner.computeLayout(nodes.map(({ node: node2 }) => toNodeRect(node2)));
      for (const { rect, node: node2 } of nodes)
        rect.positionAbsolute = {
          ...rect.positionAbsolute,
          ...aligner.applyPosition(toNodeRect(node2))
        };
      constraints.updateXYFlowNodes();
    },
    updateFeatures: xstate_cjsExports.enqueueActions(({ enqueue, system, event }) => {
      xstate_cjsExports.assertEvent(event, "update.features");
      const { features } = event;
      enqueue.assign({
        features: { ...features }
      });
      const enableOverlays = features.enableElementDetails || features.enableRelationshipDetails || features.enableRelationshipBrowser, hasRunning = typedSystem(system).overlaysActorRef;
      if (enableOverlays && !hasRunning) {
        enqueue.spawnChild("overlaysActorLogic", { id: "overlays", systemId: "overlays" });
        return;
      }
      !enableOverlays && hasRunning && (enqueue.sendTo(hasRunning, {
        type: "close.all"
      }), enqueue.stopChild("overlays"));
    }),
    closeAllOverlays: xstate_cjsExports.sendTo(
      ({ system }) => typedSystem(system).overlaysActorRef,
      {
        type: "close.all"
      }
    ),
    startSyncLayout: xstate_cjsExports.assign(({ context: context2, spawn, self: self2 }) => ({
      syncLayoutActorRef: spawn("syncManualLayoutActorLogic", {
        id: "syncLayout",
        input: { parent: self2, viewId: context2.view.id }
      })
    })),
    stopSyncLayout: xstate_cjsExports.enqueueActions(({ context: context2, enqueue }) => {
      enqueue.sendTo(context2.syncLayoutActorRef, { type: "stop" }), enqueue.stopChild(context2.syncLayoutActorRef), enqueue.assign({
        syncLayoutActorRef: null
      });
    }),
    onNodeMouseEnter: xstate_cjsExports.assign(({ context: context2 }, params) => ({
      xynodes: context2.xynodes.map((n2) => n2.id === params.node.id ? Base.setHovered(n2, !0) : n2)
    })),
    onNodeMouseLeave: xstate_cjsExports.assign(({ context: context2 }, params) => ({
      xynodes: context2.xynodes.map((n2) => n2.id === params.node.id ? Base.setHovered(n2, !1) : n2)
    })),
    onEdgeMouseEnter: xstate_cjsExports.assign(({ context: context2 }, params) => ({
      xyedges: context2.xyedges.map((e2) => e2.id === params.edge.id ? Base.setHovered(e2, !0) : e2)
    })),
    onEdgeMouseLeave: xstate_cjsExports.assign(({ context: context2 }, params) => ({
      xyedges: context2.xyedges.map((e2) => e2.id === params.edge.id ? Base.setHovered(e2, !1) : e2)
    })),
    "notations.highlight": xstate_cjsExports.assign(({ context: context2 }, params) => {
      const kinds = params.kind ? [params.kind] : params.notation.kinds;
      return {
        xynodes: context2.xynodes.map((n2) => {
          const node2 = findDiagramNode(context2, n2.id);
          return node2 && node2.notation === params.notation.title && node2.shape === params.notation.shape && node2.color === params.notation.color && kinds.includes(node2.kind) ? Base.setDimmed(n2, !1) : Base.setDimmed(n2, "immediate");
        }),
        xyedges: context2.xyedges.map(Base.setDimmed("immediate"))
      };
    })
  }
}).createMachine({
  initial: "initializing",
  context: ({ input: input2, self: self2, spawn }) => ({
    ...input2,
    xyedges: [],
    xynodes: [],
    features: { ...AllDisabled },
    toggledFeatures: DiagramToggledFeaturesPersistence.read() ?? {
      enableReadOnly: !0
    },
    initialized: {
      xydata: !1,
      xyflow: !1
    },
    viewportChangedManually: !1,
    lastOnNavigate: null,
    lastClickedNode: null,
    focusedNode: null,
    activeElementDetails: null,
    viewportBeforeFocus: null,
    navigationHistory: {
      currentIndex: 0,
      history: []
    },
    viewport: { x: 0, y: 0, zoom: 1 },
    xyflow: null,
    syncLayoutActorRef: null,
    activeWalkthrough: null
  }),
  // entry: ({ spawn }) => spawn(layoutActor, { id: 'layout', input: { parent: self } }),
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: xstate_cjsExports.assign(({ context: context2, event }) => ({
            initialized: {
              ...context2.initialized,
              xyflow: !0
            },
            xyflow: event.instance
          })),
          target: "isReady"
        },
        "update.view": {
          actions: xstate_cjsExports.assign(({ context: context2, event, spawn, self: self2 }) => ({
            initialized: {
              ...context2.initialized,
              xydata: !0
            },
            view: event.view,
            xynodes: event.xynodes,
            xyedges: event.xyedges
          })),
          target: "isReady"
        }
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        actions: [
          {
            type: "xyflow:fitDiagram",
            params: { duration: 0 }
          },
          xstate_cjsExports.assign(({ context: context2 }) => ({
            navigationHistory: {
              currentIndex: 0,
              history: [{
                viewId: context2.view.id,
                fromNode: null,
                viewport: { ...context2.xyflow.getViewport() }
              }]
            }
          })),
          "startSyncLayout"
        ],
        target: "ready"
      }, {
        target: "initializing"
      }]
    },
    ready: {
      initial: "idle",
      on: {
        "navigate.to": {
          guard: "is another view",
          actions: xstate_cjsExports.assign({
            lastOnNavigate: ({ context: context2, event }) => ({
              fromView: context2.view.id,
              toView: event.viewId,
              fromNode: event.fromNode ?? null
            })
          }),
          target: "#navigating"
        },
        "navigate.back": {
          guard: ({ context: context2 }) => context2.navigationHistory.currentIndex > 0,
          actions: xstate_cjsExports.assign(navigateBack),
          target: "#navigating"
        },
        "navigate.forward": {
          guard: ({ context: context2 }) => context2.navigationHistory.currentIndex < context2.navigationHistory.history.length - 1,
          actions: xstate_cjsExports.assign(navigateForward),
          target: "#navigating"
        },
        "layout.align": {
          guard: "not readonly",
          actions: [
            {
              type: "layout.align",
              params: ({ event }) => ({ mode: event.mode })
            },
            xstate_cjsExports.raise({ type: "saveManualLayout.schedule" })
          ]
        },
        "layout.resetEdgeControlPoints": {
          guard: "not readonly",
          actions: [
            xstate_cjsExports.assign(resetEdgeControlPoints),
            xstate_cjsExports.raise({ type: "saveManualLayout.schedule" })
          ]
        },
        "xyflow.resized": {
          guard: ({ context: context2 }) => context2.features.enableFitView && !context2.viewportChangedManually,
          actions: [
            xstate_cjsExports.cancel("fitDiagram"),
            xstate_cjsExports.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 200 })
          ]
        },
        "open.elementDetails": {
          actions: xstate_cjsExports.sendTo(({ system }) => typedSystem(system).overlaysActorRef, ({ context: context2, event }) => {
            let initiatedFrom = null;
            const fromNodeId = event.fromNode ?? context2.view.nodes.find((n2) => DiagramNode.modelRef(n2) === event.fqn)?.id, internalNode = fromNodeId ? context2.xystore.getState().nodeLookup.get(fromNodeId) : null;
            if (fromNodeId && internalNode) {
              const nodeRect = nodeToRect(internalNode), zoom2 = context2.xyflow.getZoom(), clientRect = {
                ...context2.xyflow.flowToScreenPosition(nodeRect),
                width: nodeRect.width * zoom2,
                height: nodeRect.height * zoom2
              };
              initiatedFrom = {
                node: fromNodeId,
                clientRect
              };
            }
            return {
              type: "open.elementDetails",
              subject: event.fqn,
              currentView: context2.view,
              ...initiatedFrom && { initiatedFrom }
            };
          })
        },
        "open.relationshipsBrowser": {
          actions: xstate_cjsExports.sendTo(({ system }) => typedSystem(system).overlaysActorRef, ({ context: context2, event }) => ({
            type: "open.relationshipsBrowser",
            subject: event.fqn,
            viewId: context2.view.id,
            scope: "view",
            closeable: !0,
            enableChangeScope: !0,
            enableSelectSubject: !0
          }))
        },
        "open.relationshipDetails": {
          actions: xstate_cjsExports.sendTo(({ system }) => typedSystem(system).overlaysActorRef, ({ context: context2, event }) => ({
            type: "open.relationshipDetails",
            viewId: context2.view.id,
            ...event.params
          }))
        },
        "open.source": {
          actions: {
            type: "trigger:OpenSource",
            params: p$2("event")
          }
        },
        "walkthrough.start": {
          guard: "is dynamic view",
          target: ".walkthrough"
        },
        "toggle.feature": {
          actions: xstate_cjsExports.assign({
            toggledFeatures: ({ context: context2, event }) => DiagramToggledFeaturesPersistence.write({
              ...context2.toggledFeatures,
              [`enable${event.feature}`]: event.forceValue ?? !(context2.toggledFeatures[`enable${event.feature}`] ?? context2.features[`enable${event.feature}`])
            })
          })
        },
        "xyflow.nodeMouseEnter": {
          actions: {
            type: "onNodeMouseEnter",
            params: p$2("event")
          }
        },
        "xyflow.nodeMouseLeave": {
          actions: {
            type: "onNodeMouseLeave",
            params: p$2("event")
          }
        },
        "xyflow.edgeMouseEnter": {
          actions: {
            type: "onEdgeMouseEnter",
            params: p$2("event")
          }
        },
        "xyflow.edgeMouseLeave": {
          actions: {
            type: "onEdgeMouseLeave",
            params: p$2("event")
          }
        },
        "notations.highlight": {
          actions: {
            type: "notations.highlight",
            params: p$2("event")
          }
        },
        "notations.unhighlight": {
          actions: xstate_cjsExports.assign(({ context: context2 }) => ({
            xynodes: context2.xynodes.map(Base.setDimmed(!1)),
            xyedges: context2.xyedges.map(Base.setDimmed(!1))
          }))
        },
        "saveManualLayout.*": {
          guard: "not readonly",
          actions: xstate_cjsExports.sendTo((c2) => c2.context.syncLayoutActorRef, ({ event }) => {
            if (event.type === "saveManualLayout.schedule")
              return { type: "sync" };
            if (event.type === "saveManualLayout.cancel")
              return { type: "cancel" };
            nonexhaustive(event);
          })
        }
      },
      exit: [
        xstate_cjsExports.cancel("fitDiagram")
      ],
      states: {
        idle: {
          id: "idle",
          on: {
            "xyflow.nodeClick": [
              {
                // TODO: xstate fails to infer the type of the guard
                guard: xstate_cjsExports.and([
                  "enabled: FocusMode",
                  "click: node has connections",
                  xstate_cjsExports.or([
                    "click: same node",
                    "click: selected node"
                  ])
                ]),
                actions: [
                  xstate_cjsExports.assign({
                    lastClickedNode,
                    focusedNode: ({ event }) => event.node.id
                  })
                ],
                target: "focused"
              },
              {
                actions: [
                  "assign lastClickedNode",
                  "open source of focused or last clicked node"
                ]
              }
            ],
            "xyflow.paneClick": {
              actions: [
                xstate_cjsExports.assign({
                  lastClickedNode: null
                })
              ]
            },
            "xyflow.paneDblClick": {
              actions: [
                { type: "xyflow:fitDiagram" },
                { type: "trigger:OpenSource", params: ({ context: context2 }) => ({ view: context2.view.id }) }
              ]
            },
            "focus.node": {
              guard: "enabled: FocusMode",
              actions: xstate_cjsExports.assign({
                focusedNode: ({ event }) => event.nodeId
              }),
              target: "focused"
            },
            "xyflow.edgeClick": [{
              guard: xstate_cjsExports.and([
                "is dynamic view",
                "click: selected edge"
              ]),
              actions: xstate_cjsExports.raise(({ event }) => ({
                type: "walkthrough.start",
                stepId: event.edge.id
              }))
            }, {
              guard: xstate_cjsExports.and([
                "enabled: RelationshipDetails",
                "click: selected edge"
              ]),
              actions: xstate_cjsExports.sendTo(({ system }) => typedSystem(system).overlaysActorRef, ({ context: context2, event }) => ({
                type: "open.relationshipDetails",
                viewId: context2.view.id,
                edgeId: event.edge.id
              }))
            }]
          }
        },
        focused: {
          entry: [
            xstate_cjsExports.assign((s2) => ({
              ...focusNodesEdges(s2),
              viewportBeforeFocus: { ...s2.context.viewport }
            })),
            "open source of focused or last clicked node",
            xstate_cjsExports.spawnChild("hotkeyActorLogic", { id: "hotkey" }),
            "xyflow:fitFocusedBounds"
          ],
          exit: xstate_cjsExports.enqueueActions(({ enqueue, context: context2, event }) => {
            enqueue.stopChild("hotkey"), context2.viewportBeforeFocus ? enqueue({ type: "xyflow:setViewport", params: { viewport: context2.viewportBeforeFocus } }) : enqueue({ type: "xyflow:fitDiagram" }), enqueue.assign({
              ...unfocusNodesEdges({ context: context2 }),
              viewportBeforeFocus: null,
              focusedNode: null
            });
          }),
          on: {
            "xyflow.nodeClick": [
              {
                guard: "click: focused node",
                target: "#idle"
              },
              {
                actions: [
                  xstate_cjsExports.assign({
                    lastClickedNode
                  }),
                  xstate_cjsExports.raise(({ event }) => ({
                    type: "focus.node",
                    nodeId: event.node.id
                  }))
                ]
              }
            ],
            "focus.node": {
              actions: [
                xstate_cjsExports.assign({
                  focusedNode: ({ event }) => event.nodeId
                }),
                xstate_cjsExports.assign(focusNodesEdges),
                "open source of focused or last clicked node",
                "xyflow:fitFocusedBounds"
              ]
            },
            "key.esc": {
              target: "idle"
            },
            "xyflow.paneClick": {
              actions: xstate_cjsExports.assign({
                lastClickedNode: null
              }),
              target: "idle"
            },
            "notations.unhighlight": {
              actions: xstate_cjsExports.assign((s2) => ({
                ...focusNodesEdges(s2)
              }))
            }
          }
        },
        walkthrough: {
          entry: [
            xstate_cjsExports.spawnChild("hotkeyActorLogic", { id: "hotkey" }),
            xstate_cjsExports.assign({
              viewportBeforeFocus: ({ context: context2 }) => context2.viewport,
              activeWalkthrough: ({ context: context2, event }) => {
                xstate_cjsExports.assertEvent(event, "walkthrough.start");
                const stepId = event.stepId ?? d(context2.xyedges).id;
                return {
                  stepId,
                  parallelPrefix: getParallelStepsPrefix(stepId)
                };
              }
            }),
            xstate_cjsExports.assign(updateActiveWalkthrough),
            "xyflow:fitFocusedBounds"
          ],
          on: {
            "key.esc": {
              target: "idle"
            },
            "key.arrow.left": {
              actions: xstate_cjsExports.raise({ type: "walkthrough.step", direction: "previous" })
            },
            "key.arrow.right": {
              actions: xstate_cjsExports.raise({ type: "walkthrough.step", direction: "next" })
            },
            "walkthrough.step": {
              actions: xstate_cjsExports.enqueueActions(({ enqueue, context: context2, event }) => {
                const { stepId } = context2.activeWalkthrough, stepIndex = context2.xyedges.findIndex((e2) => e2.id === stepId), nextStepIndex = u(event.direction === "next" ? stepIndex + 1 : stepIndex - 1, {
                  min: 0,
                  max: context2.xyedges.length - 1
                });
                if (nextStepIndex === stepIndex)
                  return;
                const nextStepId = context2.xyedges[nextStepIndex].id;
                enqueue.assign({
                  activeWalkthrough: {
                    stepId: nextStepId,
                    parallelPrefix: getParallelStepsPrefix(nextStepId)
                  }
                }), enqueue.assign(updateActiveWalkthrough), enqueue("xyflow:fitFocusedBounds");
              })
            },
            "xyflow.edgeClick": {
              actions: [
                xstate_cjsExports.assign(({ event, context: context2 }) => !isStepEdgeId(event.edge.id) || event.edge.id === context2.activeWalkthrough?.stepId ? {} : {
                  activeWalkthrough: {
                    stepId: event.edge.id,
                    parallelPrefix: getParallelStepsPrefix(event.edge.id)
                  }
                }),
                xstate_cjsExports.assign(updateActiveWalkthrough),
                "xyflow:fitFocusedBounds"
              ]
            },
            "notations.unhighlight": {
              actions: xstate_cjsExports.assign((s2) => ({
                ...updateActiveWalkthrough(s2)
              }))
            },
            "walkthrough.end": {
              target: "idle"
            },
            "xyflow.paneDblClick": {
              target: "idle"
            },
            // We received another view, close overlay and process event again
            "update.view": {
              guard: "is another view",
              actions: xstate_cjsExports.raise(({ event }) => event, { delay: 50 }),
              target: "idle"
            }
          },
          exit: xstate_cjsExports.enqueueActions(({ enqueue, context: context2, event }) => {
            enqueue.stopChild("hotkey"), context2.viewportBeforeFocus ? enqueue({ type: "xyflow:setViewport", params: { viewport: context2.viewportBeforeFocus } }) : enqueue({ type: "xyflow:fitDiagram" }), enqueue.assign({
              activeWalkthrough: null,
              ...unfocusNodesEdges({ context: context2 }),
              viewportBeforeFocus: null
            });
          })
        }
      }
    },
    // Navigating to another view (after `navigateTo` event)
    navigating: {
      id: "navigating",
      entry: [
        "closeAllOverlays",
        "stopSyncLayout",
        {
          type: "trigger:NavigateTo",
          params: ({ context: context2 }) => ({
            viewId: nonNullable(context2.lastOnNavigate, "Invalid state, lastOnNavigate is null").toView
          })
        }
      ],
      on: {
        "update.view": {
          actions: xstate_cjsExports.enqueueActions(({ enqueue, context: context2, event }) => {
            const { fromNode, toNode } = findCorrespondingNode(context2, event);
            enqueue(fromNode && toNode ? {
              type: "xyflow:alignNodeFromToAfterNavigate",
              params: {
                fromNode: fromNode.id,
                toPosition: {
                  x: toNode.position[0],
                  y: toNode.position[1]
                }
              }
            } : {
              type: "xyflow:setViewportCenter",
              params: getBBoxCenter(event.view.bounds)
            }), enqueue.assign(updateNavigationHistory), enqueue.assign({
              ...mergeXYNodesEdges({ context: context2, event }),
              lastOnNavigate: null
            }), enqueue("startSyncLayout"), enqueue.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 25 });
          }),
          target: "#idle"
        }
      }
    }
  },
  on: {
    "xyflow.applyNodeChanges": {
      actions: xstate_cjsExports.assign({
        xynodes: ({ context: context2, event }) => applyNodeChanges(event.changes, context2.xynodes)
      })
    },
    "xyflow.applyEdgeChanges": {
      actions: xstate_cjsExports.assign({
        xyedges: ({ context: context2, event }) => applyEdgeChanges(event.changes, context2.xyedges)
      })
    },
    "xyflow.viewportMoved": {
      actions: xstate_cjsExports.assign({
        viewportChangedManually: ({ event }) => event.manually,
        viewport: ({ event }) => event.viewport
      })
    },
    fitDiagram: {
      guard: "enabled: FitView",
      actions: {
        type: "xyflow:fitDiagram",
        params: p$2("event")
      }
    },
    "update.nodeData": {
      actions: xstate_cjsExports.assign(updateNodeData)
    },
    "update.edgeData": {
      actions: xstate_cjsExports.assign(updateEdgeData)
    },
    "update.view": {
      actions: [
        xstate_cjsExports.assign(updateNavigationHistory),
        xstate_cjsExports.enqueueActions(({ enqueue, event, check, context: context2 }) => {
          const isAnotherView = check("is another view");
          if (isAnotherView) {
            enqueue("closeAllOverlays"), enqueue("stopSyncLayout"), enqueue.assign({
              focusedNode: null
            });
            const { fromNode, toNode } = findCorrespondingNode(context2, event);
            fromNode && toNode ? (enqueue({
              type: "xyflow:alignNodeFromToAfterNavigate",
              params: {
                fromNode: fromNode.id,
                toPosition: {
                  x: toNode.position[0],
                  y: toNode.position[1]
                }
              }
            }), enqueue.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 80 })) : (enqueue({
              type: "xyflow:setViewportCenter",
              params: getBBoxCenter(event.view.bounds)
            }), enqueue.raise({ type: "fitDiagram", duration: 200 }, { id: "fitDiagram", delay: 25 }));
          }
          enqueue.assign({
            ...mergeXYNodesEdges({ context: context2, event }),
            lastOnNavigate: null
          }), isAnotherView ? enqueue("startSyncLayout") : (enqueue.sendTo((c2) => c2.context.syncLayoutActorRef, { type: "synced" }), context2.viewportChangedManually || enqueue.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 50 }));
        })
      ]
    },
    "update.inputs": {
      actions: xstate_cjsExports.assign(({ event }) => ({ ...event.inputs }))
    },
    "update.features": {
      actions: "updateFeatures"
    }
  },
  exit: [
    "stopSyncLayout",
    xstate_cjsExports.cancel("fitDiagram"),
    xstate_cjsExports.stopChild("hotkey"),
    xstate_cjsExports.assign({
      xyflow: null,
      xystore: null,
      xyedges: [],
      xynodes: [],
      initialized: {
        xydata: !1,
        xyflow: !1
      },
      syncLayoutActorRef: null
    })
  ]
}), nodeRef = (node2) => DiagramNode.modelRef(node2) ?? DiagramNode.deploymentRef(node2);
function findCorrespondingNode(context2, event) {
  const fromNodeId = context2.lastOnNavigate?.fromNode, fromNode = fromNodeId && context2.view.nodes.find((n2) => n2.id === fromNodeId), fromRef = fromNode && nodeRef(fromNode), toNode = fromRef && event.view.nodes.find((n2) => nodeRef(n2) === fromRef);
  return { fromNode, toNode };
}
const selectToggledFeatures = (state) => state.context.toggledFeatures;
function DiagramActorProvider({
  input: {
    view,
    ...inputs
  },
  where,
  children: children2
}) {
  const handlersRef = useDiagramEventHandlersRef(), xystore = useStoreApi(), actorRef = xstateReact_cjsExports.useActorRef(
    diagramMachine.provide({
      actions: {
        "trigger:NavigateTo": (_, { viewId }) => {
          setTimeout(() => {
            handlersRef.current.onNavigateTo?.(viewId);
          }, 30);
        },
        "trigger:OnChange": (_, params) => {
          handlersRef.current.onChange?.(params);
        },
        "trigger:OpenSource": (_, params) => {
          handlersRef.current.onOpenSource?.(params);
        }
      },
      actors: {
        syncManualLayoutActorLogic: syncManualLayoutActorLogic.provide({
          actions: {
            "trigger:OnChange": (_, params) => {
              handlersRef.current.onChange?.(params);
            }
          }
        })
      }
    }),
    {
      id: `diagram:${view.id}`,
      systemId: "diagram",
      // ...inspector,
      input: {
        xystore,
        view,
        ...inputs
      }
    }
  ), features = useEnabledFeatures();
  useUpdateEffect(() => {
    actorRef.send({ type: "update.inputs", inputs });
  }, [inputs]), useEffect(() => {
    actorRef.send({ type: "update.features", features });
  }, [features]);
  const { xyedges, xynodes } = useViewToNodesEdges({
    view,
    where,
    nodesSelectable: inputs.nodesSelectable
  });
  useDeepCompareEffect(() => {
    actorRef.send({ type: "update.view", view, xyedges, xynodes });
  }, [view, xyedges, xynodes]);
  const toggledFeatures = xstateReact_cjsExports.useSelector(actorRef, selectToggledFeatures, shallowEqual);
  return /* @__PURE__ */ jsx(DiagramActorContextProvider, { value: actorRef, children: /* @__PURE__ */ jsx(DiagramFeatures, { overrides: toggledFeatures, children: children2 }) });
}
function LikeC4Diagram({
  onCanvasClick,
  onCanvasContextMenu,
  onCanvasDblClick,
  onEdgeClick,
  onChange,
  onEdgeContextMenu,
  onNavigateTo,
  onNodeClick,
  onNodeContextMenu,
  onOpenSource,
  onBurgerMenuClick,
  view,
  className,
  fitView = !0,
  fitViewPadding = "8px",
  readonly = !0,
  pannable = !0,
  zoomable = !0,
  background = "dots",
  enableFocusMode = !1,
  enableElementDetails = !1,
  enableRelationshipDetails = enableElementDetails,
  enableRelationshipBrowser = enableRelationshipDetails,
  nodesDraggable = !readonly,
  nodesSelectable = !readonly || enableFocusMode || !!onNavigateTo || !!onNodeClick,
  controls = !readonly,
  showDiagramTitle = !0,
  showNotations = !0,
  showNavigationButtons = !!onNavigateTo,
  enableDynamicViewWalkthrough = !1,
  enableSearch = !0,
  initialWidth,
  initialHeight,
  experimentalEdgeEditing = !readonly,
  reduceGraphics = "auto",
  renderIcon,
  renderControls,
  where,
  reactFlowProps = {},
  children: children2
}) {
  const hasLikec4model = !!useLikeC4Model$1(), initialRef = useRef(null), isDynamicView = view.__ === "dynamic";
  initialRef.current == null && (initialRef.current = {
    defaultEdges: [],
    defaultNodes: [],
    initialWidth: initialWidth ?? view.bounds.width,
    initialHeight: initialHeight ?? view.bounds.height
  });
  const isReducedGraphicsMode = reduceGraphics === "auto" ? pannable && (view.bounds?.width ?? 1) * (view.bounds?.height ?? 1) > 6e6 : reduceGraphics;
  return /* @__PURE__ */ jsx(EnsureMantine, { children: /* @__PURE__ */ jsx(
    FramerMotionConfig,
    {
      ...isReducedGraphicsMode && { reducedMotion: "always" },
      children: /* @__PURE__ */ jsx(IconRendererProvider, { value: renderIcon ?? null, children: /* @__PURE__ */ jsx(
        DiagramFeatures,
        {
          features: {
            enableFitView: fitView,
            enableReadOnly: readonly,
            enableFocusMode,
            enableNavigateTo: !!onNavigateTo,
            enableElementDetails,
            enableRelationshipDetails,
            enableRelationshipBrowser,
            enableSearch,
            enableNavigationButtons: showNavigationButtons && !!onNavigateTo,
            enableDynamicViewWalkthrough: isDynamicView && enableDynamicViewWalkthrough,
            enableEdgeEditing: experimentalEdgeEditing,
            enableNotations: showNotations,
            enableVscode: !!onOpenSource,
            enableControls: controls,
            enableViewTitle: showDiagramTitle,
            enableLikeC4Model: hasLikec4model
          },
          children: /* @__PURE__ */ jsx(
            DiagramEventHandlers,
            {
              handlers: {
                onCanvasClick,
                onCanvasContextMenu,
                onCanvasDblClick,
                onEdgeClick,
                onChange,
                onEdgeContextMenu,
                onNavigateTo,
                onNodeClick,
                onNodeContextMenu,
                onOpenSource,
                onBurgerMenuClick
              },
              children: /* @__PURE__ */ jsx(ReduceGraphicsContext, { reduceGraphics: isReducedGraphicsMode, children: /* @__PURE__ */ jsxs(RootContainer, { className, reduceGraphics: isReducedGraphicsMode, children: [
                !n$3(view.customColorDefinitions) && /* @__PURE__ */ jsx(LikeC4CustomColors, { customColors: view.customColorDefinitions }),
                /* @__PURE__ */ jsx(
                  ReactFlowProvider,
                  {
                    fitView,
                    ...initialRef.current,
                    children: /* @__PURE__ */ jsx(
                      DiagramActorProvider,
                      {
                        input: {
                          view,
                          pannable,
                          zoomable,
                          nodesSelectable,
                          fitViewPadding
                        },
                        children: /* @__PURE__ */ jsx(ControlsCustomLayoutProvider, { value: renderControls ?? null, children: /* @__PURE__ */ jsx(
                          LikeC4DiagramXYFlow,
                          {
                            nodesDraggable,
                            nodesSelectable,
                            background,
                            reactFlowProps,
                            children: children2
                          }
                        ) })
                      }
                    )
                  }
                )
              ] }) })
            }
          )
        }
      ) })
    }
  ) });
}
function LikeC4ModelProvider({
  children: children2,
  likec4model
}) {
  return /* @__PURE__ */ jsx(LikeC4ModelContext$1.Provider, { value: likec4model, children: children2 });
}
function StaticLikeC4Diagram({
  view,
  fitView = !0,
  fitViewPadding = "8px",
  enableElementDetails = !1,
  enableRelationshipDetails = !1,
  enableRelationshipBrowser = enableRelationshipDetails,
  background = "transparent",
  ...rest
}) {
  return /* @__PURE__ */ jsx(
    LikeC4Diagram,
    {
      view,
      readonly: !0,
      fitView,
      fitViewPadding,
      pannable: !1,
      zoomable: !1,
      controls: !1,
      background,
      showDiagramTitle: !1,
      showNotations: !1,
      enableElementDetails,
      enableRelationshipDetails,
      enableRelationshipBrowser,
      enableDynamicViewWalkthrough: !1,
      showNavigationButtons: !1,
      experimentalEdgeEditing: !1,
      enableFocusMode: !1,
      enableSearch: !1,
      nodesSelectable: !1,
      nodesDraggable: !1,
      ...rest
    }
  );
}
function Fallback$1({ error, resetErrorBoundary }) {
  const router = useRouter();
  return isNotFound(error) ? /* @__PURE__ */ jsx(Container, { my: "md", children: /* @__PURE__ */ jsxs(Alert, { variant: "light", color: "orange", children: [
    /* @__PURE__ */ jsxs(Text, { c: "orange", fz: "md", children: [
      "The diagram",
      " ",
      /* @__PURE__ */ jsx(Code, { color: "orange" }),
      " ",
      "does not exist or contains errors"
    ] }),
    /* @__PURE__ */ jsx(
      Button,
      {
        onClick: () => {
          resetErrorBoundary(), router.navigate({
            to: "/",
            search: !0
          });
        },
        variant: "light",
        color: "orange",
        mt: "lg",
        size: "xs",
        children: "Go to overview"
      }
    )
  ] }) }) : /* @__PURE__ */ jsx(Container, { my: "md", children: /* @__PURE__ */ jsxs(Alert, { variant: "filled", color: "red", title: "Something went wrong", children: [
    /* @__PURE__ */ jsx(Code, { block: !0, color: "red", children: error.stack ?? error.message }),
    /* @__PURE__ */ jsx(Button, { onClick: resetErrorBoundary, color: "red", variant: "white", mt: "lg", size: "xs", children: "Try again" })
  ] }) });
}
const LikeC4ModelDataContext = createContext(null);
function useLikeC4ModelDataContext() {
  return useContext(LikeC4ModelDataContext);
}
function LikeC4ModelContext({ likec4data, children: children2 }) {
  const $likec4model = useMemo(() => computed(likec4data, (data) => createLikeC4Model(data)), [likec4data]), model = useStore($likec4model);
  return /* @__PURE__ */ jsx(LikeC4ModelDataContext.Provider, { value: likec4data, children: /* @__PURE__ */ jsx(LikeC4ModelProvider, { likec4model: model, children: children2 }) });
}
css({
  position: "absolute",
  inset: 0,
  zIndex: 1
});
const svgContainer = css({
  minWidth: 300,
  "& svg": {
    width: "100%",
    height: "auto"
  }
}), headerHeight$1 = {
  var: "--header-height",
  ref: "var(--header-height)"
}, cssViewOutlet = css({
  padding: 0,
  margin: 0,
  // paddingTop: headerHeight,
  width: "100%",
  height: "100%",
  // position: 'absolute',
  // top: headerHeight,
  // left: 0,
  // width: '100vw',
  // height: `calc(100vh - ${headerHeight})`
  [headerHeight$1.var]: "60px",
  // TODO: temporary hack to fix the navigation webview position
  "--likec4-options-panel-top": "60px",
  "--likec4-options-panel-right": "10px"
  // ['--likec4-navigation-webview-top']: '0.8rem',
  // ['--likec4-navigation-webview-left']: '3.2rem'
});
css({
  boxSizing: "border-box",
  border: "0px solid transparent",
  padding: 0,
  margin: 0,
  marginRight: "auto",
  marginBottom: "auto",
  background: "transparent"
});
const cssWebcomponentView = css({
  position: "fixed",
  inset: 0,
  width: "100%",
  height: "100%"
}), cssWebcomponentIframeContainer = css({
  flex: 1,
  width: "100%",
  height: "100%",
  overflow: "hidden",
  "& iframe": {
    width: "100%",
    height: "100%",
    borderStyle: "none",
    backgroundColor: "transparent",
    overflow: "hidden"
  }
}), Route$j = createFileRoute("/_single")({
  loader: async ({ params }) => await import("likec4:single-project"),
  component: RouteComponent$2
});
function RouteComponent$2() {
  const { $likec4data, IconRenderer: IconRenderer2 } = Route$j.useLoaderData();
  return /* @__PURE__ */ jsx(Box$1, { className: cssViewOutlet, children: /* @__PURE__ */ jsx(reactErrorBoundary_cjsExports.ErrorBoundary, { FallbackComponent: Fallback$1, children: /* @__PURE__ */ jsx(LikeC4ModelContext, { likec4data: $likec4data, children: /* @__PURE__ */ jsx(IconRendererProvider, { value: IconRenderer2, children: /* @__PURE__ */ jsx(Outlet, {}) }) }) }) });
}
const Route$i = createFileRoute("/")({
  beforeLoad: () => {
    if (!isSingleProject)
      throw redirect({
        to: "/projects/",
        replace: !0
      });
  },
  component: () => /* @__PURE__ */ jsx(
    Navigate,
    {
      to: "/single-index/",
      mask: {
        to: "/",
        unmaskOnReload: !0
      }
    }
  )
});
css({
  color: "mantine.colors.dimmed"
});
css({
  // background: 'var(--color-surface)',
});
const previewBg = css({
  position: "relative",
  overflow: "hidden",
  padding: 0,
  margin: 0,
  backgroundOrigin: "padding-box",
  backgroundImage: "radial-gradient({colors.mantine.colors.defaultBorder} 15%, {colors.mantine.colors.body} 15%)",
  backgroundPosition: "0 0",
  backgroundSize: "12px 12px",
  _after: {
    content: '" "',
    position: "absolute",
    top: "0",
    left: "0",
    right: "0",
    bottom: "0",
    zIndex: "1"
  }
}), cardLink = css({
  position: "absolute",
  inset: 0,
  zIndex: 5
}), Route$h = createFileRoute("/_single/single-index")({
  component: RouteComponent$1
});
function RouteComponent$1() {
  useDocumentTitle("LikeC4");
  const views = t$4(useLikeC4Model$1(!0).$model.views);
  return /* @__PURE__ */ jsx(
    SimpleGrid,
    {
      p: { base: "md", sm: "xl" },
      cols: { base: 1, sm: 2, md: 3, lg: 5 },
      spacing: { base: 10, sm: "xl" },
      verticalSpacing: { base: "md", sm: "xl" },
      children: views.map((v) => /* @__PURE__ */ jsx(ViewCard, { viewId: v }, v))
    }
  );
}
const ViewCard = memo$2(({ viewId }) => {
  const diagram = useLikeC4Model$1(!0, "layouted").findView(viewId)?.$view;
  if (!diagram)
    return null;
  const { id: id2, title: title2, description: description2 } = diagram;
  return /* @__PURE__ */ jsxs(
    Card,
    {
      shadow: "xs",
      padding: "lg",
      radius: "sm",
      withBorder: !0,
      children: [
        /* @__PURE__ */ jsx(Card.Section, { children: /* @__PURE__ */ jsx(DiagramPreview$1, { diagram }) }),
        /* @__PURE__ */ jsx(Group, { justify: "space-between", mt: "md", mb: "xs", children: /* @__PURE__ */ jsx(Text, { fw: 500, children: title2 }) }),
        /* @__PURE__ */ jsx(Text, { size: "sm", c: "dimmed", children: description2 }),
        /* @__PURE__ */ jsx(Link$1, { to: "/view/$viewId/", params: { viewId: id2 }, search: !0, className: cardLink })
      ]
    }
  );
});
function DiagramPreview$1({ diagram }) {
  const { ref, inViewport } = useInViewport(), [visible2, setVisible] = useState(inViewport);
  return useLayoutEffect$1(() => {
    inViewport && !visible2 && setVisible(!0);
  }, [inViewport]), /* @__PURE__ */ jsx(Box$1, { ref, className: previewBg, style: { height: 175 }, children: visible2 && /* @__PURE__ */ jsx(
    StaticLikeC4Diagram,
    {
      background: "transparent",
      view: diagram,
      fitView: !0,
      fitViewPadding: "4px",
      reduceGraphics: !0
    }
  ) });
}
const Route$g = createFileRoute("/project/$projectId")({
  loader: async ({ params }) => {
    const { $likec4data } = await loadModel(params.projectId);
    return {
      $likec4data,
      IconRenderer: ProjectIcons(params.projectId)
    };
  },
  component: RouteComponent
});
function RouteComponent() {
  const { $likec4data, IconRenderer: IconRenderer2 } = Route$g.useLoaderData();
  return /* @__PURE__ */ jsx(Box$1, { className: cssViewOutlet, children: /* @__PURE__ */ jsx(reactErrorBoundary_cjsExports.ErrorBoundary, { FallbackComponent: Fallback$1, children: /* @__PURE__ */ jsx(LikeC4ModelContext, { likec4data: $likec4data, children: /* @__PURE__ */ jsx(IconRendererProvider, { value: IconRenderer2, children: /* @__PURE__ */ jsx(Outlet, {}) }) }) }) });
}
const Route$f = createFileRoute("/project/$projectId/")({
  component: () => {
    const { projectId: projectId2 } = Route$f.useParams();
    return /* @__PURE__ */ jsx(
      Navigate,
      {
        to: "/project/$projectId/view/$viewId/",
        replace: !0,
        params: {
          projectId: projectId2,
          viewId: "index"
        }
      }
    );
  }
}), Route$e = createFileRoute("/_single/webcomponent/$")({
  component: WebcomponentPage
});
function WebcomponentPage() {
  const router = useRouter(), viewId = Route$e.useParams()._splat || "index", { colorScheme } = useMantineColorScheme();
  let base = router.basepath.endsWith("/") ? router.basepath : `${router.basepath}/`;
  const jsurl = new URL(
    `${base}likec4-views.js`,
    window.location.href
  ), iframeHtml = `
    <!DOCTYPE html>
    <html lang="en-US" style="color-scheme: ${colorScheme};">
    <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" />
      <style>
        * {
          border-width: 0px;
          border-style: solid;
          box-sizing: border-box;
          overflow-wrap: break-word;
        }
        html, body {
          margin: 0;
          background-color: transparent !important;
          width: 100%;
          height: 100%;
          font-size: 16px;
        }
        body {
          position: relative;
          min-height: 100%;
          padding: clamp(0.5rem, 5vh, 4rem) clamp(0.5rem, 5vw, 5rem);
        }
      </style>
    </head>
    <body>
      <script type="module" src="${jsurl.href}"><\/script>
      <${ComponentName.View} view-id="${encodeURIComponent(viewId)}"></${ComponentName.View}>
    </body>
    </html>
  `;
  return /* @__PURE__ */ jsx(Flex, { direction: "column", className: cssWebcomponentView, children: /* @__PURE__ */ jsx(Box$1, { className: cssWebcomponentIframeContainer, children: /* @__PURE__ */ jsx(
    "iframe",
    {
      srcDoc: iframeHtml,
      allowtransparency: "true"
    }
  ) }) });
}
function useTransparentBackground(enabled = !0) {
  useIsomorphicLayoutEffect(() => {
    const htmlEl = document.body.parentElement;
    if (!htmlEl || enabled !== !0) return;
    const classname = "transparent-bg";
    return htmlEl.classList.add(classname), () => {
      htmlEl.classList.remove(classname);
    };
  }, [enabled]);
}
function useLikeC4Views() {
  const $likec4data = useLikeC4ModelDataContext(), $viewsAtom = useMemo(() => computed($likec4data, (model) => r$6(model.views)), [$likec4data]);
  return useStore($viewsAtom);
}
function useCurrentDiagram() {
  const viewId = useParams({
    select: (params) => params.viewId ?? "index",
    strict: !1
  }), $likec4data = useLikeC4ModelDataContext(), $viewAtom = useMemo(() => computed($likec4data, (model) => model.views[viewId] ?? null), [viewId, $likec4data]);
  return useStore($viewAtom);
}
function useCurrentProjectd() {
  return useParams({
    select: (params) => params.projectId,
    strict: !1
  }) ?? projects[0];
}
const isTreeNodeData = (node2) => "type" in node2 && ["file", "folder", "view", "deployment-view"].includes(node2.type);
function dropFilename(relativePath) {
  return relativePath === "" ? "" : relativePath.split("/").slice(0, -1).join("/");
}
function compareTreeNodes(a2, b2) {
  return a2.children.length === 0 && b2.children.length > 0 ? 1 : a2.children.length > 0 && b2.children.length === 0 ? -1 : compareNatural(a2.label, b2.label);
}
function buildDiagramTreeData(views, groupBy) {
  const root2 = {
    value: "",
    label: "Diagrams",
    type: "folder",
    children: []
  }, findParent = (path) => {
    let parent = root2;
    if (path === "")
      return parent;
    const segments = path.split("/"), traversed = ["@fs"];
    for (; segments.length; ) {
      const label2 = segments.shift();
      traversed.push(label2);
      const value = traversed.join("/");
      let node2 = f(parent.children, (n2) => n2.value === value);
      node2 || (node2 = { label: label2, value, type: "folder", children: [] }, parent.children.push(node2)), parent = node2;
    }
    return parent;
  };
  for (const view of views) {
    let relativePath;
    switch (groupBy) {
      case "by-files":
        relativePath = view.relativePath ?? "";
        break;
      case "by-folders":
        relativePath = dropFilename(view.relativePath ?? "");
        break;
      case "none":
        relativePath = "";
        break;
      default:
        nonexhaustive(groupBy);
    }
    const parent = findParent(relativePath);
    parent.children.push({
      value: view.id,
      label: view.title ?? view.id,
      type: ComputedView.isDeployment(view) ? "deployment-view" : "view",
      children: []
    }), parent !== root2 && (parent.children.sort(compareTreeNodes), groupBy === "by-files" && parent.type !== "file" && (parent.type = "file"));
  }
  return root2.children.sort(compareTreeNodes);
}
function useDiagramsTreeData(groupBy = "by-files") {
  const views = useLikeC4Views();
  return useMemo(() => buildDiagramTreeData(views, groupBy), [views, groupBy]);
}
const isFile = (node2) => isTreeNodeData(node2) && node2.type === "file", FolderIcon = ({ node: node2, expanded }) => isFile(node2) ? /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "indigo", children: /* @__PURE__ */ jsx(IconFileCode, { size: 16 }) }) : /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "violet", children: expanded ? /* @__PURE__ */ jsx(IconFolderOpen, { size: 16 }) : /* @__PURE__ */ jsx(IconFolderFilled, { size: 16 }) }), DiagramsTree = /* @__PURE__ */ memo$2(({ groupBy }) => {
  const data = useDiagramsTreeData(groupBy), router = useRouter(), diagram = useCurrentDiagram(), viewId = diagram?.id ?? null, tree = useTree({
    multiple: !1
  }), relativePath = diagram?.relativePath ?? null;
  useUpdateEffect(() => {
    tree.collapseAllNodes();
  }, [groupBy]), useEffect(() => {
    if (relativePath) {
      const segments = relativePath.split("/");
      let path = "@fs";
      for (const segment of segments)
        path += `/${segment}`, tree.expand(path);
    }
  }, [relativePath, groupBy]), useEffect(() => {
    viewId && tree.select(viewId);
  }, [viewId]);
  const theme2 = useComputedColorScheme();
  return /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(
    Tree,
    {
      allowRangeSelection: !1,
      tree,
      data,
      styles: {
        node: {
          marginTop: 2,
          marginBottom: 2
        }
      },
      levelOffset: "md",
      renderNode: ({ node: node2, selected: selected2, expanded, elementProps, hasChildren }) => /* @__PURE__ */ jsx(DiagramPreviewHoverCard, { viewId: hasChildren ? null : node2.value, ...elementProps, children: /* @__PURE__ */ jsx(
        Button,
        {
          fullWidth: !0,
          color: theme2 === "light" ? "dark" : "gray",
          variant: selected2 ? "transparent" : "subtle",
          size: "sm",
          fz: "sm",
          fw: hasChildren ? "600" : "500",
          justify: "flex-start",
          styles: {
            section: {
              opacity: 0.5
            }
          },
          leftSection: /* @__PURE__ */ jsxs(Fragment$1, { children: [
            !hasChildren && node2.value === "index" && /* @__PURE__ */ jsx(IconStarFilled, { size: 14, opacity: 0.7 }),
            !hasChildren && node2.value !== "index" && isTreeNodeData(node2) && /* @__PURE__ */ jsxs(Fragment$1, { children: [
              node2.type === "deployment-view" && /* @__PURE__ */ jsx(IconStack2, { size: 14 }),
              node2.type === "view" && /* @__PURE__ */ jsx(IconLayoutDashboard, { size: 14 })
            ] }),
            hasChildren && /* @__PURE__ */ jsx(FolderIcon, { node: node2, expanded })
          ] }),
          ...!hasChildren && {
            onClick: (e2) => {
              e2.stopPropagation(), router.commitLocation(
                router.buildLocation({
                  to: ".",
                  params: (p2) => ({
                    ...p2,
                    viewId: node2.value
                  })
                })
              );
            }
          },
          children: node2.label
        }
      ) })
    }
  ) });
});
function DiagramPreviewHoverCard({
  viewId,
  children: children2,
  ...props
}) {
  return viewId ? /* @__PURE__ */ jsx(Box$1, { ...props, children: /* @__PURE__ */ jsx(DiagramPreview, { viewId, onClick: props.onClick, children: children2 }) }) : /* @__PURE__ */ jsx(Box$1, { ...props, children: children2 });
}
function DiagramPreview({
  viewId,
  children: children2,
  onClick
}) {
  const diagram = useLikeC4Model$1(!0, "layouted").view(viewId).$view;
  if (!diagram)
    return children2;
  const ratio = Math.max(diagram.bounds.width / 400, diagram.bounds.height / 300), width = Math.round(diagram.bounds.width / ratio), height = Math.round(diagram.bounds.height / ratio);
  return /* @__PURE__ */ jsxs(HoverCard, { position: "right-start", openDelay: 400, closeDelay: 100, keepMounted: !1, shadow: "lg", children: [
    /* @__PURE__ */ jsx(HoverCardTarget, { children: children2 }),
    /* @__PURE__ */ jsx(HoverCardDropdown, { style: { width, height }, p: "xs", onClick, children: /* @__PURE__ */ jsx(
      StaticLikeC4Diagram,
      {
        view: diagram,
        fitView: !0,
        fitViewPadding: "4px",
        enableElementDetails: !1,
        reduceGraphics: !0,
        initialWidth: width,
        initialHeight: height
      }
    ) })
  ] });
}
const drawerOpenedAtom = atom(!1);
onMount(drawerOpenedAtom, () => {
  drawerOpenedAtom.set(!1);
});
const useDrawerOpened = () => useStore(drawerOpenedAtom), SidebarDrawerOps = {
  open: () => drawerOpenedAtom.set(!0),
  close: () => drawerOpenedAtom.set(!1)
};
function SidebarDrawer() {
  const opened = useDrawerOpened(), [grouping, setGrouping] = useLocalStorage({
    key: "sidebar-drawer-grouping",
    defaultValue: "by-files"
  });
  return /* @__PURE__ */ jsxs(
    Drawer.Root,
    {
      keepMounted: !0,
      opened,
      scrollAreaComponent: ScrollArea.Autosize,
      onClose: SidebarDrawerOps.close,
      children: [
        /* @__PURE__ */ jsx(Drawer.Overlay, { blur: 2 }),
        /* @__PURE__ */ jsxs(Drawer.Content, { children: [
          /* @__PURE__ */ jsxs(Drawer.Header, { children: [
            /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
              /* @__PURE__ */ jsx(
                Button,
                {
                  component: Link$1,
                  to: "/",
                  leftSection: /* @__PURE__ */ jsx(IconArrowLeft, { size: 14 }),
                  color: "dimmed",
                  variant: "subtle",
                  px: rem(5),
                  styles: {
                    section: {
                      marginInlineEnd: 4
                    }
                  },
                  size: "xs",
                  children: "Overview"
                }
              ),
              /* @__PURE__ */ jsx(
                SegmentedControl,
                {
                  size: "xs",
                  withItemsBorders: !1,
                  value: grouping,
                  onChange: setGrouping,
                  data: [
                    { label: "By files", value: "by-files" },
                    { label: "By folders", value: "by-folders" },
                    { label: "List", value: "none" }
                  ]
                }
              ),
              /* @__PURE__ */ jsx(
                Button,
                {
                  leftSection: /* @__PURE__ */ jsx(IconStarFilled, { size: 12, stroke: 2 }),
                  color: "dimmed",
                  variant: "subtle",
                  px: rem(5),
                  styles: {
                    section: {
                      marginInlineEnd: 4
                    }
                  },
                  size: "xs",
                  renderRoot: (props) => /* @__PURE__ */ jsx(
                    Link$1,
                    {
                      to: "/view/$viewId",
                      params: { viewId: "index" },
                      ...props
                    }
                  ),
                  children: "Open index"
                }
              )
            ] }),
            /* @__PURE__ */ jsx(Drawer.CloseButton, {})
          ] }),
          /* @__PURE__ */ jsx(Drawer.Body, { children: /* @__PURE__ */ jsx(DiagramsTree, { groupBy: grouping }) })
        ] })
      ]
    }
  );
}
function ColorSchemeToggle() {
  const { setColorScheme } = useMantineColorScheme(), computedColorScheme = useComputedColorScheme("light", { getInitialValueInEffect: !0 });
  return /* @__PURE__ */ jsx(
    ActionIcon$1,
    {
      visibleFrom: "sm",
      size: "md",
      variant: "subtle",
      color: "gray",
      onClick: () => setColorScheme(computedColorScheme === "light" ? "dark" : "light"),
      "aria-label": "Toggle color scheme",
      children: computedColorScheme === "light" ? /* @__PURE__ */ jsx(IconMoonStars, { stroke: 1.5 }) : /* @__PURE__ */ jsx(IconSun, { stroke: 1.5 })
    }
  );
}
const cssHeader = css({
  position: "absolute",
  backgroundColor: "mantine.colors.body/80",
  _dark: {
    backgroundColor: "mantine.colors.dark[6]/60"
  },
  "#likec4-root:has([data-likec4-diagram-panning]) &": {
    boxShadow: "none",
    borderRadius: "0px",
    backgroundColor: "mantine.colors.body"
  }
});
function SelectProject() {
  const projectId2 = useCurrentProjectd();
  return projects.length < 2 ? null : /* @__PURE__ */ jsxs(Menu, { shadow: "md", width: 200, trigger: "click-hover", openDelay: 200, children: [
    /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
      Button,
      {
        variant: "subtle",
        size: "sm",
        color: "gray",
        px: "sm",
        rightSection: /* @__PURE__ */ jsx(IconChevronDown, { opacity: 0.5, size: 14 }),
        visibleFrom: "md",
        children: projectId2
      }
    ) }),
    /* @__PURE__ */ jsx(MenuDropdown, { children: projects.map((projectId22) => /* @__PURE__ */ jsx(
      MenuItem,
      {
        renderRoot: (props) => /* @__PURE__ */ jsx(
          Link$1,
          {
            ...props,
            to: "/project/$projectId/view/$viewId/",
            params: {
              projectId: projectId22,
              viewId: "index"
            }
          }
        ),
        children: projectId22
      },
      projectId22
    )) })
  ] });
}
const AlertLocalhost = () => /* @__PURE__ */ jsx(
  Alert,
  {
    color: "yellow",
    icon: /* @__PURE__ */ jsx(IconAlertTriangle, {}),
    title: "Localhost URL",
    styles: { body: { gap: rem(4) } },
    children: /* @__PURE__ */ jsx(Text, { c: "yellow", size: "sm", children: "You need to deploy your project to make it available on the internet" })
  }
), CopyButtonChild = ({ copied, copy }) => /* @__PURE__ */ jsx(
  Button,
  {
    size: "xs",
    color: copied ? "teal" : "gray",
    variant: "light",
    leftSection: copied ? /* @__PURE__ */ jsx(IconCheck, { style: { width: rem(16) } }) : /* @__PURE__ */ jsx(IconCopy, { style: { width: rem(16) } }),
    onClick: copy,
    children: copied ? "Copied" : "Copy to clipboard"
  }
), EmbedPanel = ({ diagram }) => {
  const router = useRouter(), { colorScheme } = useMantineColorScheme(), [theme2, setTheme] = useState(colorScheme), padding = 20;
  let location = router.buildLocation({
    to: "/embed/$viewId",
    params: { viewId: diagram.id },
    search: {
      padding,
      theme: theme2 !== "auto" ? theme2 : void 0
    }
  }).href;
  location = useHashHistory ? `#${location}` : location;
  const url = new URL(location, window.location.href), width = diagram.bounds.width + padding * 2, height = diagram.bounds.height + padding * 2, href = url.href, code = `
<div style="aspect-ratio:${width}/${height};width:100%;height:auto;max-width:${width}px;margin:0 auto">
  <iframe src="${href}" width="100%" height="100%" style="border:0;background:transparent;"></iframe>
</div>
`.trim();
  return /* @__PURE__ */ jsxs(Stack, { children: [
    code.includes("http://localhost") && /* @__PURE__ */ jsx(AlertLocalhost, {}),
    /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(Text, { size: "sm", children: "Embedded view is an iframe with a static diagram" }) }),
    /* @__PURE__ */ jsxs(Stack, { gap: "xs", children: [
      /* @__PURE__ */ jsxs(Group, { justify: "space-between", children: [
        /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(Text, { fw: "500", size: "sm", children: "HTML" }) }),
        /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
          /* @__PURE__ */ jsx(ActionIcon$1, { component: "a", href, target: "_blank", variant: "light", color: "gray", children: /* @__PURE__ */ jsx(IconExternalLink, {}) }),
          /* @__PURE__ */ jsx(CopyButton$1, { value: code, timeout: 1500, children: CopyButtonChild })
        ] })
      ] }),
      /* @__PURE__ */ jsx(Code, { block: !0, children: code }),
      /* @__PURE__ */ jsx(
        Box$1,
        {
          style: {
            alignSelf: "flex-start"
          },
          children: /* @__PURE__ */ jsx(
            Select,
            {
              label: "Color scheme",
              value: theme2,
              allowDeselect: !1,
              onChange: (v) => setTheme(v ?? "auto"),
              data: [
                { value: "auto", label: "Auto" },
                { value: "light", label: "Light" },
                { value: "dark", label: "Dark" }
              ]
            }
          )
        }
      )
    ] })
  ] });
};
function WebcomponentsPanel({ diagram }) {
  const router = useRouter();
  let base = router.basepath.endsWith("/") ? router.basepath : `${router.basepath}/`;
  const jscode = `
  <script module src="${new URL(
    `${base}likec4-views.js`,
    window.location.href
  ).href}"><\/script>
`.trim(), htmlCode = `
  <${ComponentName.View} view-id="${encodeURIComponent(diagram.id)}"></${ComponentName.View}>
`.trim(), webcomponentPreview = router.buildLocation(
    {
      to: "/webcomponent/$",
      params: { _splat: diagram.id },
      search: !0
    }
  );
  return /* @__PURE__ */ jsxs(Stack, { children: [
    jscode.includes("http://localhost") && /* @__PURE__ */ jsx(AlertLocalhost, {}),
    /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(Text, { size: "sm", children: "Add this script to your page:" }) }),
    /* @__PURE__ */ jsxs(Stack, { gap: "xs", children: [
      /* @__PURE__ */ jsxs(Group, { justify: "space-between", children: [
        /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(Text, { fw: "500", size: "sm", children: "JavaScript" }) }),
        /* @__PURE__ */ jsxs(Group, { gap: "xs", children: [
          /* @__PURE__ */ jsx(ActionIcon$1, { component: "a", href: webcomponentPreview.href, target: "_blank", variant: "light", color: "gray", children: /* @__PURE__ */ jsx(IconExternalLink, {}) }),
          /* @__PURE__ */ jsx(
            CopyButton$1,
            {
              value: jscode,
              timeout: 1500,
              children: CopyButtonChild
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsx(Code, { block: !0, children: jscode }),
      /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsxs(Text, { size: "sm", c: "dimmed", children: [
        "This script defines a custom element (webcomponent) that renders your diagrams.",
        /* @__PURE__ */ jsx("br", {}),
        "Script must be inserted once in the ",
        /* @__PURE__ */ jsx("code", { children: "<head>" }),
        " or at the end of the ",
        /* @__PURE__ */ jsx("code", { children: "<body>" }),
        " ",
        "tag."
      ] }) })
    ] }),
    /* @__PURE__ */ jsxs(Stack, { gap: "xs", children: [
      /* @__PURE__ */ jsxs(Group, { justify: "space-between", children: [
        /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(Text, { fw: "500", size: "sm", children: "HTML" }) }),
        /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(
          CopyButton$1,
          {
            value: htmlCode,
            timeout: 1500,
            children: CopyButtonChild
          }
        ) })
      ] }),
      /* @__PURE__ */ jsx(Code, { block: !0, children: htmlCode }),
      /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsxs(Text, { size: "sm", c: "dimmed", children: [
        "Insert this code to your page. Page may have multiple ",
        /* @__PURE__ */ jsx("code", { children: "<likec4-view>" }),
        "."
      ] }) })
    ] })
  ] });
}
function ShareModal({
  opened,
  onClose,
  diagram
}) {
  const [activeTab, setActiveTab] = useState("webcomponent");
  return /* @__PURE__ */ jsxs(
    ModalRoot,
    {
      size: "xl",
      opened,
      keepMounted: !0,
      onClose,
      children: [
        /* @__PURE__ */ jsx(ModalOverlay, { backgroundOpacity: 0.5, blur: 3 }),
        /* @__PURE__ */ jsx(ModalContent, { children: /* @__PURE__ */ jsxs(ModalBody, { children: [
          /* @__PURE__ */ jsxs(Tabs, { value: activeTab, onChange: (tab) => setActiveTab(tab ?? "webcomponent"), children: [
            /* @__PURE__ */ jsxs(TabsList, { children: [
              /* @__PURE__ */ jsx(TabsTab, { value: "webcomponent", children: "Webcomponent" }),
              /* @__PURE__ */ jsx(TabsTab, { value: "embed", children: "Embedded" })
            ] }),
            /* @__PURE__ */ jsx(TabsPanel, { value: "embed", pt: "md", children: /* @__PURE__ */ jsx(EmbedPanel, { diagram }) }),
            /* @__PURE__ */ jsx(TabsPanel, { value: "webcomponent", pt: "md", children: /* @__PURE__ */ jsx(WebcomponentsPanel, { diagram }) })
          ] }),
          /* @__PURE__ */ jsx(Group, { justify: "flex-end", mt: "lg", children: /* @__PURE__ */ jsx(Button, { size: "sm", onClick: onClose, children: "Close" }) })
        ] }) })
      ]
    }
  );
}
function Header({ diagram }) {
  const isReactDiagramRoute = useRouterState().matches.some(
    ({ routeId }) => routeId === "/_single/view/$viewId/" || routeId === "/_single/view/$viewId/editor" || routeId === "/project/$projectId/view/$viewId"
  ), { breakpoints } = useMantineTheme(), isTablet = useMediaQuery(`(min-width: ${breakpoints.md})`) ?? !1, [opened, { open, close }] = useDisclosure(!1);
  return /* @__PURE__ */ jsxs(
    Paper,
    {
      className: cssHeader,
      top: "0.5rem",
      right: "0.5rem",
      p: 4,
      radius: "sm",
      shadow: "lg",
      children: [
        /* @__PURE__ */ jsxs(Group, { gap: isTablet ? 6 : 4, wrap: "nowrap", children: [
          isReactDiagramRoute ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
            /* @__PURE__ */ jsx(SelectProject, {}),
            projects.length <= 1 && /* @__PURE__ */ jsx(
              Button,
              {
                size: isTablet ? "sm" : "xs",
                leftSection: /* @__PURE__ */ jsx(IconShare, { size: 14 }),
                onClick: open,
                children: "Share"
              }
            ),
            /* @__PURE__ */ jsx(ExportButton, { diagram })
          ] }) : /* @__PURE__ */ jsx(
            Button,
            {
              component: Link$1,
              to: "/view/$viewId/",
              size: isTablet ? "sm" : "xs",
              variant: "subtle",
              color: "gray",
              children: "Back to diagram"
            }
          ),
          /* @__PURE__ */ jsx(Divider$1, { orientation: "vertical", visibleFrom: "md" }),
          /* @__PURE__ */ jsx(ColorSchemeToggle, {}),
          /* @__PURE__ */ jsx(Space, {})
        ] }),
        /* @__PURE__ */ jsx(
          ShareModal,
          {
            opened,
            onClose: close,
            diagram
          }
        )
      ]
    }
  );
}
function ExportButton({ diagram }) {
  const params = useParams({ strict: !1 }), isInsideProject = useParentMatches().some((match) => match.routeId === "/project/$projectId"), viewId = diagram.id;
  return /* @__PURE__ */ jsxs(Menu, { shadow: "md", width: 200, trigger: "click-hover", openDelay: 200, children: [
    /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
      Button,
      {
        variant: "subtle",
        size: "sm",
        color: "gray",
        px: "sm",
        rightSection: /* @__PURE__ */ jsx(IconChevronDown, { opacity: 0.5, size: 14 }),
        visibleFrom: "md",
        children: "Export"
      }
    ) }),
    /* @__PURE__ */ jsxs(MenuDropdown, { children: [
      /* @__PURE__ */ jsx(MenuLabel, { children: "Current view" }),
      /* @__PURE__ */ jsx(
        MenuItem,
        {
          renderRoot: (props) => /* @__PURE__ */ jsx(
            Link$1,
            {
              target: "_blank",
              to: isInsideProject ? "/project/$projectId/export/$viewId/" : "/export/$viewId/",
              search: { download: !0 },
              params: !0,
              ...props
            }
          ),
          children: "Export as .png"
        }
      ),
      /* @__PURE__ */ jsx(
        MenuItem,
        {
          disabled: isInsideProject,
          renderRoot: (props) => /* @__PURE__ */ jsx(
            Link$1,
            {
              to: "/view/$viewId/dot",
              search: !0,
              params: !0,
              ...props
            }
          ),
          children: "Export as .dot"
        }
      ),
      /* @__PURE__ */ jsx(
        MenuItem,
        {
          disabled: isInsideProject,
          renderRoot: (props) => /* @__PURE__ */ jsx(
            Link$1,
            {
              to: "/view/$viewId/d2",
              search: !0,
              params,
              ...props
            }
          ),
          children: "Export as .d2"
        }
      ),
      /* @__PURE__ */ jsx(
        MenuItem,
        {
          disabled: isInsideProject,
          renderRoot: (props) => /* @__PURE__ */ jsx(
            Link$1,
            {
              to: "/view/$viewId/mmd",
              search: !0,
              params: {
                viewId
              },
              ...props
            }
          ),
          children: "Export as .mmd"
        }
      ),
      /* @__PURE__ */ jsx(MenuItem, { disabled: !0, children: "Export to Draw.io" }),
      /* @__PURE__ */ jsx(MenuItem, { disabled: !0, children: "Export to Miro" }),
      /* @__PURE__ */ jsx(MenuItem, { disabled: !0, children: "Export to Notion" })
    ] })
  ] });
}
const Route$d = createFileRoute("/_single/view/$viewId")({
  component: ViewLayout$2,
  errorComponent: ({ error, reset }) => /* @__PURE__ */ jsx(Fallback, { error, resetErrorBoundary: reset })
});
function Fallback({ error, resetErrorBoundary }) {
  const router = useRouter(), { viewId } = Route$d.useParams();
  return useUpdateEffect(() => {
    resetErrorBoundary();
  }, [viewId]), isNotFound(error) ? /* @__PURE__ */ jsx(Container, { my: "md", children: /* @__PURE__ */ jsxs(Alert, { variant: "light", color: "orange", children: [
    /* @__PURE__ */ jsxs(Text, { c: "orange", fz: "md", children: [
      "The diagram",
      " ",
      /* @__PURE__ */ jsx(Code, { color: "orange", children: viewId }),
      " ",
      "does not exist or contains errors"
    ] }),
    /* @__PURE__ */ jsx(
      Button,
      {
        onClick: () => {
          resetErrorBoundary(), router.navigate({
            to: "/",
            search: !0
          });
        },
        variant: "light",
        color: "orange",
        mt: "lg",
        size: "xs",
        children: "Go to overview"
      }
    )
  ] }) }) : /* @__PURE__ */ jsx(Container, { my: "md", children: /* @__PURE__ */ jsxs(Alert, { variant: "filled", color: "red", title: "Something went wrong", children: [
    /* @__PURE__ */ jsx(Code, { block: !0, color: "red", children: error.stack ?? error.message }),
    /* @__PURE__ */ jsx(Button, { onClick: resetErrorBoundary, color: "red", variant: "white", mt: "lg", size: "xs", children: "Try again" })
  ] }) });
}
function ViewLayout$2() {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(Outlet, {}),
    /* @__PURE__ */ jsx(ViewHeader$1, {}),
    !withOverviewGraph && /* @__PURE__ */ jsx(SidebarDrawer, {})
  ] });
}
function ViewHeader$1() {
  const view = useCurrentDiagram();
  return view ? /* @__PURE__ */ jsx(Header, { diagram: view }) : null;
}
const Sizes = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 120,
    height: 10,
    minlen: 1,
    weight: 1
  },
  nodeWidth: 340,
  nodeHeight: 190,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function createGraph() {
  const g = new dagre.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return g.setGraph({
    ...Sizes.dagre,
    rankdir: "LR"
  }), g.setDefaultEdgeLabel(() => ({ ...Sizes.edgeLabel })), g.setDefaultNodeLabel(() => ({})), g;
}
const PortSuffix = "-port";
function treeFromElements(elements) {
  const sorted = sortParentsFirst([...elements]), root2 = new Set(sorted), map2 = new Map(sorted.map((e2) => [e2.id, e2])), parents = new DefaultMap(() => null), children2 = sorted.reduce((acc, parent, index2, all) => (acc.set(
    parent,
    all.slice(index2 + 1).filter(isDescendantOf(parent)).map((e2) => (root2.delete(e2), e2)).reduce((acc2, el) => (acc2.some(isAncestor(el)) || (acc2.push(el), parents.set(el, parent)), acc2), [])
  ), acc), new DefaultMap(() => []));
  return {
    sorted,
    byId: (id2) => nonNullable(map2.get(id2), `Element not found by id: ${id2}`),
    root: root2,
    parent: (el) => parents.get(el),
    children: (el) => children2.get(el)
  };
}
function createNodes(prefix2, elements, g) {
  const graphNodes = new DefaultMap((key2) => ({
    id: `${prefix2}-${key2}`,
    portId: `${prefix2}-${key2}`
  })), tree = treeFromElements(elements);
  for (const element of tree.sorted) {
    const isCompound = tree.children(element).length > 0, fqn2 = element.id, id2 = `${prefix2}-${fqn2}`, portId = isCompound ? `${id2}${PortSuffix}` : id2;
    graphNodes.set(fqn2, {
      id: id2,
      portId
    }), g.setNode(id2, {
      element,
      isCompound,
      portId,
      inPorts: [],
      outPorts: [],
      width: Sizes.nodeWidth,
      height: Sizes.nodeHeight
    }), isCompound && (g.setNode(portId, {
      element,
      portId,
      isCompound,
      inPorts: [],
      outPorts: [],
      width: Sizes.nodeWidth - Sizes.dagre.ranksep,
      height: Sizes.compound.labelHeight
    }), g.setParent(portId, id2));
    const parent = tree.parent(element);
    parent && g.setParent(id2, `${prefix2}-${parent.id}`);
  }
  return {
    ...tree,
    byId: (id2) => {
      const element = tree.byId(id2), graph2 = graphNodes.get(element.id);
      return {
        element,
        graph: graph2
      };
    },
    graphNodes
  };
}
function applyDagreLayout(g) {
  return dagre.layout(g, {
    // disableOptimalOrderHeuristic: true,
  }), (nodeId) => {
    const node2 = g.node(nodeId), { x: x2, y: y2, width, height } = node2;
    return {
      position: {
        x: x2 - Math.round(width / 2),
        y: y2 - Math.round(height / 2)
      },
      width,
      height
    };
  };
}
function layoutRelationshipsView(data) {
  const g = createGraph(), incomers = createNodes("in", data.incomers, g), subjects = createNodes("subject", data.subjects, g), outgoers = createNodes("out", data.outgoers, g), edges = [];
  C(
    a(
      C(
        toArray(data.incoming),
        m((r2) => ({
          id: r2.source.id,
          source: incomers.byId(r2.source.id).graph,
          target: subjects.byId(r2.target.id).graph,
          relation: r2
        })),
        // Sort by source
        sortParentsFirst
      ),
      C(
        toArray(data.outgoing),
        m((r2) => ({
          id: r2.target.id,
          source: subjects.byId(r2.source.id).graph,
          target: outgoers.byId(r2.target.id).graph,
          relation: r2
        })),
        // Sort by target
        sortParentsFirst
      )
    ),
    m((r2) => ({
      ...r2,
      expr: `${r2.source.id}->${r2.target.id}`
    })),
    // Group if same source and target
    i$3(p$2("expr")),
    i$2((grouped) => {
      const source = grouped[0].source, target = grouped[0].target, name = grouped[0].expr;
      g.node(source.id).outPorts.push(target.id), g.node(target.id).inPorts.push(source.id), g.setEdge(source.portId, target.portId, {
        ...Sizes.edgeLabel
      }, name), edges.push({
        name,
        source: source.id,
        target: target.id,
        relations: m(grouped, p$2("relation"))
      });
    })
  );
  for (const subjectNode of subjects.graphNodes.values()) {
    const nodeId = subjectNode.id, node2 = g.node(nodeId);
    if (node2.isCompound)
      continue;
    const edgeCount = Math.max(g.inEdges(nodeId)?.length ?? 0, g.outEdges(nodeId)?.length ?? 0);
    edgeCount > 2 && (node2.height = node2.height + (edgeCount - 3) * 14);
  }
  const dagreBounds = applyDagreLayout(g), nodeIds = [
    ...incomers.graphNodes.values(),
    ...subjects.graphNodes.values(),
    ...outgoers.graphNodes.values()
  ], _calculatedNodeBounds = C(
    nodeIds,
    // Compound nodes have different portId
    T((n2) => n2.id === n2.portId),
    l$3((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ??= C(
      g.children(nodeId) ?? [],
      T((id2) => !id2.endsWith(PortSuffix)),
      m((id2) => nodeBounds(id2)),
      r$4((bounds) => {
        invariant$2(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      l$4((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: minY2, maxY }) => {
        const {
          position: { x: x2 },
          width
        } = dagreBounds(nodeId);
        return minY2 = minY2 - Sizes.compound.paddingTop, maxY = maxY + Sizes.compound.paddingBottom, {
          position: {
            x: x2,
            y: minY2
          },
          width,
          height: maxY - minY2
        };
      }
    );
  }
  function nodeLevel(nodeId) {
    const parent = g.parent(nodeId);
    return parent ? nodeLevel(parent) + 1 : 0;
  }
  function nodeDepth(nodeId) {
    const children2 = g.children(nodeId) ?? [];
    return children2.length === 0 ? 0 : 1 + Math.max(...children2.map(nodeDepth));
  }
  let minX = 0, minY = 0;
  const nodes = nodeIds.map(({ id: id2 }) => {
    const { element } = g.node(id2);
    let { position, width, height } = nodeBounds(id2);
    const parentId = g.parent(id2), children2 = (g.children(id2) ?? []).filter((c2) => !c2.endsWith(PortSuffix));
    minX = Math.min(minX, position.x), minY = Math.min(minY, position.y);
    const navigateTo = element.defaultView?.id ?? null;
    return {
      id: id2,
      parent: parentId ?? null,
      position: [position.x, position.y],
      title: element.title,
      description: element.description,
      technology: element.technology,
      tags: null,
      links: null,
      color: element.color,
      shape: element.shape,
      modelRef: element.id,
      kind: element.kind,
      level: nodeLevel(id2),
      labelBBox: {
        x: position.x,
        y: position.y,
        width,
        height
      },
      style: {
        ...element.$element.style
      },
      navigateTo,
      inEdges: [],
      outEdges: [],
      ...children2.length > 0 && { depth: nodeDepth(id2) },
      children: children2,
      width,
      height
    };
  });
  return {
    bounds: {
      x: minX,
      y: minY,
      width: g.graph().width ?? 100,
      height: g.graph().height ?? 100
    },
    nodes,
    edges: g.edges().map((e2) => {
      const edge = g.edge(e2), ename = e2.name;
      invariant$2(ename, `Edge ${e2} has no name`);
      const { name, source, target, relations } = f(edges, (e22) => e22.name === ename), points = edge.points.map((p2) => [p2.x, p2.y]);
      return invariant$2(i$7(points, 1), `Edge ${name} has less than 2 points`), {
        id: name,
        source,
        target,
        label: null,
        relations: relations.map((r2) => r2.id),
        parent: null,
        points
      };
    })
  };
}
function useRelationshipsView(fqn2) {
  const model = useLikeC4Model();
  return useMemo(() => ({
    id: `relationships-${fqn2}`,
    title: `Relationships of ${fqn2}`,
    description: null,
    autoLayout: {
      direction: "LR"
    },
    tags: null,
    links: null,
    hash: "empty",
    customColorDefinitions: {},
    ...layoutRelationshipsView(computeRelationshipsView(fqn2, model, null))
  }), [model, fqn2, computeRelationshipsView]);
}
const Route$c = createFileRoute("/_single/relationships/$fqn")({
  component: ViewLayout$1
});
function ViewLayout$1() {
  const { fqn: fqn2 } = Route$c.useParams();
  return useRelationshipsView(fqn2), /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx(Box$1, { className: cssViewOutlet }) });
}
css({
  position: "absolute",
  inset: 0,
  zIndex: 1
});
css({
  minWidth: 300,
  "& svg": {
    width: "100%",
    height: "auto"
  }
});
const headerHeight = {
  var: "--header-height"
};
css({
  padding: 0,
  margin: 0,
  // paddingTop: headerHeight,
  width: "100%",
  height: "100%",
  // position: 'absolute',
  // top: headerHeight,
  // left: 0,
  // width: '100vw',
  // height: `calc(100vh - ${headerHeight})`
  [headerHeight.var]: "60px",
  // TODO: temporary hack to fix the navigation webview position
  "--likec4-options-panel-top": "60px",
  "--likec4-options-panel-right": "10px"
  // ['--likec4-navigation-webview-top']: '0.8rem',
  // ['--likec4-navigation-webview-left']: '3.2rem'
});
const cssExportView = css({
  boxSizing: "border-box",
  border: "0px solid transparent",
  padding: 0,
  margin: 0,
  marginRight: "auto",
  marginBottom: "auto",
  background: "transparent"
});
css({
  position: "fixed",
  inset: 0,
  width: "100%",
  height: "100%"
});
css({
  flex: 1,
  width: "100%",
  height: "100%",
  overflow: "hidden",
  "& iframe": {
    width: "100%",
    height: "100%",
    borderStyle: "none",
    backgroundColor: "transparent",
    overflow: "hidden"
  }
});
async function downloadAsPng({
  pngFilename,
  viewport
}) {
  const { toBlob } = await import("./index-iX7kahqQ.js");
  try {
    const blob = await toBlob(viewport, {
      backgroundColor: "transparent",
      cacheBust: !0,
      imagePlaceholder: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
    });
    if (!blob)
      throw new Error("Failed to create PNG blob");
    var url = URL.createObjectURL(blob), link2 = document.createElement("a");
    link2.setAttribute("download", `${pngFilename}.png`), link2.href = url, document.body.appendChild(link2), link2.click(), await new Promise((resolve) => setTimeout(resolve, 1e3)), document.body.removeChild(link2), URL.revokeObjectURL(url), window.close();
  } catch (err) {
    console.error(err), window.alert("Failed to export to PNG, check the console for more details.");
  }
}
function ExportPage() {
  const {
    padding = 20,
    download = !1
  } = useSearch$1({
    strict: !1
  }), diagram = useCurrentDiagram(), viewportRef = useRef(null), loadingOverlayRef = useRef(null), downloadedRef = useRef(!1);
  if (useTransparentBackground(), useEffect(
    () => {
      if (!viewportRef.current)
        return;
      [...viewportRef.current.querySelectorAll(".react-flow__viewport")].forEach((el) => {
        el.style.transform = "";
      });
    }
  ), useDebouncedEffect(
    () => {
      const viewport = viewportRef.current;
      if (!download || !viewport || !diagram)
        return;
      const loadingOverlay = loadingOverlayRef.current;
      loadingOverlay && (loadingOverlay.style.display = "none"), !downloadedRef.current && (downloadedRef.current = !0, downloadAsPng({
        pngFilename: diagram.id,
        viewport
      }));
    },
    [],
    500
  ), !diagram)
    throw notFound();
  const extraPadding = 16, width = diagram.bounds.width + padding * 2 + extraPadding, height = diagram.bounds.height + padding * 2 + extraPadding;
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ref: viewportRef,
      "data-testid": "export-page",
      className: cx(cssExportView),
      style: {
        padding,
        minWidth: width,
        width,
        minHeight: height,
        height
      },
      children: [
        download && /* @__PURE__ */ jsx(LoadingOverlay, { ref: loadingOverlayRef, visible: !0 }),
        /* @__PURE__ */ jsx(
          StaticLikeC4Diagram,
          {
            view: diagram,
            fitView: !1,
            fitViewPadding: 0,
            background: "transparent",
            reduceGraphics: !1,
            initialWidth: diagram.bounds.width,
            initialHeight: diagram.bounds.height
          }
        )
      ]
    }
  );
}
const asBoolean$1 = (v) => {
  if (typeof v == "boolean")
    return v;
  if (typeof v == "string")
    return v === "true";
}, Route$b = createFileRoute("/_single/export/$viewId")({
  component: ExportPage,
  validateSearch: (search) => ({
    download: asBoolean$1(search.download)
  })
});
function EmbedPage() {
  const { padding = 20 } = useSearch$1({
    strict: !1
  }), diagram = useCurrentDiagram();
  if (useTransparentBackground(!!diagram), !diagram)
    throw notFound();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      pos: "absolute",
      style: {
        top: 0,
        left: "50%",
        boxSizing: "border-box",
        padding,
        transform: "translateX(-50%)",
        aspectRatio: `${diagram.bounds.width + padding * 2} / ${diagram.bounds.height + padding * 2}`,
        width: "100vw",
        maxWidth: diagram.bounds.width + padding * 2,
        height: "auto",
        maxHeight: "100vh"
      },
      children: /* @__PURE__ */ jsx(
        StaticLikeC4Diagram,
        {
          view: diagram,
          fitView: !0,
          background: "transparent",
          fitViewPadding: 0,
          initialWidth: diagram.bounds.width,
          initialHeight: diagram.bounds.height
        }
      )
    }
  );
}
const Route$a = createFileRoute("/_single/embed/$viewId")({
  component: EmbedPage
});
function ViewReact() {
  const viewId = useParams({
    select: (params) => params.viewId ?? "index",
    strict: !1
  }), router = useRouter(), view = useCurrentDiagram(), onNavigateTo = useCallbackRef((viewId2) => {
    const loc = router.buildLocation({
      to: ".",
      params: (current) => ({
        ...current,
        viewId: viewId2
      }),
      search: !0
    });
    router.commitLocation(loc);
  }), title2 = view ? view.title ?? view.id : `${viewId} not found`;
  if (useDocumentTitle(title2 + " - LikeC4"), !view)
    return /* @__PURE__ */ jsx(NotFound, {});
  const hasNotations = (view.notation?.elements ?? []).length > 0;
  return /* @__PURE__ */ jsx(
    LikeC4Diagram,
    {
      view,
      readonly: !0,
      zoomable: !0,
      pannable: !0,
      controls: !0,
      fitViewPadding: "48px",
      showDiagramTitle: !0,
      showNavigationButtons: !0,
      enableFocusMode: !0,
      enableDynamicViewWalkthrough: !0,
      enableElementDetails: !0,
      enableRelationshipDetails: !0,
      enableRelationshipBrowser: !0,
      experimentalEdgeEditing: !1,
      showNotations: hasNotations,
      nodesDraggable: !1,
      nodesSelectable: !0,
      onNavigateTo,
      onBurgerMenuClick: SidebarDrawerOps.open
    }
  );
}
const Route$9 = createFileRoute("/_single/view/$viewId/")({
  component: ViewReact
}), Route$8 = createFileRoute("/project/$projectId/view/$viewId")({
  component: ViewLayout
});
function ViewLayout() {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(Outlet, {}),
    /* @__PURE__ */ jsx(ViewHeader, {}),
    !withOverviewGraph && /* @__PURE__ */ jsx(SidebarDrawer, {})
  ] });
}
function ViewHeader() {
  const view = useCurrentDiagram();
  return view ? /* @__PURE__ */ jsx(Header, { diagram: view }) : null;
}
const asBoolean = (v) => {
  if (typeof v == "boolean")
    return v;
  if (typeof v == "string")
    return v === "true";
}, Route$7 = createFileRoute("/project/$projectId/export/$viewId")({
  component: ExportPage,
  validateSearch: (search) => ({
    download: asBoolean(search.download)
  })
}), Route$6 = createFileRoute("/project/$projectId/embed/$viewId")({
  component: EmbedPage
});
var reactResizablePanels_cjs = {}, hasRequiredReactResizablePanels_cjs;
function requireReactResizablePanels_cjs() {
  if (hasRequiredReactResizablePanels_cjs) return reactResizablePanels_cjs;
  hasRequiredReactResizablePanels_cjs = 1, Object.defineProperty(reactResizablePanels_cjs, "__esModule", { value: !0 });
  var React2 = React__default;
  function _interopNamespace(e2) {
    if (e2 && e2.__esModule) return e2;
    var n2 = /* @__PURE__ */ Object.create(null);
    return e2 && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default") {
        var d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: !0,
          get: function() {
            return e2[k2];
          }
        });
      }
    }), n2.default = e2, Object.freeze(n2);
  }
  var React__namespace = /* @__PURE__ */ _interopNamespace(React2);
  const isBrowser2 = typeof window < "u", {
    createElement: createElement2,
    createContext: createContext2,
    createRef: createRef2,
    forwardRef: forwardRef2,
    useCallback: useCallback2,
    useContext: useContext2,
    useEffect: useEffect2,
    useImperativeHandle,
    useLayoutEffect: useLayoutEffect2,
    useMemo: useMemo2,
    useRef: useRef2,
    useState: useState2
  } = React__namespace, useId2 = React__namespace[`useId${Math.random()}`.slice(0, 5)], useLayoutEffect_do_not_use_directly = useLayoutEffect2, PanelGroupContext = createContext2(null);
  PanelGroupContext.displayName = "PanelGroupContext";
  const useIsomorphicLayoutEffect2 = isBrowser2 ? useLayoutEffect_do_not_use_directly : () => {
  }, wrappedUseId = typeof useId2 == "function" ? useId2 : () => null;
  let counter = 0;
  function useUniqueId(idFromParams = null) {
    const idFromUseId = wrappedUseId(), idRef = useRef2(idFromParams || idFromUseId || null);
    return idRef.current === null && (idRef.current = "" + counter++), idFromParams ?? idRef.current;
  }
  function PanelWithForwardedRef({
    children: children2,
    className: classNameFromProps = "",
    collapsedSize,
    collapsible,
    defaultSize: defaultSize2,
    forwardedRef,
    id: idFromProps,
    maxSize,
    minSize,
    onCollapse,
    onExpand,
    onResize,
    order,
    style: styleFromProps,
    tagName: Type = "div",
    ...rest
  }) {
    const context2 = useContext2(PanelGroupContext);
    if (context2 === null)
      throw Error("Panel components must be rendered within a PanelGroup container");
    const {
      collapsePanel,
      expandPanel,
      getPanelSize,
      getPanelStyle,
      groupId,
      isPanelCollapsed,
      reevaluatePanelConstraints,
      registerPanel,
      resizePanel: resizePanel2,
      unregisterPanel
    } = context2, panelId = useUniqueId(idFromProps), panelDataRef = useRef2({
      callbacks: {
        onCollapse,
        onExpand,
        onResize
      },
      constraints: {
        collapsedSize,
        collapsible,
        defaultSize: defaultSize2,
        maxSize,
        minSize
      },
      id: panelId,
      idIsFromProps: idFromProps !== void 0,
      order
    });
    useRef2({
      didLogMissingDefaultSizeWarning: !1
    }), useIsomorphicLayoutEffect2(() => {
      const {
        callbacks,
        constraints
      } = panelDataRef.current, prevConstraints = {
        ...constraints
      };
      panelDataRef.current.id = panelId, panelDataRef.current.idIsFromProps = idFromProps !== void 0, panelDataRef.current.order = order, callbacks.onCollapse = onCollapse, callbacks.onExpand = onExpand, callbacks.onResize = onResize, constraints.collapsedSize = collapsedSize, constraints.collapsible = collapsible, constraints.defaultSize = defaultSize2, constraints.maxSize = maxSize, constraints.minSize = minSize, (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) && reevaluatePanelConstraints(panelDataRef.current, prevConstraints);
    }), useIsomorphicLayoutEffect2(() => {
      const panelData = panelDataRef.current;
      return registerPanel(panelData), () => {
        unregisterPanel(panelData);
      };
    }, [order, panelId, registerPanel, unregisterPanel]), useImperativeHandle(forwardedRef, () => ({
      collapse: () => {
        collapsePanel(panelDataRef.current);
      },
      expand: (minSize2) => {
        expandPanel(panelDataRef.current, minSize2);
      },
      getId() {
        return panelId;
      },
      getSize() {
        return getPanelSize(panelDataRef.current);
      },
      isCollapsed() {
        return isPanelCollapsed(panelDataRef.current);
      },
      isExpanded() {
        return !isPanelCollapsed(panelDataRef.current);
      },
      resize: (size2) => {
        resizePanel2(panelDataRef.current, size2);
      }
    }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel2]);
    const style2 = getPanelStyle(panelDataRef.current, defaultSize2);
    return createElement2(Type, {
      ...rest,
      children: children2,
      className: classNameFromProps,
      id: idFromProps,
      style: {
        ...style2,
        ...styleFromProps
      },
      // CSS selectors
      "data-panel": "",
      "data-panel-collapsible": collapsible || void 0,
      "data-panel-group-id": groupId,
      "data-panel-id": panelId,
      "data-panel-size": parseFloat("" + style2.flexGrow).toFixed(1)
    });
  }
  const Panel2 = forwardRef2((props2, ref) => createElement2(PanelWithForwardedRef, {
    ...props2,
    forwardedRef: ref
  }));
  PanelWithForwardedRef.displayName = "Panel", Panel2.displayName = "forwardRef(Panel)";
  let nonce;
  function getNonce2() {
    return nonce;
  }
  function setNonce(value) {
    nonce = value;
  }
  let currentCursorStyle = null, enabled = !0, styleElement = null;
  function disableGlobalCursorStyles() {
    enabled = !1;
  }
  function enableGlobalCursorStyles() {
    enabled = !0;
  }
  function getCursorStyle(state, constraintFlags) {
    if (constraintFlags) {
      const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0, horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0, verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0, verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
      if (horizontalMin)
        return verticalMin ? "se-resize" : verticalMax ? "ne-resize" : "e-resize";
      if (horizontalMax)
        return verticalMin ? "sw-resize" : verticalMax ? "nw-resize" : "w-resize";
      if (verticalMin)
        return "s-resize";
      if (verticalMax)
        return "n-resize";
    }
    switch (state) {
      case "horizontal":
        return "ew-resize";
      case "intersection":
        return "move";
      case "vertical":
        return "ns-resize";
    }
  }
  function resetGlobalCursorStyle() {
    styleElement !== null && (document.head.removeChild(styleElement), currentCursorStyle = null, styleElement = null);
  }
  function setGlobalCursorStyle(state, constraintFlags) {
    if (!enabled)
      return;
    const style2 = getCursorStyle(state, constraintFlags);
    if (currentCursorStyle !== style2) {
      if (currentCursorStyle = style2, styleElement === null) {
        styleElement = document.createElement("style");
        const nonce2 = getNonce2();
        nonce2 && styleElement.setAttribute("nonce", nonce2), document.head.appendChild(styleElement);
      }
      styleElement.innerHTML = `*{cursor: ${style2}!important;}`;
    }
  }
  function isKeyDown(event) {
    return event.type === "keydown";
  }
  function isPointerEvent(event) {
    return event.type.startsWith("pointer");
  }
  function isMouseEvent2(event) {
    return event.type.startsWith("mouse");
  }
  function getResizeEventCoordinates(event) {
    if (isPointerEvent(event)) {
      if (event.isPrimary)
        return {
          x: event.clientX,
          y: event.clientY
        };
    } else if (isMouseEvent2(event))
      return {
        x: event.clientX,
        y: event.clientY
      };
    return {
      x: 1 / 0,
      y: 1 / 0
    };
  }
  function getInputType() {
    if (typeof matchMedia == "function")
      return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
  function intersects(rectOne, rectTwo, strict) {
    return strict ? rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y : rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;
  }
  function compare(a2, b2) {
    if (a2 === b2) throw new Error("Cannot compare node with itself");
    const ancestors = {
      a: get_ancestors(a2),
      b: get_ancestors(b2)
    };
    let common_ancestor;
    for (; ancestors.a.at(-1) === ancestors.b.at(-1); )
      a2 = ancestors.a.pop(), b2 = ancestors.b.pop(), common_ancestor = a2;
    assert(common_ancestor, "Stacking order can only be calculated for elements with a common ancestor");
    const z_indexes = {
      a: get_z_index(find_stacking_context(ancestors.a)),
      b: get_z_index(find_stacking_context(ancestors.b))
    };
    if (z_indexes.a === z_indexes.b) {
      const children2 = common_ancestor.childNodes, furthest_ancestors = {
        a: ancestors.a.at(-1),
        b: ancestors.b.at(-1)
      };
      let i2 = children2.length;
      for (; i2--; ) {
        const child = children2[i2];
        if (child === furthest_ancestors.a) return 1;
        if (child === furthest_ancestors.b) return -1;
      }
    }
    return Math.sign(z_indexes.a - z_indexes.b);
  }
  const props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
  function is_flex_item(node2) {
    var _get_parent;
    const display = getComputedStyle((_get_parent = get_parent(node2)) !== null && _get_parent !== void 0 ? _get_parent : node2).display;
    return display === "flex" || display === "inline-flex";
  }
  function creates_stacking_context(node2) {
    const style2 = getComputedStyle(node2);
    return !!(style2.position === "fixed" || style2.zIndex !== "auto" && (style2.position !== "static" || is_flex_item(node2)) || +style2.opacity < 1 || "transform" in style2 && style2.transform !== "none" || "webkitTransform" in style2 && style2.webkitTransform !== "none" || "mixBlendMode" in style2 && style2.mixBlendMode !== "normal" || "filter" in style2 && style2.filter !== "none" || "webkitFilter" in style2 && style2.webkitFilter !== "none" || "isolation" in style2 && style2.isolation === "isolate" || props.test(style2.willChange) || style2.webkitOverflowScrolling === "touch");
  }
  function find_stacking_context(nodes) {
    let i2 = nodes.length;
    for (; i2--; ) {
      const node2 = nodes[i2];
      if (assert(node2, "Missing node"), creates_stacking_context(node2)) return node2;
    }
    return null;
  }
  function get_z_index(node2) {
    return node2 && Number(getComputedStyle(node2).zIndex) || 0;
  }
  function get_ancestors(node2) {
    const ancestors = [];
    for (; node2; )
      ancestors.push(node2), node2 = get_parent(node2);
    return ancestors;
  }
  function get_parent(node2) {
    const {
      parentNode
    } = node2;
    return parentNode && parentNode instanceof ShadowRoot ? parentNode.host : parentNode;
  }
  const EXCEEDED_HORIZONTAL_MIN = 1, EXCEEDED_HORIZONTAL_MAX = 2, EXCEEDED_VERTICAL_MIN = 4, EXCEEDED_VERTICAL_MAX = 8, isCoarsePointer = getInputType() === "coarse";
  let intersectingHandles = [], isPointerDown = !1, ownerDocumentCounts = /* @__PURE__ */ new Map(), panelConstraintFlags = /* @__PURE__ */ new Map();
  const registeredResizeHandlers = /* @__PURE__ */ new Set();
  function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {
    var _ownerDocumentCounts$;
    const {
      ownerDocument
    } = element, data = {
      direction,
      element,
      hitAreaMargins,
      setResizeHandlerState
    }, count2 = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;
    return ownerDocumentCounts.set(ownerDocument, count2 + 1), registeredResizeHandlers.add(data), updateListeners(), function() {
      var _ownerDocumentCounts$2;
      panelConstraintFlags.delete(resizeHandleId), registeredResizeHandlers.delete(data);
      const count3 = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;
      if (ownerDocumentCounts.set(ownerDocument, count3 - 1), updateListeners(), count3 === 1 && ownerDocumentCounts.delete(ownerDocument), intersectingHandles.includes(data)) {
        const index2 = intersectingHandles.indexOf(data);
        index2 >= 0 && intersectingHandles.splice(index2, 1), updateCursor(), setResizeHandlerState("up", !0, null);
      }
    };
  }
  function handlePointerDown(event) {
    const {
      target
    } = event, {
      x: x2,
      y: y2
    } = getResizeEventCoordinates(event);
    isPointerDown = !0, recalculateIntersectingHandles({
      target,
      x: x2,
      y: y2
    }), updateListeners(), intersectingHandles.length > 0 && (updateResizeHandlerStates("down", event), event.preventDefault(), event.stopPropagation());
  }
  function handlePointerMove(event) {
    const {
      x: x2,
      y: y2
    } = getResizeEventCoordinates(event);
    if (isPointerDown && event.buttons === 0 && (isPointerDown = !1, updateResizeHandlerStates("up", event)), !isPointerDown) {
      const {
        target
      } = event;
      recalculateIntersectingHandles({
        target,
        x: x2,
        y: y2
      });
    }
    updateResizeHandlerStates("move", event), updateCursor(), intersectingHandles.length > 0 && event.preventDefault();
  }
  function handlePointerUp(event) {
    const {
      target
    } = event, {
      x: x2,
      y: y2
    } = getResizeEventCoordinates(event);
    panelConstraintFlags.clear(), isPointerDown = !1, intersectingHandles.length > 0 && event.preventDefault(), updateResizeHandlerStates("up", event), recalculateIntersectingHandles({
      target,
      x: x2,
      y: y2
    }), updateCursor(), updateListeners();
  }
  function recalculateIntersectingHandles({
    target,
    x: x2,
    y: y2
  }) {
    intersectingHandles.splice(0);
    let targetElement = null;
    (target instanceof HTMLElement || target instanceof SVGElement) && (targetElement = target), registeredResizeHandlers.forEach((data) => {
      const {
        element: dragHandleElement,
        hitAreaMargins
      } = data, dragHandleRect = dragHandleElement.getBoundingClientRect(), {
        bottom,
        left,
        right,
        top
      } = dragHandleRect, margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
      if (x2 >= left - margin && x2 <= right + margin && y2 >= top - margin && y2 <= bottom + margin) {
        if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible
        // That is why we only check potentially intersecting handles,
        // and why we skip if the event target is within the handle's DOM
        compare(targetElement, dragHandleElement) > 0) {
          let currentElement = targetElement, didIntersect = !1;
          for (; currentElement && !currentElement.contains(dragHandleElement); ) {
            if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, !0)) {
              didIntersect = !0;
              break;
            }
            currentElement = currentElement.parentElement;
          }
          if (didIntersect)
            return;
        }
        intersectingHandles.push(data);
      }
    });
  }
  function reportConstraintsViolation(resizeHandleId, flag) {
    panelConstraintFlags.set(resizeHandleId, flag);
  }
  function updateCursor() {
    let intersectsHorizontal = !1, intersectsVertical = !1;
    intersectingHandles.forEach((data) => {
      const {
        direction
      } = data;
      direction === "horizontal" ? intersectsHorizontal = !0 : intersectsVertical = !0;
    });
    let constraintFlags = 0;
    panelConstraintFlags.forEach((flag) => {
      constraintFlags |= flag;
    }), intersectsHorizontal && intersectsVertical ? setGlobalCursorStyle("intersection", constraintFlags) : intersectsHorizontal ? setGlobalCursorStyle("horizontal", constraintFlags) : intersectsVertical ? setGlobalCursorStyle("vertical", constraintFlags) : resetGlobalCursorStyle();
  }
  function updateListeners() {
    ownerDocumentCounts.forEach((_, ownerDocument) => {
      const {
        body: body2
      } = ownerDocument;
      body2.removeEventListener("contextmenu", handlePointerUp), body2.removeEventListener("pointerdown", handlePointerDown), body2.removeEventListener("pointerleave", handlePointerMove), body2.removeEventListener("pointermove", handlePointerMove);
    }), window.removeEventListener("pointerup", handlePointerUp), window.removeEventListener("pointercancel", handlePointerUp), registeredResizeHandlers.size > 0 && (isPointerDown ? (intersectingHandles.length > 0 && ownerDocumentCounts.forEach((count2, ownerDocument) => {
      const {
        body: body2
      } = ownerDocument;
      count2 > 0 && (body2.addEventListener("contextmenu", handlePointerUp), body2.addEventListener("pointerleave", handlePointerMove), body2.addEventListener("pointermove", handlePointerMove));
    }), window.addEventListener("pointerup", handlePointerUp), window.addEventListener("pointercancel", handlePointerUp)) : ownerDocumentCounts.forEach((count2, ownerDocument) => {
      const {
        body: body2
      } = ownerDocument;
      count2 > 0 && (body2.addEventListener("pointerdown", handlePointerDown, {
        capture: !0
      }), body2.addEventListener("pointermove", handlePointerMove));
    }));
  }
  function updateResizeHandlerStates(action, event) {
    registeredResizeHandlers.forEach((data) => {
      const {
        setResizeHandlerState
      } = data, isActive = intersectingHandles.includes(data);
      setResizeHandlerState(action, isActive, event);
    });
  }
  function useForceUpdate2() {
    const [_, setCount] = useState2(0);
    return useCallback2(() => setCount((prevCount) => prevCount + 1), []);
  }
  function assert(expectedCondition, message) {
    if (!expectedCondition)
      throw console.error(message), Error(message);
  }
  const PRECISION = 10;
  function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
    return actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits) ? 0 : actual > expected ? 1 : -1;
  }
  function fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {
    return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
  }
  function fuzzyNumbersEqual(actual, expected, fractionDigits) {
    return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
  }
  function fuzzyLayoutsEqual(actual, expected, fractionDigits) {
    if (actual.length !== expected.length)
      return !1;
    for (let index2 = 0; index2 < actual.length; index2++) {
      const actualSize = actual[index2], expectedSize = expected[index2];
      if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits))
        return !1;
    }
    return !0;
  }
  function resizePanel({
    panelConstraints: panelConstraintsArray,
    panelIndex,
    size: size2
  }) {
    const panelConstraints = panelConstraintsArray[panelIndex];
    assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);
    let {
      collapsedSize = 0,
      collapsible,
      maxSize = 100,
      minSize = 0
    } = panelConstraints;
    if (fuzzyCompareNumbers(size2, minSize) < 0)
      if (collapsible) {
        const halfwayPoint = (collapsedSize + minSize) / 2;
        fuzzyCompareNumbers(size2, halfwayPoint) < 0 ? size2 = collapsedSize : size2 = minSize;
      } else
        size2 = minSize;
    return size2 = Math.min(maxSize, size2), size2 = parseFloat(size2.toFixed(PRECISION)), size2;
  }
  function adjustLayoutByDelta({
    delta,
    initialLayout,
    panelConstraints: panelConstraintsArray,
    pivotIndices,
    prevLayout,
    trigger
  }) {
    if (fuzzyNumbersEqual(delta, 0))
      return initialLayout;
    const nextLayout = [...initialLayout], [firstPivotIndex, secondPivotIndex] = pivotIndices;
    assert(firstPivotIndex != null, "Invalid first pivot index"), assert(secondPivotIndex != null, "Invalid second pivot index");
    let deltaApplied = 0;
    if (trigger === "keyboard") {
      {
        const index2 = delta < 0 ? secondPivotIndex : firstPivotIndex, panelConstraints = panelConstraintsArray[index2];
        assert(panelConstraints, `Panel constraints not found for index ${index2}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index2];
          if (assert(prevSize != null, `Previous layout not found for panel index ${index2}`), fuzzyNumbersEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0 && (delta = delta < 0 ? 0 - localDelta : localDelta);
          }
        }
      }
      {
        const index2 = delta < 0 ? firstPivotIndex : secondPivotIndex, panelConstraints = panelConstraintsArray[index2];
        assert(panelConstraints, `No panel constraints found for index ${index2}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index2];
          if (assert(prevSize != null, `Previous layout not found for panel index ${index2}`), fuzzyNumbersEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0 && (delta = delta < 0 ? 0 - localDelta : localDelta);
          }
        }
      }
    }
    {
      const increment = delta < 0 ? 1 : -1;
      let index2 = delta < 0 ? secondPivotIndex : firstPivotIndex, maxAvailableDelta = 0;
      for (; ; ) {
        const prevSize = initialLayout[index2];
        assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
        const delta2 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index2,
          size: 100
        }) - prevSize;
        if (maxAvailableDelta += delta2, index2 += increment, index2 < 0 || index2 >= panelConstraintsArray.length)
          break;
      }
      const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
      delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
    }
    {
      let index2 = delta < 0 ? firstPivotIndex : secondPivotIndex;
      for (; index2 >= 0 && index2 < panelConstraintsArray.length; ) {
        const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied), prevSize = initialLayout[index2];
        assert(prevSize != null, `Previous layout not found for panel index ${index2}`);
        const unsafeSize = prevSize - deltaRemaining, safeSize = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index2,
          size: unsafeSize
        });
        if (!fuzzyNumbersEqual(prevSize, safeSize) && (deltaApplied += prevSize - safeSize, nextLayout[index2] = safeSize, deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: !0
        }) >= 0))
          break;
        delta < 0 ? index2-- : index2++;
      }
    }
    if (fuzzyLayoutsEqual(prevLayout, nextLayout))
      return prevLayout;
    {
      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex, prevSize = initialLayout[pivotIndex];
      assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);
      const unsafeSize = prevSize + deltaApplied, safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: pivotIndex,
        size: unsafeSize
      });
      if (nextLayout[pivotIndex] = safeSize, !fuzzyNumbersEqual(safeSize, unsafeSize)) {
        let deltaRemaining = unsafeSize - safeSize, index2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
        for (; index2 >= 0 && index2 < panelConstraintsArray.length; ) {
          const prevSize2 = nextLayout[index2];
          assert(prevSize2 != null, `Previous layout not found for panel index ${index2}`);
          const unsafeSize2 = prevSize2 + deltaRemaining, safeSize2 = resizePanel({
            panelConstraints: panelConstraintsArray,
            panelIndex: index2,
            size: unsafeSize2
          });
          if (fuzzyNumbersEqual(prevSize2, safeSize2) || (deltaRemaining -= safeSize2 - prevSize2, nextLayout[index2] = safeSize2), fuzzyNumbersEqual(deltaRemaining, 0))
            break;
          delta > 0 ? index2-- : index2++;
        }
      }
    }
    const totalSize = nextLayout.reduce((total, size2) => size2 + total, 0);
    return fuzzyNumbersEqual(totalSize, 100) ? nextLayout : prevLayout;
  }
  function calculateAriaValues({
    layout: layout2,
    panelsArray,
    pivotIndices
  }) {
    let currentMinSize = 0, currentMaxSize = 100, totalMinSize = 0, totalMaxSize = 0;
    const firstIndex = pivotIndices[0];
    assert(firstIndex != null, "No pivot index found"), panelsArray.forEach((panelData, index2) => {
      const {
        constraints
      } = panelData, {
        maxSize = 100,
        minSize = 0
      } = constraints;
      index2 === firstIndex ? (currentMinSize = minSize, currentMaxSize = maxSize) : (totalMinSize += minSize, totalMaxSize += maxSize);
    });
    const valueMax = Math.min(currentMaxSize, 100 - totalMinSize), valueMin = Math.max(currentMinSize, 100 - totalMaxSize), valueNow = layout2[firstIndex];
    return {
      valueMax,
      valueMin,
      valueNow
    };
  }
  function getResizeHandleElementsForGroup(groupId, scope = document) {
    return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${groupId}"]`));
  }
  function getResizeHandleElementIndex(groupId, id2, scope = document) {
    const index2 = getResizeHandleElementsForGroup(groupId, scope).findIndex((handle) => handle.getAttribute("data-panel-resize-handle-id") === id2);
    return index2 ?? null;
  }
  function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
    const index2 = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);
    return index2 != null ? [index2, index2 + 1] : [-1, -1];
  }
  function getPanelGroupElement(id2, rootElement = document) {
    var _dataset;
    if (rootElement instanceof HTMLElement && (rootElement == null || (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id2)
      return rootElement;
    const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id="${id2}"]`);
    return element || null;
  }
  function getResizeHandleElement(id2, scope = document) {
    const element = scope.querySelector(`[data-panel-resize-handle-id="${id2}"]`);
    return element || null;
  }
  function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
    var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;
    const handle = getResizeHandleElement(handleId, scope), handles = getResizeHandleElementsForGroup(groupId, scope), index2 = handle ? handles.indexOf(handle) : -1, idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index2]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null, idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index2 + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;
    return [idBefore, idAfter];
  }
  function useWindowSplitterPanelGroupBehavior({
    committedValuesRef,
    eagerValuesRef,
    groupId,
    layout: layout2,
    panelDataArray,
    panelGroupElement,
    setLayout
  }) {
    useRef2({
      didWarnAboutMissingResizeHandle: !1
    }), useIsomorphicLayoutEffect2(() => {
      if (!panelGroupElement)
        return;
      const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);
      for (let index2 = 0; index2 < panelDataArray.length - 1; index2++) {
        const {
          valueMax,
          valueMin,
          valueNow
        } = calculateAriaValues({
          layout: layout2,
          panelsArray: panelDataArray,
          pivotIndices: [index2, index2 + 1]
        }), resizeHandleElement = resizeHandleElements[index2];
        if (resizeHandleElement != null) {
          const panelData = panelDataArray[index2];
          assert(panelData, `No panel data found for index "${index2}"`), resizeHandleElement.setAttribute("aria-controls", panelData.id), resizeHandleElement.setAttribute("aria-valuemax", "" + Math.round(valueMax)), resizeHandleElement.setAttribute("aria-valuemin", "" + Math.round(valueMin)), resizeHandleElement.setAttribute("aria-valuenow", valueNow != null ? "" + Math.round(valueNow) : "");
        }
      }
      return () => {
        resizeHandleElements.forEach((resizeHandleElement, index2) => {
          resizeHandleElement.removeAttribute("aria-controls"), resizeHandleElement.removeAttribute("aria-valuemax"), resizeHandleElement.removeAttribute("aria-valuemin"), resizeHandleElement.removeAttribute("aria-valuenow");
        });
      };
    }, [groupId, layout2, panelDataArray, panelGroupElement]), useEffect2(() => {
      if (!panelGroupElement)
        return;
      const eagerValues = eagerValuesRef.current;
      assert(eagerValues, "Eager values not found");
      const {
        panelDataArray: panelDataArray2
      } = eagerValues, groupElement = getPanelGroupElement(groupId, panelGroupElement);
      assert(groupElement != null, `No group found for id "${groupId}"`);
      const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
      assert(handles, `No resize handles found for group id "${groupId}"`);
      const cleanupFunctions = handles.map((handle) => {
        const handleId = handle.getAttribute("data-panel-resize-handle-id");
        assert(handleId, "Resize handle element has no handle id attribute");
        const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray2, panelGroupElement);
        if (idBefore == null || idAfter == null)
          return () => {
          };
        const onKeyDown = (event) => {
          if (!event.defaultPrevented)
            switch (event.key) {
              case "Enter": {
                event.preventDefault();
                const index2 = panelDataArray2.findIndex((panelData) => panelData.id === idBefore);
                if (index2 >= 0) {
                  const panelData = panelDataArray2[index2];
                  assert(panelData, `No panel data found for index ${index2}`);
                  const size2 = layout2[index2], {
                    collapsedSize = 0,
                    collapsible,
                    minSize = 0
                  } = panelData.constraints;
                  if (size2 != null && collapsible) {
                    const nextLayout = adjustLayoutByDelta({
                      delta: fuzzyNumbersEqual(size2, collapsedSize) ? minSize - collapsedSize : collapsedSize - size2,
                      initialLayout: layout2,
                      panelConstraints: panelDataArray2.map((panelData2) => panelData2.constraints),
                      pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),
                      prevLayout: layout2,
                      trigger: "keyboard"
                    });
                    layout2 !== nextLayout && setLayout(nextLayout);
                  }
                }
                break;
              }
            }
        };
        return handle.addEventListener("keydown", onKeyDown), () => {
          handle.removeEventListener("keydown", onKeyDown);
        };
      });
      return () => {
        cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
      };
    }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout2, panelDataArray, setLayout]);
  }
  function areEqual2(arrayA, arrayB) {
    if (arrayA.length !== arrayB.length)
      return !1;
    for (let index2 = 0; index2 < arrayA.length; index2++)
      if (arrayA[index2] !== arrayB[index2])
        return !1;
    return !0;
  }
  function getResizeEventCursorPosition(direction, event) {
    const isHorizontal = direction === "horizontal", {
      x: x2,
      y: y2
    } = getResizeEventCoordinates(event);
    return isHorizontal ? x2 : y2;
  }
  function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
    const isHorizontal = direction === "horizontal", handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
    assert(handleElement, `No resize handle element found for id "${dragHandleId}"`);
    const groupId = handleElement.getAttribute("data-panel-group-id");
    assert(groupId, "Resize handle element has no group id attribute");
    let {
      initialCursorPosition
    } = initialDragState;
    const cursorPosition = getResizeEventCursorPosition(direction, event), groupElement = getPanelGroupElement(groupId, panelGroupElement);
    assert(groupElement, `No group element found for id "${groupId}"`);
    const groupRect = groupElement.getBoundingClientRect(), groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
    return (cursorPosition - initialCursorPosition) / groupSizeInPixels * 100;
  }
  function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
    if (isKeyDown(event)) {
      const isHorizontal = direction === "horizontal";
      let delta = 0;
      event.shiftKey ? delta = 100 : keyboardResizeBy != null ? delta = keyboardResizeBy : delta = 10;
      let movement = 0;
      switch (event.key) {
        case "ArrowDown":
          movement = isHorizontal ? 0 : delta;
          break;
        case "ArrowLeft":
          movement = isHorizontal ? -delta : 0;
          break;
        case "ArrowRight":
          movement = isHorizontal ? delta : 0;
          break;
        case "ArrowUp":
          movement = isHorizontal ? 0 : -delta;
          break;
        case "End":
          movement = 100;
          break;
        case "Home":
          movement = -100;
          break;
      }
      return movement;
    } else
      return initialDragState == null ? 0 : calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);
  }
  function calculateUnsafeDefaultLayout({
    panelDataArray
  }) {
    const layout2 = Array(panelDataArray.length), panelConstraintsArray = panelDataArray.map((panelData) => panelData.constraints);
    let numPanelsWithSizes = 0, remainingSize = 100;
    for (let index2 = 0; index2 < panelDataArray.length; index2++) {
      const panelConstraints = panelConstraintsArray[index2];
      assert(panelConstraints, `Panel constraints not found for index ${index2}`);
      const {
        defaultSize: defaultSize2
      } = panelConstraints;
      defaultSize2 != null && (numPanelsWithSizes++, layout2[index2] = defaultSize2, remainingSize -= defaultSize2);
    }
    for (let index2 = 0; index2 < panelDataArray.length; index2++) {
      const panelConstraints = panelConstraintsArray[index2];
      assert(panelConstraints, `Panel constraints not found for index ${index2}`);
      const {
        defaultSize: defaultSize2
      } = panelConstraints;
      if (defaultSize2 != null)
        continue;
      const numRemainingPanels = panelDataArray.length - numPanelsWithSizes, size2 = remainingSize / numRemainingPanels;
      numPanelsWithSizes++, layout2[index2] = size2, remainingSize -= size2;
    }
    return layout2;
  }
  function callPanelCallbacks(panelsArray, layout2, panelIdToLastNotifiedSizeMap) {
    layout2.forEach((size2, index2) => {
      const panelData = panelsArray[index2];
      assert(panelData, `Panel data not found for index ${index2}`);
      const {
        callbacks,
        constraints,
        id: panelId
      } = panelData, {
        collapsedSize = 0,
        collapsible
      } = constraints, lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
      if (lastNotifiedSize == null || size2 !== lastNotifiedSize) {
        panelIdToLastNotifiedSizeMap[panelId] = size2;
        const {
          onCollapse,
          onExpand,
          onResize
        } = callbacks;
        onResize && onResize(size2, lastNotifiedSize), collapsible && (onCollapse || onExpand) && (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size2, collapsedSize) && onExpand(), onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size2, collapsedSize) && onCollapse());
      }
    });
  }
  function compareLayouts(a2, b2) {
    if (a2.length !== b2.length)
      return !1;
    for (let index2 = 0; index2 < a2.length; index2++)
      if (a2[index2] != b2[index2])
        return !1;
    return !0;
  }
  function computePanelFlexBoxStyle({
    defaultSize: defaultSize2,
    dragState,
    layout: layout2,
    panelData,
    panelIndex,
    precision = 3
  }) {
    const size2 = layout2[panelIndex];
    let flexGrow;
    return size2 == null ? flexGrow = defaultSize2 != null ? defaultSize2.toPrecision(precision) : "1" : panelData.length === 1 ? flexGrow = "1" : flexGrow = size2.toPrecision(precision), {
      flexBasis: 0,
      flexGrow,
      flexShrink: 1,
      // Without this, Panel sizes may be unintentionally overridden by their content
      overflow: "hidden",
      // Disable pointer events inside of a panel during resize
      // This avoid edge cases like nested iframes
      pointerEvents: dragState !== null ? "none" : void 0
    };
  }
  function debounce(callback, durationMs = 10) {
    let timeoutId = null;
    return (...args) => {
      timeoutId !== null && clearTimeout(timeoutId), timeoutId = setTimeout(() => {
        callback(...args);
      }, durationMs);
    };
  }
  function initializeDefaultStorage(storageObject) {
    try {
      if (typeof localStorage < "u")
        storageObject.getItem = (name) => localStorage.getItem(name), storageObject.setItem = (name, value) => {
          localStorage.setItem(name, value);
        };
      else
        throw new Error("localStorage not supported in this environment");
    } catch (error) {
      console.error(error), storageObject.getItem = () => null, storageObject.setItem = () => {
      };
    }
  }
  function getPanelGroupKey(autoSaveId) {
    return `react-resizable-panels:${autoSaveId}`;
  }
  function getPanelKey(panels) {
    return panels.map((panel2) => {
      const {
        constraints,
        id: id2,
        idIsFromProps,
        order
      } = panel2;
      return idIsFromProps ? id2 : order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
    }).sort((a2, b2) => a2.localeCompare(b2)).join(",");
  }
  function loadSerializedPanelGroupState(autoSaveId, storage) {
    try {
      const panelGroupKey = getPanelGroupKey(autoSaveId), serialized = storage.getItem(panelGroupKey);
      if (serialized) {
        const parsed = JSON.parse(serialized);
        if (typeof parsed == "object" && parsed != null)
          return parsed;
      }
    } catch {
    }
    return null;
  }
  function loadPanelGroupState(autoSaveId, panels, storage) {
    var _loadSerializedPanelG, _state$panelKey;
    const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {}, panelKey = getPanelKey(panels);
    return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;
  }
  function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes2, storage) {
    var _loadSerializedPanelG2;
    const panelGroupKey = getPanelGroupKey(autoSaveId), panelKey = getPanelKey(panels), state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};
    state[panelKey] = {
      expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
      layout: sizes2
    };
    try {
      storage.setItem(panelGroupKey, JSON.stringify(state));
    } catch (error) {
      console.error(error);
    }
  }
  function validatePanelGroupLayout({
    layout: prevLayout,
    panelConstraints
  }) {
    const nextLayout = [...prevLayout], nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
    if (nextLayout.length !== panelConstraints.length)
      throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size2) => `${size2}%`).join(", ")}`);
    if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0)
      for (let index2 = 0; index2 < panelConstraints.length; index2++) {
        const unsafeSize = nextLayout[index2];
        assert(unsafeSize != null, `No layout data found for index ${index2}`);
        const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
        nextLayout[index2] = safeSize;
      }
    let remainingSize = 0;
    for (let index2 = 0; index2 < panelConstraints.length; index2++) {
      const unsafeSize = nextLayout[index2];
      assert(unsafeSize != null, `No layout data found for index ${index2}`);
      const safeSize = resizePanel({
        panelConstraints,
        panelIndex: index2,
        size: unsafeSize
      });
      unsafeSize != safeSize && (remainingSize += unsafeSize - safeSize, nextLayout[index2] = safeSize);
    }
    if (!fuzzyNumbersEqual(remainingSize, 0))
      for (let index2 = 0; index2 < panelConstraints.length; index2++) {
        const prevSize = nextLayout[index2];
        assert(prevSize != null, `No layout data found for index ${index2}`);
        const unsafeSize = prevSize + remainingSize, safeSize = resizePanel({
          panelConstraints,
          panelIndex: index2,
          size: unsafeSize
        });
        if (prevSize !== safeSize && (remainingSize -= safeSize - prevSize, nextLayout[index2] = safeSize, fuzzyNumbersEqual(remainingSize, 0)))
          break;
      }
    return nextLayout;
  }
  const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100, defaultStorage = {
    getItem: (name) => (initializeDefaultStorage(defaultStorage), defaultStorage.getItem(name)),
    setItem: (name, value) => {
      initializeDefaultStorage(defaultStorage), defaultStorage.setItem(name, value);
    }
  }, debounceMap = {};
  function PanelGroupWithForwardedRef({
    autoSaveId = null,
    children: children2,
    className: classNameFromProps = "",
    direction,
    forwardedRef,
    id: idFromProps = null,
    onLayout = null,
    keyboardResizeBy = null,
    storage = defaultStorage,
    style: styleFromProps,
    tagName: Type = "div",
    ...rest
  }) {
    const groupId = useUniqueId(idFromProps), panelGroupElementRef = useRef2(null), [dragState, setDragState] = useState2(null), [layout2, setLayout] = useState2([]), forceUpdate = useForceUpdate2(), panelIdToLastNotifiedSizeMapRef = useRef2({}), panelSizeBeforeCollapseRef = useRef2(/* @__PURE__ */ new Map()), prevDeltaRef = useRef2(0), committedValuesRef = useRef2({
      autoSaveId,
      direction,
      dragState,
      id: groupId,
      keyboardResizeBy,
      onLayout,
      storage
    }), eagerValuesRef = useRef2({
      layout: layout2,
      panelDataArray: [],
      panelDataArrayChanged: !1
    });
    useRef2({
      didLogIdAndOrderWarning: !1,
      didLogPanelConstraintsWarning: !1,
      prevPanelIds: []
    }), useImperativeHandle(forwardedRef, () => ({
      getId: () => committedValuesRef.current.id,
      getLayout: () => {
        const {
          layout: layout3
        } = eagerValuesRef.current;
        return layout3;
      },
      setLayout: (unsafeLayout) => {
        const {
          onLayout: onLayout2
        } = committedValuesRef.current, {
          layout: prevLayout,
          panelDataArray
        } = eagerValuesRef.current, safeLayout = validatePanelGroupLayout({
          layout: unsafeLayout,
          panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
        });
        areEqual2(prevLayout, safeLayout) || (setLayout(safeLayout), eagerValuesRef.current.layout = safeLayout, onLayout2 && onLayout2(safeLayout), callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current));
      }
    }), []), useIsomorphicLayoutEffect2(() => {
      committedValuesRef.current.autoSaveId = autoSaveId, committedValuesRef.current.direction = direction, committedValuesRef.current.dragState = dragState, committedValuesRef.current.id = groupId, committedValuesRef.current.onLayout = onLayout, committedValuesRef.current.storage = storage;
    }), useWindowSplitterPanelGroupBehavior({
      committedValuesRef,
      eagerValuesRef,
      groupId,
      layout: layout2,
      panelDataArray: eagerValuesRef.current.panelDataArray,
      setLayout,
      panelGroupElement: panelGroupElementRef.current
    }), useEffect2(() => {
      const {
        panelDataArray
      } = eagerValuesRef.current;
      if (autoSaveId) {
        if (layout2.length === 0 || layout2.length !== panelDataArray.length)
          return;
        let debouncedSave = debounceMap[autoSaveId];
        debouncedSave == null && (debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL), debounceMap[autoSaveId] = debouncedSave);
        const clonedPanelDataArray = [...panelDataArray], clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);
        debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout2, storage);
      }
    }, [autoSaveId, layout2, storage]), useEffect2(() => {
    });
    const collapsePanel = useCallback2((panelData) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current, {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      if (panelData.constraints.collapsible) {
        const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints), {
          collapsedSize = 0,
          panelSize,
          pivotIndices
        } = panelDataHelper(panelDataArray, panelData, prevLayout);
        if (assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`), !fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
          panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);
          const delta = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1 ? panelSize - collapsedSize : collapsedSize - panelSize, nextLayout = adjustLayoutByDelta({
            delta,
            initialLayout: prevLayout,
            panelConstraints: panelConstraintsArray,
            pivotIndices,
            prevLayout,
            trigger: "imperative-api"
          });
          compareLayouts(prevLayout, nextLayout) || (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
        }
      }
    }, []), expandPanel = useCallback2((panelData, minSizeOverride) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current, {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      if (panelData.constraints.collapsible) {
        const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints), {
          collapsedSize = 0,
          panelSize = 0,
          minSize: minSizeFromProps = 0,
          pivotIndices
        } = panelDataHelper(panelDataArray, panelData, prevLayout), minSize = minSizeOverride ?? minSizeFromProps;
        if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
          const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id), baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize, delta = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1 ? panelSize - baseSize : baseSize - panelSize, nextLayout = adjustLayoutByDelta({
            delta,
            initialLayout: prevLayout,
            panelConstraints: panelConstraintsArray,
            pivotIndices,
            prevLayout,
            trigger: "imperative-api"
          });
          compareLayouts(prevLayout, nextLayout) || (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
        }
      }
    }, []), getPanelSize = useCallback2((panelData) => {
      const {
        layout: layout3,
        panelDataArray
      } = eagerValuesRef.current, {
        panelSize
      } = panelDataHelper(panelDataArray, panelData, layout3);
      return assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`), panelSize;
    }, []), getPanelStyle = useCallback2((panelData, defaultSize2) => {
      const {
        panelDataArray
      } = eagerValuesRef.current, panelIndex = findPanelDataIndex(panelDataArray, panelData);
      return computePanelFlexBoxStyle({
        defaultSize: defaultSize2,
        dragState,
        layout: layout2,
        panelData: panelDataArray,
        panelIndex
      });
    }, [dragState, layout2]), isPanelCollapsed = useCallback2((panelData) => {
      const {
        layout: layout3,
        panelDataArray
      } = eagerValuesRef.current, {
        collapsedSize = 0,
        collapsible,
        panelSize
      } = panelDataHelper(panelDataArray, panelData, layout3);
      return assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`), collapsible === !0 && fuzzyNumbersEqual$1(panelSize, collapsedSize);
    }, []), isPanelExpanded = useCallback2((panelData) => {
      const {
        layout: layout3,
        panelDataArray
      } = eagerValuesRef.current, {
        collapsedSize = 0,
        collapsible,
        panelSize
      } = panelDataHelper(panelDataArray, panelData, layout3);
      return assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`), !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;
    }, []), registerPanel = useCallback2((panelData) => {
      const {
        panelDataArray
      } = eagerValuesRef.current;
      panelDataArray.push(panelData), panelDataArray.sort((panelA, panelB) => {
        const orderA = panelA.order, orderB = panelB.order;
        return orderA == null && orderB == null ? 0 : orderA == null ? -1 : orderB == null ? 1 : orderA - orderB;
      }), eagerValuesRef.current.panelDataArrayChanged = !0, forceUpdate();
    }, [forceUpdate]);
    useIsomorphicLayoutEffect2(() => {
      if (eagerValuesRef.current.panelDataArrayChanged) {
        eagerValuesRef.current.panelDataArrayChanged = !1;
        const {
          autoSaveId: autoSaveId2,
          onLayout: onLayout2,
          storage: storage2
        } = committedValuesRef.current, {
          layout: prevLayout,
          panelDataArray
        } = eagerValuesRef.current;
        let unsafeLayout = null;
        if (autoSaveId2) {
          const state = loadPanelGroupState(autoSaveId2, panelDataArray, storage2);
          state && (panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes)), unsafeLayout = state.layout);
        }
        unsafeLayout == null && (unsafeLayout = calculateUnsafeDefaultLayout({
          panelDataArray
        }));
        const nextLayout = validatePanelGroupLayout({
          layout: unsafeLayout,
          panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
        });
        areEqual2(prevLayout, nextLayout) || (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
      }
    }), useIsomorphicLayoutEffect2(() => {
      const eagerValues = eagerValuesRef.current;
      return () => {
        eagerValues.layout = [];
      };
    }, []);
    const registerResizeHandle2 = useCallback2((dragHandleId) => {
      let isRTL2 = !1;
      const panelGroupElement = panelGroupElementRef.current;
      return panelGroupElement && window.getComputedStyle(panelGroupElement, null).getPropertyValue("direction") === "rtl" && (isRTL2 = !0), function(event) {
        event.preventDefault();
        const panelGroupElement2 = panelGroupElementRef.current;
        if (!panelGroupElement2)
          return () => null;
        const {
          direction: direction2,
          dragState: dragState2,
          id: groupId2,
          keyboardResizeBy: keyboardResizeBy2,
          onLayout: onLayout2
        } = committedValuesRef.current, {
          layout: prevLayout,
          panelDataArray
        } = eagerValuesRef.current, {
          initialLayout
        } = dragState2 ?? {}, pivotIndices = determinePivotIndices(groupId2, dragHandleId, panelGroupElement2);
        let delta = calculateDeltaPercentage(event, dragHandleId, direction2, dragState2, keyboardResizeBy2, panelGroupElement2);
        const isHorizontal = direction2 === "horizontal";
        isHorizontal && isRTL2 && (delta = -delta);
        const panelConstraints = panelDataArray.map((panelData) => panelData.constraints), nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: initialLayout ?? prevLayout,
          panelConstraints,
          pivotIndices,
          prevLayout,
          trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
        }), layoutChanged = !compareLayouts(prevLayout, nextLayout);
        (isPointerEvent(event) || isMouseEvent2(event)) && prevDeltaRef.current != delta && (prevDeltaRef.current = delta, !layoutChanged && delta !== 0 ? isHorizontal ? reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX) : reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX) : reportConstraintsViolation(dragHandleId, 0)), layoutChanged && (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
      };
    }, []), resizePanel2 = useCallback2((panelData, unsafePanelSize) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current, {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current, panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints), {
        panelSize,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
      const delta = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1 ? panelSize - unsafePanelSize : unsafePanelSize - panelSize, nextLayout = adjustLayoutByDelta({
        delta,
        initialLayout: prevLayout,
        panelConstraints: panelConstraintsArray,
        pivotIndices,
        prevLayout,
        trigger: "imperative-api"
      });
      compareLayouts(prevLayout, nextLayout) || (setLayout(nextLayout), eagerValuesRef.current.layout = nextLayout, onLayout2 && onLayout2(nextLayout), callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current));
    }, []), reevaluatePanelConstraints = useCallback2((panelData, prevConstraints) => {
      const {
        layout: layout3,
        panelDataArray
      } = eagerValuesRef.current, {
        collapsedSize: prevCollapsedSize = 0,
        collapsible: prevCollapsible
      } = prevConstraints, {
        collapsedSize: nextCollapsedSize = 0,
        collapsible: nextCollapsible,
        maxSize: nextMaxSize = 100,
        minSize: nextMinSize = 0
      } = panelData.constraints, {
        panelSize: prevPanelSize
      } = panelDataHelper(panelDataArray, panelData, layout3);
      prevPanelSize != null && (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize) ? fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize) || resizePanel2(panelData, nextCollapsedSize) : prevPanelSize < nextMinSize ? resizePanel2(panelData, nextMinSize) : prevPanelSize > nextMaxSize && resizePanel2(panelData, nextMaxSize));
    }, [resizePanel2]), startDragging = useCallback2((dragHandleId, event) => {
      const {
        direction: direction2
      } = committedValuesRef.current, {
        layout: layout3
      } = eagerValuesRef.current;
      if (!panelGroupElementRef.current)
        return;
      const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);
      assert(handleElement, `Drag handle element not found for id "${dragHandleId}"`);
      const initialCursorPosition = getResizeEventCursorPosition(direction2, event);
      setDragState({
        dragHandleId,
        dragHandleRect: handleElement.getBoundingClientRect(),
        initialCursorPosition,
        initialLayout: layout3
      });
    }, []), stopDragging = useCallback2(() => {
      setDragState(null);
    }, []), unregisterPanel = useCallback2((panelData) => {
      const {
        panelDataArray
      } = eagerValuesRef.current, index2 = findPanelDataIndex(panelDataArray, panelData);
      index2 >= 0 && (panelDataArray.splice(index2, 1), delete panelIdToLastNotifiedSizeMapRef.current[panelData.id], eagerValuesRef.current.panelDataArrayChanged = !0, forceUpdate());
    }, [forceUpdate]), context2 = useMemo2(() => ({
      collapsePanel,
      direction,
      dragState,
      expandPanel,
      getPanelSize,
      getPanelStyle,
      groupId,
      isPanelCollapsed,
      isPanelExpanded,
      reevaluatePanelConstraints,
      registerPanel,
      registerResizeHandle: registerResizeHandle2,
      resizePanel: resizePanel2,
      startDragging,
      stopDragging,
      unregisterPanel,
      panelGroupElement: panelGroupElementRef.current
    }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle2, resizePanel2, startDragging, stopDragging, unregisterPanel]), style2 = {
      display: "flex",
      flexDirection: direction === "horizontal" ? "row" : "column",
      height: "100%",
      overflow: "hidden",
      width: "100%"
    };
    return createElement2(PanelGroupContext.Provider, {
      value: context2
    }, createElement2(Type, {
      ...rest,
      children: children2,
      className: classNameFromProps,
      id: idFromProps,
      ref: panelGroupElementRef,
      style: {
        ...style2,
        ...styleFromProps
      },
      // CSS selectors
      "data-panel-group": "",
      "data-panel-group-direction": direction,
      "data-panel-group-id": groupId
    }));
  }
  const PanelGroup = forwardRef2((props2, ref) => createElement2(PanelGroupWithForwardedRef, {
    ...props2,
    forwardedRef: ref
  }));
  PanelGroupWithForwardedRef.displayName = "PanelGroup", PanelGroup.displayName = "forwardRef(PanelGroup)";
  function findPanelDataIndex(panelDataArray, panelData) {
    return panelDataArray.findIndex((prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id);
  }
  function panelDataHelper(panelDataArray, panelData, layout2) {
    const panelIndex = findPanelDataIndex(panelDataArray, panelData), pivotIndices = panelIndex === panelDataArray.length - 1 ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1], panelSize = layout2[panelIndex];
    return {
      ...panelData.constraints,
      panelSize,
      pivotIndices
    };
  }
  function useWindowSplitterResizeHandlerBehavior({
    disabled,
    handleId,
    resizeHandler,
    panelGroupElement
  }) {
    useEffect2(() => {
      if (disabled || resizeHandler == null || panelGroupElement == null)
        return;
      const handleElement = getResizeHandleElement(handleId, panelGroupElement);
      if (handleElement == null)
        return;
      const onKeyDown = (event) => {
        if (!event.defaultPrevented)
          switch (event.key) {
            case "ArrowDown":
            case "ArrowLeft":
            case "ArrowRight":
            case "ArrowUp":
            case "End":
            case "Home": {
              event.preventDefault(), resizeHandler(event);
              break;
            }
            case "F6": {
              event.preventDefault();
              const groupId = handleElement.getAttribute("data-panel-group-id");
              assert(groupId, `No group element found for id "${groupId}"`);
              const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement), index2 = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);
              assert(index2 !== null, `No resize element found for id "${handleId}"`);
              const nextIndex = event.shiftKey ? index2 > 0 ? index2 - 1 : handles.length - 1 : index2 + 1 < handles.length ? index2 + 1 : 0;
              handles[nextIndex].focus();
              break;
            }
          }
      };
      return handleElement.addEventListener("keydown", onKeyDown), () => {
        handleElement.removeEventListener("keydown", onKeyDown);
      };
    }, [panelGroupElement, disabled, handleId, resizeHandler]);
  }
  function PanelResizeHandle({
    children: children2 = null,
    className: classNameFromProps = "",
    disabled = !1,
    hitAreaMargins,
    id: idFromProps,
    onBlur,
    onDragging,
    onFocus,
    style: styleFromProps = {},
    tabIndex = 0,
    tagName: Type = "div",
    ...rest
  }) {
    var _hitAreaMargins$coars, _hitAreaMargins$fine;
    const elementRef = useRef2(null), callbacksRef = useRef2({
      onDragging
    });
    useEffect2(() => {
      callbacksRef.current.onDragging = onDragging;
    });
    const panelGroupContext = useContext2(PanelGroupContext);
    if (panelGroupContext === null)
      throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const {
      direction,
      groupId,
      registerResizeHandle: registerResizeHandleWithParentGroup,
      startDragging,
      stopDragging,
      panelGroupElement
    } = panelGroupContext, resizeHandleId = useUniqueId(idFromProps), [state, setState] = useState2("inactive"), [isFocused, setIsFocused] = useState2(!1), [resizeHandler, setResizeHandler] = useState2(null), committedValuesRef = useRef2({
      state
    });
    useIsomorphicLayoutEffect2(() => {
      committedValuesRef.current.state = state;
    }), useEffect2(() => {
      if (disabled)
        setResizeHandler(null);
      else {
        const resizeHandler2 = registerResizeHandleWithParentGroup(resizeHandleId);
        setResizeHandler(() => resizeHandler2);
      }
    }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);
    const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins?.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15, fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins?.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;
    return useEffect2(() => {
      if (disabled || resizeHandler == null)
        return;
      const element = elementRef.current;
      return assert(element, "Element ref not attached"), registerResizeHandle(resizeHandleId, element, direction, {
        coarse: coarseHitAreaMargins,
        fine: fineHitAreaMargins
      }, (action, isActive, event) => {
        if (isActive)
          switch (action) {
            case "down": {
              setState("drag"), assert(event, 'Expected event to be defined for "down" action'), startDragging(resizeHandleId, event);
              const {
                onDragging: onDragging2
              } = callbacksRef.current;
              onDragging2 && onDragging2(!0);
              break;
            }
            case "move": {
              const {
                state: state2
              } = committedValuesRef.current;
              state2 !== "drag" && setState("hover"), assert(event, 'Expected event to be defined for "move" action'), resizeHandler(event);
              break;
            }
            case "up": {
              setState("hover"), stopDragging();
              const {
                onDragging: onDragging2
              } = callbacksRef.current;
              onDragging2 && onDragging2(!1);
              break;
            }
          }
        else
          setState("inactive");
      });
    }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]), useWindowSplitterResizeHandlerBehavior({
      disabled,
      handleId: resizeHandleId,
      resizeHandler,
      panelGroupElement
    }), createElement2(Type, {
      ...rest,
      children: children2,
      className: classNameFromProps,
      id: idFromProps,
      onBlur: () => {
        setIsFocused(!1), onBlur?.();
      },
      onFocus: () => {
        setIsFocused(!0), onFocus?.();
      },
      ref: elementRef,
      role: "separator",
      style: {
        ...{
          touchAction: "none",
          userSelect: "none"
        },
        ...styleFromProps
      },
      tabIndex,
      // CSS selectors
      "data-panel-group-direction": direction,
      "data-panel-group-id": groupId,
      "data-resize-handle": "",
      "data-resize-handle-active": state === "drag" ? "pointer" : isFocused ? "keyboard" : void 0,
      "data-resize-handle-state": state,
      "data-panel-resize-handle-enabled": !disabled,
      "data-panel-resize-handle-id": resizeHandleId
    });
  }
  PanelResizeHandle.displayName = "PanelResizeHandle";
  function getPanelElement(id2, scope = document) {
    const element = scope.querySelector(`[data-panel-id="${id2}"]`);
    return element || null;
  }
  function getPanelElementsForGroup(groupId, scope = document) {
    return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id="${groupId}"]`));
  }
  function getIntersectingRectangle(rectOne, rectTwo, strict) {
    return intersects(rectOne, rectTwo, strict) ? {
      x: Math.max(rectOne.x, rectTwo.x),
      y: Math.max(rectOne.y, rectTwo.y),
      width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),
      height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)
    } : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  return reactResizablePanels_cjs.Panel = Panel2, reactResizablePanels_cjs.PanelGroup = PanelGroup, reactResizablePanels_cjs.PanelResizeHandle = PanelResizeHandle, reactResizablePanels_cjs.assert = assert, reactResizablePanels_cjs.disableGlobalCursorStyles = disableGlobalCursorStyles, reactResizablePanels_cjs.enableGlobalCursorStyles = enableGlobalCursorStyles, reactResizablePanels_cjs.getIntersectingRectangle = getIntersectingRectangle, reactResizablePanels_cjs.getPanelElement = getPanelElement, reactResizablePanels_cjs.getPanelElementsForGroup = getPanelElementsForGroup, reactResizablePanels_cjs.getPanelGroupElement = getPanelGroupElement, reactResizablePanels_cjs.getResizeHandleElement = getResizeHandleElement, reactResizablePanels_cjs.getResizeHandleElementIndex = getResizeHandleElementIndex, reactResizablePanels_cjs.getResizeHandleElementsForGroup = getResizeHandleElementsForGroup, reactResizablePanels_cjs.getResizeHandlePanelIds = getResizeHandlePanelIds, reactResizablePanels_cjs.intersects = intersects, reactResizablePanels_cjs.setNonce = setNonce, reactResizablePanels_cjs;
}
var reactResizablePanels_cjsExports = requireReactResizablePanels_cjs();
function CopyButton({ text }) {
  return /* @__PURE__ */ jsx(CopyButton$1, { value: text, timeout: 2e3, children: ({ copied, copy }) => /* @__PURE__ */ jsx(Tooltip$5, { label: copied ? "Copied" : "Copy", withArrow: !0, position: "right", children: /* @__PURE__ */ jsx(ActionIcon$1, { color: copied ? "teal" : "gray", variant: copied ? "light" : "subtle", onClick: copy, children: copied ? /* @__PURE__ */ jsx(IconCheck, { style: { width: rem(16) } }) : /* @__PURE__ */ jsx(IconCopy, { style: { width: rem(16) } }) }) }) });
}
function CopyToClipboard({ text }) {
  return /* @__PURE__ */ jsx(Box$1, { pos: "absolute", top: "0", right: "0", p: "4", children: /* @__PURE__ */ jsx(CopyButton, { text }) });
}
const cssScrollArea = css({
  height: "100%",
  "& .mantine-ScrollArea-viewport": {
    minHeight: "100%"
  },
  "& .mantine-ScrollArea-viewport > div": {
    minHeight: "100%",
    height: "100%"
  }
}), cssCodeBlock = css({
  minHeight: "100%"
}), viewWithTopPadding = css({
  paddingTop: headerHeight$1.ref
}), Route$5 = createFileRoute("/_single/view/$viewId/mmd")({
  component: ViewAsMmd,
  loader: async ({ params }) => {
    const { viewId } = params;
    try {
      const { mmdSource } = await loadMmdSources(projectId);
      return {
        source: mmdSource(viewId)
      };
    } catch {
      throw notFound();
    }
  }
}), renderSvg = async (viewId, diagram) => {
  const { default: mermaid } = await import("https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs");
  mermaid.initialize({
    theme: "dark"
  });
  const { svg } = await mermaid.render(viewId, diagram);
  return svg;
};
function ViewAsMmd() {
  const { viewId } = Route$5.useParams(), { source } = Route$5.useLoaderData(), [mmdSvg, { execute }] = useAsync(renderSvg, null);
  return useEffect(() => {
    execute(viewId, source);
  }, [source]), /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(reactResizablePanels_cjsExports.PanelGroup, { className: viewWithTopPadding, direction: "horizontal", autoSaveId: "viewAsMmd", children: [
      /* @__PURE__ */ jsx(reactResizablePanels_cjsExports.Panel, { children: /* @__PURE__ */ jsxs(
        ScrollArea,
        {
          className: cssScrollArea,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ jsx(Code, { block: !0, className: cssCodeBlock, children: source }),
            /* @__PURE__ */ jsx(CopyToClipboard, { text: source })
          ]
        }
      ) }),
      /* @__PURE__ */ jsx(
        reactResizablePanels_cjsExports.PanelResizeHandle,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ jsx(reactResizablePanels_cjsExports.Panel, { children: /* @__PURE__ */ jsx(ScrollArea, { h: "100%", children: mmdSvg.result && /* @__PURE__ */ jsx("div", { className: svgContainer, dangerouslySetInnerHTML: { __html: mmdSvg.result } }) }) })
    ] }),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ jsx(
          Burger,
          {
            size: "sm",
            onClick: SidebarDrawerOps.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
function ViewEditor() {
  const router = useRouter(), view = useCurrentDiagram(), onNavigateTo = useCallbackRef((viewId) => {
    const loc = router.buildLocation({
      to: ".",
      params: (current) => ({
        ...current,
        viewId
      }),
      search: !0
    });
    router.commitLocation(loc);
  });
  if (!view)
    return /* @__PURE__ */ jsx(NotFound, {});
  const hasNotations = (view.notation?.elements ?? []).length > 0;
  return /* @__PURE__ */ jsx(
    LikeC4Diagram,
    {
      view,
      readonly: !1,
      zoomable: !0,
      pannable: !0,
      nodesDraggable: !0,
      experimentalEdgeEditing: !0,
      fitViewPadding: "48px",
      showDiagramTitle: !0,
      showNavigationButtons: !0,
      showNotations: isDevelopment || hasNotations,
      enableDynamicViewWalkthrough: !0,
      enableFocusMode: !0,
      enableElementDetails: !0,
      enableRelationshipDetails: !0,
      enableRelationshipBrowser: !0,
      onNavigateTo,
      onChange: (e2) => console.log(e2),
      onBurgerMenuClick: withOverviewGraph ? () => {
        router.navigate({
          to: "/",
          search: !0
        });
      } : SidebarDrawerOps.open
    }
  );
}
const Route$4 = createFileRoute("/_single/view/$viewId/editor")({
  component: ViewEditor
}), Route$3 = createFileRoute("/_single/view/$viewId/dot")({
  component: ViewAsDot,
  loader: async ({ params }) => {
    const { viewId } = params;
    try {
      const { dotSource, svgSource } = await loadDotSources(projectId), dot = dotSource(viewId), dotSvg = svgSource(viewId);
      return {
        dot,
        dotSvg
      };
    } catch (error) {
      throw console.error(error), notFound();
    }
  }
});
function ViewAsDot() {
  const { dot, dotSvg } = Route$3.useLoaderData();
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(reactResizablePanels_cjsExports.PanelGroup, { className: viewWithTopPadding, direction: "horizontal", autoSaveId: "viewAsDot", children: [
      /* @__PURE__ */ jsx(reactResizablePanels_cjsExports.Panel, { children: /* @__PURE__ */ jsxs(
        ScrollArea,
        {
          className: cssScrollArea,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ jsx(Code, { block: !0, className: cssCodeBlock, children: dot }),
            /* @__PURE__ */ jsx(CopyToClipboard, { text: dot })
          ]
        }
      ) }),
      /* @__PURE__ */ jsx(
        reactResizablePanels_cjsExports.PanelResizeHandle,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ jsx(reactResizablePanels_cjsExports.Panel, { children: /* @__PURE__ */ jsx(ScrollArea, { h: "100%", children: /* @__PURE__ */ jsx("div", { className: svgContainer, dangerouslySetInnerHTML: { __html: dotSvg } }) }) })
    ] }),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ jsx(
          Burger,
          {
            size: "sm",
            onClick: SidebarDrawerOps.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
const Route$2 = createFileRoute("/_single/view/$viewId/d2")({
  component: ViewAsD2,
  loader: async ({ params }) => {
    const { viewId } = params;
    try {
      const { d2Source } = await loadD2Sources(projectId);
      return {
        source: d2Source(viewId)
      };
    } catch {
      throw notFound();
    }
  }
}), fetchFromKroki = async (d2) => await (await fetch(krokiD2SvgUrl, {
  method: "POST",
  cache: "force-cache",
  body: JSON.stringify({
    diagram_source: d2,
    // diagram_options: {
    //   theme: 'colorblind-clear'
    // },
    output_format: "svg"
  }),
  headers: {
    "Content-Type": "application/json"
  }
})).text();
function ViewAsD2() {
  const { source } = Route$2.useLoaderData(), [krokiSvg, { execute }] = useAsync(fetchFromKroki, null);
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(reactResizablePanels_cjsExports.PanelGroup, { className: viewWithTopPadding, direction: "horizontal", autoSaveId: "viewAsD2", children: [
      /* @__PURE__ */ jsx(reactResizablePanels_cjsExports.Panel, { children: /* @__PURE__ */ jsxs(
        ScrollArea,
        {
          className: cssScrollArea,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ jsx(Code, { block: !0, className: cssCodeBlock, children: source }),
            /* @__PURE__ */ jsx(CopyToClipboard, { text: source })
          ]
        }
      ) }),
      /* @__PURE__ */ jsx(
        reactResizablePanels_cjsExports.PanelResizeHandle,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ jsx(reactResizablePanels_cjsExports.Panel, { children: /* @__PURE__ */ jsxs(ScrollArea, { h: "100%", children: [
        krokiSvg.status !== "success" && /* @__PURE__ */ jsxs(Fragment$1, { children: [
          /* @__PURE__ */ jsx(
            Button,
            {
              mt: "xs",
              variant: "light",
              disabled: krokiSvg.status === "loading",
              onClick: () => void execute(source),
              children: krokiSvg.status === "loading" ? "Loading..." : "Render with Kroki"
            }
          ),
          krokiSvg.status === "error" && /* @__PURE__ */ jsx(Box$1, { children: krokiSvg.error?.message })
        ] }),
        krokiSvg.status === "success" && /* @__PURE__ */ jsx(Box$1, { className: svgContainer, children: krokiSvg.result ? /* @__PURE__ */ jsx("div", { dangerouslySetInnerHTML: { __html: krokiSvg.result } }) : /* @__PURE__ */ jsx(Box$1, { children: "Empty result" }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ jsx(
          Burger,
          {
            size: "sm",
            onClick: SidebarDrawerOps.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
const Route$1 = createFileRoute("/project/$projectId/view/$viewId/")({
  component: ViewReact
}), Route2 = createFileRoute("/project/$projectId/view/$viewId/editor")({
  component: ViewEditor
}), ProjectsRoute = Route$k.update({
  id: "/projects",
  path: "/projects",
  getParentRoute: () => Route$l
}), SingleRouteRoute = Route$j.update({
  id: "/_single",
  getParentRoute: () => Route$l
}), IndexRoute = Route$i.update({
  id: "/",
  path: "/",
  getParentRoute: () => Route$l
}), SingleSingleIndexRoute = Route$h.update({
  id: "/single-index",
  path: "/single-index",
  getParentRoute: () => SingleRouteRoute
}), ProjectProjectIdRouteRoute = Route$g.update({
  id: "/project/$projectId",
  path: "/project/$projectId",
  getParentRoute: () => Route$l
}), ProjectProjectIdIndexRoute = Route$f.update({
  id: "/",
  path: "/",
  getParentRoute: () => ProjectProjectIdRouteRoute
}), SingleWebcomponentSplatRoute = Route$e.update({
  id: "/webcomponent/$",
  path: "/webcomponent/$",
  getParentRoute: () => SingleRouteRoute
}), SingleViewViewIdRoute = Route$d.update({
  id: "/view/$viewId",
  path: "/view/$viewId",
  getParentRoute: () => SingleRouteRoute
}), SingleRelationshipsFqnRoute = Route$c.update({
  id: "/relationships/$fqn",
  path: "/relationships/$fqn",
  getParentRoute: () => SingleRouteRoute
}), SingleExportViewIdRoute = Route$b.update({
  id: "/export/$viewId",
  path: "/export/$viewId",
  getParentRoute: () => SingleRouteRoute
}), SingleEmbedViewIdRoute = Route$a.update({
  id: "/embed/$viewId",
  path: "/embed/$viewId",
  getParentRoute: () => SingleRouteRoute
}), SingleViewViewIdIndexRoute = Route$9.update({
  id: "/",
  path: "/",
  getParentRoute: () => SingleViewViewIdRoute
}), ProjectProjectIdViewViewIdRoute = Route$8.update(
  {
    id: "/view/$viewId",
    path: "/view/$viewId",
    getParentRoute: () => ProjectProjectIdRouteRoute
  }
), ProjectProjectIdExportViewIdRoute = Route$7.update({
  id: "/export/$viewId",
  path: "/export/$viewId",
  getParentRoute: () => ProjectProjectIdRouteRoute
}), ProjectProjectIdEmbedViewIdRoute = Route$6.update({
  id: "/embed/$viewId",
  path: "/embed/$viewId",
  getParentRoute: () => ProjectProjectIdRouteRoute
}), SingleViewViewIdMmdRoute = Route$5.update({
  id: "/mmd",
  path: "/mmd",
  getParentRoute: () => SingleViewViewIdRoute
}), SingleViewViewIdEditorRoute = Route$4.update({
  id: "/editor",
  path: "/editor",
  getParentRoute: () => SingleViewViewIdRoute
}), SingleViewViewIdDotRoute = Route$3.update({
  id: "/dot",
  path: "/dot",
  getParentRoute: () => SingleViewViewIdRoute
}), SingleViewViewIdD2Route = Route$2.update({
  id: "/d2",
  path: "/d2",
  getParentRoute: () => SingleViewViewIdRoute
}), ProjectProjectIdViewViewIdIndexRoute = Route$1.update({
  id: "/",
  path: "/",
  getParentRoute: () => ProjectProjectIdViewViewIdRoute
}), ProjectProjectIdViewViewIdEditorRoute = Route2.update({
  id: "/editor",
  path: "/editor",
  getParentRoute: () => ProjectProjectIdViewViewIdRoute
}), SingleViewViewIdRouteChildren = {
  SingleViewViewIdD2Route,
  SingleViewViewIdDotRoute,
  SingleViewViewIdEditorRoute,
  SingleViewViewIdMmdRoute,
  SingleViewViewIdIndexRoute
}, SingleViewViewIdRouteWithChildren = SingleViewViewIdRoute._addFileChildren(SingleViewViewIdRouteChildren), SingleRouteRouteChildren = {
  SingleSingleIndexRoute,
  SingleEmbedViewIdRoute,
  SingleExportViewIdRoute,
  SingleRelationshipsFqnRoute,
  SingleViewViewIdRoute: SingleViewViewIdRouteWithChildren,
  SingleWebcomponentSplatRoute
}, SingleRouteRouteWithChildren = SingleRouteRoute._addFileChildren(
  SingleRouteRouteChildren
), ProjectProjectIdViewViewIdRouteChildren = {
  ProjectProjectIdViewViewIdEditorRoute,
  ProjectProjectIdViewViewIdIndexRoute
}, ProjectProjectIdViewViewIdRouteWithChildren = ProjectProjectIdViewViewIdRoute._addFileChildren(
  ProjectProjectIdViewViewIdRouteChildren
), ProjectProjectIdRouteRouteChildren = {
  ProjectProjectIdIndexRoute,
  ProjectProjectIdEmbedViewIdRoute,
  ProjectProjectIdExportViewIdRoute,
  ProjectProjectIdViewViewIdRoute: ProjectProjectIdViewViewIdRouteWithChildren
}, ProjectProjectIdRouteRouteWithChildren = ProjectProjectIdRouteRoute._addFileChildren(
  ProjectProjectIdRouteRouteChildren
), rootRouteChildren = {
  IndexRoute,
  SingleRouteRoute: SingleRouteRouteWithChildren,
  ProjectsRoute,
  ProjectProjectIdRouteRoute: ProjectProjectIdRouteRouteWithChildren
}, routeTree = Route$l._addFileChildren(rootRouteChildren)._addFileTypes();
function createRouter() {
  return createRouter$1({
    routeTree,
    context: {},
    basepath,
    trailingSlash: "always",
    defaultViewTransition: !0,
    history: useHashHistory ? createHashHistory() : createBrowserHistory(),
    defaultStaleTime: 1 / 0,
    scrollRestoration: !1,
    defaultStructuralSharing: !0,
    defaultNotFoundComponent: () => /* @__PURE__ */ jsx(NotFound, {})
    // defaultPendingComponent: () => (
    //   <Box p={'md'}>
    //     <Loader type="dots" />
    //   </Box>
    // )
  });
}
function Routes() {
  const router = useMemo(() => createRouter(), []);
  return /* @__PURE__ */ jsx(RouterProvider, { router });
}
const theme = {
  autoContrast: !0,
  primaryColor: "indigo",
  cursorType: "pointer",
  fontFamily: "var(--likec4-app-font)",
  headings: {
    fontWeight: "500",
    sizes: {
      h1: {
        // fontSize: '2rem',
        fontWeight: "600"
      },
      h2: {
        // fontSize: '1.85rem',
      }
    }
  },
  components: {
    Portal: Portal.extend({
      defaultProps: {
        reuseTargetNode: !0
      }
    })
  }
};
createRoot(document.getElementById("likec4-root")).render(
  /* @__PURE__ */ jsx(StrictMode, { children: /* @__PURE__ */ jsx(MantineProvider, { defaultColorScheme: "auto", theme, children: /* @__PURE__ */ jsx(Routes, {}) }) })
);
