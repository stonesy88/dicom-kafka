// Generated by dts-bundle-generator v9.5.1

import { CSSProperties, ComponentType, DependencyList, HTMLAttributes, JSX, MouseEvent as ReactMouseEvent, PropsWithChildren, ReactNode, WheelEvent as WheelEvent$1 } from 'react';

type Primitive = null | undefined | string | number | boolean | symbol | bigint;
type UnionToIntersection<Union> = (
// `extends unknown` is always going to be the case and is used to convert the
// `Union` into a [distributive conditional
// type](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types).
Union extends unknown ? (distributedUnion: Union) => void : never) extends ((mergedIntersection: infer Intersection) => void) ? Intersection & Union : never;
type Simplify<T> = {
	[KeyType in keyof T]: T[KeyType];
} & {};
type LiteralUnion<LiteralType, BaseType extends Primitive> = LiteralType | (BaseType & Record<never, never>);
declare const tag: unique symbol;
type TagContainer<Token> = {
	readonly [tag]: Token;
};
type Tag<Token extends PropertyKey, TagMetadata> = TagContainer<{
	[K in Token]: TagMetadata;
}>;
type Tagged<Type, TagName extends PropertyKey, TagMetadata = never> = Type & Tag<TagName, TagMetadata>;
type TupleToUnion<ArrayType> = ArrayType extends readonly unknown[] ? ArrayType[number] : never;
type NonEmptyArray<T> = [
	T,
	...T[]
];
type Point = readonly [
	x: number,
	y: number
];
interface XYPoint {
	x: number;
	y: number;
}
type AllNever<Expressions> = UnionToIntersection<{
	[Name in keyof Expressions]: {
		-readonly [Key in keyof Expressions[Name]]?: never;
	};
}[keyof Expressions]>;
type ExclusiveUnion<Expressions> = Expressions extends object ? {
	[Name in keyof Expressions]: Simplify<Omit<AllNever<Expressions>, keyof Expressions[Name]> & Expressions[Name]>;
}[keyof Expressions] : Expressions;
type ProjectId = Tagged<string, "ProjectID">;
type IconUrl = Tagged<string, "IconUrl"> | "none";
type Fqn<Id extends string = string> = Tagged<Id, "Fqn">;
type Tag$1<Tags extends string = string> = Tagged<Tags, "Tag">;
declare const ThemeColors: readonly [
	"amber",
	"blue",
	"gray",
	"slate",
	"green",
	"indigo",
	"muted",
	"primary",
	"red",
	"secondary",
	"sky"
];
type ThemeColor = typeof ThemeColors[number];
type HexColorLiteral = `#${string}`;
type ColorLiteral = HexColorLiteral;
type Color = LiteralUnion<ThemeColor, string>;
type ShapeSize = "xs" | "sm" | "md" | "lg" | "xl";
type SpacingSize = "xs" | "sm" | "md" | "lg" | "xl";
type TextSize = "xs" | "sm" | "md" | "lg" | "xl";
interface ElementThemeColorValues {
	fill: ColorLiteral;
	stroke: ColorLiteral;
	hiContrast: ColorLiteral;
	loContrast: ColorLiteral;
}
interface RelationshipThemeColorValues {
	lineColor: ColorLiteral;
	labelBgColor: ColorLiteral;
	labelColor: ColorLiteral;
}
interface ThemeColorValues {
	elements: ElementThemeColorValues;
	relationships: RelationshipThemeColorValues;
}
declare const BorderStyles: readonly [
	"solid",
	"dashed",
	"dotted",
	"none"
];
type BorderStyle = TupleToUnion<typeof BorderStyles>;
type ElementKind<Kinds extends string = string> = Tagged<Kinds, "ElementKind">;
declare namespace ElementKind {
	const Group: ElementKind;
}
declare const ElementShapes: readonly [
	"rectangle",
	"person",
	"browser",
	"mobile",
	"cylinder",
	"storage",
	"queue"
];
type ElementShape = TupleToUnion<typeof ElementShapes>;
interface ElementStyle {
	readonly border?: BorderStyle;
	/**
	 * In percentage 0-100, 0 is fully transparent
	 *
	 * @default 100
	 */
	readonly opacity?: number;
	/**
	 * If true, the element is rendered as multiple shapes
	 * @default false
	 */
	readonly multiple?: boolean;
	/**
	 * Shape size
	 *
	 * @default 'md'
	 */
	readonly size?: ShapeSize;
	readonly padding?: SpacingSize;
	readonly textSize?: TextSize;
}
interface Link {
	readonly title?: string;
	readonly url: string;
	readonly relative?: string;
}
type EqualOperator<V> = {
	eq: V;
	neq?: never;
} | {
	eq?: never;
	neq: V;
};
type AllNever$1 = {
	not?: never;
	and?: never;
	or?: never;
	tag?: never;
	kind?: never;
	participant?: never;
};
type TagEqual<Tag> = Omit<AllNever$1, "tag"> & {
	tag: EqualOperator<Tag>;
};
type KindEqual<Kind> = Omit<AllNever$1, "kind"> & {
	kind: EqualOperator<Kind>;
};
type Participant = "source" | "target";
type ParticipantOperator<Tag, Kind> = Omit<AllNever$1, "participant"> & {
	participant: Participant;
	operator: KindEqual<Kind> | TagEqual<Tag>;
};
type NotOperator<Tag, Kind> = Omit<AllNever$1, "not"> & {
	not: WhereOperator<Tag, Kind>;
};
type AndOperator<Tag, Kind> = Omit<AllNever$1, "and"> & {
	and: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
type OrOperator<Tag, Kind> = Omit<AllNever$1, "or"> & {
	or: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
type WhereOperator<Tag, Kind> = TagEqual<Tag> | KindEqual<Kind> | ParticipantOperator<Tag, Kind> | NotOperator<Tag, Kind> | AndOperator<Tag, Kind> | OrOperator<Tag, Kind>;
declare namespace FqnRef {
	/**
	 * Represents a reference to an instance within a deployment.
	 *
	 * @template D - The type representing the deployment fqn. Defaults to `Fqn`.
	 * @template M - The type representing the model fqn. Defaults to `Fqn`.
	 *
	 * @property {D} deployment - TThe fully qualified name (FQN) of the deployed instance.
	 * @property {M} element - The element reference within the deployment.
	 */
	type InsideInstanceRef<D = Fqn, M = Fqn> = {
		deployment: D;
		element: M;
	};
	const isInsideInstanceRef: (ref: FqnRef) => ref is InsideInstanceRef;
	/**
	 * Represents a reference to a deployment element.
	 *
	 * @template F - The type of the fully qualified name (FQN) of the deployment element. Defaults to `Fqn`.
	 * @property {F} deployment - The fully qualified name (FQN) of the deployment element.
	 */
	type DeploymentElementRef<F = Fqn> = {
		deployment: F;
	};
	const isDeploymentElementRef: (ref: FqnRef) => ref is DeploymentElementRef;
	type DeploymentRef<D = Fqn, M = Fqn> = DeploymentElementRef<D> | InsideInstanceRef<D, M>;
	const isDeploymentRef: (ref: FqnRef) => ref is DeploymentRef;
	/**
	 * Reference to logical model element
	 */
	type ModelRef<F = Fqn> = {
		model: F;
	};
	const isModelRef: (ref: FqnRef) => ref is ModelRef;
	/**
	 * Reference to imported logical model element
	 */
	type ImportRef<F = Fqn> = {
		project: ProjectId;
		model: F;
	};
	const isImportRef: (ref: FqnRef) => ref is ImportRef;
	const toDeploymentRef: (ref: FqnRef) => DeploymentRef;
	const toModelFqn: (ref: FqnRef) => Fqn;
}
type FqnRef<D = Fqn, M = Fqn> = ExclusiveUnion<{
	InsideInstanceRef: FqnRef.InsideInstanceRef<D, M>;
	DeploymentRef: FqnRef.DeploymentRef<D>;
	ModelRef: FqnRef.ModelRef<M>;
	ImportRef: FqnRef.ImportRef<M>;
}>;
declare namespace FqnExpr {
	type Wildcard = {
		wildcard: true;
	};
	const isWildcard: (expr: ExpressionV2) => expr is FqnExpr.Wildcard;
	type ModelRef<M = Fqn> = {
		ref: FqnRef.ModelRef<M> | FqnRef.ImportRef<M>;
		selector?: PredicateSelector;
	};
	const isModelRef: (ref: ExpressionV2) => ref is FqnExpr.ModelRef;
	type DeploymentRef<D = Fqn, M = Fqn> = {
		ref: FqnRef.DeploymentRef<D> | FqnRef.InsideInstanceRef<D, M>;
		selector?: PredicateSelector;
	};
	const isDeploymentRef: (ref: ExpressionV2) => ref is FqnExpr.DeploymentRef;
	type ElementKindExpr = {
		elementKind: ElementKind;
		isEqual: boolean;
	};
	function isElementKindExpr(expr: ExpressionV2): expr is ElementKindExpr;
	type ElementTagExpr = {
		elementTag: Tag$1;
		isEqual: boolean;
	};
	function isElementTagExpr(expr: ExpressionV2): expr is ElementTagExpr;
	type NonWildcard<D = Fqn, M = Fqn> = ExclusiveUnion<{
		ModelRef: ModelRef<M>;
		DeploymentRef: DeploymentRef<D, M>;
		ElementKind: ElementKindExpr;
		ElementTag: ElementTagExpr;
	}>;
	type Where<D = Fqn, M = Fqn> = {
		where: {
			expr: ExclusiveUnion<{
				Wildcard: Wildcard;
				ModelRef: ModelRef<M>;
				DeploymentRef: DeploymentRef<D, M>;
				ElementKind: ElementKindExpr;
				ElementTag: ElementTagExpr;
			}>;
			condition: WhereOperator<string, string>;
		};
	};
	const isWhere: (expr: ExpressionV2) => expr is FqnExpr.Where;
	type Custom<D = Fqn, M = Fqn> = {
		custom: {
			expr: OrWhere<D, M>;
			title?: string;
			description?: string;
			technology?: string;
			notation?: string;
			shape?: ElementShape;
			color?: Color;
			icon?: IconUrl;
			border?: BorderStyle;
			opacity?: number;
			navigateTo?: ViewId;
			multiple?: boolean;
			size?: ShapeSize;
			padding?: ShapeSize;
			textSize?: ShapeSize;
		};
	};
	const isCustom: (expr: ExpressionV2) => expr is Custom;
	const is: (expr: ExpressionV2) => expr is FqnExpr;
	type OrWhere<D = Fqn, M = Fqn> = ExclusiveUnion<{
		Wildcard: FqnExpr.Wildcard;
		ModelRef: FqnExpr.ModelRef<M>;
		DeploymentRef: FqnExpr.DeploymentRef<D, M>;
		ElementKind: ElementKindExpr;
		ElementTag: ElementTagExpr;
		Where: FqnExpr.Where<D, M>;
	}>;
	type Any<D = Fqn, M = Fqn> = ExclusiveUnion<{
		Wildcard: Wildcard;
		ModelRef: ModelRef<M>;
		DeploymentRef: DeploymentRef<D, M>;
		ElementKind: ElementKindExpr;
		ElementTag: ElementTagExpr;
		Where: Where<D, M>;
		Custom: Custom<D, M>;
	}>;
	const unwrap: (expr: FqnExpr) => Wildcard | ModelRef | DeploymentRef | ElementKindExpr | ElementTagExpr;
}
type FqnExpr<D = Fqn, M = Fqn> = ExclusiveUnion<{
	Wildcard: FqnExpr.Wildcard;
	ModelRef: FqnExpr.ModelRef<M>;
	DeploymentRef: FqnExpr.DeploymentRef<D, M>;
	ElementKind: FqnExpr.ElementKindExpr;
	ElementTag: FqnExpr.ElementTagExpr;
}>;
declare namespace RelationExpr {
	type Endpoint<D = Fqn, M = Fqn> = FqnExpr.Where<D, M>["where"]["expr"];
	type Direct<D = Fqn, M = Fqn> = {
		source: Endpoint<D, M>;
		target: Endpoint<D, M>;
		isBidirectional?: boolean;
	};
	const isDirect: (expr: ExpressionV2) => expr is RelationExpr.Direct;
	type Incoming<D = Fqn, M = Fqn> = {
		incoming: Endpoint<D, M>;
	};
	const isIncoming: (expr: ExpressionV2) => expr is RelationExpr.Incoming;
	type Outgoing<D = Fqn, M = Fqn> = {
		outgoing: Endpoint<D, M>;
	};
	const isOutgoing: (expr: ExpressionV2) => expr is RelationExpr.Outgoing;
	type InOut<D = Fqn, M = Fqn> = {
		inout: Endpoint<D, M>;
	};
	const isInOut: (expr: ExpressionV2) => expr is RelationExpr.InOut;
	type Where<D = Fqn, M = Fqn> = {
		where: {
			expr: ExclusiveUnion<{
				Direct: RelationExpr.Direct<D, M>;
				Incoming: RelationExpr.Incoming<D, M>;
				Outgoing: RelationExpr.Outgoing<D, M>;
				InOut: RelationExpr.InOut<D, M>;
			}>;
			condition: WhereOperator<string, string>;
		};
	};
	const isWhere: (expr: ExpressionV2) => expr is RelationExpr.Where;
	type Custom<D = Fqn, M = Fqn> = {
		customRelation: {
			expr: OrWhere<D, M>;
			title?: string;
			description?: string;
			technology?: string;
			notation?: string;
			navigateTo?: ViewId;
			notes?: string;
			color?: Color;
			line?: RelationshipLineType;
			head?: RelationshipArrowType;
			tail?: RelationshipArrowType;
		};
	};
	const isCustom: (expr: ExpressionV2) => expr is Custom;
	const is: (expr: ExpressionV2) => expr is RelationExpr;
	type OrWhere<D = Fqn, M = Fqn> = ExclusiveUnion<{
		Direct: Direct<D, M>;
		Incoming: Incoming<D, M>;
		Outgoing: Outgoing<D, M>;
		InOut: InOut<D, M>;
		Where: Where<D, M>;
	}>;
	type Any<D = Fqn, M = Fqn> = ExclusiveUnion<{
		Direct: Direct<D, M>;
		Incoming: Incoming<D, M>;
		Outgoing: Outgoing<D, M>;
		InOut: InOut<D, M>;
		Where: Where<D, M>;
		Custom: Custom<D, M>;
	}>;
	const unwrap: (expr: RelationExpr) => Direct | Incoming | Outgoing | InOut;
}
type RelationExpr<D = Fqn, M = Fqn> = ExclusiveUnion<{
	Direct: RelationExpr.Direct<D, M>;
	Incoming: RelationExpr.Incoming<D, M>;
	Outgoing: RelationExpr.Outgoing<D, M>;
	InOut: RelationExpr.InOut<D, M>;
}>;
type ExpressionV2<D = Fqn, M = Fqn> = ExclusiveUnion<{
	Wildcard: FqnExpr.Wildcard;
	ModelRef: FqnExpr.ModelRef<M>;
	DeploymentRef: FqnExpr.DeploymentRef<D, M>;
	ElementKind: FqnExpr.ElementKindExpr;
	ElementTag: FqnExpr.ElementTagExpr;
	Custom: FqnExpr.Custom<D, M>;
	Direct: RelationExpr.Direct<D, M>;
	Incoming: RelationExpr.Incoming<D, M>;
	Outgoing: RelationExpr.Outgoing<D, M>;
	InOut: RelationExpr.InOut<D, M>;
	Where: ExpressionV2.Where<D, M>;
	CustomRelation: RelationExpr.Custom<D, M>;
}>;
declare namespace ExpressionV2 {
	type Where<D = Fqn, M = Fqn> = FqnExpr.Where<D, M> | RelationExpr.Where<D, M>;
	const isWhere: (expr: ExpressionV2) => expr is ExpressionV2.Where;
	const isRelationWhere: (expr: ExpressionV2) => expr is RelationExpr.Where;
	const isFqnExprWhere: (expr: ExpressionV2) => expr is FqnExpr.Where;
	const isFqnExpr: (expr: ExpressionV2) => expr is FqnExpr.Any;
	const isRelation: (expr: ExpressionV2) => expr is RelationExpr.Any;
}
declare namespace ModelLayer {
	namespace FqnRef {
		/**
		 * Reference to logical model element
		 */
		type ModelRef<F = Fqn> = {
			model: F;
		};
		const isModelRef: (ref: FqnRef) => ref is ModelRef;
		/**
		 * Reference to imported logical model element
		 */
		type ImportRef<F = Fqn> = {
			project: ProjectId;
			model: F;
		};
		const isImportRef: (ref: FqnRef) => ref is ImportRef;
		const toFqn: (ref: FqnRef) => Fqn;
	}
	type FqnRef<M = Fqn> = ExclusiveUnion<{
		ModelRef: FqnRef.ModelRef<M>;
		ImportRef: FqnRef.ImportRef<M>;
	}>;
	namespace FqnExpr {
		type Wildcard = {
			wildcard: true;
		};
		const isWildcard: (expr: Expression) => expr is FqnExpr.Wildcard;
		type ModelRef<M = Fqn> = {
			ref: FqnRef.ModelRef<M> | FqnRef.ImportRef<M>;
			selector?: PredicateSelector;
		};
		const isModelRef: (ref: Expression) => ref is FqnExpr.ModelRef;
		type ElementKindExpr = {
			elementKind: ElementKind;
			isEqual: boolean;
		};
		function isElementKindExpr(expr: Expression): expr is ElementKindExpr;
		type ElementTagExpr = {
			elementTag: Tag$1;
			isEqual: boolean;
		};
		function isElementTagExpr(expr: Expression): expr is ElementTagExpr;
		type NonWildcard<M = Fqn> = ExclusiveUnion<{
			ModelRef: ModelRef<M>;
			ElementKind: ElementKindExpr;
			ElementTag: ElementTagExpr;
		}>;
		type Where<M = Fqn> = {
			where: {
				expr: ExclusiveUnion<{
					Wildcard: Wildcard;
					ModelRef: ModelRef<M>;
					ElementKind: ElementKindExpr;
					ElementTag: ElementTagExpr;
				}>;
				condition: WhereOperator<string, string>;
			};
		};
		const isWhere: (expr: Expression) => expr is FqnExpr.Where;
		type Custom<M = Fqn> = {
			custom: {
				expr: FqnExprOrWhere<M>;
				title?: string;
				description?: string;
				technology?: string;
				notation?: string;
				shape?: ElementShape;
				color?: Color;
				icon?: IconUrl;
				border?: BorderStyle;
				opacity?: number;
				navigateTo?: ViewId;
				multiple?: boolean;
				size?: ShapeSize;
				padding?: ShapeSize;
				textSize?: ShapeSize;
			};
		};
		const isCustom: (expr: Expression) => expr is FqnExpr.Custom;
		const is: (expr: Expression) => expr is FqnExpr;
	}
	type FqnExpr<M = Fqn> = ExclusiveUnion<{
		Wildcard: FqnExpr.Wildcard;
		ModelRef: FqnExpr.ModelRef<M>;
		ElementKind: FqnExpr.ElementKindExpr;
		ElementTag: FqnExpr.ElementTagExpr;
	}>;
	type FqnExprOrWhere<M = Fqn> = ExclusiveUnion<{
		Wildcard: FqnExpr.Wildcard;
		ModelRef: FqnExpr.ModelRef<M>;
		ElementKind: FqnExpr.ElementKindExpr;
		ElementTag: FqnExpr.ElementTagExpr;
		Where: FqnExpr.Where<M>;
	}>;
	type AnyFqnExpr<M = Fqn> = ExclusiveUnion<{
		Wildcard: FqnExpr.Wildcard;
		ModelRef: FqnExpr.ModelRef<M>;
		ElementKind: FqnExpr.ElementKindExpr;
		ElementTag: FqnExpr.ElementTagExpr;
		Where: FqnExpr.Where<M>;
		Custom: FqnExpr.Custom<M>;
	}>;
	function isAnyFqnExpr(expr: Expression): expr is AnyFqnExpr;
	namespace RelationExpr {
		type Direct<M = Fqn> = {
			source: FqnExpr<M>;
			target: FqnExpr<M>;
			isBidirectional?: boolean;
		};
		const isDirect: (expr: Expression) => expr is RelationExpr.Direct;
		type Incoming<M = Fqn> = {
			incoming: FqnExpr<M>;
		};
		const isIncoming: (expr: Expression) => expr is RelationExpr.Incoming;
		type Outgoing<M = Fqn> = {
			outgoing: FqnExpr<M>;
		};
		const isOutgoing: (expr: Expression) => expr is RelationExpr.Outgoing;
		type InOut<M = Fqn> = {
			inout: FqnExpr<M>;
		};
		const isInOut: (expr: Expression) => expr is RelationExpr.InOut;
		type Where<M = Fqn> = {
			where: {
				expr: ExclusiveUnion<{
					Direct: RelationExpr.Direct<M>;
					Incoming: RelationExpr.Incoming<M>;
					Outgoing: RelationExpr.Outgoing<M>;
					InOut: RelationExpr.InOut<M>;
				}>;
				condition: WhereOperator<string, string>;
			};
		};
		const isWhere: (expr: Expression) => expr is RelationExpr.Where;
		type Custom<M = Fqn> = {
			customRelation: {
				expr: RelationExprOrWhere<M>;
				title?: string;
				description?: string;
				technology?: string;
				notation?: string;
				navigateTo?: ViewId;
				notes?: string;
				color?: Color;
				line?: RelationshipLineType;
				head?: RelationshipArrowType;
				tail?: RelationshipArrowType;
			};
		};
		const isCustom: (expr: Expression) => expr is Custom;
		const is: (expr: Expression) => expr is RelationExpr;
	}
	type RelationExpr<M = Fqn> = ExclusiveUnion<{
		Direct: RelationExpr.Direct<M>;
		Incoming: RelationExpr.Incoming<M>;
		Outgoing: RelationExpr.Outgoing<M>;
		InOut: RelationExpr.InOut<M>;
	}>;
	type RelationExprOrWhere<M = Fqn> = ExclusiveUnion<{
		Direct: RelationExpr.Direct<M>;
		Incoming: RelationExpr.Incoming<M>;
		Outgoing: RelationExpr.Outgoing<M>;
		InOut: RelationExpr.InOut<M>;
		Where: RelationExpr.Where<M>;
	}>;
	type AnyRelationExpr<M = Fqn> = ExclusiveUnion<{
		Direct: RelationExpr.Direct<M>;
		Incoming: RelationExpr.Incoming<M>;
		Outgoing: RelationExpr.Outgoing<M>;
		InOut: RelationExpr.InOut<M>;
		Where: RelationExpr.Where<M>;
		CustomRelation: RelationExpr.Custom<M>;
	}>;
	function isAnyRelationExpr(expr: Expression): expr is AnyRelationExpr;
	/**
	 * Represents a version 2 expression which can be one of several types.
	 *
	 * @template M - The type for the model FQN, defaults to `Fqn`.
	 */
	type Expression<M = Fqn> = ExclusiveUnion<{
		Wildcard: FqnExpr.Wildcard;
		ModelRef: FqnExpr.ModelRef<M>;
		ElementKind: FqnExpr.ElementKindExpr;
		ElementTag: FqnExpr.ElementTagExpr;
		Custom: FqnExpr.Custom<M>;
		Direct: RelationExpr.Direct<M>;
		Incoming: RelationExpr.Incoming<M>;
		Outgoing: RelationExpr.Outgoing<M>;
		InOut: RelationExpr.InOut<M>;
		CustomRelation: RelationExpr.Custom<M>;
		Where: Expression.Where<M>;
	}>;
	function isExpression(expr: any): expr is Expression;
	namespace Expression {
		type Where<M = Fqn> = FqnExpr.Where<M> | RelationExpr.Where<M>;
		const isWhere: (expr: Expression) => expr is Expression.Where;
		const isCustomFqnExpr: (expr: Expression) => expr is FqnExpr.Custom;
		const isCustomRelationExpr: (expr: Expression) => expr is RelationExpr.Custom;
		const isFqnExpr: (expr: Expression) => expr is FqnExpr;
		const isRelation: (expr: Expression) => expr is RelationExpr;
	}
}
type GlobalPredicateId = Tagged<string, "GlobalPredicateId">;
type GlobalStyleID = Tagged<string, "GlobalStyleID">;
type ElementNotation = {
	kinds: string[];
	shape: ElementShape;
	color: Color;
	title: string;
};
type ViewId<Id extends string = string> = Tagged<Id, "ViewID">;
type ViewRulePredicate = {
	include: ModelLayer.Expression[];
	exclude?: never;
} | {
	include?: never;
	exclude: ModelLayer.Expression[];
};
interface ViewRuleGlobalPredicateRef {
	predicateId: GlobalPredicateId;
}
interface ViewRuleStyle {
	targets: ModelLayer.FqnExpr[];
	notation?: string;
	style: ElementStyle & {
		color?: Color;
		shape?: ElementShape;
		icon?: IconUrl;
	};
}
interface ViewRuleGlobalStyle {
	styleId: GlobalStyleID;
}
type AutoLayoutDirection = "TB" | "BT" | "LR" | "RL";
interface ViewRuleAutoLayout {
	direction: AutoLayoutDirection;
	nodeSep?: number;
	rankSep?: number;
}
interface ViewRuleGroup {
	groupRules: Array<ViewRulePredicate | ViewRuleGroup>;
	title: string | null;
	color?: Color;
	border?: BorderStyle;
	opacity?: number;
	multiple?: boolean;
	size?: ShapeSize;
	padding?: SpacingSize;
	textSize?: TextSize;
}
type ViewRule = ViewRulePredicate | ViewRuleGlobalPredicateRef | ViewRuleGroup | ViewRuleStyle | ViewRuleGlobalStyle | ViewRuleAutoLayout;
interface BasicView<ViewType extends "element" | "dynamic" | "deployment", ViewIDs extends string, Tags extends string> {
	readonly __?: ViewType;
	readonly id: ViewId<ViewIDs>;
	readonly title: string | null;
	readonly description: string | null;
	readonly tags: NonEmptyArray<Tag$1<Tags>> | null;
	readonly links: NonEmptyArray<Link> | null;
	/**
	 * URI to the source file of this view.
	 * Undefined if the view is auto-generated.
	 */
	readonly docUri?: string;
	/**
	 * For all views we find common ancestor path.
	 * This is used to generate relative paths, i.e.:
	 * - "/home/project/index.c4" becomes "index.c4"
	 * - "/home/project/subdir/views.c4" becomes "subdir/views.c4"
	 *
	 * Undefined if the view is auto-generated.
	 */
	readonly relativePath?: string;
	/**
	 * If the view is changed manually this field contains the layout data.
	 */
	readonly manualLayout?: ViewManualLayout | undefined;
	readonly customColorDefinitions: CustomColorDefinitions;
}
interface BasicElementView<ViewIDs extends string, Tags extends string> extends BasicView<"element", ViewIDs, Tags> {
	readonly viewOf?: Fqn;
	readonly rules: ViewRule[];
}
interface ScopedElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
	readonly viewOf: Fqn;
}
interface ExtendsElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
	readonly extends: ViewId<ViewIDs>;
}
type ElementView<ViewIDs extends string = string, Tags extends string = string> = ScopedElementView<ViewIDs, Tags> | ExtendsElementView<ViewIDs, Tags> | BasicElementView<ViewIDs, Tags>;
interface DynamicViewStep {
	readonly source: Fqn;
	readonly target: Fqn;
	readonly title: string | null;
	readonly description?: string;
	readonly technology?: string;
	readonly notation?: string;
	readonly notes?: string;
	readonly color?: Color;
	readonly line?: RelationshipLineType;
	readonly head?: RelationshipArrowType;
	readonly tail?: RelationshipArrowType;
	readonly isBackward?: boolean;
	readonly navigateTo?: ViewId;
	__parallel?: never;
}
interface DynamicViewParallelSteps {
	readonly __parallel: DynamicViewStep[];
}
type DynamicViewStepOrParallel = DynamicViewStep | DynamicViewParallelSteps;
type DynamicViewIncludeRule = {
	include: ModelLayer.AnyFqnExpr[];
};
type DynamicViewRule = DynamicViewIncludeRule | ViewRuleGlobalPredicateRef | ViewRuleStyle | ViewRuleGlobalStyle | ViewRuleAutoLayout;
interface DynamicView<ViewIDs extends string = string, Tags extends string = string> extends BasicView<"dynamic", ViewIDs, Tags> {
	readonly __: "dynamic";
	readonly steps: DynamicViewStepOrParallel[];
	readonly rules: DynamicViewRule[];
}
type CustomColorDefinitions = {
	[key: string]: ThemeColorValues;
};
type DeploymentViewRulePredicate = {
	include: ExpressionV2[];
	exclude?: never;
} | {
	include?: never;
	exclude: ExpressionV2[];
};
type DeploymentViewRuleStyle = {
	targets: FqnExpr[];
	notation?: string;
	style: ElementStyle & {
		color?: Color;
		shape?: ElementShape;
		icon?: IconUrl;
	};
};
type DeploymentViewRule = DeploymentViewRulePredicate | ViewRuleAutoLayout | DeploymentViewRuleStyle;
interface DeploymentView<ViewIDs extends string = string, Tags extends string = string> extends BasicView<"deployment", ViewIDs, Tags> {
	readonly __: "deployment";
	readonly rules: DeploymentViewRule[];
}
type NodeId<IDs extends string = string> = Tagged<IDs, "Fqn">;
type EdgeId = Tagged<string, "EdgeId">;
interface ComputedNode {
	id: NodeId;
	kind: string;
	parent: NodeId | null;
	/**
	 * Reference to model element
	 * If 1 - node id is a reference
	 */
	modelRef?: 1 | Fqn;
	/**
	 * Reference to deployment element
	 * If 1 - node id is a reference
	 */
	deploymentRef?: 1 | Fqn;
	title: string;
	description: string | null;
	technology: string | null;
	notation?: string;
	tags: NonEmptyArray<Tag$1> | null;
	links: NonEmptyArray<Link> | null;
	children: NodeId[];
	inEdges: EdgeId[];
	outEdges: EdgeId[];
	shape: ElementShape;
	color: Color;
	/**
	 * @deprecated Use `style` instead
	 */
	icon?: IconUrl;
	style: ElementStyle;
	navigateTo?: ViewId | null;
	level: number;
	depth?: number;
	/**
	 * If this node was customized in the view
	 */
	isCustomized?: boolean;
}
declare namespace ComputedNode {
	function modelRef(node: ComputedNode): Fqn | null;
	function deploymentRef(node: ComputedNode): Fqn | null;
	/**
	 * Nodes group is a special kind of node, exisiting only in view
	 */
	function isNodesGroup(node: ComputedNode): boolean;
}
interface ComputedEdge {
	id: EdgeId;
	parent: NodeId | null;
	source: NodeId;
	target: NodeId;
	label: string | null;
	description?: string;
	technology?: string;
	relations: RelationId[];
	kind?: RelationshipKind;
	notation?: string;
	notes?: string;
	color?: Color;
	line?: RelationshipLineType;
	head?: RelationshipArrowType;
	tail?: RelationshipArrowType;
	tags?: NonEmptyArray<Tag$1>;
	navigateTo?: ViewId;
	/**
	 * If this edge is derived from custom relationship predicate
	 */
	isCustomized?: boolean;
	/**
	 * For layouting purposes
	 * @default 'forward'
	 */
	dir?: "forward" | "back" | "both";
}
interface ViewWithHash {
	/**
	 * Hash of the view object.
	 * This is used to detect changes in layout
	 */
	hash: string;
}
interface ViewWithNotation {
	notation?: {
		elements: ElementNotation[];
	};
}
interface ViewAutoLayout {
	direction: ViewRuleAutoLayout["direction"];
	rankSep?: number;
	nodeSep?: number;
}
interface ComputedElementView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ElementView<ViewIDs, Tags>, "rules" | "docUri">, ViewWithHash, ViewWithNotation {
	readonly extends?: ViewId<ViewIDs>;
	readonly autoLayout: ViewAutoLayout;
	readonly nodes: ComputedNode[];
	readonly edges: ComputedEdge[];
	rules?: never;
	docUri?: never;
}
interface ComputedDynamicView<ViewIDs extends string = string, Tags extends string = string> extends Omit<DynamicView<ViewIDs, Tags>, "rules" | "steps" | "docUri">, ViewWithHash, ViewWithNotation {
	readonly autoLayout: ViewAutoLayout;
	readonly nodes: ComputedNode[];
	readonly edges: ComputedEdge[];
	steps?: never;
	rules?: never;
	docUri?: never;
}
interface ComputedDeploymentView<ViewIDs extends string = string, Tags extends string = string> extends Omit<DeploymentView<ViewIDs, Tags>, "rules" | "docUri">, ViewWithHash, ViewWithNotation {
	readonly autoLayout: ViewAutoLayout;
	readonly nodes: ComputedNode[];
	readonly edges: ComputedEdge[];
	rules?: never;
	docUri?: never;
}
type ComputedView<ViewIDs extends string = string, Tags extends string = string> = ComputedElementView<ViewIDs, Tags> | ComputedDynamicView<ViewIDs, Tags> | ComputedDeploymentView<ViewIDs, Tags>;
declare namespace ComputedView {
	function isDeployment(view: ComputedView): view is ComputedDeploymentView;
	function isDynamic(view: ComputedView): view is ComputedDynamicView;
	function isElement(view: ComputedView): view is ComputedElementView;
}
type BBox = {
	x: number;
	y: number;
	width: number;
	height: number;
};
interface DiagramNode extends ComputedNode {
	width: number;
	height: number;
	position: Point;
	labelBBox: BBox;
}
declare namespace DiagramNode {
	function modelRef(node: Pick<DiagramNode, "id" | "modelRef">): Fqn | null;
	function deploymentRef(node: Pick<DiagramNode, "id" | "deploymentRef">): Fqn | null;
	/**
	 * Nodes group is a special kind of node, exisiting only in view
	 */
	function isNodesGroup(node: Pick<DiagramNode, "kind">): boolean;
}
interface DiagramEdge extends ComputedEdge {
	points: NonEmptyArray<Point>;
	controlPoints?: NonEmptyArray<XYPoint>;
	labelBBox?: BBox | null;
	dotpos?: string;
}
interface DiagramView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ComputedView<ViewIDs, Tags>, "nodes" | "edges" | "manualLayout"> {
	readonly nodes: DiagramNode[];
	readonly edges: DiagramEdge[];
	readonly bounds: BBox;
	/**
	 * If diagram has manual layout
	 * But was changed and layout should be recalculated
	 */
	hasLayoutDrift?: boolean;
	manualLayout?: never;
}
type ViewManualLayout = {
	readonly hash: string;
	readonly x: number;
	readonly y: number;
	readonly width: number;
	readonly height: number;
	readonly autoLayout: ViewAutoLayout;
	readonly nodes: Record<string, {
		isCompound: boolean;
		x: number;
		y: number;
		width: number;
		height: number;
	}>;
	readonly edges: Record<string, {
		dotpos?: string;
		points: NonEmptyArray<Point>;
		controlPoints?: NonEmptyArray<XYPoint>;
		labelBBox?: BBox;
	}>;
};
type RelationId = Tagged<string, "RelationID">;
type RelationshipKind<Kinds extends string = string> = Tagged<Kinds, "RelationshipKind">;
type RelationshipLineType = "dashed" | "solid" | "dotted";
type RelationshipArrowType = "none" | "normal" | "onormal" | "dot" | "odot" | "diamond" | "odiamond" | "crow" | "open" | "vee";
type PredicateSelector = "children" | "expanded" | "descendants";
declare namespace ViewChange {
	interface ChangeElementStyle {
		op: "change-element-style";
		style: {
			border?: BorderStyle;
			opacity?: number;
			shape?: ElementShape;
			color?: ThemeColor;
		};
		targets: NonEmptyArray<Fqn>;
	}
	interface SaveManualLayout {
		op: "save-manual-layout";
		layout: ViewManualLayout;
	}
	interface ChangeAutoLayout {
		op: "change-autolayout";
		layout: {
			direction: AutoLayoutDirection;
			nodeSep?: number | null;
			rankSep?: number | null;
		};
	}
}
type ViewChange = ViewChange.ChangeElementStyle | ViewChange.SaveManualLayout | ViewChange.ChangeAutoLayout;
type NodeDimensionChange = {
	id: string;
	type: "dimensions";
	dimensions?: Dimensions;
	resizing?: boolean;
	setAttributes?: boolean;
};
type NodePositionChange = {
	id: string;
	type: "position";
	position?: XYPosition;
	positionAbsolute?: XYPosition;
	dragging?: boolean;
};
type NodeSelectionChange = {
	id: string;
	type: "select";
	selected: boolean;
};
type NodeRemoveChange = {
	id: string;
	type: "remove";
};
type NodeAddChange<NodeType extends NodeBase = NodeBase> = {
	item: NodeType;
	type: "add";
	index?: number;
};
type NodeReplaceChange<NodeType extends NodeBase = NodeBase> = {
	id: string;
	item: NodeType;
	type: "replace";
};
type NodeChange<NodeType extends NodeBase = NodeBase> = NodeDimensionChange | NodePositionChange | NodeSelectionChange | NodeRemoveChange | NodeAddChange<NodeType> | NodeReplaceChange<NodeType>;
type EdgeSelectionChange = NodeSelectionChange;
type EdgeRemoveChange = NodeRemoveChange;
type EdgeAddChange<EdgeType extends EdgeBase = EdgeBase> = {
	item: EdgeType;
	type: "add";
	index?: number;
};
type EdgeReplaceChange<EdgeType extends EdgeBase = EdgeBase> = {
	id: string;
	item: EdgeType;
	type: "replace";
};
type EdgeChange<EdgeType extends EdgeBase = EdgeBase> = EdgeSelectionChange | EdgeRemoveChange | EdgeAddChange<EdgeType> | EdgeReplaceChange<EdgeType>;
declare enum Position {
	Left = "left",
	Top = "top",
	Right = "right",
	Bottom = "bottom"
}
type XYPosition = {
	x: number;
	y: number;
};
type Dimensions = {
	width: number;
	height: number;
};
type Rect = Dimensions & XYPosition;
type CoordinateExtent = [
	[
		number,
		number
	],
	[
		number,
		number
	]
];
type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
type NodeBase<NodeData extends Record<string, unknown> = Record<string, unknown>, NodeType extends string = string> = {
	/** Unique id of a node. */
	id: string;
	/**
	 * Position of a node on the pane.
	 * @example { x: 0, y: 0 }
	 */
	position: XYPosition;
	/** Arbitrary data passed to a node. */
	data: NodeData;
	/** Type of node defined in `nodeTypes`. */
	type?: NodeType;
	/**
	 * Only relevant for default, source, target nodeType. Controls source position.
	 * @example 'right', 'left', 'top', 'bottom'
	 */
	sourcePosition?: Position;
	/**
	 * Only relevant for default, source, target nodeType. Controls target position.
	 * @example 'right', 'left', 'top', 'bottom'
	 */
	targetPosition?: Position;
	/** Whether or not the node should be visible on the canvas. */
	hidden?: boolean;
	selected?: boolean;
	/** Whether or not the node is currently being dragged. */
	dragging?: boolean;
	/** Whether or not the node is able to be dragged. */
	draggable?: boolean;
	selectable?: boolean;
	connectable?: boolean;
	deletable?: boolean;
	/**
	 * A class name that can be applied to elements inside the node that allows those elements to act
	 * as drag handles, letting the user drag the node by clicking and dragging on those elements.
	 */
	dragHandle?: string;
	width?: number;
	height?: number;
	initialWidth?: number;
	initialHeight?: number;
	/** Parent node id, used for creating sub-flows. */
	parentId?: string;
	zIndex?: number;
	/**
	 * Boundary a node can be moved in.
	 * @example 'parent' or [[0, 0], [100, 100]]
	 */
	extent?: "parent" | CoordinateExtent;
	/**
	 * When `true`, the parent node will automatically expand if this node is dragged to the edge of
	 * the parent node's bounds.
	 */
	expandParent?: boolean;
	ariaLabel?: string;
	/**
	 * Origin of the node relative to its position.
	 * @example
	 * [0.5, 0.5] // centers the node
	 * [0, 0] // top left
	 * [1, 1] // bottom right
	 */
	origin?: NodeOrigin;
	handles?: NodeHandle[];
	measured?: {
		width?: number;
		height?: number;
	};
};
type InternalNodeBase<NodeType extends NodeBase = NodeBase> = Omit<NodeType, "measured"> & {
	measured: {
		width?: number;
		height?: number;
	};
	internals: {
		positionAbsolute: XYPosition;
		z: number;
		/**
		 * Holds a reference to the original node object provided by the user.
		 * Used as an optimization to avoid certain operations.
		 */
		userNode: NodeType;
		handleBounds?: NodeHandleBounds;
		bounds?: NodeBounds;
	};
};
type NodeProps<NodeType extends NodeBase> = Pick<NodeType, "id" | "data" | "width" | "height" | "sourcePosition" | "targetPosition" | "dragHandle" | "parentId"> & Required<Pick<NodeType, "type" | "dragging" | "zIndex" | "selectable" | "deletable" | "selected" | "draggable">> & {
	/** Whether a node is connectable or not. */
	isConnectable: boolean;
	/** Position absolute x value. */
	positionAbsoluteX: number;
	/** Position absolute y value. */
	positionAbsoluteY: number;
};
type NodeHandleBounds = {
	source: Handle[] | null;
	target: Handle[] | null;
};
type NodeBounds = XYPosition & {
	width: number | null;
	height: number | null;
};
type NodeOrigin = [
	number,
	number
];
type NodeHandle = Omit<Optional<Handle, "width" | "height">, "nodeId">;
type HandleType = "source" | "target";
type Handle = {
	id?: string | null;
	nodeId: string;
	x: number;
	y: number;
	position: Position;
	type: HandleType;
	width: number;
	height: number;
};
type OnMove = (event: MouseEvent | TouchEvent | null, viewport: Viewport) => void;
type OnMoveStart = OnMove;
type OnMoveEnd = OnMove;
type ZoomInOut = (options?: ViewportHelperFunctionOptions) => Promise<boolean>;
type ZoomTo = (zoomLevel: number, options?: ViewportHelperFunctionOptions) => Promise<boolean>;
type GetZoom = () => number;
type GetViewport = () => Viewport;
type SetViewport = (viewport: Viewport, options?: ViewportHelperFunctionOptions) => Promise<boolean>;
type SetCenter = (x: number, y: number, options?: SetCenterOptions) => Promise<boolean>;
type FitBounds = (bounds: Rect, options?: FitBoundsOptions) => Promise<boolean>;
type Connection = {
	/** The id of the node this connection originates from. */
	source: string;
	/** The id of the node this connection terminates at. */
	target: string;
	/** When not `null`, the id of the handle on the source node that this connection originates from. */
	sourceHandle: string | null;
	/** When not `null`, the id of the handle on the target node that this connection terminates at. */
	targetHandle: string | null;
};
type HandleConnection = Connection & {
	edgeId: string;
};
type NodeConnection = Connection & {
	edgeId: string;
};
declare enum ConnectionMode {
	Strict = "strict",
	Loose = "loose"
}
type OnConnectStartParams = {
	nodeId: string | null;
	handleId: string | null;
	handleType: HandleType | null;
};
type OnConnectStart = (event: MouseEvent | TouchEvent, params: OnConnectStartParams) => void;
type OnConnect = (connection: Connection) => void;
type OnConnectEnd = (event: MouseEvent | TouchEvent, connectionState: FinalConnectionState) => void;
type PaddingUnit = "px" | "%";
type PaddingWithUnit = `${number}${PaddingUnit}` | number;
type Padding = PaddingWithUnit | {
	top?: PaddingWithUnit;
	right?: PaddingWithUnit;
	bottom?: PaddingWithUnit;
	left?: PaddingWithUnit;
	x?: PaddingWithUnit;
	y?: PaddingWithUnit;
};
type FitViewOptionsBase<NodeType extends NodeBase = NodeBase> = {
	padding?: Padding;
	includeHiddenNodes?: boolean;
	minZoom?: number;
	maxZoom?: number;
	duration?: number;
	nodes?: (NodeType | {
		id: string;
	})[];
};
type Viewport = {
	x: number;
	y: number;
	zoom: number;
};
type KeyCode = string | Array<string>;
type SnapGrid = [
	number,
	number
];
declare enum PanOnScrollMode {
	Free = "free",
	Vertical = "vertical",
	Horizontal = "horizontal"
}
type ViewportHelperFunctionOptions = {
	duration?: number;
};
type SetCenterOptions = ViewportHelperFunctionOptions & {
	zoom?: number;
};
type FitBoundsOptions = ViewportHelperFunctionOptions & {
	padding?: number;
};
type PanelPosition = "top-left" | "top-center" | "top-right" | "bottom-left" | "bottom-center" | "bottom-right" | "center-left" | "center-right";
type ProOptions = {
	account?: string;
	hideAttribution: boolean;
};
declare enum SelectionMode$1 {
	Partial = "partial",
	Full = "full"
}
type OnError = (id: string, message: string) => void;
type NoConnection = {
	inProgress: false;
	isValid: null;
	from: null;
	fromHandle: null;
	fromPosition: null;
	fromNode: null;
	to: null;
	toHandle: null;
	toPosition: null;
	toNode: null;
};
type ConnectionInProgress<NodeType extends InternalNodeBase = InternalNodeBase> = {
	/** Indicates whether a connection is currently in progress. */
	inProgress: true;
	/**
	 * If an ongoing connection is above a handle or inside the connection radius, this will be `true`
	 * or `false`, otherwise `null`.
	 */
	isValid: boolean | null;
	/** Returns the xy start position or `null` if no connection is in progress. */
	from: XYPosition;
	/** Returns the start handle or `null` if no connection is in progress. */
	fromHandle: Handle;
	/** Returns the side (called position) of the start handle or `null` if no connection is in progress. */
	fromPosition: Position;
	/** Returns the start node or `null` if no connection is in progress. */
	fromNode: NodeType;
	/** Returns the xy end position or `null` if no connection is in progress. */
	to: XYPosition;
	/** Returns the end handle or `null` if no connection is in progress. */
	toHandle: Handle | null;
	/** Returns the side (called position) of the end handle or `null` if no connection is in progress. */
	toPosition: Position;
	/** Returns the end node or `null` if no connection is in progress. */
	toNode: NodeType | null;
};
type ConnectionState<NodeType extends InternalNodeBase = InternalNodeBase> = ConnectionInProgress<NodeType> | NoConnection;
type FinalConnectionState<NodeType extends InternalNodeBase = InternalNodeBase> = Omit<ConnectionState<NodeType>, "inProgress">;
type ColorModeClass = "light" | "dark";
type ColorMode = ColorModeClass | "system";
type OnBeforeDeleteBase<NodeType extends NodeBase = NodeBase, EdgeType extends EdgeBase = EdgeBase> = ({ nodes, edges, }: {
	nodes: NodeType[];
	edges: EdgeType[];
}) => Promise<boolean | {
	nodes: NodeType[];
	edges: EdgeType[];
}>;
type EdgeBase<EdgeData extends Record<string, unknown> = Record<string, unknown>, EdgeType extends string | undefined = string | undefined> = {
	/** Unique id of an edge. */
	id: string;
	/** Type of edge defined in `edgeTypes`. */
	type?: EdgeType;
	/** Id of source node. */
	source: string;
	/** Id of target node. */
	target: string;
	/** Id of source handle, only needed if there are multiple handles per node. */
	sourceHandle?: string | null;
	/** Id of target handle, only needed if there are multiple handles per node. */
	targetHandle?: string | null;
	animated?: boolean;
	hidden?: boolean;
	deletable?: boolean;
	selectable?: boolean;
	/** Arbitrary data passed to an edge. */
	data?: EdgeData;
	selected?: boolean;
	/**
	 * Set the marker on the beginning of an edge.
	 * @example 'arrow', 'arrowclosed' or custom marker
	 */
	markerStart?: EdgeMarkerType;
	/**
	 * Set the marker on the end of an edge.
	 * @example 'arrow', 'arrowclosed' or custom marker
	 */
	markerEnd?: EdgeMarkerType;
	zIndex?: number;
	ariaLabel?: string;
	/**
	 * ReactFlow renders an invisible path around each edge to make them easier to click or tap on.
	 * This property sets the width of that invisible path.
	 */
	interactionWidth?: number;
};
type DefaultEdgeOptionsBase<EdgeType extends EdgeBase> = Omit<EdgeType, "id" | "source" | "target" | "sourceHandle" | "targetHandle" | "selected">;
declare enum ConnectionLineType {
	Bezier = "default",
	Straight = "straight",
	Step = "step",
	SmoothStep = "smoothstep",
	SimpleBezier = "simplebezier"
}
type EdgeMarker = {
	type: MarkerType;
	color?: string;
	width?: number;
	height?: number;
	markerUnits?: string;
	orient?: string;
	strokeWidth?: number;
};
type EdgeMarkerType = string | EdgeMarker;
declare enum MarkerType {
	Arrow = "arrow",
	ArrowClosed = "arrowclosed"
}
type EdgePosition = {
	sourceX: number;
	sourceY: number;
	targetX: number;
	targetY: number;
	sourcePosition: Position;
	targetPosition: Position;
};
type OnNodesChange<NodeType extends Node$1 = Node$1> = (changes: NodeChange<NodeType>[]) => void;
type OnEdgesChange<EdgeType extends Edge = Edge> = (changes: EdgeChange<EdgeType>[]) => void;
type OnNodesDelete<NodeType extends Node$1 = Node$1> = (nodes: NodeType[]) => void;
type OnEdgesDelete<EdgeType extends Edge = Edge> = (edges: EdgeType[]) => void;
type OnDelete<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> = (params: {
	nodes: NodeType[];
	edges: EdgeType[];
}) => void;
type NodeTypes = Record<string, ComponentType<NodeProps$1 & {
	data: any;
	type: any;
}>>;
type EdgeTypes = Record<string, ComponentType<EdgeProps & {
	data: any;
	type: any;
}>>;
type OnSelectionChangeParams<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> = {
	nodes: NodeType[];
	edges: EdgeType[];
};
type OnSelectionChangeFunc<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> = (params: OnSelectionChangeParams<NodeType, EdgeType>) => void;
type FitViewOptions<NodeType extends Node$1 = Node$1> = FitViewOptionsBase<NodeType>;
type FitView<NodeType extends Node$1 = Node$1> = (fitViewOptions?: FitViewOptions<NodeType>) => Promise<boolean>;
type OnInit<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> = (reactFlowInstance: ReactFlowInstance<NodeType, EdgeType>) => void;
type ViewportHelperFunctions = {
	/**
	 * Zooms viewport in by 1.2.
	 *
	 * @param options.duration - optional duration. If set, a transition will be applied
	 */
	zoomIn: ZoomInOut;
	/**
	 * Zooms viewport out by 1 / 1.2.
	 *
	 * @param options.duration - optional duration. If set, a transition will be applied
	 */
	zoomOut: ZoomInOut;
	/**
	 * Zoom the viewport to a given zoom level. Passing in a `duration` will animate the viewport to
	 * the new zoom level.
	 *
	 * @param zoomLevel - the zoom level to set
	 * @param options.duration - optional duration. If set, a transition will be applied
	 */
	zoomTo: ZoomTo;
	/**
	 * Get the current zoom level of the viewport.
	 *
	 * @returns current zoom as a number
	 */
	getZoom: GetZoom;
	/**
	 * Sets the current viewport.
	 *
	 * @param viewport - the viewport to set
	 * @param options.duration - optional duration. If set, a transition will be applied
	 */
	setViewport: SetViewport;
	/**
	 * Returns the current viewport.
	 *
	 * @returns Viewport
	 */
	getViewport: GetViewport;
	/**
	 * Center the viewport on a given position. Passing in a `duration` will animate the viewport to
	 * the new position.
	 *
	 * @param x - x position
	 * @param y - y position
	 * @param options.zoom - optional zoom
	 */
	setCenter: SetCenter;
	/**
	 * A low-level utility function to fit the viewport to a given rectangle. By passing in a
	 * `duration`, the viewport will animate from its current position to the new position. The
	 * `padding` option can be used to add space around the bounds.
	 *
	 * @param bounds - the bounds ({ x: number, y: number, width: number, height: number }) to fit the view to
	 * @param options.padding - optional padding
	 */
	fitBounds: FitBounds;
	/**
	 * With this function you can translate a screen pixel position to a flow position. It is useful
	 * for implementing drag and drop from a sidebar for example.
	 *
	 * @param clientPosition - the screen / client position. When you are working with events you can use event.clientX and event.clientY
	 * @param options.snapToGrid - if true, the converted position will be snapped to the grid
	 * @returns position as { x: number, y: number }
	 *
	 * @example
	 * const flowPosition = screenToFlowPosition({ x: event.clientX, y: event.clientY })
	 */
	screenToFlowPosition: (clientPosition: XYPosition, options?: {
		snapToGrid: boolean;
	}) => XYPosition;
	/**
	 * Translate a position inside the flow's canvas to a screen pixel position.
	 *
	 * @param flowPosition - the screen / client position. When you are working with events you can use event.clientX and event.clientY
	 * @returns position as { x: number, y: number }
	 *
	 * @example
	 * const clientPosition = flowToScreenPosition({ x: node.position.x, y: node.position.y })
	 */
	flowToScreenPosition: (flowPosition: XYPosition) => XYPosition;
};
type OnBeforeDelete<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> = OnBeforeDeleteBase<NodeType, EdgeType>;
type IsValidConnection<EdgeType extends Edge = Edge> = (edge: EdgeType | Connection) => boolean;
type Node$1<NodeData extends Record<string, unknown> = Record<string, unknown>, NodeType extends string = string> = NodeBase<NodeData, NodeType> & {
	style?: CSSProperties;
	className?: string;
	resizing?: boolean;
	focusable?: boolean;
};
type InternalNode<NodeType extends Node$1 = Node$1> = InternalNodeBase<NodeType>;
type NodeMouseHandler<NodeType extends Node$1 = Node$1> = (event: ReactMouseEvent, node: NodeType) => void;
type SelectionDragHandler<NodeType extends Node$1 = Node$1> = (event: ReactMouseEvent, nodes: NodeType[]) => void;
type OnNodeDrag<NodeType extends Node$1 = Node$1> = (event: ReactMouseEvent, node: NodeType, nodes: NodeType[]) => void;
type NodeProps$1<NodeType extends Node$1 = Node$1> = NodeProps<NodeType>;
type EdgeLabelOptions = {
	/**
	 * The label or custom element to render along the edge. This is commonly a text label or some
	 * custom controls.
	 */
	label?: ReactNode;
	/**
	 * Custom styles to apply to the label.
	 */
	labelStyle?: CSSProperties;
	labelShowBg?: boolean;
	labelBgStyle?: CSSProperties;
	labelBgPadding?: [
		number,
		number
	];
	labelBgBorderRadius?: number;
};
type Edge<EdgeData extends Record<string, unknown> = Record<string, unknown>, EdgeType extends string | undefined = string | undefined> = EdgeBase<EdgeData, EdgeType> & EdgeLabelOptions & {
	style?: CSSProperties;
	className?: string;
	/**
	 * Determines whether the edge can be updated by dragging the source or target to a new node.
	 * This property will override the default set by the `edgesReconnectable` prop on the
	 * `<ReactFlow />` component.
	 */
	reconnectable?: boolean | HandleType;
	focusable?: boolean;
};
type EdgeMouseHandler<EdgeType extends Edge = Edge> = (event: ReactMouseEvent, edge: EdgeType) => void;
type DefaultEdgeOptions = DefaultEdgeOptionsBase<Edge>;
type EdgeProps<EdgeType extends Edge = Edge> = Pick<EdgeType, "id" | "animated" | "data" | "style" | "selected" | "source" | "target" | "selectable" | "deletable"> & EdgePosition & EdgeLabelOptions & {
	sourceHandleId?: string | null;
	targetHandleId?: string | null;
	markerStart?: string;
	markerEnd?: string;
	pathOptions?: any;
	interactionWidth?: number;
};
type OnReconnect<EdgeType extends Edge = Edge> = (oldEdge: EdgeType, newConnection: Connection) => void;
type ConnectionLineComponentProps<NodeType extends Node$1 = Node$1> = {
	connectionLineStyle?: CSSProperties;
	connectionLineType: ConnectionLineType;
	/** The node the connection line originates from. */
	fromNode: InternalNode<NodeType>;
	/** The handle on the `fromNode` that the connection line originates from. */
	fromHandle: Handle;
	fromX: number;
	fromY: number;
	toX: number;
	toY: number;
	fromPosition: Position;
	toPosition: Position;
	/**
	 * If there is an `isValidConnection` callback, this prop will be set to `"valid"` or `"invalid"`
	 * based on the return value of that callback. Otherwise, it will be `null`.
	 */
	connectionStatus: "valid" | "invalid" | null;
	toNode: InternalNode<NodeType> | null;
	toHandle: Handle | null;
};
type ConnectionLineComponent<NodeType extends Node$1 = Node$1> = ComponentType<ConnectionLineComponentProps<NodeType>>;
interface ReactFlowProps<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> extends Omit<HTMLAttributes<HTMLDivElement>, "onError"> {
	/**
	 * An array of nodes to render in a controlled flow.
	 * @default []
	 * @example
	 * const nodes = [
	 *  {
	 *    id: 'node-1',
	 *    type: 'input',
	 *    data: { label: 'Node 1' },
	 *    position: { x: 250, y: 50 }
	 *  }
	 * ];
	 */
	nodes?: NodeType[];
	/**
	 * An array of edges to render in a controlled flow.
	 * @default []
	 * @example
	 * const edges = [
	 *  {
	 *    id: 'edge-1-2',
	 *    source: 'node-1',
	 *    target: 'node-2',
	 *  }
	 * ];
	 */
	edges?: EdgeType[];
	/** The initial nodes to render in an uncontrolled flow. */
	defaultNodes?: NodeType[];
	/** The initial edges to render in an uncontrolled flow. */
	defaultEdges?: EdgeType[];
	/**
	 * Defaults to be applied to all new edges that are added to the flow.
	 *
	 * Properties on a new edge will override these defaults if they exist.
	 * @example
	 * const defaultEdgeOptions = {
	 *  type: 'customEdgeType',
	 *  animated: true,
	 *  interactionWidth: 10,
	 *  data: { label: 'custom label' },
	 *  hidden: false,
	 *  deletable: true,
	 *  selected: false,
	 *  focusable: true,
	 *  markerStart: EdgeMarker.ArrowClosed,
	 *  markerEnd: EdgeMarker.ArrowClosed,
	 *  zIndex: 12,
	 *  ariaLabel: 'custom aria label'
	 * }
	 */
	defaultEdgeOptions?: DefaultEdgeOptions;
	/** This event handler is called when a user clicks on a node. */
	onNodeClick?: NodeMouseHandler<NodeType>;
	/** This event handler is called when a user double-clicks on a node. */
	onNodeDoubleClick?: NodeMouseHandler<NodeType>;
	/** This event handler is called when mouse of a user enters a node. */
	onNodeMouseEnter?: NodeMouseHandler<NodeType>;
	/** This event handler is called when mouse of a user moves over a node. */
	onNodeMouseMove?: NodeMouseHandler<NodeType>;
	/** This event handler is called when mouse of a user leaves a node. */
	onNodeMouseLeave?: NodeMouseHandler<NodeType>;
	/** This event handler is called when a user right-clicks on a node. */
	onNodeContextMenu?: NodeMouseHandler<NodeType>;
	/** This event handler is called when a user starts to drag a node. */
	onNodeDragStart?: OnNodeDrag<NodeType>;
	/** This event handler is called when a user drags a node. */
	onNodeDrag?: OnNodeDrag<NodeType>;
	/** This event handler is called when a user stops dragging a node. */
	onNodeDragStop?: OnNodeDrag<NodeType>;
	/** This event handler is called when a user clicks on an edge. */
	onEdgeClick?: (event: ReactMouseEvent, edge: EdgeType) => void;
	/** This event handler is called when a user right-clicks on an edge. */
	onEdgeContextMenu?: EdgeMouseHandler<EdgeType>;
	/** This event handler is called when mouse of a user enters an edge. */
	onEdgeMouseEnter?: EdgeMouseHandler<EdgeType>;
	/** This event handler is called when mouse of a user moves over an edge. */
	onEdgeMouseMove?: EdgeMouseHandler<EdgeType>;
	/** This event handler is called when mouse of a user leaves an edge. */
	onEdgeMouseLeave?: EdgeMouseHandler<EdgeType>;
	/** This event handler is called when a user double-clicks on an edge. */
	onEdgeDoubleClick?: EdgeMouseHandler<EdgeType>;
	/**
	 * This handler is called when the source or target of a reconnectable edge is dragged from the
	 * current node. It will fire even if the edge's source or target do not end up changing.
	 *
	 * You can use the `reconnectEdge` utility to convert the connection to a new edge.
	 */
	onReconnect?: OnReconnect<EdgeType>;
	/**
	 * This event fires when the user begins dragging the source or target of an editable edge.
	 */
	onReconnectStart?: (event: ReactMouseEvent, edge: EdgeType, handleType: HandleType) => void;
	/**
	 * This event fires when the user releases the source or target of an editable edge. It is called
	 * even if an edge update does not occur.
	 *
	 */
	onReconnectEnd?: (event: MouseEvent | TouchEvent, edge: EdgeType, handleType: HandleType) => void;
	/**
	 * Use this event handler to add interactivity to a controlled flow.
	 * It is called on node drag, select, and move.
	 * @example // Use NodesState hook to create edges and get onNodesChange handler
	 * import ReactFlow, { useNodesState } from '@xyflow/react';
	 * const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
	 *
	 * return (<ReactFlow onNodeChange={onNodeChange} {...rest} />)
	 * @example // Use helper function to update node
	 * import ReactFlow, { applyNodeChanges } from '@xyflow/react';
	 *
	 * const onNodeChange = useCallback(
	 *  (changes) => setNode((nds) => applyNodeChanges(changes, nds)),
	 *  [],
	 * );
	 *
	 * return (<ReactFlow onNodeChange={onNodeChange} {...rest} />)
	 */
	onNodesChange?: OnNodesChange<NodeType>;
	/**
	 * Use this event handler to add interactivity to a controlled flow. It is called on edge select
	 * and remove.
	 * @example // Use EdgesState hook to create edges and get onEdgesChange handler
	 * import ReactFlow, { useEdgesState } from '@xyflow/react';
	 * const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
	 *
	 * return (<ReactFlow onEdgesChange={onEdgesChange} {...rest} />)
	 * @example // Use helper function to update edge
	 * import ReactFlow, { applyEdgeChanges } from '@xyflow/react';
	 *
	 * const onEdgesChange = useCallback(
	 *  (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
	 *  [],
	 * );
	 *
	 * return (<ReactFlow onEdgesChange={onEdgesChange} {...rest} />)
	 */
	onEdgesChange?: OnEdgesChange<EdgeType>;
	/** This event handler gets called when a node is deleted. */
	onNodesDelete?: OnNodesDelete<NodeType>;
	/** This event handler gets called when an edge is deleted. */
	onEdgesDelete?: OnEdgesDelete<EdgeType>;
	/** This event handler gets called when a node or edge is deleted. */
	onDelete?: OnDelete<NodeType, EdgeType>;
	/** This event handler gets called when a user starts to drag a selection box. */
	onSelectionDragStart?: SelectionDragHandler<NodeType>;
	/** This event handler gets called when a user drags a selection box. */
	onSelectionDrag?: SelectionDragHandler<NodeType>;
	/** This event handler gets called when a user stops dragging a selection box. */
	onSelectionDragStop?: SelectionDragHandler<NodeType>;
	onSelectionStart?: (event: ReactMouseEvent) => void;
	onSelectionEnd?: (event: ReactMouseEvent) => void;
	/**
	 * This event handler is called when a user right-clicks on a node selection.
	 */
	onSelectionContextMenu?: (event: ReactMouseEvent, nodes: NodeType[]) => void;
	/**
	 * When a connection line is completed and two nodes are connected by the user, this event fires with the new connection.
	 *
	 * You can use the `addEdge` utility to convert the connection to a complete edge.
	 * @example // Use helper function to update edges onConnect
	 * import ReactFlow, { addEdge } from '@xyflow/react';
	 *
	 * const onConnect = useCallback(
	 *  (params) => setEdges((eds) => addEdge(params, eds)),
	 *  [],
	 * );
	 *
	 * return (<ReactFlow onConnect={onConnect} {...rest} />)
	 */
	onConnect?: OnConnect;
	/** This event handler gets called when a user starts to drag a connection line. */
	onConnectStart?: OnConnectStart;
	/**
	 * This callback will fire regardless of whether a valid connection could be made or not. You can
	 * use the second `connectionState` parameter to have different behavior when a connection was
	 * unsuccessful.
	 */
	onConnectEnd?: OnConnectEnd;
	onClickConnectStart?: OnConnectStart;
	onClickConnectEnd?: OnConnectEnd;
	/**
	 * The `onInit` callback is called when the viewport is initialized. At this point you can use the
	 * instance to call methods like `fitView` or `zoomTo`.
	 */
	onInit?: OnInit<NodeType, EdgeType>;
	/** This event handler is called while the user is either panning or zooming the viewport. */
	onMove?: OnMove;
	/** This event handler is called when the user begins to pan or zoom the viewport. */
	onMoveStart?: OnMoveStart;
	/**
	 * This event handler is called when panning or zooming viewport movement stops.
	 * If the movement is not user-initiated, the event parameter will be `null`.
	 */
	onMoveEnd?: OnMoveEnd;
	/** This event handler gets called when a user changes group of selected elements in the flow. */
	onSelectionChange?: OnSelectionChangeFunc<NodeType, EdgeType>;
	/** This event handler gets called when user scroll inside the pane. */
	onPaneScroll?: (event?: WheelEvent) => void;
	/** This event handler gets called when user clicks inside the pane. */
	onPaneClick?: (event: ReactMouseEvent) => void;
	/** This event handler gets called when user right clicks inside the pane. */
	onPaneContextMenu?: (event: ReactMouseEvent | MouseEvent) => void;
	/** This event handler gets called when mouse enters the pane. */
	onPaneMouseEnter?: (event: ReactMouseEvent) => void;
	/** This event handler gets called when mouse moves over the pane. */
	onPaneMouseMove?: (event: ReactMouseEvent) => void;
	/** This event handler gets called when mouse leaves the pane. */
	onPaneMouseLeave?: (event: ReactMouseEvent) => void;
	/**
	 * Distance that the mouse can move between mousedown/up that will trigger a click.
	 * @default 0
	 */
	paneClickDistance?: number;
	/**
	 * Distance that the mouse can move between mousedown/up that will trigger a click.
	 * @default 0
	 */
	nodeClickDistance?: number;
	/**
	 * This handler is called before nodes or edges are deleted, allowing the deletion to be aborted
	 * by returning `false` or modified by returning updated nodes and edges.
	 */
	onBeforeDelete?: OnBeforeDelete<NodeType, EdgeType>;
	/**
	 * Custom node types to be available in a flow.
	 *
	 * React Flow matches a node's type to a component in the `nodeTypes` object.
	 * @TODO check if @default is correct
	 * @default {
	 *   input: InputNode,
	 *   default: DefaultNode,
	 *   output: OutputNode,
	 *   group: GroupNode
	 * }
	 * @example
	 * import CustomNode from './CustomNode';
	 *
	 * const nodeTypes = { nameOfNodeType: CustomNode };
	 */
	nodeTypes?: NodeTypes;
	/**
	 * Custom edge types to be available in a flow.
	 *
	 * React Flow matches an edge's type to a component in the `edgeTypes` object.
	 * @TODO check if @default is correct
	 * @default {
	 *   default: BezierEdge,
	 *   straight: StraightEdge,
	 *   step: StepEdge,
	 *   smoothstep: SmoothStepEdge,
	 *   simplebezier: SimpleBezier
	 * }
	 * @example
	 * import CustomEdge from './CustomEdge';
	 *
	 * const edgeTypes = { nameOfEdgeType: CustomEdge };
	 */
	edgeTypes?: EdgeTypes;
	/**
	 * The type of edge path to use for connection lines.
	 *
	 * Although created edges can be of any type, React Flow needs to know what type of path to render for the connection line before the edge is created!
	 * @default ConnectionLineType.Bezier
	 */
	connectionLineType?: ConnectionLineType;
	/** Styles to be applied to the connection line. */
	connectionLineStyle?: CSSProperties;
	/** React Component to be used as a connection line. */
	connectionLineComponent?: ConnectionLineComponent<NodeType>;
	/** Styles to be applied to the container of the connection line. */
	connectionLineContainerStyle?: CSSProperties;
	/**
	 * A loose connection mode will allow you to connect handles with differing types, including
	 * source-to-source connections. However, it does not support target-to-target connections. Strict
	 * mode allows only connections between source handles and target handles.
	 * @default 'strict'
	 */
	connectionMode?: ConnectionMode;
	/**
	 * If set, pressing the key or chord will delete any selected nodes and edges. Passing an array
	 * represents multiple keys that can be pressed.
	 *
	 * For example, `["Delete", "Backspace"]` will delete selected elements when either key is pressed.
	 * @default 'Backspace'
	 */
	deleteKeyCode?: KeyCode | null;
	/**
	 * If set, holding this key will let you click and drag to draw a selection box around multiple
	 * nodes and edges. Passing an array represents multiple keys that can be pressed.
	 *
	 * For example, `["Shift", "Meta"]` will allow you to draw a selection box when either key is
	 * pressed.
	 * @default 'Shift'
	 */
	selectionKeyCode?: KeyCode | null;
	/**
	 * Select multiple elements with a selection box, without pressing down `selectionKey`.
	 * @default false
	 */
	selectionOnDrag?: boolean;
	/**
	 * When set to `"partial"`, when the user creates a selection box by click and dragging nodes that
	 * are only partially in the box are still selected.
	 * @default 'full'
	 */
	selectionMode?: SelectionMode$1;
	/**
	 * If a key is set, you can pan the viewport while that key is held down even if `panOnScroll`
	 * is set to `false`.
	 *
	 * By setting this prop to `null` you can disable this functionality.
	 * @default 'Space'
	 */
	panActivationKeyCode?: KeyCode | null;
	/**
	 * Pressing down this key you can select multiple elements by clicking.
	 * @default "Meta" for macOS, "Control" for other systems
	 */
	multiSelectionKeyCode?: KeyCode | null;
	/**
	 * If a key is set, you can zoom the viewport while that key is held down even if `panOnScroll`
	 * is set to `false`.
	 *
	 * By setting this prop to `null` you can disable this functionality.
	 * @default "Meta" for macOS, "Control" for other systems
	 *
	 */
	zoomActivationKeyCode?: KeyCode | null;
	/** When enabled, nodes will snap to the grid when dragged. */
	snapToGrid?: boolean;
	/**
	 * If `snapToGrid` is enabled, this prop configures the grid that nodes will snap to.
	 * @example [20, 20]
	 */
	snapGrid?: SnapGrid;
	/**
	 * You can enable this optimisation to instruct React Flow to only render nodes and edges that would be visible in the viewport.
	 *
	 * This might improve performance when you have a large number of nodes and edges but also adds an overhead.
	 * @default false
	 */
	onlyRenderVisibleElements?: boolean;
	/**
	 * Controls whether all nodes should be draggable or not. Individual nodes can override this
	 * setting by setting their `draggable` prop. If you want to use the mouse handlers on
	 * non-draggable nodes, you need to add the `"nopan"` class to those nodes.
	 * @default true
	 */
	nodesDraggable?: boolean;
	/**
	 * Controls whether all nodes should be connectable or not. Individual nodes can override this
	 * setting by setting their `connectable` prop.
	 * @default true
	 */
	nodesConnectable?: boolean;
	/**
	 * When `true`, focus between nodes can be cycled with the `Tab` key and selected with the `Enter`
	 * key. This option can be overridden by individual nodes by setting their `focusable` prop.
	 * @default true
	 */
	nodesFocusable?: boolean;
	/**
	 * The origin of the node to use when placing it in the flow or looking up its `x` and `y`
	 * position. An origin of `[0, 0]` means that a node's top left corner will be placed at the `x`
	 * and `y` position.
	 * @default [0, 0]
	 * @example
	 * [0, 0] // default, top left
	 * [0.5, 0.5] // center
	 * [1, 1] // bottom right
	 */
	nodeOrigin?: NodeOrigin;
	/**
	 * When `true`, focus between edges can be cycled with the `Tab` key and selected with the `Enter`
	 * key. This option can be overridden by individual edges by setting their `focusable` prop.
	 * @default true
	 */
	edgesFocusable?: boolean;
	/**
	 * Whether edges can be updated once they are created. When both this prop is `true` and an
	 * `onReconnect` handler is provided, the user can drag an existing edge to a new source or
	 * target. Individual edges can override this value with their reconnectable property.
	 * @default true
	 */
	edgesReconnectable?: boolean;
	/**
	 * When `true`, elements (nodes and edges) can be selected by clicking on them. This option can be
	 * overridden by individual elements by setting their `selectable` prop.
	 * @default true
	 */
	elementsSelectable?: boolean;
	/**
	 * If `true`, nodes get selected on drag.
	 * @default true
	 */
	selectNodesOnDrag?: boolean;
	/**
	 * Enabling this prop allows users to pan the viewport by clicking and dragging.
	 *
	 * You can also set this prop to an array of numbers to limit which mouse buttons can activate panning.
	 * @default true
	 * @example [0, 2] // allows panning with the left and right mouse buttons
	 * [0, 1, 2, 3, 4] // allows panning with all mouse buttons
	 */
	panOnDrag?: boolean | number[];
	/**
	 * Minimum zoom level.
	 * @default 0.5
	 */
	minZoom?: number;
	/**
	 * Maximum zoom level.
	 * @default 2
	 */
	maxZoom?: number;
	/**
	 * When you pass a `viewport` prop, it's controlled, and you also need to pass `onViewportChange`
	 * to handle internal changes.
	 */
	viewport?: Viewport;
	/**
	 * Sets the initial position and zoom of the viewport. If a default viewport is provided but
	 * `fitView` is enabled, the default viewport will be ignored.
	 * @default { x: 0, y: 0, zoom: 1 }
	 * @example
	 * const initialViewport = {
	 *  zoom: 0.5,
	 *  position: { x: 0, y: 0 }
	 * };
	 */
	defaultViewport?: Viewport;
	/**
	 * Used when working with a controlled viewport for updating the user viewport state.
	 */
	onViewportChange?: (viewport: Viewport) => void;
	/**
	 * By default, the viewport extends infinitely. You can use this prop to set a boundary.
	 *
	 * The first pair of coordinates is the top left boundary and the second pair is the bottom right.
	 * @default [[-∞, -∞], [+∞, +∞]]
	 * @example [[-1000, -10000], [1000, 1000]]
	 */
	translateExtent?: CoordinateExtent;
	/**
	 * Disabling this prop will allow the user to scroll the page even when their pointer is over the flow.
	 * @default true
	 */
	preventScrolling?: boolean;
	/**
	 * By default, nodes can be placed on an infinite flow. You can use this prop to set a boundary.
	 *
	 * The first pair of coordinates is the top left boundary and the second pair is the bottom right.
	 * @example [[-1000, -10000], [1000, 1000]]
	 */
	nodeExtent?: CoordinateExtent;
	/**
	 * Color of edge markers.
	 * @default '#b1b1b7'
	 */
	defaultMarkerColor?: string;
	/**
	 * Controls if the viewport should zoom by scrolling inside the container.
	 * @default true
	 */
	zoomOnScroll?: boolean;
	/**
	 * Controls if the viewport should zoom by pinching on a touch screen.
	 * @default true
	 */
	zoomOnPinch?: boolean;
	/**
	 * Controls if the viewport should pan by scrolling inside the container.
	 *
	 * Can be limited to a specific direction with `panOnScrollMode`.
	 * @default false
	 */
	panOnScroll?: boolean;
	/**
	 * Controls how fast viewport should be panned on scroll.
	 *
	 * Use together with `panOnScroll` prop.
	 * @default 0.5
	 */
	panOnScrollSpeed?: number;
	/**
	 * This prop is used to limit the direction of panning when `panOnScroll` is enabled.
	 *
	 * The `"free"` option allows panning in any direction.
	 * @default "free"
	 * @example "horizontal" | "vertical"
	 */
	panOnScrollMode?: PanOnScrollMode;
	/**
	 * Controls if the viewport should zoom by double-clicking somewhere on the flow.
	 * @default true
	 */
	zoomOnDoubleClick?: boolean;
	/**
	 * The radius around an edge connection that can trigger an edge reconnection.
	 * @default 10
	 */
	reconnectRadius?: number;
	/**
	 * If a node is draggable, clicking and dragging that node will move it around the canvas. Adding
	 * the `"nodrag"` class prevents this behavior and this prop allows you to change the name of that
	 * class.
	 * @default "nodrag"
	 */
	noDragClassName?: string;
	/**
	 * Typically, scrolling the mouse wheel when the mouse is over the canvas will zoom the viewport.
	 * Adding the `"nowheel"` class to an element n the canvas will prevent this behavior and this prop
	 * allows you to change the name of that class.
	 * @default "nowheel"
	 */
	noWheelClassName?: string;
	/**
	 * If an element in the canvas does not stop mouse events from propagating, clicking and dragging
	 * that element will pan the viewport. Adding the `"nopan"` class prevents this behavior and this
	 * prop allows you to change the name of that class.
	 * @default "nopan"
	 */
	noPanClassName?: string;
	/** When `true`, the flow will be zoomed and panned to fit all the nodes initially provided. */
	fitView?: boolean;
	/**
	 * When you typically call `fitView` on a `ReactFlowInstance`, you can provide an object of
	 * options to customize its behavior. This prop lets you do the same for the initial `fitView`
	 * call.
	 * @example
	 * const fitViewOptions = {
	 *  padding: 0.1,
	 *  includeHiddenNodes: false,
	 *  minZoom: 0.1,
	 *  maxZoom: 1,
	 *  duration: 200,
	 *  nodes: [{id: 'node-1'}, {id: 'node-2'}], // nodes to fit
	 * };
	 */
	fitViewOptions?: FitViewOptions;
	/**
	 * The `connectOnClick` option lets you click or tap on a source handle to start a connection
	 * and then click on a target handle to complete the connection.
	 *
	 * If you set this option to `false`, users will need to drag the connection line to the target
	 * handle to create a connection.
	 * @default true
	 */
	connectOnClick?: boolean;
	/**
	 * By default, React Flow will render a small attribution in the bottom right corner of the flow.
	 *
	 * You can use this prop to change its position in case you want to place something else there.
	 * @default 'bottom-right'
	 * @example 'top-left' | 'top-center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'bottom-right'
	 */
	attributionPosition?: PanelPosition;
	/**
	 * By default, we render a small attribution in the corner of your flows that links back to the project.
	 *
	 * Anyone is free to remove this attribution whether they're a Pro subscriber or not
	 * but we ask that you take a quick look at our {@link https://reactflow.dev/learn/troubleshooting/remove-attribution | removing attribution guide}
	 * before doing so.
	 */
	proOptions?: ProOptions;
	/**
	 * Enabling this option will raise the z-index of nodes when they are selected.
	 * @default true
	 */
	elevateNodesOnSelect?: boolean;
	/**
	 * Enabling this option will raise the z-index of edges when they are selected.
	 */
	elevateEdgesOnSelect?: boolean;
	/**
	 * You can use this prop to disable keyboard accessibility features such as selecting nodes or
	 * moving selected nodes with the arrow keys.
	 * @default false
	 */
	disableKeyboardA11y?: boolean;
	/**
	 * When `true`, the viewport will pan automatically when the cursor moves to the edge of the
	 * viewport while dragging a node.
	 * @default true
	 */
	autoPanOnNodeDrag?: boolean;
	/**
	 * When `true`, the viewport will pan automatically when the cursor moves to the edge of the
	 * viewport while creating a connection.
	 * @default true
	 */
	autoPanOnConnect?: boolean;
	/**
	 * The speed at which the viewport pans while dragging a node or a selection box.
	 * @default 15
	 */
	autoPanSpeed?: number;
	/**
	 * The radius around a handle where you drop a connection line to create a new edge.
	 * @default 20
	 */
	connectionRadius?: number;
	/**
	 * Occasionally something may happen that causes React Flow to throw an error.
	 *
	 * Instead of exploding your application, we log a message to the console and then call this event handler.
	 * You might use it for additional logging or to show a message to the user.
	 */
	onError?: OnError;
	/**
	 * This callback can be used to validate a new connection
	 *
	 * If you return `false`, the edge will not be added to your flow.
	 * If you have custom connection logic its preferred to use this callback over the
	 * `isValidConnection` prop on the handle component for performance reasons.
	 */
	isValidConnection?: IsValidConnection<EdgeType>;
	/**
	 * With a threshold greater than zero you can delay node drag events.
	 *
	 * If threshold equals 1, you need to drag the node 1 pixel before a drag event is fired.
	 *
	 * 1 is the default value, so clicks don't trigger drag events.
	 * @default 1
	 */
	nodeDragThreshold?: number;
	/** Sets a fixed width for the flow. */
	width?: number;
	/** Sets a fixed height for the flow. */
	height?: number;
	/**
	 * Controls color scheme used for styling the flow.
	 * @default 'light'
	 * @example 'system' | 'light' | 'dark'
	 */
	colorMode?: ColorMode;
	/**
	 * If set `true`, some debug information will be logged to the console like which events are fired.
	 * @default false
	 */
	debug?: boolean;
}
type ReactFlowJsonObject<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> = {
	nodes: NodeType[];
	edges: EdgeType[];
	viewport: Viewport;
};
type DeleteElementsOptions = {
	nodes?: (Node$1 | {
		id: Node$1["id"];
	})[];
	edges?: (Edge | {
		id: Edge["id"];
	})[];
};
type GeneralHelpers<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> = {
	/**
	 * Returns nodes.
	 *
	 * @returns nodes array
	 */
	getNodes: () => NodeType[];
	/**
	 * Set your nodes array to something else by either overwriting it with a new array or by passing
	 * in a function to update the existing array. If using a function, it is important to make sure a
	 * new array is returned instead of mutating the existing array. Calling this function will
	 * trigger the `onNodesChange` handler in a controlled flow.
	 *
	 * @param payload - the nodes to set or a function that receives the current nodes and returns the new nodes
	 */
	setNodes: (payload: NodeType[] | ((nodes: NodeType[]) => NodeType[])) => void;
	/**
	 * Add one or many nodes to your existing nodes array. Calling this function will trigger the
	 * `onNodesChange` handler in a controlled flow.
	 *
	 * @param payload - the nodes to add
	 */
	addNodes: (payload: NodeType[] | NodeType) => void;
	/**
	 * Returns a node by id.
	 *
	 * @param id - the node id
	 * @returns the node or undefined if no node was found
	 */
	getNode: (id: string) => NodeType | undefined;
	/**
	 * Returns an internal node by id.
	 *
	 * @param id - the node id
	 * @returns the internal node or undefined if no node was found
	 */
	getInternalNode: (id: string) => InternalNode<NodeType> | undefined;
	/**
	 * Returns edges.
	 *
	 * @returns edges array
	 */
	getEdges: () => EdgeType[];
	/**
	 * Set your edges array to something else by either overwriting it with a new array or by passing
	 * in a function to update the existing array. If using a function, it is important to make sure a
	 * new array is returned instead of mutating the existing array. Calling this function will
	 * trigger the `onEdgesChange` handler in a controlled flow.
	 *
	 * @param payload - the edges to set or a function that receives the current edges and returns the new edges
	 */
	setEdges: (payload: EdgeType[] | ((edges: EdgeType[]) => EdgeType[])) => void;
	/**
	 * Add one or many edges to your existing edges array. Calling this function will trigger the
	 * `onEdgesChange` handler in a controlled flow.
	 *
	 * @param payload - the edges to add
	 */
	addEdges: (payload: EdgeType[] | EdgeType) => void;
	/**
	 * Returns an edge by id.
	 *
	 * @param id - the edge id
	 * @returns the edge or undefined if no edge was found
	 */
	getEdge: (id: string) => EdgeType | undefined;
	/**
	 * Returns the nodes, edges and the viewport as a JSON object.
	 *
	 * @returns the nodes, edges and the viewport as a JSON object
	 */
	toObject: () => ReactFlowJsonObject<NodeType, EdgeType>;
	/**
	 * Deletes nodes and edges.
	 *
	 * @param params.nodes - optional nodes array to delete
	 * @param params.edges - optional edges array to delete
	 *
	 * @returns a promise that resolves with the deleted nodes and edges
	 */
	deleteElements: (params: DeleteElementsOptions) => Promise<{
		deletedNodes: Node$1[];
		deletedEdges: Edge[];
	}>;
	/**
	 * Find all the nodes currently intersecting with a given node or rectangle. The `partially`
	 * parameter can be set to `true` to include nodes that are only partially intersecting.
	 *
	 * @param node - the node or rect to check for intersections
	 * @param partially - if true, the node is considered to be intersecting if it partially overlaps with the passed node or rect
	 * @param nodes - optional nodes array to check for intersections
	 *
	 * @returns an array of intersecting nodes
	 */
	getIntersectingNodes: (node: NodeType | {
		id: Node$1["id"];
	} | Rect, partially?: boolean, nodes?: NodeType[]) => NodeType[];
	/**
	 * Determine if a given node or rectangle is intersecting with another rectangle. The `partially`
	 * parameter can be set to true return `true` even if the node is only partially intersecting.
	 *
	 * @param node - the node or rect to check for intersections
	 * @param area - the rect to check for intersections
	 * @param partially - if true, the node is considered to be intersecting if it partially overlaps with the passed react
	 *
	 * @returns true if the node or rect intersects with the given area
	 */
	isNodeIntersecting: (node: NodeType | {
		id: Node$1["id"];
	} | Rect, area: Rect, partially?: boolean) => boolean;
	/**
	 * Updates a node.
	 *
	 * @param id - id of the node to update
	 * @param nodeUpdate - the node update as an object or a function that receives the current node and returns the node update
	 * @param options.replace - if true, the node is replaced with the node update, otherwise the changes get merged
	 *
	 * @example
	 * updateNode('node-1', (node) => ({ position: { x: node.position.x + 10, y: node.position.y } }));
	 */
	updateNode: (id: string, nodeUpdate: Partial<NodeType> | ((node: NodeType) => Partial<NodeType>), options?: {
		replace: boolean;
	}) => void;
	/**
	 * Updates the data attribute of a node.
	 *
	 * @param id - id of the node to update
	 * @param dataUpdate - the data update as an object or a function that receives the current data and returns the data update
	 * @param options.replace - if true, the data is replaced with the data update, otherwise the changes get merged
	 *
	 * @example
	 * updateNodeData('node-1', { label: 'A new label' });
	 */
	updateNodeData: (id: string, dataUpdate: Partial<NodeType["data"]> | ((node: NodeType) => Partial<NodeType["data"]>), options?: {
		replace: boolean;
	}) => void;
	/**
	 * Updates an edge.
	 *
	 * @param id - id of the edge to update
	 * @param edgeUpdate - the edge update as an object or a function that receives the current edge and returns the edge update
	 * @param options.replace - if true, the edge is replaced with the edge update, otherwise the changes get merged
	 *
	 * @example
	 * updateEdge('edge-1', (edge) => ({ label: 'A new label' }));
	 */
	updateEdge: (id: string, edgeUpdate: Partial<EdgeType> | ((edge: EdgeType) => Partial<EdgeType>), options?: {
		replace: boolean;
	}) => void;
	/**
	 * Updates the data attribute of a edge.
	 *
	 * @param id - id of the edge to update
	 * @param dataUpdate - the data update as an object or a function that receives the current data and returns the data update
	 * @param options.replace - if true, the data is replaced with the data update, otherwise the changes get merged
	 *
	 * @example
	 * updateEdgeData('edge-1', { label: 'A new label' });
	 */
	updateEdgeData: (id: string, dataUpdate: Partial<EdgeType["data"]> | ((edge: EdgeType) => Partial<EdgeType["data"]>), options?: {
		replace: boolean;
	}) => void;
	/**
	 * Returns the bounds of the given nodes or node ids.
	 *
	 * @param nodes - the nodes or node ids to calculate the bounds for
	 *
	 * @returns the bounds of the given nodes
	 */
	getNodesBounds: (nodes: (NodeType | InternalNode | string)[]) => Rect;
	/**
	 * Get all the connections of a handle belonging to a specific node. The type parameter be either
	 * `'source'` or `'target'`.
	 * @deprecated
	 * @param type - handle type 'source' or 'target'
	 * @param id - the handle id (this is only needed if you have multiple handles of the same type, meaning you have to provide a unique id for each handle)
	 * @param nodeId - the node id the handle belongs to
	 * @returns an array with handle connections
	 */
	getHandleConnections: ({ type, id, nodeId, }: {
		type: HandleType;
		nodeId: string;
		id?: string | null;
	}) => HandleConnection[];
	/**
	 * Gets all connections to a node. Can be filtered by handle type and id.
	 * @param type - handle type 'source' or 'target'
	 * @param handleId - the handle id (this is only needed if you have multiple handles of the same type, meaning you have to provide a unique id for each handle)
	 * @param nodeId - the node id the handle belongs to
	 * @returns an array with handle connections
	 */
	getNodeConnections: ({ type, handleId, nodeId, }: {
		type?: HandleType;
		nodeId: string;
		handleId?: string | null;
	}) => NodeConnection[];
	fitView: FitView<NodeType>;
};
type ReactFlowInstance<NodeType extends Node$1 = Node$1, EdgeType extends Edge = Edge> = GeneralHelpers<NodeType, EdgeType> & ViewportHelperFunctions & {
	/**
	 * React Flow needs to mount the viewport to the DOM and initialize its zoom and pan behavior.
	 * This property tells you when viewport is initialized.
	 */
	viewportInitialized: boolean;
};
type ControlsCustomLayoutProps = {
	burgerMenu: ReactNode;
	navigationButtons: ReactNode;
	search: ReactNode;
	actionsGroup: ReactNode;
	syncInProgressBadge: ReactNode;
};
type ControlsCustomLayout = (props: ControlsCustomLayoutProps) => ReactNode;
type DiagramNodeWithNavigate<ID = ViewId> = Omit<DiagramNode, "navigateTo"> & {
	navigateTo: ID;
};
type ElementIconRendererProps = {
	node: {
		id: string;
		title: string;
		icon?: string | null | undefined;
	};
};
type ElementIconRenderer = (props: ElementIconRendererProps) => ReactNode;
type OnNavigateTo<ID = ViewId> = (to: ID, event?: ReactMouseEvent, element?: DiagramNodeWithNavigate<ID>) => void;
type OnNodeClick = (node: DiagramNode, event: ReactMouseEvent) => void;
type OnEdgeClick = (edge: DiagramEdge, event: ReactMouseEvent) => void;
type OnCanvasClick = (event: ReactMouseEvent) => void;
type ChangeEvent = {
	change: ViewChange;
};
type OnChange = (event: ChangeEvent) => void;
type OverrideReactFlowProps = Pick<ReactFlowProps, "paneClickDistance" | "nodeClickDistance" | "selectionKeyCode" | "panActivationKeyCode" | "multiSelectionKeyCode" | "zoomActivationKeyCode" | "snapToGrid" | "snapGrid" | "onlyRenderVisibleElements" | "nodesDraggable" | "nodesFocusable" | "elementsSelectable" | "selectNodesOnDrag" | "panOnDrag" | "preventScrolling" | "zoomOnScroll" | "zoomOnPinch" | "panOnScroll" | "panOnScrollSpeed" | "panOnScrollMode" | "zoomOnDoubleClick" | "nodeDragThreshold">;
type PaddingUnit$1 = "px" | "%";
type PaddingWithUnit$1 = `${number}${PaddingUnit$1}` | number;
interface LikeC4DiagramProperties {
	view: DiagramView;
	className?: string | undefined;
	/**
	 * Enable/disable panning
	 * @default true
	 */
	pannable?: boolean | undefined;
	/**
	 * Enable/disable zooming
	 * @default true
	 */
	zoomable?: boolean | undefined;
	/**
	 * Disable any editing (dragging still can be enabled with `nodesDraggable`)
	 * @default true
	 */
	readonly?: boolean | undefined;
	/**
	 * Show/hide panel with top left controls,
	 *
	 * @default true if not readonly
	 */
	controls?: boolean | undefined;
	/**
	 * If set, initial viewport will show all nodes & edges
	 * @default true
	 */
	fitView?: boolean | undefined;
	/**
	 * Padding around the diagram
	 * @default '8px'
	 */
	fitViewPadding?: PaddingWithUnit$1 | undefined;
	/**
	 * @default false if readonly
	 */
	nodesSelectable?: boolean | undefined;
	/**
	 * @default false if readonly
	 */
	nodesDraggable?: boolean | undefined;
	initialWidth?: number | undefined;
	initialHeight?: number | undefined;
	/**
	 * Background pattern
	 * @default 'dots'
	 */
	background?: "transparent" | "solid" | "dots" | "lines" | "cross" | undefined;
	/**
	 * Display webview with diagram title / description
	 * @default true
	 */
	showDiagramTitle?: boolean | undefined;
	/**
	 * Show back/forward history navigation buttons
	 * @default true if `onNavigateTo` is set
	 */
	showNavigationButtons?: undefined | boolean;
	/**
	 * Display notations of the view
	 * @default true
	 */
	showNotations?: boolean | undefined;
	/**
	 * Display dropdown with details on relationship's label click
	 * @default false
	 */
	enableRelationshipDetails?: boolean | undefined;
	/**
	 * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
	 * @default false
	 */
	enableFocusMode?: boolean | undefined;
	/**
	 * Enable search popup for elements and views
	 * @default true
	 */
	enableSearch?: boolean | undefined;
	/**
	 * Enable modal with element details
	 * @default false
	 */
	enableElementDetails?: boolean | undefined;
	/**
	 * Experimental feature to browse relationships
	 *
	 * @default false
	 */
	enableRelationshipBrowser?: boolean | undefined;
	/**
	 * If Walkthrough for dynamic views should be enabled
	 * @default false
	 */
	enableDynamicViewWalkthrough?: boolean | undefined;
	/**
	 * Experimental feature to enable edge editing
	 * @default false
	 */
	experimentalEdgeEditing?: boolean | undefined;
	/**
	 * Improve performance by hiding certain elements and reducing visual effects (disable mix-blend, shadows, animations)
	 *
	 * @default 'auto' - will be set to true if view has more then 3000 * 2000 pixels
	 */
	reduceGraphics?: "auto" | boolean | undefined;
	/**
	 * Render icon for an element, bundled or remote
	 * By default, if icon is http:// or https://, it will be rendered as an image
	 */
	renderIcon?: ElementIconRenderer | undefined;
	/**
	 * Customize layout of the controls on the top left
	 */
	renderControls?: ControlsCustomLayout | undefined;
	/**
	 * Dynamic filter, applies both to nodes and edges
	 */
	where?: WhereOperator<string, string> | undefined;
	/**
	 * Override ReactFlow props
	 */
	reactFlowProps?: OverrideReactFlowProps | undefined;
}
type OpenSourceParams = {
	element: Fqn;
	property?: string;
} | {
	relation: RelationId;
} | {
	deployment: Fqn;
	property?: string;
} | {
	view: ViewId;
};
interface LikeC4DiagramEventHandlers {
	onChange?: OnChange | null | undefined;
	onNavigateTo?: OnNavigateTo | null | undefined;
	onNodeClick?: OnNodeClick | null | undefined;
	onNodeContextMenu?: OnNodeClick | null | undefined;
	onCanvasContextMenu?: OnCanvasClick | null | undefined;
	onEdgeClick?: OnEdgeClick | null | undefined;
	onEdgeContextMenu?: OnEdgeClick | null | undefined;
	onCanvasClick?: OnCanvasClick | null | undefined;
	onCanvasDblClick?: OnCanvasClick | null | undefined;
	onBurgerMenuClick?: null | undefined | (() => void);
	onOpenSource?: null | undefined | ((params: OpenSourceParams) => void);
}
export interface LikeC4ViewProps<ViewId = string, Tag = string, Kind = string> {
	/**
	 * View to display.
	 */
	viewId: ViewId;
	/**
	 * Enable/disable panning
	 * @default false
	 */
	pannable?: boolean | undefined;
	/**
	 * Enable/disable zooming
	 * @default false
	 */
	zoomable?: boolean | undefined;
	/**
	 * @default true
	 */
	keepAspectRatio?: boolean | undefined;
	/**
	 * Background pattern
	 * @default 'transparent'
	 */
	background?: "dots" | "lines" | "cross" | "transparent" | "solid" | undefined;
	/**
	 * Click on the view opens a modal with browser.
	 * You can customize or disable the browser.
	 *
	 * @default true
	 */
	browser?: boolean | LikeC4BrowserProps | undefined;
	/**
	 * @default - determined by the user's system preferences.
	 */
	colorScheme?: "light" | "dark" | undefined;
	/**
	 * LikeC4 views are using 'IBM Plex Sans' font.
	 * By default, component injects the CSS to document head.
	 * Set to false if you want to handle the font yourself.
	 *
	 * @default true
	 */
	injectFontCss?: boolean | undefined;
	/**
	 * Show/hide panel with top left controls,
	 * @default false
	 */
	controls?: boolean | undefined;
	/**
	 * If set, initial viewport will show all nodes & edges
	 * @default true
	 */
	fitView?: boolean | undefined;
	/**
	 * Padding around the diagram
	 * @default '8px'
	 */
	fitViewPadding?: PaddingWithUnit$1 | undefined;
	/**
	 * Display diagram title / description
	 *
	 * @default false
	 */
	showDiagramTitle?: boolean | undefined;
	/**
	 * Show back/forward navigation buttons
	 * @default false
	 */
	showNavigationButtons?: undefined | boolean;
	/**
	 * Display notations of the view
	 * @default false
	 */
	showNotations?: boolean | undefined;
	/**
	 * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
	 * Conflicts with `browser` prop
	 *
	 * @default false
	 */
	enableFocusMode?: boolean | undefined;
	/**
	 * If Walkthrough for dynamic views should be enabled
	 * @default enableFocusMode
	 */
	enableDynamicViewWalkthrough?: boolean | undefined;
	/**
	 * Enable popup with element details
	 * @default false
	 */
	enableElementDetails?: boolean | undefined;
	/**
	 * Experimental feature to browse relationships
	 *
	 * @default enableElementDetails
	 */
	enableRelationshipBrowser?: boolean | undefined;
	/**
	 * Display dropdown with details on relationship's label click
	 * @default enableRelationshipBrowser
	 */
	enableRelationshipDetails?: boolean | undefined;
	/**
	 * Improve performance by hiding certain elements and reducing visual effects (disable mix-blend, shadows, animations)
	 *
	 * @default 'auto' - will be set to true if view is pannable and has more than 3000 * 2000 pixels
	 */
	reduceGraphics?: "auto" | boolean | undefined;
	where?: WhereOperator<Tag, Kind> | undefined;
	/**
	 * Override some react flow props
	 */
	reactFlowProps?: OverrideReactFlowProps | undefined;
	className?: string | undefined;
	style?: CSSProperties | undefined;
	/**
	 * Override Mantine theme
	 */
	mantineTheme?: any;
	/** Function to generate nonce attribute added to all generated `<style />` tags */
	styleNonce?: string | (() => string) | undefined;
	/**
	 * Render custom icon for a node
	 * By default, if icon is http:// or https://, it will be rendered as an image
	 */
	renderIcon?: ElementIconRenderer | undefined;
}
interface LikeC4BrowserProps {
	/**
	 * Background pattern for the browser view.
	 * @default 'dots'
	 */
	background?: "dots" | "lines" | "cross" | "transparent" | "solid" | undefined;
	/**
	 * Padding around the diagram
	 * @default '16px'
	 */
	fitViewPadding?: PaddingWithUnit$1 | undefined;
	/**
	 * Show/hide panel with top left controls,
	 * @default true
	 */
	controls?: boolean | undefined;
	/**
	 * Display diagram title / description
	 *
	 * @default true
	 */
	showDiagramTitle?: boolean | undefined;
	/**
	 * Show back/forward navigation buttons
	 * @default true
	 */
	showNavigationButtons?: undefined | boolean;
	/**
	 * Enable search popup for elements and views
	 * @default true
	 */
	enableSearch?: boolean | undefined;
	/**
	 * If double click on a node should enable focus mode
	 *
	 * @default true
	 */
	enableFocusMode?: boolean | undefined;
	/**
	 * If Walkthrough for dynamic views should be enabled
	 * @default true
	 */
	enableDynamicViewWalkthrough?: boolean | undefined;
	/**
	 * Enable popup with element details
	 * @default true
	 */
	enableElementDetails?: boolean | undefined;
	/**
	 * Experimental feature to browse relationships
	 *
	 * @default enableElementDetails
	 */
	enableRelationshipBrowser?: boolean | undefined;
	/**
	 * Display dropdown with details on relationship's label click
	 * @default enableRelationshipBrowser
	 */
	enableRelationshipDetails?: boolean | undefined;
	/**
	 * Display notations of the view
	 * @default true
	 */
	showNotations?: boolean | undefined;
	/**
	 * Improve performance by hiding certain elements and reducing visual effects (disable mix-blend, shadows, animations)
	 *
	 * @default 'auto' - will be set to true if view is pannable and has more than 3000 * 2000 pixels
	 */
	reduceGraphics?: "auto" | boolean | undefined;
	className?: string | undefined;
	style?: CSSProperties | undefined;
	/**
	 * Override some react flow props
	 */
	reactFlowProps?: OverrideReactFlowProps | undefined;
}
export declare function LikeC4View<ViewId extends string = string, Tag = string, Kind = string>({ viewId, ...props }: LikeC4ViewProps<ViewId, Tag, Kind>): import("react/jsx-runtime").JSX.Element;
type LikeC4DiagramProps = PropsWithChildren<LikeC4DiagramProperties & LikeC4DiagramEventHandlers>;
export type ReactLikeC4Props<ViewId = string, Tag = string, Kind = string> = Omit<LikeC4DiagramProps, "view" | "where" | "onNavigateTo"> & {
	viewId: ViewId;
	/**
	 * Keep aspect ratio of the diagram
	 * Disable if you need to manage the viewport (use className)
	 *
	 * @default true
	 */
	keepAspectRatio?: boolean | undefined;
	/**
	 * By default determined by the user's system preferences.
	 */
	colorScheme?: "light" | "dark" | undefined;
	/**
	 * LikeC4 views are using 'IBM Plex Sans' font.
	 * By default, component injects the CSS to document head.
	 * Set to false if you want to handle the font yourself.
	 *
	 * @default true
	 */
	injectFontCss?: boolean | undefined;
	style?: CSSProperties | undefined;
	where?: WhereOperator<Tag, Kind> | undefined;
	onNavigateTo?: OnNavigateTo<ViewId> | undefined;
	mantineTheme?: any;
	/** Function to generate nonce attribute added to all generated `<style />` tags */
	styleNonce?: string | (() => string) | undefined;
};
export declare function ReactLikeC4<ViewId extends string = string, Tag = string, Kind = string>({ viewId, ...props }: ReactLikeC4Props<ViewId, Tag, Kind>): import("react/jsx-runtime").JSX.Element;
export declare namespace ReactLikeC4 {
	var displayName: string;
}
type LikeC4ModelProviderProps = PropsWithChildren<{
	/**
	 * The LikeC4 model to be provided to the context.
	 * TODO: refer to 'likec4/model'
	 */
	likec4model: any;
}>;
export declare const LikeC4ModelProvider: (props: LikeC4ModelProviderProps) => JSX.Element;
type AllKeys<T> = T extends any ? keyof T : never;
type Primitive$1 = boolean | number | string;
type ReadonlyIfObject<Value> = Value extends undefined ? Value : Value extends (...args: any) => any ? Value : Value extends Primitive$1 ? Value : Value extends object ? Readonly<Value> : Value;
interface ReadableAtom<Value = any> {
	/**
	 * Get store value.
	 *
	 * In contrast with {@link ReadableAtom#value} this value will be always
	 * initialized even if store had no listeners.
	 *
	 * ```js
	 * $store.get()
	 * ```
	 *
	 * @returns Store value.
	 */
	get(): Value;
	/**
	 * Listeners count.
	 */
	readonly lc: number;
	/**
	 * Subscribe to store changes.
	 *
	 * In contrast with {@link Store#subscribe} it do not call listener
	 * immediately.
	 *
	 * @param listener Callback with store value and old value.
	 * @returns Function to remove listener.
	 */
	listen(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value>) => void): () => void;
	/**
	 * Low-level method to notify listeners about changes in the store.
	 *
	 * Can cause unexpected behaviour when combined with frontend frameworks
	 * that perform equality checks for values, such as React.
	 */
	notify(oldValue?: ReadonlyIfObject<Value>): void;
	/**
	 * Unbind all listeners.
	 */
	off(): void;
	/**
	 * Subscribe to store changes and call listener immediately.
	 *
	 * ```
	 * import { $router } from '../store'
	 *
	 * $router.subscribe(page => {
	 *   console.log(page)
	 * })
	 * ```
	 *
	 * @param listener Callback with store value and old value.
	 * @returns Function to remove listener.
	 */
	subscribe(listener: (value: ReadonlyIfObject<Value>, oldValue?: ReadonlyIfObject<Value>) => void): () => void;
	/**
	 * Low-level method to read store’s value without calling `onStart`.
	 *
	 * Try to use only {@link ReadableAtom#get}.
	 * Without subscribers, value can be undefined.
	 */
	readonly value: undefined | Value;
}
interface WritableAtom<Value = any> extends ReadableAtom<Value> {
	/**
	 * Change store value.
	 *
	 * ```js
	 * $router.set({ path: location.pathname, page: parse(location.pathname) })
	 * ```
	 *
	 * @param newValue New store value.
	 */
	set(newValue: Value): void;
}
interface PreinitializedWritableAtom<Value> extends WritableAtom<Value> {
	readonly value: Value;
}
type Atom<Value = any> = ReadableAtom<Value> | WritableAtom<Value>;
declare function atom<Value, StoreExt = object>(...args: undefined extends Value ? [
] | [
	Value
] : [
	Value
]): PreinitializedWritableAtom<Value> & StoreExt;
type KeyofBase = keyof any;
type Get<T, K extends KeyofBase> = Extract<T, {
	[K1 in K]: any;
}>[K];
type HasIndexSignature<T> = string extends keyof T ? true : false;
type ValueWithUndefinedForIndexSignatures<Value, Key extends keyof Value> = HasIndexSignature<Value> extends true ? undefined | Value[Key] : Value[Key];
type WritableStore<Value = any> = (Value extends object ? MapStore<Value> : never) | WritableAtom<Value>;
type Store<Value = any> = ReadableAtom<Value> | WritableStore<Value>;
type AnyStore<Value = any> = {
	get(): Value;
	readonly value: undefined | Value;
};
type StoreValue<SomeStore> = SomeStore extends {
	get(): infer Value;
} ? Value : any;
interface MapStore<Value extends object = any> extends WritableAtom<Value> {
	/**
	 * Subscribe to store changes.
	 *
	 * In contrast with {@link Store#subscribe} it do not call listener
	 * immediately.
	 *
	 * @param listener Callback with store value and old value.
	 * @param changedKey Key that was changed. Will present only if `setKey`
	 *                   has been used to change a store.
	 * @returns Function to remove listener.
	 */
	listen(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value>, changedKey: AllKeys<Value>) => void): () => void;
	/**
	 * Low-level method to notify listeners about changes in the store.
	 *
	 * Can cause unexpected behaviour when combined with frontend frameworks
	 * that perform equality checks for values, such as React.
	 */
	notify(oldValue?: ReadonlyIfObject<Value>, changedKey?: AllKeys<Value>): void;
	/**
	 * Change store value.
	 *
	 * ```js
	 * $settings.set({ theme: 'dark' })
	 * ```
	 *
	 * Operation is atomic, subscribers will be notified once with the new value.
	 * `changedKey` will be undefined
	 *
	 * @param newValue New store value.
	 */
	set(newValue: Value): void;
	/**
	 * Change key in store value.
	 *
	 * ```js
	 * $settings.setKey('theme', 'dark')
	 * ```
	 *
	 * To delete key set `undefined`.
	 *
	 * ```js
	 * $settings.setKey('theme', undefined)
	 * ```
	 *
	 * @param key The key name.
	 * @param value New value.
	 */
	setKey<Key extends AllKeys<Value>>(key: Key, value: Get<Value, Key> | ValueWithUndefinedForIndexSignatures<Value, Key>): void;
	/**
	 * Subscribe to store changes and call listener immediately.
	 *
	 * ```
	 * import { $router } from '../store'
	 *
	 * $router.subscribe(page => {
	 *   console.log(page)
	 * })
	 * ```
	 *
	 * @param listener Callback with store value and old value.
	 * @param changedKey Key that was changed. Will present only
	 *                   if `setKey` has been used to change a store.
	 * @returns Function to remove listener.
	 */
	subscribe(listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value> | undefined, changedKey: AllKeys<Value> | undefined) => void): () => void;
}
interface PreinitializedMapStore<Value extends object = any> extends MapStore<Value> {
	readonly value: Value;
}
declare function map<Value extends object, StoreExt extends object = object>(value?: Value): PreinitializedMapStore<Value> & StoreExt;
interface Task<Value> extends Promise<Value> {
	t: true;
}
type StoreValues<Stores extends AnyStore[]> = {
	[Index in keyof Stores]: StoreValue<Stores[Index]>;
};
interface Computed {
	<Value, OriginStore extends Store>(stores: OriginStore, cb: (value: StoreValue<OriginStore>) => Task<Value>): ReadableAtom<undefined | Value>;
	<Value, OriginStores extends AnyStore[]>(stores: [
		...OriginStores
	], cb: (...values: StoreValues<OriginStores>) => Task<Value>): ReadableAtom<undefined | Value>;
	<Value, OriginStore extends Store>(stores: OriginStore, cb: (value: StoreValue<OriginStore>) => Value): ReadableAtom<Value>;
	/**
	 * Create derived store, which use generates value from another stores.
	 *
	 * ```js
	 * import { computed } from 'nanostores'
	 *
	 * import { $users } from './users.js'
	 *
	 * export const $admins = computed($users, users => {
	 *   return users.filter(user => user.isAdmin)
	 * })
	 * ```
	 *
	 * An async function can be evaluated by using {@link task}.
	 *
	 * ```js
	 * import { computed, task } from 'nanostores'
	 *
	 * import { $userId } from './users.js'
	 *
	 * export const $user = computed($userId, userId => task(async () => {
	 *   const response = await fetch(`https://my-api/users/${userId}`)
	 *   return response.json()
	 * }))
	 * ```
	 */
	<Value, OriginStores extends AnyStore[]>(stores: [
		...OriginStores
	], cb: (...values: StoreValues<OriginStores>) => Task<Value> | Value): ReadableAtom<Value>;
}
declare const computed: Computed;
type StoreKeys<T> = T extends {
	setKey: (k: infer K, v: any) => unknown;
} ? K : never;
interface UseStoreOptions<SomeStore> {
	/**
	 * @default
	 * ```ts
	 * [store, options.keys]
	 * ```
	 */
	deps?: DependencyList;
	/**
	 * Will re-render components only on specific key changes.
	 */
	keys?: StoreKeys<SomeStore>[];
}
declare function useStore<SomeStore extends Store>(store: SomeStore, options?: UseStoreOptions<SomeStore>): StoreValue<SomeStore>;
export declare const createHooksForModel: ($atom: WritableAtom) => any;

declare namespace nano {
	export { Atom, WritableAtom, atom, computed, map, useStore };
}

export {
	nano,
};

export {};
