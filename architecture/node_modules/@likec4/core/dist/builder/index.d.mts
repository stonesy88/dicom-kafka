import { LastArrayElement, Split, Simplify, Writable, IfNever, TupleToUnion, Tagged, IsStringLiteral as IsStringLiteral$1, IsLiteral } from 'type-fest';
import { L as LikeC4Model } from '../shared/core.CiFKryGW.mjs';
import { D as DeploymentElement, i as DeploymentRelation, q as Element, ah as ModelRelation, a9 as Participant, M as ModelLayer, bs as ViewRuleStyle, aT as AutoLayoutDirection, y as ExpressionV2, L as LikeC4View, b0 as DeploymentView, bd as ElementView, t as ElementShape, ap as Color, p as BorderStyle, av as ShapeSize, aw as SpacingSize, ax as TextSize, aj as RelationshipArrowType, am as RelationshipLineType, r as ElementKindSpecification, al as RelationshipKindSpecification, g as DeploymentNodeKindSpecification, V as ParsedLikeC4ModelData } from '../shared/core.DJvmfnEi.mjs';
import { F as Fqn, N as NonEmptyArray, K as KeysOf } from '../shared/core.SjLhMA7a.mjs';
import { IsStringLiteral } from 'type-fest/source/is-literal';

type ToNested$1<T, Id extends string> = T extends TypesNested<infer P, any, any, any, any, any, any, any, infer F> ? TypesNested<`${P}.${Id}`, T['ElementKind'], T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], `${P}.${Id}` | F> : T extends AnyTypes ? TypesNested<Id, T['ElementKind'], T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], Id | T['DeploymentFqn']> : never;
type FromNested$1<T extends AnyTypes, N> = N extends TypesNested<any, any, any, any, any, any, any, any, infer F> ? T extends TypesNested<infer P, any, any, any, any, any, any, any, any> ? TypesNested<P, T['ElementKind'], T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], F> : T extends AnyTypes ? Types<T['ElementKind'], T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], F> : never : never;
/**
 * Chainable builder to create deployment node
 */
interface AddDeploymentNode<Id extends string> {
    <T extends AnyTypes>(builder: DeploymentModelBuilder<T>): DeploymentModelBuilder<Types.AddDeploymentFqn<T, Id>>;
    with<T extends AnyTypes>(): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<Types.AddDeploymentFqn<T, Id>>;
    with<T extends AnyTypes, A extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, A>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, B>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op3: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, C>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op3: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op4: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, D>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op3: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op4: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op5: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, E>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op3: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op4: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op5: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op6: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, F>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op3: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op4: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op5: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op6: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op7: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, G>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op3: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op4: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op5: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op6: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op7: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op8: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, H>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op3: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op4: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op5: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op6: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op7: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op8: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op9: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, I>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: DeploymentModelBuilder<ToNested$1<T, Id>>) => DeploymentModelBuilder<A>, op2: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op3: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op4: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op5: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op6: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op7: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op8: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op9: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>, op10: (input: DeploymentModelBuilder<I>) => DeploymentModelBuilder<J>): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<FromNested$1<T, J>>;
}

interface DeploymentModelBuilder<T extends AnyTypes> extends Builder<T> {
    __addDeployment(node: DeploymentElement): Builder<T>;
    __addDeploymentRelation(rel: Omit<DeploymentRelation, 'id'>): Builder<T>;
    /**
     * Create a fully qualified name from an id (for nested models)
     */
    __fqn(id: string): Fqn;
}
declare function deployment<A extends AnyTypes>(): (input: Builder<A>) => Builder<A>;
declare function deployment<A extends AnyTypes, B extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>): (input: Builder<A>) => Builder<B>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>): (input: Builder<A>) => Builder<C>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>): (input: Builder<A>) => Builder<D>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>): (input: Builder<A>) => Builder<E>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>): (input: Builder<A>) => Builder<F>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>): (input: Builder<A>) => Builder<G>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>): (input: Builder<A>) => Builder<H>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op8: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>): (input: Builder<A>) => Builder<I>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op8: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>, op9: (input: DeploymentModelBuilder<I>) => DeploymentModelBuilder<J>): (input: Builder<A>) => Builder<J>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op8: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>, op9: (input: DeploymentModelBuilder<I>) => DeploymentModelBuilder<J>, op10: (input: DeploymentModelBuilder<J>) => DeploymentModelBuilder<K>): (input: Builder<A>) => Builder<K>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op8: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>, op9: (input: DeploymentModelBuilder<I>) => DeploymentModelBuilder<J>, op10: (input: DeploymentModelBuilder<J>) => DeploymentModelBuilder<K>, op11: (input: DeploymentModelBuilder<K>) => DeploymentModelBuilder<L>): (input: Builder<A>) => Builder<L>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op8: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>, op9: (input: DeploymentModelBuilder<I>) => DeploymentModelBuilder<J>, op10: (input: DeploymentModelBuilder<J>) => DeploymentModelBuilder<K>, op11: (input: DeploymentModelBuilder<K>) => DeploymentModelBuilder<L>, op12: (input: DeploymentModelBuilder<L>) => DeploymentModelBuilder<M>): (input: Builder<A>) => Builder<M>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op8: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>, op9: (input: DeploymentModelBuilder<I>) => DeploymentModelBuilder<J>, op10: (input: DeploymentModelBuilder<J>) => DeploymentModelBuilder<K>, op11: (input: DeploymentModelBuilder<K>) => DeploymentModelBuilder<L>, op12: (input: DeploymentModelBuilder<L>) => DeploymentModelBuilder<M>, op13: (input: DeploymentModelBuilder<M>) => DeploymentModelBuilder<N>): (input: Builder<A>) => Builder<N>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op8: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>, op9: (input: DeploymentModelBuilder<I>) => DeploymentModelBuilder<J>, op10: (input: DeploymentModelBuilder<J>) => DeploymentModelBuilder<K>, op11: (input: DeploymentModelBuilder<K>) => DeploymentModelBuilder<L>, op12: (input: DeploymentModelBuilder<L>) => DeploymentModelBuilder<M>, op13: (input: DeploymentModelBuilder<M>) => DeploymentModelBuilder<N>, op14: (input: DeploymentModelBuilder<N>) => DeploymentModelBuilder<O>): (input: Builder<A>) => Builder<O>;
declare function deployment<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes, P extends AnyTypes>(op1: (input: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>, op2: (input: DeploymentModelBuilder<B>) => DeploymentModelBuilder<C>, op3: (input: DeploymentModelBuilder<C>) => DeploymentModelBuilder<D>, op4: (input: DeploymentModelBuilder<D>) => DeploymentModelBuilder<E>, op5: (input: DeploymentModelBuilder<E>) => DeploymentModelBuilder<F>, op6: (input: DeploymentModelBuilder<F>) => DeploymentModelBuilder<G>, op7: (input: DeploymentModelBuilder<G>) => DeploymentModelBuilder<H>, op8: (input: DeploymentModelBuilder<H>) => DeploymentModelBuilder<I>, op9: (input: DeploymentModelBuilder<I>) => DeploymentModelBuilder<J>, op10: (input: DeploymentModelBuilder<J>) => DeploymentModelBuilder<K>, op11: (input: DeploymentModelBuilder<K>) => DeploymentModelBuilder<L>, op12: (input: DeploymentModelBuilder<L>) => DeploymentModelBuilder<M>, op13: (input: DeploymentModelBuilder<M>) => DeploymentModelBuilder<N>, op14: (input: DeploymentModelBuilder<N>) => DeploymentModelBuilder<O>, op15: (input: DeploymentModelBuilder<O>) => DeploymentModelBuilder<P>): (input: Builder<A>) => Builder<P>;
type NameFromFqn<FQN extends string> = LastArrayElement<Split<FQN, '.'>>;
type AddDeployedInstance<Props = unknown> = {
    <const T extends AnyTypes, Id extends string & T['Fqn']>(target: Id): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<Types.AddDeploymentFqn<T, NameFromFqn<Id>>>;
    <const Id extends string, T extends AnyTypes, Target extends string & T['Fqn']>(id: ValidId<Id>, target: Target, titleOrProps?: string | Props | undefined): (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<Types.AddDeploymentFqn<T, Id>>;
};
type AddDeploymentNodeHelper<T = unknown> = <const Id extends string>(id: ValidId<Id>, titleOrProps?: string | T) => AddDeploymentNode<Id>;
type AddDeploymentNodeHelpers<T extends AnyTypes> = T extends Types<any, any, any, any, any, any, infer Kinds extends string, any> ? {
    [Kind in Kinds]: AddDeploymentNodeHelper<T['NewDeploymentNodeProps']>;
} : Invalid<'No Deployment Kinds'>;
type AddDeploymentRelation<Props = unknown> = <T extends AnyTypes, Source extends string & T['DeploymentFqn'], Target extends string & T['DeploymentFqn']>(source: Source, target: Target, titleOrProps?: string | Props) => (builder: DeploymentModelBuilder<T>) => DeploymentModelBuilder<T>;
type DeloymentModelHelpers<T extends AnyTypes> = AddDeploymentNodeHelpers<T> & {
    instanceOf: AddDeployedInstance<T['NewDeploymentNodeProps']>;
    rel: AddDeploymentRelation<T['NewRelationshipProps']>;
    deployment: typeof deployment;
};
type DeloymentModelBuildFunction<A extends AnyTypes, B extends AnyTypes> = (helpers: DeloymentModelHelpers<A> & {
    _: DeloymentModelHelpers<A>['deployment'];
}, add: DeloymentModelHelpers<A>['deployment']) => ((builder: DeploymentModelBuilder<A>) => DeploymentModelBuilder<B>) | ((builder: Builder<A>) => Builder<B>);

type ToNested<T, Id extends string> = T extends TypesNested<infer P, any, infer F, any, any, any, any, any, any> ? TypesNested<`${P}.${Id}`, T['ElementKind'], `${P}.${Id}` | F, T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], T['DeploymentFqn']> : T extends AnyTypes ? TypesNested<Id, T['ElementKind'], Id | T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], T['DeploymentFqn']> : never;
type FromNested<T extends AnyTypes, N> = N extends TypesNested<any, any, infer F, any, any, any, any, any, any> ? T extends TypesNested<infer P, any, any, any, any, any, any, any, any> ? TypesNested<P, T['ElementKind'], F, T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], T['DeploymentFqn']> : T extends AnyTypes ? Types<T['ElementKind'], F, T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], T['DeploymentFqn']> : never : never;
/**
 * Chainable builder to create element
 */
interface AddElement<Id extends string> {
    <T extends AnyTypes>(builder: ModelBuilder<T>): ModelBuilder<Types.AddFqn<T, Id>>;
    with<T extends AnyTypes>(): (builder: ModelBuilder<T>) => ModelBuilder<Types.AddFqn<T, Id>>;
    with<T extends AnyTypes, A extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, A>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, B>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, C>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, D>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, E>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, F>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>, op7: (input: ModelBuilder<F>) => ModelBuilder<G>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, G>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>, op7: (input: ModelBuilder<F>) => ModelBuilder<G>, op8: (input: ModelBuilder<G>) => ModelBuilder<H>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, H>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>, op7: (input: ModelBuilder<F>) => ModelBuilder<G>, op8: (input: ModelBuilder<G>) => ModelBuilder<H>, op9: (input: ModelBuilder<H>) => ModelBuilder<I>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, I>>;
    with<T extends AnyTypes, A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: ModelBuilder<ToNested<T, Id>>) => ModelBuilder<A>, op2: (input: ModelBuilder<A>) => ModelBuilder<B>, op3: (input: ModelBuilder<B>) => ModelBuilder<C>, op4: (input: ModelBuilder<C>) => ModelBuilder<D>, op5: (input: ModelBuilder<D>) => ModelBuilder<E>, op6: (input: ModelBuilder<E>) => ModelBuilder<F>, op7: (input: ModelBuilder<F>) => ModelBuilder<G>, op8: (input: ModelBuilder<G>) => ModelBuilder<H>, op9: (input: ModelBuilder<H>) => ModelBuilder<I>, op10: (input: ModelBuilder<I>) => ModelBuilder<J>): (builder: ModelBuilder<T>) => ModelBuilder<FromNested<T, J>>;
}

interface ModelBuilder<T extends AnyTypes> extends Builder<T> {
    __addElement(element: Element): Builder<T>;
    __addRelation(relation: Omit<ModelRelation, 'id'>): Builder<T>;
    /**
     * Create a fully qualified name from an id (for nested models)
     */
    __fqn(id: string): Fqn;
    __addSourcelessRelation(relation: Omit<ModelRelation, 'id' | 'source'>): Builder<T>;
}
declare function model<A extends AnyTypes>(): (input: Builder<A>) => Builder<A>;
declare function model<A extends AnyTypes, B extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>): (input: Builder<A>) => Builder<B>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>): (input: Builder<A>) => Builder<C>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>): (input: Builder<A>) => Builder<D>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>): (input: Builder<A>) => Builder<E>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>): (input: Builder<A>) => Builder<F>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>): (input: Builder<A>) => Builder<G>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>): (input: Builder<A>) => Builder<H>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>): (input: Builder<A>) => Builder<I>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>): (input: Builder<A>) => Builder<J>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>): (input: Builder<A>) => Builder<K>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>): (input: Builder<A>) => Builder<L>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>): (input: Builder<A>) => Builder<M>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>, op13: (input: ModelBuilder<M>) => ModelBuilder<N>): (input: Builder<A>) => Builder<N>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>, op13: (input: ModelBuilder<M>) => ModelBuilder<N>, op14: (input: ModelBuilder<N>) => ModelBuilder<O>): (input: Builder<A>) => Builder<O>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes, P extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>, op13: (input: ModelBuilder<M>) => ModelBuilder<N>, op14: (input: ModelBuilder<N>) => ModelBuilder<O>, op15: (input: ModelBuilder<O>) => ModelBuilder<P>): (input: Builder<A>) => Builder<P>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes, P extends AnyTypes, Q extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>, op13: (input: ModelBuilder<M>) => ModelBuilder<N>, op14: (input: ModelBuilder<N>) => ModelBuilder<O>, op15: (input: ModelBuilder<O>) => ModelBuilder<P>, op16: (input: ModelBuilder<P>) => ModelBuilder<Q>): (input: Builder<A>) => Builder<Q>;
declare function model<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes, P extends AnyTypes, Q extends AnyTypes, R extends AnyTypes>(op1: (input: ModelBuilder<A>) => ModelBuilder<B>, op2: (input: ModelBuilder<B>) => ModelBuilder<C>, op3: (input: ModelBuilder<C>) => ModelBuilder<D>, op4: (input: ModelBuilder<D>) => ModelBuilder<E>, op5: (input: ModelBuilder<E>) => ModelBuilder<F>, op6: (input: ModelBuilder<F>) => ModelBuilder<G>, op7: (input: ModelBuilder<G>) => ModelBuilder<H>, op8: (input: ModelBuilder<H>) => ModelBuilder<I>, op9: (input: ModelBuilder<I>) => ModelBuilder<J>, op10: (input: ModelBuilder<J>) => ModelBuilder<K>, op11: (input: ModelBuilder<K>) => ModelBuilder<L>, op12: (input: ModelBuilder<L>) => ModelBuilder<M>, op13: (input: ModelBuilder<M>) => ModelBuilder<N>, op14: (input: ModelBuilder<N>) => ModelBuilder<O>, op15: (input: ModelBuilder<O>) => ModelBuilder<P>, op16: (input: ModelBuilder<P>) => ModelBuilder<Q>, op17: (input: ModelBuilder<Q>) => ModelBuilder<R>): (input: Builder<A>) => Builder<R>;
type RelationshipHelper<Props = unknown> = <T extends AnyTypes, From extends string & T['Fqn'], To extends string & T['Fqn']>(from: From, to: To, titleOrProps?: string | Props) => (builder: ModelBuilder<T>) => ModelBuilder<T>;
type NestedRelationshipHelper<Props = unknown> = <T extends AnyTypesNested, To extends string & T['Fqn']>(to: To, titleOrProps?: string | Props) => (builder: ModelBuilder<T>) => ModelBuilder<T>;
type AddElementHelper<T = unknown> = <const Id extends string>(id: ValidId<Id>, titleOrProps?: string | T) => AddElement<Id>;
type AddElementHelpers<T extends AnyTypes> = T extends Types<infer Kinds extends string, any, any, any, any, any, any, any> ? {
    [Kind in Kinds]: AddElementHelper<T['NewElementProps']>;
} : Invalid<'No Element Kinds'>;
type ModelHelpers<T extends AnyTypes> = AddElementHelpers<T> & {
    model: typeof model;
    rel: RelationshipHelper<T['NewRelationshipProps']>;
    relTo: NestedRelationshipHelper<T['NewRelationshipProps']>;
};
type ModelBuilderFunction<A extends AnyTypes, B extends AnyTypes> = (helpers: ModelHelpers<A> & {
    _: ModelHelpers<A>['model'];
}, add: ModelHelpers<A>['model']) => ((builder: ModelBuilder<A>) => ModelBuilder<B>) | ((builder: Builder<A>) => Builder<B>);

interface LikeC4ViewBuilder<Types extends AnyTypes, Fqn extends string, TypedExpr, ElementExpr extends string = ViewPredicate.ElementExpr<Fqn>, Expr extends string = ViewPredicate.AllExpression<ElementExpr>> {
    Types: Types;
    ElementExpr: ElementExpr;
    Expr: Expr;
    TypedExpr: TypedExpr;
    $expr(expr: Expr | TypedExpr): TypedExpr;
    include(...exprs: Expr[]): this;
    exclude(...exprs: Expr[]): this;
    style(rule: ViewRuleStyle): this;
    autoLayout(layout: AutoLayoutDirection): this;
}
declare namespace ViewPredicate {
    type ElementExpr<Fqn extends string> = '*' | Fqn | `${Fqn}.*` | `${Fqn}._` | `${Fqn}.**`;
    type AllExpression<ElementExpr extends string> = ElementExpr | `-> ${ElementExpr} ->` | `-> ${ElementExpr}` | `${ElementExpr} ->` | `${ElementExpr} ${'->' | '<->'} ${ElementExpr}`;
    type Expression<T extends AnyTypes> = T extends Types<any, infer F extends string, any, any, any, any, any, any> ? AllExpression<ViewPredicate.ElementExpr<F>> : never;
    type ConnectionExpression<T extends AnyTypes> = T extends Types<any, infer F extends string, any, any, any, any, any, any> ? `${F} -> ${F}` : never;
    type DeploymentExpression<T extends AnyTypes> = T extends Types<any, any, any, any, any, any, any, infer F extends string> ? AllExpression<ViewPredicate.ElementExpr<F>> : never;
    type DeploymentConnectionExpression<T extends AnyTypes> = T extends Types<any, any, any, any, any, any, any, infer F extends string> ? `${F} -> ${F}` : never;
    type WhereTag<Tag extends string> = `tag ${'is' | 'is not'} #${Tag}`;
    type WhereKind<Kind extends string> = `kind ${'is' | 'is not'} ${Kind}`;
    type WhereParticipant<Types extends AnyTypes> = `${Participant}.${WhereTag<Types['Tag']> | WhereKind<Types['ElementKind']>}`;
    type WhereEq<Types extends AnyTypes> = ViewPredicate.WhereTag<Types['Tag']> | ViewPredicate.WhereKind<Types['ElementKind']> | ViewPredicate.WhereKind<Types['DeploymentKind']> | ViewPredicate.WhereParticipant<Types>;
    type WhereOperator<Types extends AnyTypes> = ViewPredicate.WhereEq<Types> | {
        and: NonEmptyArray<ViewPredicate.WhereOperator<Types>>;
        or?: never;
        not?: never;
    } | {
        or: NonEmptyArray<ViewPredicate.WhereOperator<Types>>;
        and?: never;
        not?: never;
    } | {
        not: ViewPredicate.WhereOperator<Types>;
        and?: never;
        or?: never;
    };
    type Custom<Types extends AnyTypes> = {
        where?: ViewPredicate.WhereOperator<Types>;
        with?: Simplify<Omit<ModelLayer.FqnExpr.Custom['custom'] & ModelLayer.RelationExpr.Custom['customRelation'], 'expr' | 'relation' | 'navigateTo'> & {
            navigateTo?: Types['ViewId'];
        }>;
    };
}
declare function $include<B extends LikeC4ViewBuilder<AnyTypes, any, any>>(...args: [B['Expr']] | [B['TypedExpr']] | [B['Expr'], ViewPredicate.Custom<B['Types']>]): (b: B) => B;
declare function $exclude<B extends LikeC4ViewBuilder<AnyTypes, any, any>>(...args: [B['Expr']] | [B['TypedExpr']] | [B['Expr'], ViewPredicate.Custom<B['Types']>] | [B['TypedExpr'], ViewPredicate.Custom<B['Types']>]): (b: B) => B;
declare function $style<B extends LikeC4ViewBuilder<AnyTypes, any, any>>(element: B['ElementExpr'] | B['TypedExpr'] | NonEmptyArray<B['ElementExpr']>, { notation, ...style }: ViewRuleStyle['style'] & {
    notation?: string;
}): (b: B) => B;
declare function $autoLayout<B extends LikeC4ViewBuilder<AnyTypes, any, any>>(layout: AutoLayoutDirection): (b: B) => B;
type Op<T> = (b: T) => T;
declare function $rules<B extends LikeC4ViewBuilder<AnyTypes, any, any>>(...rules: Op<B>[]): (b: B) => B;

interface DeploymentViewBuilder<T extends AnyTypes> extends LikeC4ViewBuilder<T, T['DeploymentFqn'], Types.ToExpression<T>> {
}
type DeploymentRulesBuilderOp<Types extends AnyTypes> = (b: DeploymentViewBuilder<Types>) => DeploymentViewBuilder<Types>;
interface AddDeploymentViewRules<Id extends string> {
    with<S extends AnyTypes>(...rules: DeploymentRulesBuilderOp<S>[]): (builder: ViewsBuilder<S>) => ViewsBuilder<Types.AddView<S, Id>>;
}
/**
 * Chainable builder to create element
 */
interface AddDeploymentViewHelper {
    <const Id extends string, T extends AnyTypes>(id: Id): AddDeploymentViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
    <const Id extends string, T extends AnyTypes>(id: Id, bulder: (b: DeploymentViewBuilder<T>) => DeploymentViewBuilder<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
    <const Id extends string, T extends AnyTypes>(id: Id, propsOrTitle: T['NewViewProps'] | string): AddDeploymentViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
    <const Id extends string, T extends AnyTypes>(id: Id, propsOrTitle: T['NewViewProps'] | string, bulder: (b: DeploymentViewBuilder<T>) => DeploymentViewBuilder<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
}
declare function $deploymentExpr<T extends AnyTypes>(expr: ViewPredicate.DeploymentExpression<T> | ExpressionV2): Types.ToExpression<T>;

interface ElementViewBuilder<T extends AnyTypes> extends LikeC4ViewBuilder<T, T['Fqn'], Types.ToExpression<T>> {
}
type ElementViewRulesBuilder<T extends AnyTypes> = (b: ElementViewBuilder<T>) => ElementViewBuilder<T>;
interface AddViewRules<Id extends string> {
    with<S extends AnyTypes>(...rules: ElementViewRulesBuilder<S>[]): (builder: ViewsBuilder<S>) => ViewsBuilder<Types.AddView<S, Id>>;
}
interface AddViewHelper {
    <const Id extends string, T extends AnyTypes>(id: Id): AddViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
    <const Id extends string, T extends AnyTypes>(id: Id, builder: (b: ElementViewBuilder<T>) => ElementViewBuilder<T>): AddViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
    <const Id extends string, T extends AnyTypes>(id: Id, propsOrTitle: NoInfer<T['NewViewProps']> | string): AddViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
    <const Id extends string, T extends AnyTypes>(id: Id, propsOrTitle: NoInfer<T['NewViewProps']> | string | undefined, builder: (b: ElementViewBuilder<T>) => ElementViewBuilder<T>): AddViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
}
type ValidFqn<T extends AnyTypes> = IsStringLiteral<T['Fqn']> extends true ? T['Fqn'] : Invalid<'Fqn must be from known'>;
interface AddViewOfHelper {
    <const Id extends string, T extends AnyTypes>(id: Id, of: ValidFqn<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
    <const Id extends string, T extends AnyTypes>(id: Id, of: ValidFqn<T>, propsOrTitle: T['NewViewProps'] | string | ElementViewRulesBuilder<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
    <const Id extends string, T extends AnyTypes>(id: Id, of: ValidFqn<T>, propsOrTitle: NoInfer<T>['NewViewProps'] | string, builder: (b: ElementViewBuilder<T>) => ElementViewBuilder<T>): (builder: ViewsBuilder<T>) => ViewsBuilder<Types.AddView<T, Id>>;
}
interface TypedAddViewOfHelper<A extends AnyTypes> {
    <const Id extends string, T extends AnyTypes>(id: Id, of: ValidFqn<A>): AddViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
    <const Id extends string, T extends AnyTypes>(id: Id, of: ValidFqn<A>, builder: ((b: ElementViewBuilder<A>) => ElementViewBuilder<A>) | A['NewViewProps'] | string): AddViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
    <const Id extends string, T extends AnyTypes>(id: Id, of: ValidFqn<A>, propsOrTitle: A['NewViewProps'] | string, builder: (b: ElementViewBuilder<A>) => ElementViewBuilder<A>): AddViewRules<Id> & {
        (builder: ViewsBuilder<T>): ViewsBuilder<Types.AddView<T, Id>>;
    };
}
declare function $expr<Types extends AnyTypes>(expr: ViewPredicate.Expression<Types> | ExpressionV2): ExpressionV2;

interface ViewsBuilder<T extends AnyTypes> extends Builder<T> {
    __addView(view: LikeC4View): Builder<T>;
}
declare function views<A extends AnyTypes>(): (input: Builder<A>) => Builder<A>;
declare function views<A extends AnyTypes, B extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>): (input: Builder<A>) => Builder<B>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>): (input: Builder<A>) => Builder<C>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>): (input: Builder<A>) => Builder<D>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>): (input: Builder<A>) => Builder<E>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>): (input: Builder<A>) => Builder<F>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>): (input: Builder<A>) => Builder<G>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>): (input: Builder<A>) => Builder<H>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>): (input: Builder<A>) => Builder<I>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>): (input: Builder<A>) => Builder<J>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>): (input: Builder<A>) => Builder<K>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>): (input: Builder<A>) => Builder<L>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>, op12: (input: ViewsBuilder<L>) => ViewsBuilder<M>): (input: Builder<A>) => Builder<M>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>, op12: (input: ViewsBuilder<L>) => ViewsBuilder<M>, op13: (input: ViewsBuilder<M>) => ViewsBuilder<N>): (input: Builder<A>) => Builder<N>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>, op12: (input: ViewsBuilder<L>) => ViewsBuilder<M>, op13: (input: ViewsBuilder<M>) => ViewsBuilder<N>, op14: (input: ViewsBuilder<N>) => ViewsBuilder<O>): (input: Builder<A>) => Builder<O>;
declare function views<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes, K extends AnyTypes, L extends AnyTypes, M extends AnyTypes, N extends AnyTypes, O extends AnyTypes, P extends AnyTypes>(op1: (input: ViewsBuilder<A>) => ViewsBuilder<B>, op2: (input: ViewsBuilder<B>) => ViewsBuilder<C>, op3: (input: ViewsBuilder<C>) => ViewsBuilder<D>, op4: (input: ViewsBuilder<D>) => ViewsBuilder<E>, op5: (input: ViewsBuilder<E>) => ViewsBuilder<F>, op6: (input: ViewsBuilder<F>) => ViewsBuilder<G>, op7: (input: ViewsBuilder<G>) => ViewsBuilder<H>, op8: (input: ViewsBuilder<H>) => ViewsBuilder<I>, op9: (input: ViewsBuilder<I>) => ViewsBuilder<J>, op10: (input: ViewsBuilder<J>) => ViewsBuilder<K>, op11: (input: ViewsBuilder<K>) => ViewsBuilder<L>, op12: (input: ViewsBuilder<L>) => ViewsBuilder<M>, op13: (input: ViewsBuilder<M>) => ViewsBuilder<N>, op14: (input: ViewsBuilder<N>) => ViewsBuilder<O>, op15: (input: ViewsBuilder<O>) => ViewsBuilder<P>): (input: Builder<A>) => Builder<P>;
type ViewsHelpers = {
    views: typeof views;
    view: AddViewHelper;
    viewOf: AddViewOfHelper;
    deploymentView: AddDeploymentViewHelper;
    $include: typeof $include;
    $exclude: typeof $exclude;
    $style: typeof $style;
    $rules: typeof $rules;
    $autoLayout: typeof $autoLayout;
};
type ViewsBuilderFunction<A extends AnyTypes, B extends AnyTypes> = (helpers: Simplify<ViewsHelpers['views'] & Omit<ViewsHelpers, 'viewOf'> & {
    viewOf: TypedAddViewOfHelper<A>;
    _: ViewsHelpers['views'];
}>, add: ViewsHelpers['views']) => ((builder: ViewsBuilder<A>) => ViewsBuilder<B>) | ((builder: Builder<A>) => Builder<B>);
declare function mkViewBuilder(view: Writable<DeploymentView>): DeploymentViewBuilder<AnyTypes>;
declare function mkViewBuilder(view: Writable<ElementView>): ElementViewBuilder<AnyTypes>;

interface BuilderMethods<T extends AnyTypes> {
    with<A extends AnyTypes>(): Builder<A>;
    with<A extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>): Builder<A>;
    with<A extends AnyTypes, B extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>): Builder<B>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>): Builder<C>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>): Builder<D>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>): Builder<E>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>): Builder<F>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>, op7: (input: Builder<F>) => Builder<G>): Builder<G>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>, op7: (input: Builder<F>) => Builder<G>, op8: (input: Builder<G>) => Builder<H>): Builder<H>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>, op7: (input: Builder<F>) => Builder<G>, op8: (input: Builder<G>) => Builder<H>, op9: (input: Builder<H>) => Builder<I>): Builder<I>;
    with<A extends AnyTypes, B extends AnyTypes, C extends AnyTypes, D extends AnyTypes, E extends AnyTypes, F extends AnyTypes, G extends AnyTypes, H extends AnyTypes, I extends AnyTypes, J extends AnyTypes>(op1: (input: Builder<T>) => Builder<A>, op2: (input: Builder<A>) => Builder<B>, op3: (input: Builder<B>) => Builder<C>, op4: (input: Builder<C>) => Builder<D>, op5: (input: Builder<D>) => Builder<E>, op6: (input: Builder<E>) => Builder<F>, op7: (input: Builder<F>) => Builder<G>, op8: (input: Builder<G>) => Builder<H>, op9: (input: Builder<H>) => Builder<I>, op10: (input: Builder<I>) => Builder<J>): Builder<J>;
}

interface Builder<T extends AnyTypes> extends BuilderMethods<T> {
    /**
     * Only available in compile time
     */
    readonly Types: T;
    clone(): Builder<T>;
    /**
     * Builders for each element kind
     */
    helpers(): {
        model: ModelHelpers<T>;
        views: ViewsHelpers;
        deployment: DeloymentModelHelpers<T>;
    };
    /**
     * Adds model elements
     *
     * @example
     *  builder.model(({ el }, _) =>
     *    _(
     *      el('a'),
     *      el('a.b').with(
     *        el('c')
     *      )
     *    )
     *  )
     *
     *  builder.model((_, m) =>
     *    m(
     *      _.el('a'),
     *      _.el('a.b').with(
     *        _.el('c')
     *      )
     *    )
     *  )
     */
    model<Out extends AnyTypes>(callback: ModelBuilderFunction<T, Out>): Builder<Out>;
    /**
     * Adds deployment model
     *
     * @example
     *  builder.deployment(({ node, instanceOf }, _) =>
     *    _(
     *      node('node1'),
     *      node('node1.child1').with(
     *        instanceOf('model.element')
     *      )
     *    )
     *  )
     *
     *  builder.deployment((_,d) =>
     *    d(
     *      _.node('node1'),
     *       _.node('node1.child1').with(
     *        _.instanceOf('model.element')
     *      )
     *    )
     *  )
     */
    deployment<Out extends AnyTypes>(callback: DeloymentModelBuildFunction<T, Out>): Builder<Out>;
    /**
     * Adds views
     *
     * @example
     *  builder.views(({ view, $include }, _) =>
     *    _(
     *      view('index').with(
     *        $include('a -> b')
     *      )
     *    )
     *  )
     */
    views<Out extends AnyTypes>(callback: ViewsBuilderFunction<T, Out>): Builder<Out>;
    /**
     * Returns model as result of parsing only
     * Views are not computed or layouted
     * {@link toLikeC4Model} should be used to get model with computed views
     */
    build(): Types.ToParsedLikeC4Model<T>;
    /**
     * Returns LikeC4Model with computed views
     */
    toLikeC4Model(): Types.ToLikeC4Model<T>;
}
declare namespace Builder {
    type Any = Builder<AnyTypes>;
    function forSpecification<const Spec extends BuilderSpecification>(spec: Spec): {
        builder: Builder<Types.FromSpecification<Spec>>;
        model: ModelHelpers<Types.FromSpecification<Spec>>;
        deployment: DeloymentModelHelpers<Types.FromSpecification<Spec>>;
        views: ViewsHelpers;
    };
    function specification<const Spec extends BuilderSpecification>(spec: Spec): Builder<Types.FromSpecification<Spec>>;
}

type BuilderSpecification = {
    elements: {
        [kind: string]: Partial<ElementKindSpecification>;
    };
    relationships?: {
        [kind: string]: Partial<RelationshipKindSpecification>;
    };
    deployments?: {
        [kind: string]: Partial<DeploymentNodeKindSpecification>;
    };
    tags?: [string, ...string[]];
    metadataKeys?: [string, ...string[]];
};
type Metadata<MetadataKey extends string> = IfNever<MetadataKey, never, Record<MetadataKey, string>>;
type NewElementProps<Tag, Metadata> = {
    title?: string;
    description?: string;
    technology?: string;
    tags?: IfNever<Tag, never, [Tag, ...Tag[]]>;
    metadata?: Metadata;
    icon?: string;
    shape?: ElementShape;
    color?: Color;
    links?: Array<string | {
        title?: string;
        url: string;
    }>;
    style?: {
        border?: BorderStyle;
        opacity?: number;
        size?: ShapeSize;
        padding?: SpacingSize;
        textSize?: TextSize;
    };
};
type NewDeploymentNodeProps<Tag, Metadata> = {
    title?: string;
    description?: string;
    technology?: string;
    tags?: IfNever<Tag, never, [Tag, ...Tag[]]>;
    metadata?: Metadata;
    icon?: string;
    shape?: ElementShape;
    color?: Color;
    links?: NonEmptyArray<string | {
        title?: string;
        url: string;
    }>;
    style?: {
        border?: BorderStyle;
        opacity?: number;
        size?: ShapeSize;
        padding?: SpacingSize;
        textSize?: TextSize;
    };
};
type NewViewProps<Tag> = {
    title?: string;
    description?: string;
    tags?: IfNever<Tag, never, [Tag, ...Tag[]]>;
    links?: Array<string | {
        title?: string;
        url: string;
    }>;
};
type NewRelationProps<Kind, Tag, Metadata> = {
    kind?: Kind;
    title?: string;
    description?: string;
    technology?: string;
    tags?: IfNever<Tag, never, [Tag, ...Tag[]]>;
    metadata?: Metadata;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
    line?: RelationshipLineType;
    color?: Color;
    links?: NonEmptyArray<string | {
        title?: string;
        url: string;
    }>;
};
type Invalid<Message extends string> = Tagged<Message, 'Error'>;
type Warn<Id, Existing> = IsLiteral<Existing> extends true ? Id extends Existing ? Invalid<'Already exists'> : Id : Id;
type ValidId<Id> = Id extends `${number}${string}` ? Invalid<'Id must not start with number'> : IsStringLiteral$1<Id> extends true ? Id : Invalid<'Id must be a literal'>;
/**
 * When building nested objects
 */
interface TypesNested<Parent extends string, ElementKind extends string, Fqn extends string, ViewId extends string, RelationshipKind extends string, Tag extends string, MetadataKey extends string, DeploymentKind extends string, DeploymentFqn extends string> extends Types<ElementKind, Fqn, ViewId, RelationshipKind, Tag, MetadataKey, DeploymentKind, DeploymentFqn> {
    Parent: Parent;
}
type AnyTypes = Types<any, any, any, any, any, any, any, any>;
type AnyTypesNested = TypesNested<any, any, any, any, any, any, any, any, any>;
/**
 * Auxilary type to keep track of the types in builder
 */
interface Types<ElementKind extends string, Fqn extends string, ViewId extends string, RelationshipKind extends string, Tag extends string, MetadataKey extends string, DeploymentKind extends string, DeploymentFqn extends string> {
    ElementKind: ElementKind;
    Fqn: Fqn;
    ViewId: ViewId;
    RelationshipKind: RelationshipKind;
    Tag: Tag;
    MetadataKey: MetadataKey;
    DeploymentKind: DeploymentKind;
    DeploymentFqn: DeploymentFqn;
    Tags: IfNever<Tag, never, [Tag, ...Tag[]]>;
    NewElementProps: NewElementProps<Tag, Metadata<MetadataKey>>;
    NewRelationshipProps: NewRelationProps<RelationshipKind, Tag, Metadata<MetadataKey>>;
    NewViewProps: NewViewProps<Tag>;
    NewDeploymentNodeProps: NewDeploymentNodeProps<Tag, Metadata<MetadataKey>>;
}
declare namespace Types {
    type FromSpecification<Spec> = Spec extends BuilderSpecification ? Types<KeysOf<Spec['elements']>, never, never, KeysOf<Spec['relationships']>, TupleToUnion<Spec['tags']>, TupleToUnion<Spec['metadataKeys']>, KeysOf<Spec['deployments']>, never> : never;
    type AddFqn<T, Id extends string> = T extends TypesNested<infer P, any, any, any, any, any, any, any, any> ? TypesNested<P, T['ElementKind'], `${P}.${Id}` | T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], T['DeploymentFqn']> : T extends AnyTypes ? Types<T['ElementKind'], Id | T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], T['DeploymentFqn']> : never;
    type AddDeploymentFqn<T, Id extends string> = T extends TypesNested<infer P, any, any, any, any, any, any, any, any> ? TypesNested<P, T['ElementKind'], T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], `${P}.${Id}` | T['DeploymentFqn']> : T extends AnyTypes ? Types<T['ElementKind'], T['Fqn'], T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], Id | T['DeploymentFqn']> : never;
    type AddView<T, Id extends string> = T extends TypesNested<infer P, any, any, any, any, any, any, any, any> ? TypesNested<P, T['ElementKind'], T['Fqn'], Id | T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], T['DeploymentFqn']> : T extends AnyTypes ? Types<T['ElementKind'], T['Fqn'], Id | T['ViewId'], T['RelationshipKind'], T['Tag'], T['MetadataKey'], T['DeploymentKind'], T['DeploymentFqn']> : never;
    type ToParsedLikeC4Model<T> = T extends AnyTypes ? ParsedLikeC4ModelData<T['ElementKind'], T['RelationshipKind'], T['Tag'], T['Fqn'], T['ViewId'], T['DeploymentFqn']> : never;
    type ToLikeC4Model<T extends AnyTypes> = LikeC4Model.Computed<T['Fqn'], T['DeploymentFqn'], T['ViewId']>;
    type ToExpression<T> = T extends AnyTypes ? ExpressionV2<T['DeploymentFqn'], T['Fqn']> : never;
    type From<B> = B extends Builder<infer T> ? B['Types'] extends AnyTypes ? T : AnyTypes : never;
    type DeploymentRules<B> = DeploymentRulesBuilderOp<From<B>>;
}

export { $autoLayout, $deploymentExpr, $exclude, $expr, $include, $rules, $style, type AddDeployedInstance, type AddDeploymentNode, type AddDeploymentNodeHelpers, type AddDeploymentRelation, type AddDeploymentViewHelper, type AddDeploymentViewRules, type AddElement, type AddElementHelpers, type AddViewHelper, type AddViewOfHelper, type AddViewRules, type AnyTypes, type AnyTypesNested, Builder, type BuilderMethods, type BuilderSpecification, type DeloymentModelBuildFunction, type DeloymentModelHelpers, type DeploymentModelBuilder, type DeploymentRulesBuilderOp, type DeploymentViewBuilder, type ElementViewBuilder, type ElementViewRulesBuilder, type Invalid, type LikeC4ViewBuilder, type Metadata, type ModelBuilder, type ModelBuilderFunction, type ModelHelpers, type NestedRelationshipHelper, type NewDeploymentNodeProps, type NewElementProps, type NewRelationProps, type NewViewProps, type RelationshipHelper, type TypedAddViewOfHelper, Types, type TypesNested, type ValidId, ViewPredicate, type ViewsBuilder, type ViewsBuilderFunction, type ViewsHelpers, type Warn, deployment, mkViewBuilder, model, views };
