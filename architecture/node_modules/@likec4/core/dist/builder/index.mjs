import { a as i, l, d, L as LikeC4Model } from '../shared/core.CAcZ6_cP.mjs';
import { m, l as l$1, i as i$1 } from '../shared/core.Cu-UdkSl.mjs';
import { f as t, n as nameFromFqn, g as isSameHierarchy, p as parentFqn, h as t$1 } from '../shared/core.CQXU9DF7.mjs';
import { o, M as ModelLayer, D as DefaultElementShape, b as DefaultThemeColor, n as n$1, c as DeploymentElement, d as isScopedElementView } from '../shared/core.DgfwjBtu.mjs';
import { u } from '../shared/core.DbRvwARP.mjs';
import { i as invariant } from '../shared/core.C-YXI-43.mjs';

function n(...r){return u(Object.fromEntries,r)}

function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();

function parseWhere(where) {
  if (t(where)) {
    const op = where;
    switch (true) {
      case op.startsWith("tag is not #"):
        return {
          tag: {
            neq: op.replace("tag is not #", "")
          }
        };
      case op.startsWith("tag is #"):
        return {
          tag: {
            eq: op.replace("tag is #", "")
          }
        };
      case op.startsWith("kind is not "):
        return {
          kind: {
            neq: op.replace("kind is not ", "")
          }
        };
      case op.startsWith("kind is "):
        return {
          kind: {
            eq: op.replace("kind is ", "")
          }
        };
      case op.startsWith("source."):
        return {
          operator: parseWhere(op.replace("source.", "")),
          participant: "source"
        };
      case op.startsWith("target."):
        return {
          operator: parseWhere(op.replace("target.", "")),
          participant: "target"
        };
      default:
        throw new Error(`Unknown where operator: ${where}`);
    }
  }
  if (where.and) {
    return {
      and: m(where.and, parseWhere)
    };
  }
  if (where.or) {
    return {
      or: m(where.or, parseWhere)
    };
  }
  if (where.not) {
    return {
      not: parseWhere(where.not)
    };
  }
  throw new Error(`Unknown where operator: ${where}`);
}
function $include(...args) {
  return (b) => {
    let expr = b.$expr(args[0]);
    if (args.length === 2) {
      const condition = args[1].where ? parseWhere(args[1].where) : void 0;
      if (condition) {
        expr = {
          where: {
            expr,
            condition
          }
        };
      }
      const custom = args[1].with;
      if (custom) {
        const isElement = ModelLayer.FqnExpr.is(expr);
        if (isElement) {
          expr = {
            custom: {
              ...custom,
              expr
            }
          };
        } else {
          expr = {
            customRelation: {
              ...custom,
              expr
            }
          };
        }
      }
    }
    b.include(expr);
    return b;
  };
}
function $exclude(...args) {
  return (b) => {
    let expr = b.$expr(args[0]);
    if (args.length === 2 && args[1].where) {
      const condition = parseWhere(args[1].where);
      expr = {
        where: {
          expr,
          condition
        }
      };
    }
    b.exclude(expr);
    return b;
  };
}
function $style(element, { notation, ...style }) {
  return (b) => b.style({
    targets: (o(element) ? element : [element]).map((e) => b.$expr(e)),
    ...notation ? { notation } : {},
    style: {
      ...style
    }
  });
}
function $autoLayout(layout) {
  return (b) => b.autoLayout(layout);
}
function $rules(...rules) {
  return (b) => rules.reduce((b2, rule) => rule(b2), b);
}

function $deploymentExpr(expr) {
  if (!t(expr)) {
    return expr;
  }
  const asTypedDeploymentExpression = (expr2) => {
    return expr2;
  };
  if (expr === "*") {
    return asTypedDeploymentExpression({ wildcard: true });
  }
  if (expr.startsWith("->")) {
    if (expr.endsWith("->")) {
      return asTypedDeploymentExpression({
        inout: $deploymentExpr(expr.replace(/->/g, "").trim())
      });
    }
    return asTypedDeploymentExpression({
      incoming: $deploymentExpr(expr.replace("-> ", ""))
    });
  }
  if (expr.endsWith(" ->")) {
    return asTypedDeploymentExpression({
      outgoing: $deploymentExpr(expr.replace(" ->", ""))
    });
  }
  if (expr.includes(" <-> ")) {
    const [source, target] = expr.split(" <-> ");
    return asTypedDeploymentExpression({
      source: $deploymentExpr(source),
      target: $deploymentExpr(target),
      isBidirectional: true
    });
  }
  if (expr.includes(" -> ")) {
    const [source, target] = expr.split(" -> ");
    return asTypedDeploymentExpression({
      source: $deploymentExpr(source),
      target: $deploymentExpr(target)
    });
  }
  if (expr.endsWith("._")) {
    return asTypedDeploymentExpression({
      ref: {
        deployment: expr.replace("._", "")
      },
      selector: "expanded"
    });
  }
  if (expr.endsWith(".**")) {
    return asTypedDeploymentExpression({
      ref: {
        deployment: expr.replace(".**", "")
      },
      selector: "descendants"
    });
  }
  if (expr.endsWith(".*")) {
    return asTypedDeploymentExpression({
      ref: {
        deployment: expr.replace(".*", "")
      },
      selector: "children"
    });
  }
  return asTypedDeploymentExpression({
    ref: {
      deployment: expr
    }
  });
}

const asTypedExpr = (expr) => {
  return expr;
};
function $expr(expr) {
  if (!t(expr)) {
    return expr;
  }
  if (expr === "*") {
    return asTypedExpr({ wildcard: true });
  }
  if (expr.startsWith("->")) {
    if (expr.endsWith("->")) {
      return asTypedExpr({
        inout: $expr(expr.replace(/->/g, "").trim())
      });
    }
    return asTypedExpr({
      incoming: $expr(expr.replace("-> ", ""))
    });
  }
  if (expr.endsWith(" ->")) {
    return asTypedExpr({
      outgoing: $expr(expr.replace(" ->", ""))
    });
  }
  if (expr.includes(" <-> ")) {
    const [source, target] = expr.split(" <-> ");
    return asTypedExpr({
      source: $expr(source),
      target: $expr(target),
      isBidirectional: true
    });
  }
  if (expr.includes(" -> ")) {
    const [source, target] = expr.split(" -> ");
    return asTypedExpr({
      source: $expr(source),
      target: $expr(target)
    });
  }
  if (expr.endsWith("._")) {
    return asTypedExpr({
      ref: {
        model: expr.replace("._", "")
      },
      selector: "expanded"
    });
  }
  if (expr.endsWith(".**")) {
    return asTypedExpr({
      ref: {
        model: expr.replace(".**", "")
      },
      selector: "descendants"
    });
  }
  if (expr.endsWith(".*")) {
    return asTypedExpr({
      ref: {
        model: expr.replace(".*", "")
      },
      selector: "children"
    });
  }
  return asTypedExpr({
    ref: {
      model: expr
    }
  });
}

function mkViewBuilder(view) {
  const viewBuilder = {
    $expr: view.__ === "deployment" ? $deploymentExpr : $expr,
    autoLayout(autoLayout) {
      view.rules.push({
        direction: autoLayout
      });
      return viewBuilder;
    },
    exclude(expr) {
      view.rules.push({
        exclude: [expr]
      });
      return viewBuilder;
    },
    include(expr) {
      view.rules.push({
        include: [expr]
      });
      return viewBuilder;
    },
    style(rule) {
      view.rules.push(rule);
      return viewBuilder;
    }
    // title(title: string) {
    //   view.title = title
    //   return viewBuilder
    // },
    // description(description: string) {
    //   view.description = description
    //   return viewBuilder
    // }
  };
  return viewBuilder;
}

function builder(spec, _elements = /* @__PURE__ */ new Map(), _relations = [], _views = /* @__PURE__ */ new Map(), _globals = {
  predicates: {},
  dynamicPredicates: {},
  styles: {}
}, _deployments = /* @__PURE__ */ new Map(), _deploymentRelations = []) {
  const toLikeC4Specification = () => ({
    elements: {
      ...structuredClone(spec.elements)
    },
    deployments: {
      ...structuredClone(spec.deployments)
    },
    relationships: {
      ...structuredClone(spec.relationships)
    },
    tags: spec.tags ?? []
  });
  const mapLinks = (links) => {
    if (!links || !i$1(links, 1)) {
      return null;
    }
    return m(links, (l) => typeof l === "string" ? { url: l } : l);
  };
  const createGenericView = (id, _props, builder2) => {
    if (t$1(_props)) {
      builder2 = _props;
      _props = {};
    }
    _props ??= {};
    const {
      links: _links = [],
      title = null,
      description = null,
      tags = null,
      ...props
    } = typeof _props === "string" ? { title: _props } : { ..._props };
    const links = mapLinks(_links);
    return [{
      id,
      title,
      description,
      tags,
      links,
      customColorDefinitions: {},
      ...props
    }, builder2];
  };
  const self = {
    get Types() {
      throw new Error("Types are not available in runtime");
    },
    clone: () => {
      return builder(
        structuredClone(spec),
        structuredClone(_elements),
        structuredClone(_relations),
        structuredClone(_views),
        structuredClone(_globals),
        structuredClone(_deployments),
        structuredClone(_deploymentRelations)
      );
    },
    __addElement: (element) => {
      const parent = parentFqn(element.id);
      if (parent) {
        invariant(
          _elements.get(parent),
          `Parent element with id "${parent}" not found for element with id "${element.id}"`
        );
      }
      if (_elements.has(element.id)) {
        throw new Error(`Element with id "${element.id}" already exists`);
      }
      _elements.set(element.id, element);
      return self;
    },
    __addRelation(relation) {
      const sourceEl = _elements.get(relation.source);
      invariant(sourceEl, `Element with id "${relation.source}" not found`);
      const targetEl = _elements.get(relation.target);
      invariant(targetEl, `Element with id "${relation.target}" not found`);
      invariant(
        !isSameHierarchy(sourceEl, targetEl),
        "Cannot create relationship between elements in the same hierarchy"
      );
      _relations.push({
        id: `rel${_relations.length + 1}`,
        ...relation
      });
      return self;
    },
    /**
     * Fully qualified name for nested elements
     */
    __fqn(id) {
      invariant(id.trim() !== "", "Id must be non-empty");
      return id;
    },
    __addSourcelessRelation() {
      throw new Error("Can be called only in nested model");
    },
    __addView: (view) => {
      if (_views.has(view.id)) {
        throw new Error(`View with id "${view.id}" already exists`);
      }
      if (isScopedElementView(view)) {
        invariant(
          _elements.get(view.viewOf),
          `Invalid scoped view ${view.id}, wlement with id "${view.viewOf}" not found`
        );
      }
      _views.set(view.id, view);
      return self;
    },
    __addDeployment: (node) => {
      if (_deployments.has(node.id)) {
        throw new Error(`Deployment with id "${node.id}" already exists`);
      }
      const parent = parentFqn(node.id);
      if (parent) {
        invariant(
          _deployments.get(parent),
          `Parent element with id "${parent}" not found for node with id "${node.id}"`
        );
      }
      if (DeploymentElement.isInstance(node)) {
        invariant(parent, `Instance ${node.id} of ${node.element} must be deployed under a parent node`);
        invariant(
          _elements.get(node.element),
          `Instance "${node.id}" references non-existing element "${node.element}"`
        );
      }
      _deployments.set(node.id, node);
      return self;
    },
    __addDeploymentRelation: (relation) => {
      invariant(
        !isSameHierarchy(relation.source.id, relation.target.id),
        "Cannot create relationship between elements in the same hierarchy"
      );
      invariant(
        _deployments.has(relation.source.id),
        `Relation "${relation.source.id} -> ${relation.target.id}" references non-existing source`
      );
      invariant(
        _deployments.has(relation.target.id),
        `Relation "${relation.source.id} -> ${relation.target.id}" references non-existing target`
      );
      _deploymentRelations.push({
        id: `deploy_rel${_deploymentRelations.length + 1}`,
        ...relation
      });
      return self;
    },
    build: () => ({
      specification: toLikeC4Specification(),
      elements: n(
        structuredClone(
          Array.from(_elements.entries())
        )
      ),
      relations: l(_relations, (r) => [r.id, structuredClone(r)]),
      globals: structuredClone(_globals),
      deployments: {
        elements: n(
          structuredClone(
            Array.from(_deployments.entries())
          )
        ),
        relations: l(_deploymentRelations, (r) => [r.id, structuredClone(r)])
      },
      views: n(
        structuredClone(
          Array.from(_views.entries())
        )
      ),
      imports: {}
    }),
    toLikeC4Model: () => {
      const parsed = self.build();
      return LikeC4Model.compute(parsed);
    },
    helpers: () => ({
      model: {
        model: (...ops) => {
          return (b) => {
            return ops.reduce((b2, op) => op(b2), b);
          };
        },
        rel: (source, target, _props) => {
          return (b) => {
            const {
              title = "",
              links: _links = [],
              ...props
            } = defu(
              typeof _props === "string" ? { title: _props } : { ..._props },
              { title: null, links: null }
            );
            const links = mapLinks(_links);
            b.__addRelation({
              source,
              target,
              title,
              ...links && { links },
              ...props
            });
            return b;
          };
        },
        relTo: (target, _props) => {
          return (b) => {
            const {
              title = "",
              links: _links = [],
              ...props
            } = defu(
              typeof _props === "string" ? { title: _props } : { ..._props },
              { title: null, links: null }
            );
            const links = mapLinks(_links);
            b.__addSourcelessRelation({
              target,
              title,
              ...links && { links },
              ...props
            });
            return b;
          };
        },
        ...i(
          spec.elements,
          ({ style: specStyle, ...spec2 }, kind) => (id, _props) => {
            const add = (b) => {
              const {
                links: _links,
                icon: _icon,
                style,
                title,
                ...props
              } = typeof _props === "string" ? { title: _props } : { ..._props };
              const links = mapLinks(_links);
              const icon = _icon ?? specStyle?.icon;
              const _id = b.__fqn(id);
              b.__addElement({
                id: _id,
                kind,
                title: title ?? nameFromFqn(_id),
                description: null,
                technology: null,
                tags: null,
                color: specStyle?.color ?? DefaultThemeColor,
                shape: specStyle?.shape ?? DefaultElementShape,
                style: d({
                  border: specStyle?.border,
                  opacity: specStyle?.opacity,
                  size: specStyle?.size,
                  padding: specStyle?.padding,
                  textSize: specStyle?.textSize,
                  ...style
                }, l$1),
                links,
                ...icon && { icon },
                ...spec2,
                ...props
              });
              return b;
            };
            add.with = (...ops) => (b) => {
              add(b);
              const { __fqn, __addSourcelessRelation } = b;
              try {
                b.__fqn = (child) => `${__fqn(id)}.${child}`;
                b.__addSourcelessRelation = (relation) => {
                  return b.__addRelation({
                    ...relation,
                    source: __fqn(id)
                  });
                };
                ops.reduce((b2, op) => op(b2), b);
              } finally {
                b.__fqn = __fqn;
                b.__addSourcelessRelation = __addSourcelessRelation;
              }
              return b;
            };
            return add;
          }
        )
      },
      views: {
        views: (...ops) => {
          return (b) => {
            return ops.reduce((b2, op) => op(b2), b);
          };
        },
        view: (id, _props, _builder) => {
          const [generic, builder2] = createGenericView(id, _props, _builder);
          const view = {
            ...generic,
            __: "element",
            rules: []
          };
          const add = (b) => {
            b.__addView(view);
            if (builder2) {
              builder2(mkViewBuilder(view));
            }
            return b;
          };
          add.with = (...ops) => (b) => {
            add(b);
            const elementViewBuilder = mkViewBuilder(view);
            for (const op of ops) {
              op(elementViewBuilder);
            }
            return b;
          };
          return add;
        },
        viewOf: (id, viewOf, _props, _builder) => {
          const [generic, builder2] = createGenericView(id, _props, _builder);
          const view = {
            ...generic,
            viewOf,
            __: "element",
            rules: []
          };
          const add = (b) => {
            b.__addView(view);
            if (builder2) {
              builder2(mkViewBuilder(view));
            }
            return b;
          };
          add.with = (...ops) => (b) => {
            add(b);
            const elementViewBuilder = mkViewBuilder(view);
            for (const op of ops) {
              op(elementViewBuilder);
            }
            return b;
          };
          return add;
        },
        deploymentView: (id, _props, _builder) => {
          const [generic, builder2] = createGenericView(id, _props, _builder);
          const view = {
            ...generic,
            __: "deployment",
            rules: []
          };
          const add = (b) => {
            b.__addView(view);
            if (builder2) {
              builder2(mkViewBuilder(view));
            }
            return b;
          };
          add.with = (...ops) => (b) => {
            add(b);
            const elementViewBuilder = mkViewBuilder(view);
            for (const op of ops) {
              op(elementViewBuilder);
            }
            return b;
          };
          return add;
        },
        $autoLayout,
        $exclude,
        $include,
        $rules,
        $style
      },
      deployment: {
        deployment: (...ops) => {
          return (b) => {
            return ops.reduce((b2, op) => op(b2), b);
          };
        },
        instanceOf: (id, target, _props) => {
          return (b) => {
            if (n$1(target)) {
              target = id;
              id = nameFromFqn(id);
            } else if (typeof target === "string") {
              _props ??= {};
            } else {
              _props = target;
              target = id;
              id = nameFromFqn(id);
            }
            const {
              links,
              title,
              ...props
            } = typeof _props === "string" ? { title: _props } : { ..._props };
            const _id = b.__fqn(id);
            invariant(_elements.has(target), `Target element with id "${target}" not found`);
            b.__addDeployment({
              id: _id,
              element: target,
              ...title && { title },
              ...links && { links: mapLinks(links) },
              ...props
            });
            return b;
          };
        },
        rel: (source, target, _props) => {
          return (b) => {
            const {
              title,
              links,
              ...props
            } = typeof _props === "string" ? { title: _props } : { ..._props };
            b.__addDeploymentRelation({
              source: {
                id: source
              },
              target: {
                id: target
              },
              ...title && { title },
              ...links && { links: mapLinks(links) },
              ...props
            });
            return b;
          };
        },
        ...i(
          spec.deployments ?? {},
          ({ style: specStyle, ...spec2 }, kind) => (id, _props) => {
            const add = (b) => {
              const {
                links,
                icon: _icon,
                style,
                title,
                ...props
              } = typeof _props === "string" ? { title: _props } : { ..._props };
              const icon = _icon ?? specStyle?.icon;
              const _id = b.__fqn(id);
              b.__addDeployment({
                id: _id,
                kind,
                title: title ?? nameFromFqn(_id),
                description: null,
                technology: null,
                tags: null,
                color: specStyle?.color ?? DefaultThemeColor,
                shape: specStyle?.shape ?? DefaultElementShape,
                style: d({
                  border: specStyle?.border,
                  opacity: specStyle?.opacity,
                  size: specStyle?.size,
                  padding: specStyle?.padding,
                  textSize: specStyle?.textSize,
                  ...style
                }, l$1),
                ...links && { links: mapLinks(links) },
                ...icon && { icon },
                ...spec2,
                ...props
              });
              return b;
            };
            add.with = (...ops) => (b) => {
              add(b);
              const { __fqn } = b;
              try {
                b.__fqn = (child) => `${__fqn(id)}.${child}`;
                ops.reduce((b2, op) => op(b2), b);
              } finally {
                b.__fqn = __fqn;
              }
              return b;
            };
            return add;
          }
        )
      }
    }),
    with: (...ops) => {
      return ops.reduce((b, op) => op(b), self).clone();
    },
    model: (cb) => {
      const b = self.clone();
      const helpers = b.helpers().model;
      const _ = helpers.model;
      return cb({ ...helpers, _ }, _)(b);
    },
    deployment: (cb) => {
      const b = self.clone();
      const helpers = b.helpers().deployment;
      const _ = helpers.deployment;
      return cb({ ...helpers, _ }, _)(b);
    },
    views: (cb) => {
      const b = self.clone();
      const helpers = b.helpers().views;
      return cb({
        ...helpers,
        _: helpers.views
      }, helpers.views)(b);
    }
  };
  return self;
}
var Builder;
((Builder2) => {
  function forSpecification(spec) {
    const b = builder(spec);
    return {
      ...b.helpers(),
      builder: b
    };
  }
  Builder2.forSpecification = forSpecification;
  function specification(spec) {
    return builder(spec);
  }
  Builder2.specification = specification;
})(Builder || (Builder = {}));

export { Builder };
