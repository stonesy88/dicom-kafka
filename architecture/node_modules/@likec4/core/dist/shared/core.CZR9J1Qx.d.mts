import { E as ElementModel, d as DeploymentElementModel, A as AnyAux, e as DeploymentNodeModel, D as DeployedInstanceModel, j as RelationshipsAccum, R as RelationshipModel, f as DeploymentRelationModel } from './core.CiFKryGW.mjs';
import { F as Fqn, I as IteratorLike } from './core.SjLhMA7a.mjs';

interface Connection<Elem = ElementModel | DeploymentElementModel, Id = string> {
    readonly id: Id;
    readonly source: Elem;
    readonly target: Elem;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    readonly boundary: Elem | null;
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    readonly expression: string;
    mergeWith(this: Connection<Elem, Id>, other: typeof this): typeof this;
    nonEmpty(): boolean;
    difference(this: Connection<Elem, Id>, other: typeof this): typeof this;
    intersect(this: Connection<Elem, Id>, other: typeof this): typeof this;
    equals(other: Connection): boolean;
}
declare namespace Connection {
    type ConnectionPredicate = <C extends Connection<{
        id: string;
    }, any>>(connection: C) => boolean;
    type ElementId = Fqn | string;
    export const isInside: (fqn: ElementId) => ConnectionPredicate;
    export const isDirectedBetween: (source: ElementId, target: ElementId) => ConnectionPredicate;
    export const isAnyBetween: (source: ElementId, target: ElementId) => ConnectionPredicate;
    export const isIncoming: (target: ElementId) => ConnectionPredicate;
    export const isOutgoing: (source: ElementId) => ConnectionPredicate;
    export const isAnyInOut: (source: ElementId) => ConnectionPredicate;
    export {  };
}

declare const customInspectSymbol: unique symbol;

/**
 * Connection is ephemeral entity, result of a resolving relationships between source and target.
 * Includes direct relationships and/or between their nested elements.
 */
declare class DeploymentConnectionModel<M extends AnyAux = AnyAux> implements Connection<DeploymentElementModel<M>, M['EdgeId']> {
    readonly source: DeploymentNodeModel<M> | DeployedInstanceModel<M>;
    readonly target: DeploymentNodeModel<M> | DeployedInstanceModel<M>;
    readonly relations: RelationshipsAccum<M>;
    constructor(source: DeploymentNodeModel<M> | DeployedInstanceModel<M>, target: DeploymentNodeModel<M> | DeployedInstanceModel<M>, relations: RelationshipsAccum<M>);
    readonly id: M['EdgeId'];
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    get expression(): string;
    private _boundary;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    get boundary(): DeploymentNodeModel<M> | null;
    nonEmpty(): boolean;
    [customInspectSymbol](depth: any, inspectOptions: any, inspect: any): string;
    toString(): string;
    /**
     * Check if connection contains deployment relation,
     * that is directly connected to source or target.
     */
    hasDirectDeploymentRelation(): boolean;
    values(): IteratorLike<RelationshipModel<M> | DeploymentRelationModel<M>>;
    /**
     * Merge with another connections, if it has the same source and target.
     * Returns new connection with union of relationships.
     */
    mergeWith(others: DeploymentConnectionModel<M>[]): DeploymentConnectionModel<M>;
    /**
     * Merge with another connection, if it has the same source and target.
     * Returns new connection with union of relationships.
     */
    mergeWith(other: DeploymentConnectionModel<M>): DeploymentConnectionModel<M>;
    difference(other: DeploymentConnectionModel<M>): DeploymentConnectionModel<M>;
    intersect(other: DeploymentConnectionModel<M>): DeploymentConnectionModel<M>;
    equals(other: Connection): boolean;
    /**
     * Creates a clone of the current `DeploymentConnectionModel` instance with optional overrides.
     * if `null` is provided in overrides, the corresponding relation set will be empty.
     */
    update(overrides?: {
        model?: ReadonlySet<RelationshipModel<M>> | null;
        deployment?: ReadonlySet<DeploymentRelationModel<M>> | null;
    }): DeploymentConnectionModel<M>;
}

/**
 * Connection refers to any relationships between two elements,
 * both direct and implicit ones (between their nested elements).
 *
 * Merges relationships together to an single edge on the diagram.
 */
declare class ConnectionModel<M extends AnyAux = AnyAux> implements Connection<ElementModel<M>, M['EdgeId']> {
    readonly source: ElementModel<M>;
    readonly target: ElementModel<M>;
    readonly relations: ReadonlySet<RelationshipModel<M>>;
    readonly id: M['EdgeId'];
    constructor(source: ElementModel<M>, target: ElementModel<M>, relations?: ReadonlySet<RelationshipModel<M>>);
    private _boundary;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    get boundary(): ElementModel<M> | null;
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    get expression(): string;
    /**
     * Returns true if only includes relations between the source and target elements.
     */
    get isDirect(): boolean;
    /**
     * Returns true if includes relations between nested elements of the source and target elements.
     */
    get isImplicit(): boolean;
    get directRelations(): ReadonlySet<RelationshipModel<M>>;
    nonEmpty(): boolean;
    mergeWith(other: ConnectionModel<M>): ConnectionModel<M>;
    difference(other: ConnectionModel<M>): ConnectionModel<M>;
    intersect(other: ConnectionModel<M>): ConnectionModel<M>;
    equals(other: Connection): boolean;
    /**
     * Returns a new instance with the updated relations.
     *
     * @param relations - A readonly set of `RelationshipModel` instances representing the new relations.
     * @returns A new `ConnectionModel` instance with the updated relations.
     */
    update(relations: ReadonlySet<RelationshipModel<M>>): ConnectionModel<M>;
    [customInspectSymbol](depth: any, inspectOptions: any, inspect: any): string;
    toString(): string;
    /**
     * Creates a new connection with reversed direction (target becomes source and vice versa)
     * @param search - When true, attempts to find an existing connection between the reversed nodes
     */
    reversed(search?: boolean): ConnectionModel<M>;
}

export { Connection as C, DeploymentConnectionModel as D, ConnectionModel as a };
