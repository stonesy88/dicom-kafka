import { IsStringLiteral, LiteralUnion, Simplify, SetRequired } from 'type-fest';
import { F as Fqn, K as KeysOf, I as IteratorLike, d as IconUrl, T as Tag, e as ProjectId } from './core.SjLhMA7a.mjs';
import { a as ComputedView, L as LikeC4View, V as ParsedLikeC4ModelData, C as ComputedLikeC4ModelData, bk as ViewId, ai as RelationId, bf as NodeId, bc as EdgeId, Q as GenericLikeC4ModelData, S as LayoutedLikeC4ModelData, b5 as DiagramView, U as LikeC4ModelDump, E as ElementKind, f as DeploymentNodeKind, t as ElementShape, ap as Color, v as Link, u as ElementStyle, am as RelationshipLineType, aY as ComputedDynamicView, bh as StepEdgeId, a_ as ComputedElementView, aX as ComputedDeploymentView, ah as ModelRelation, O as AnyParsedLikeC4ModelData, N as ModelGlobals, h as DeploymentRef, e as DeploymentNode, c as DeployedInstance, d as DeploymentElementStyle, ay as ThemeColor, i as DeploymentRelation, ak as RelationshipKind, q as Element } from './core.DJvmfnEi.mjs';

type ComputeViewResult<V extends ComputedView = ComputedView> = {
    isSuccess: true;
    error?: undefined;
    view: V;
} | {
    isSuccess: false;
    error: Error;
    view: undefined;
};
declare function unsafeComputeView(viewsource: LikeC4View, likec4model: LikeC4Model): ComputedView;
declare function computeView<V extends LikeC4View>(viewsource: V, likec4model: LikeC4Model): ComputeViewResult;
declare function computeViews<P extends ParsedLikeC4ModelData>(parsed: P): ComputedLikeC4ModelData;

type IncomingFilter = 'all' | 'direct' | 'to-descendants';
type OutgoingFilter = 'all' | 'direct' | 'from-descendants';
type WithId<Id> = {
    id: Id;
};
type WithViews<Id extends string, ViewType> = {
    views: Record<Id, ViewType>;
};
type AnyAux = Aux<string, string, string, any>;
/**
 * Auxilary type to keep track
 */
interface Aux<Element extends string, Deployment extends string, View extends string, ViewType> {
    Element: Element;
    Deployment: Deployment;
    View: View;
    Fqn: IsStringLiteral<Element> extends true ? Fqn<Element> : Fqn;
    ElementOrFqn: Element | WithId<this['Fqn']>;
    DeploymentFqn: IsStringLiteral<Deployment> extends true ? Fqn<Deployment> : Fqn;
    DeploymentOrFqn: Deployment | WithId<this['DeploymentFqn']>;
    ViewId: IsStringLiteral<View> extends true ? ViewId<View> : ViewId;
    ViewType: ViewType;
    RelationId: RelationId;
    NodeId: NodeId;
    NodeIdLiteral: string;
    EdgeId: EdgeId;
    EdgeIdLiteral: string;
    NodeOrId: LiteralUnion<this['NodeIdLiteral'], string> | WithId<this['NodeId']>;
    EdgeOrId: LiteralUnion<this['EdgeIdLiteral'], string> | WithId<this['EdgeId']>;
    Model: Simplify<Omit<GenericLikeC4ModelData, 'views'> & WithViews<this['ViewId'], ViewType>>;
}
declare namespace Aux {
    type FromParsed<M> = M extends ParsedLikeC4ModelData ? Aux<KeysOf<M['elements']>, KeysOf<M['deployments']['elements']>, KeysOf<M['views']>, ComputedView<ViewId<KeysOf<M['views']>>, string>> : never;
    type FromModel<M> = M extends GenericLikeC4ModelData ? Aux<KeysOf<M['elements']>, KeysOf<M['deployments']['elements']>, KeysOf<M['views']>, M extends LayoutedLikeC4ModelData ? DiagramView<ViewId<KeysOf<M['views']>>, string> : ComputedView<ViewId<KeysOf<M['views']>>, string>> : never;
    type FromDump<M> = M extends LikeC4ModelDump ? Aux<KeysOf<M['elements']>, KeysOf<M['deployments']['elements']>, KeysOf<M['views']>, DiagramView<ViewId<KeysOf<M['views']>>, string>> : never;
}

type NodesIterator<M extends AnyAux, V extends ComputedView | DiagramView> = IteratorLike<NodeModel<M, V>>;
declare namespace NodeModel {
    interface WithParent<M extends AnyAux, V extends ComputedView | DiagramView> extends NodeModel<M, V> {
        parent: NodeModel<M, V>;
    }
    interface WithElement<M extends AnyAux, V extends ComputedView | DiagramView> extends NodeModel<M, V> {
        kind: ElementKind;
        element: ElementModel<M>;
    }
    interface WithDeploymentElement<M extends AnyAux, V extends ComputedView | DiagramView> extends NodeModel<M, V> {
        kind: DeploymentNodeKind;
        deployment: DeploymentElementModel<M>;
    }
    interface WithDeployedInstance<M extends AnyAux, V extends ComputedView | DiagramView> extends NodeModel<M, V> {
        kind: 'instance';
        element: ElementModel<M>;
        deployment: DeployedInstanceModel<M>;
    }
    interface IsGroup<M extends AnyAux, V extends ComputedView | DiagramView> extends NodeModel<M, V> {
        kind: typeof ElementKind.Group;
        element: null;
        deployment: null;
    }
}
declare class NodeModel<M extends AnyAux, V extends ComputedView | DiagramView = M['ViewType']> {
    readonly $view: LikeC4ViewModel<M, V>;
    readonly $node: V['nodes'][number];
    constructor($view: LikeC4ViewModel<M, V>, $node: V['nodes'][number]);
    get id(): NodeId;
    get title(): string;
    get kind(): ElementKind | DeploymentNodeKind | typeof ElementKind.Group | 'instance';
    get description(): string | null;
    get technology(): string | null;
    get parent(): NodeModel<M, V> | null;
    get element(): ElementModel<M> | null;
    get deployment(): DeploymentElementModel<M> | null;
    get shape(): ElementShape;
    get color(): Color;
    get icon(): IconUrl | null;
    get tags(): ReadonlyArray<Tag>;
    get links(): ReadonlyArray<Link>;
    get navigateTo(): LikeC4ViewModel<M> | null;
    get style(): ElementStyle;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(): NodesIterator<M, V>;
    children(): NodesIterator<M, V>;
    sublings(): NodesIterator<M, V>;
    incoming(filter?: IncomingFilter): EdgesIterator<M, V>;
    incomers(filter?: IncomingFilter): NodesIterator<M, V>;
    outgoing(filter?: OutgoingFilter): EdgesIterator<M, V>;
    outgoers(filter?: OutgoingFilter): NodesIterator<M, V>;
    isDiagramNode(): this is NodeModel<M, DiagramView>;
    hasChildren(): boolean;
    hasParent(): this is NodeModel.WithParent<M, V>;
    /**
     * Check if this node references to logical model element.
     */
    hasElement(): this is NodeModel.WithElement<M, V>;
    /**
     * Check if this node references to deployment element (Node or Instance).
     */
    hasDeployment(): this is NodeModel.WithDeploymentElement<M, V>;
    /**
     * Check if this node references to deployed instance
     * Deployed instance always references to element and deployment element.
     */
    hasDeployedInstance(): this is NodeModel.WithDeployedInstance<M, V>;
    isGroup(): this is NodeModel.IsGroup<M, V>;
}

type EdgesIterator<M extends AnyAux, V extends ComputedView | DiagramView> = IteratorLike<EdgeModel<M, V>>;
declare class EdgeModel<M extends AnyAux, V extends ComputedView | DiagramView = M['ViewType']> {
    readonly view: LikeC4ViewModel<M, V>;
    readonly $edge: V['edges'][number];
    readonly source: NodeModel<M, V>;
    readonly target: NodeModel<M, V>;
    constructor(view: LikeC4ViewModel<M, V>, $edge: V['edges'][number], source: NodeModel<M, V>, target: NodeModel<M, V>);
    get id(): M['EdgeId'];
    get parent(): NodeModel<M, V> | null;
    get label(): string | null;
    get description(): string | null;
    get technology(): string | null;
    hasParent(): this is EdgeModel.WithParent<M, V>;
    get tags(): ReadonlyArray<Tag>;
    get stepNumber(): number | null;
    get navigateTo(): LikeC4ViewModel<M> | null;
    get color(): Color;
    get line(): RelationshipLineType;
    isStep(): this is EdgeModel.StepEdge<M, ComputedDynamicView>;
    relationships(type: 'model'): IteratorLike<RelationshipModel<M>>;
    relationships(type: 'deployment'): IteratorLike<DeploymentRelationModel<M>>;
    relationships(type?: 'model' | 'deployment'): IteratorLike<LikeC4Model.AnyRelation<M>>;
    includesRelation(rel: M['RelationId']): boolean;
}
declare namespace EdgeModel {
    interface StepEdge<M extends AnyAux, V extends ComputedView | DiagramView> extends EdgeModel<M, V> {
        id: StepEdgeId;
        stepNumber: number;
    }
    interface WithParent<M extends AnyAux, V extends ComputedView | DiagramView> extends EdgeModel<M, V> {
        parent: NodeModel<M, V>;
    }
}

type ViewsIterator<M extends AnyAux> = IteratorLike<LikeC4ViewModel<M>>;
declare class LikeC4ViewModel<M extends AnyAux, V extends ComputedView | DiagramView = M['ViewType']> {
    #private;
    readonly $model: LikeC4Model<M>;
    readonly $view: V;
    constructor($model: LikeC4Model<M>, $view: V);
    get __(): NonNullable<M['ViewType']['__']>;
    get id(): M['ViewId'];
    get title(): string | null;
    get tags(): ReadonlyArray<Tag>;
    get links(): ReadonlyArray<Link>;
    get viewOf(): ElementModel<M> | null;
    /**
     * All tags from nodes and edges.
     */
    get includedTags(): ReadonlyArray<Tag>;
    roots(): NodesIterator<M, V>;
    /**
     * Iterate over all nodes that have children.
     */
    compounds(): NodesIterator<M, V>;
    /**
     * Get node by id.
     * @throws Error if node is not found.
     */
    node(node: M['NodeOrId']): NodeModel<M, V>;
    /**
     * Find node by id.
     */
    findNode(node: M['NodeOrId']): NodeModel<M, V> | null;
    findNodeWithElement(fqn: M['Element']): NodeModel.WithElement<M, V> | null;
    /**
     * Iterate over all nodes.
     */
    nodes(): NodesIterator<M, V>;
    /**
     * Find edge by id.
     * @param edge Edge or id
     * @returns EdgeModel
     */
    edge(edge: M['EdgeOrId']): EdgeModel<M, V>;
    findEdge(edge: M['EdgeOrId']): EdgeModel<M, V> | null;
    /**
     * Iterate over all edges.
     */
    edges(): EdgesIterator<M, V>;
    /**
     * Iterate over all edges.
     */
    edgesWithRelation(relation: M['RelationId']): EdgesIterator<M, V>;
    /**
     * Nodes that have references to elements from logical model.
     */
    elements(): IteratorLike<NodeModel.WithElement<M, V>>;
    includesElement(elementId: M['Element']): boolean;
    includesDeployment(deploymentId: M['Deployment']): boolean;
    includesRelation(relationId: M['RelationId']): boolean;
    /**
     * Below are type guards.
     */
    isComputed(): this is LikeC4ViewModel<M, ComputedView>;
    isDiagram(): this is LikeC4ViewModel<M, DiagramView>;
    isElementView(): this is LikeC4ViewModel<M, ComputedElementView>;
    isDeploymentView(): this is LikeC4ViewModel<M, ComputedDeploymentView>;
    isDynamicView(): this is LikeC4ViewModel<M, ComputedDynamicView>;
}

type RelationshipsIterator<M extends AnyAux> = IteratorLike<RelationshipModel<M>>;
declare class RelationshipModel<M extends AnyAux = AnyAux> {
    readonly model: LikeC4Model<M>;
    readonly $relationship: ModelRelation;
    readonly source: ElementModel<M>;
    readonly target: ElementModel<M>;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the Relation.
     */
    readonly boundary: ElementModel<M> | null;
    constructor(model: LikeC4Model<M>, $relationship: ModelRelation);
    get id(): M['RelationId'];
    get expression(): string;
    get title(): string | null;
    get technology(): string | null;
    get description(): string | null;
    get navigateTo(): LikeC4ViewModel<M> | null;
    get tags(): ReadonlyArray<Tag>;
    get kind(): string | null;
    get links(): ReadonlyArray<Link>;
    get color(): Color;
    get line(): RelationshipLineType;
    /**
     * Iterate over all views that include this relationship.
     */
    views(): ViewsIterator<M>;
    isDeploymentRelation(): this is DeploymentRelationModel<M>;
}

declare class LikeC4Model<M extends AnyAux = LikeC4Model.Any> {
    #private;
    readonly $model: M['Model'];
    /**
     * Don't use in runtime, only for type inference
     */
    readonly Aux: M;
    readonly deployment: LikeC4DeploymentModel<M>;
    /**
     * Computes views from the parsed model
     * Creates a new LikeC4Model instance from a parsed model.
     *
     * May throw an error if the model is invalid.
     *
     * @typeParam M - The type of the parsed LikeC4 model, must extend ParsedLikeC4Model
     * @param parsed - The parsed LikeC4 model to compute from
     * @returns A new LikeC4Model instance with computed relationships and structure
     */
    static compute<const M extends AnyParsedLikeC4ModelData>(parsed: M): LikeC4Model<Aux.FromParsed<M>>;
    /**
     * Creates a function that computes a view using the data from the model.
     *
     * @example
     * const compute = LikeC4Model.makeCompute(parsedModel);
     * const result = compute(viewSource);
     */
    static makeCompute<M extends AnyParsedLikeC4ModelData>(parsed: M): (viewsource: LikeC4View) => ComputeViewResult;
    /**
     * Creates a new LikeC4Model instance from the provided model data.
     *
     * @typeParam M - Type parameter constrained to AnyLikeC4Model
     * @param model - The model data to create a LikeC4Model from
     * @returns A new LikeC4Model instance with the type derived from the input model
     */
    static create<const M extends GenericLikeC4ModelData>(model: M): LikeC4Model<Aux.FromModel<M>>;
    /**
     * Creates a new LikeC4Model instance from a model dump.
     *
     * @typeParam M - A constant type parameter extending LikeC4ModelDump
     * @param dump - The model dump to create the instance from
     * @returns A new LikeC4Model instance with types inferred from the dump
     */
    static fromDump<const M extends LikeC4ModelDump>(dump: M): LikeC4Model<Aux.FromDump<M>>;
    private constructor();
    get type(): 'computed' | 'layouted';
    element(el: M['ElementOrFqn']): ElementModel<M>;
    findElement(el: LiteralUnion<M['Element'], string>): ElementModel<M> | null;
    /**
     * Returns the root elements of the model.
     */
    roots(): ElementsIterator<M>;
    /**
     * Returns all elements in the model.
     */
    elements(): ElementsIterator<M>;
    /**
     * Returns all relationships in the model.
     */
    relationships(): RelationshipsIterator<M>;
    /**
     * Returns a specific relationship by its ID.
     * If the relationship is not found in the model, it will be searched in the deployment model.
     * Search can be limited to the model or deployment model only.
     */
    relationship(id: M['RelationId'], type: 'model'): RelationshipModel<M>;
    relationship(id: M['RelationId'], type: 'deployment'): DeploymentRelationModel<M>;
    relationship(id: M['RelationId'], type?: 'model' | 'deployment'): RelationshipModel<M> | DeploymentRelationModel<M>;
    findRelationship(id: LiteralUnion<M['RelationId'], string>, type: 'model'): RelationshipModel<M> | null;
    findRelationship(id: LiteralUnion<M['RelationId'], string>, type: 'deployment'): DeploymentRelationModel<M> | null;
    findRelationship(id: LiteralUnion<M['RelationId'], string>, type?: 'model' | 'deployment'): RelationshipModel<M> | DeploymentRelationModel<M> | null;
    /**
     * Returns all views in the model.
     */
    views(): IteratorLike<LikeC4ViewModel<M>>;
    /**
     * Returns a specific view by its ID.
     */
    view(viewId: M['View']): LikeC4ViewModel<M>;
    findView(viewId: M['View']): LikeC4ViewModel<M> | null;
    /**
     * Returns the parent element of given element.
     * @see ancestors
     */
    parent(element: M['ElementOrFqn']): ElementModel<M> | null;
    /**
     * Get all children of the element (only direct children),
     * @see descendants
     */
    children(element: M['ElementOrFqn']): ReadonlySet<ElementModel<M>>;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(element: M['ElementOrFqn']): ElementsIterator<M>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(element: M['ElementOrFqn']): ElementsIterator<M>;
    /**
     * Get all descendant elements (i.e. children, children’s children, etc.)
     */
    descendants(element: M['ElementOrFqn']): ElementsIterator<M>;
    /**
     * Incoming relationships to the element and its descendants
     * @see incomers
     */
    incoming(element: M['ElementOrFqn'], filter?: IncomingFilter): RelationshipsIterator<M>;
    /**
     * Outgoing relationships from the element and its descendants
     * @see outgoers
     */
    outgoing(element: M['ElementOrFqn'], filter?: OutgoingFilter): RelationshipsIterator<M>;
    globals(): ModelGlobals;
    allTags(): ReadonlyArray<Tag>;
    private addElement;
    private addImportedElement;
    private addRelation;
}
declare namespace LikeC4Model {
    const EMPTY: LikeC4Model<AnyAux>;
    type Any = Aux<string, string, string, ComputedView | DiagramView>;
    type Element<M extends AnyAux = Any> = ElementModel<M>;
    type Relation<M extends AnyAux = Any> = RelationshipModel<M>;
    type AnyRelation<M extends AnyAux = Any> = RelationshipModel<M> | DeploymentRelationModel<M>;
    type View<M extends AnyAux = Any, V extends ComputedView | DiagramView = M['ViewType']> = LikeC4ViewModel<M, V>;
    type Node<M extends AnyAux = Any, V extends ComputedView | DiagramView = M['ViewType']> = NodeModel<M, V>;
    type Edge<M extends AnyAux = Any, V extends ComputedView | DiagramView = M['ViewType']> = EdgeModel<M, V>;
    type DeploymentModel<M extends AnyAux = AnyAux> = LikeC4DeploymentModel<M>;
    type Deployment<M extends AnyAux = AnyAux> = DeploymentElementModel<M>;
    type DeploymentNode<M extends AnyAux = AnyAux> = DeploymentNodeModel<M>;
    type DeployedInstance<M extends AnyAux = AnyAux> = DeployedInstanceModel<M>;
    type Typed<Elements extends string = string, Deployments extends string = string, Views extends string = string, ViewType = DiagramView<Views> | ComputedView<Views>> = Aux<Elements, Deployments, Views, ViewType>;
    type Computed<Elements extends string = string, Deployments extends string = string, Views extends string = string> = LikeC4Model<Typed<Elements, Deployments, Views, ComputedView<Views>>>;
    type Layouted<Elements extends string = string, Deployments extends string = string, Views extends string = string> = LikeC4Model<Typed<Elements, Deployments, Views, DiagramView<Views>>>;
}

declare class LikeC4DeploymentModel<M extends AnyAux = AnyAux> {
    #private;
    readonly $model: LikeC4Model<M>;
    readonly $deployments: GenericLikeC4ModelData['deployments'];
    constructor($model: LikeC4Model<M>, $deployments: GenericLikeC4ModelData['deployments']);
    element(el: M['DeploymentOrFqn']): DeploymentElementModel<M>;
    findElement(el: M['Deployment']): DeploymentElementModel<M> | null;
    node(el: M['DeploymentOrFqn']): DeploymentNodeModel<M>;
    findNode(el: M['Deployment']): DeploymentNodeModel<M> | null;
    instance(el: M['DeploymentOrFqn']): DeployedInstanceModel<M>;
    findInstance(el: M['Deployment']): DeployedInstanceModel<M> | null;
    /**
     * Returns the root elements of the model.
     */
    roots(): DeploymentNodesIterator<M>;
    /**
     * Returns all elements in the model.
     */
    elements(): DeploymentElementsIterator<M>;
    /**
     * Returns all elements in the model.
     */
    nodes(): DeploymentNodesIterator<M>;
    instances(): DeployedInstancesIterator<M>;
    /**
     * Iterate over all instances of the given logical element.
     */
    instancesOf(element: M['ElementOrFqn']): DeployedInstancesIterator<M>;
    deploymentRef(ref: DeploymentRef): DeploymentElementModel<M> | NestedElementOfDeployedInstanceModel<M>;
    /**
     * Returns all relationships in the model.
     */
    relationships(): IteratorLike<DeploymentRelationModel<M>>;
    /**
     * Returns a specific relationship by its ID.
     */
    relationship(id: M['RelationId']): DeploymentRelationModel<M>;
    findRelationship(id: LiteralUnion<M['RelationId'], string>): DeploymentRelationModel<M> | null;
    /**
     * Returns all deployment views in the model.
     */
    views(): IteratorLike<LikeC4ViewModel<M, ComputedDeploymentView>>;
    /**
     * Returns the parent element of given element.
     * @see ancestors
     */
    parent(element: M['DeploymentOrFqn']): DeploymentNodeModel<M> | null;
    /**
     * Get all children of the element (only direct children),
     * @see descendants
     */
    children(element: M['DeploymentOrFqn']): ReadonlySet<DeploymentElementModel<M>>;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(element: M['DeploymentOrFqn']): DeploymentElementsIterator<M>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(element: M['DeploymentOrFqn']): DeploymentNodesIterator<M>;
    /**
     * Get all descendant elements (i.e. children, children’s children, etc.)
     */
    descendants(element: M['DeploymentOrFqn'], sort?: 'asc' | 'desc'): DeploymentElementsIterator<M>;
    /**
     * Incoming relationships to the element and its descendants
     * @see incomers
     */
    incoming(element: M['DeploymentOrFqn'], filter?: IncomingFilter): IteratorLike<DeploymentRelationModel<M>>;
    /**
     * Outgoing relationships from the element and its descendants
     * @see outgoers
     */
    outgoing(element: M['DeploymentOrFqn'], filter?: OutgoingFilter): IteratorLike<DeploymentRelationModel<M>>;
    private addElement;
    private addRelation;
}

type DeploymentElementsIterator<M extends AnyAux> = IteratorLike<DeploymentNodeModel<M> | DeployedInstanceModel<M>>;
type DeployedInstancesIterator<M extends AnyAux> = IteratorLike<DeployedInstanceModel<M>>;
type DeploymentNodesIterator<M extends AnyAux> = IteratorLike<DeploymentNodeModel<M>>;
type DeploymentElementModel<M extends AnyAux = AnyAux> = DeploymentNodeModel<M> | DeployedInstanceModel<M>;
declare abstract class AbstractDeploymentElementModel<M extends AnyAux = AnyAux> {
    abstract readonly id: M['DeploymentFqn'];
    abstract readonly parent: DeploymentNodeModel<M> | null;
    abstract readonly title: string;
    abstract readonly hierarchyLevel: number;
    abstract readonly $model: LikeC4DeploymentModel<M>;
    abstract readonly $node: DeploymentNode | DeployedInstance;
    abstract readonly kind: DeploymentNodeKind | ElementKind;
    get style(): SetRequired<DeploymentElementStyle, 'shape' | 'color' | 'size'>;
    get shape(): ElementShape;
    get color(): ThemeColor;
    get tags(): ReadonlyArray<Tag>;
    get description(): string | null;
    get technology(): string | null;
    get links(): ReadonlyArray<Link>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(): DeploymentNodesIterator<M>;
    /**
     * Returns the common ancestor of this element and another element.
     */
    commonAncestor(another: DeploymentElementModel<M>): DeploymentNodeModel<M> | null;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(): DeploymentElementsIterator<M>;
    /**
     * Check if the element is a sibling of another element
     */
    isSibling(other: DeploymentElementModel<M>): boolean;
    /**
     * Resolve siblings of the element and its ancestors
     *  (from closest to root)
     */
    ascendingSiblings(): DeploymentElementsIterator<M>;
    /**
     * Resolve siblings of the element and its ancestors
     *  (from root to closest)
     */
    descendingSiblings(): DeploymentElementsIterator<M>;
    incoming(filter?: IncomingFilter): IteratorLike<DeploymentRelationModel<M>>;
    outgoing(filter?: OutgoingFilter): IteratorLike<DeploymentRelationModel<M>>;
    incomers(filter?: IncomingFilter): IteratorLike<DeploymentRelationEndpoint<M>>;
    outgoers(filter?: OutgoingFilter): IteratorLike<DeploymentRelationEndpoint<M>>;
    /**
     * Iterate over all views that include this deployment element.
     */
    views(): IteratorLike<LikeC4ViewModel<M, ComputedDeploymentView>>;
    isDeploymentNode(): this is DeploymentNodeModel<M>;
    isInstance(): this is DeployedInstanceModel<M>;
    abstract outgoingModelRelationships(): RelationshipsIterator<M>;
    abstract incomingModelRelationships(): RelationshipsIterator<M>;
    protected cachedOutgoing: RelationshipsAccum<M> | null;
    protected cachedIncoming: RelationshipsAccum<M> | null;
    get allOutgoing(): RelationshipsAccum<M>;
    get allIncoming(): RelationshipsAccum<M>;
}
declare class DeploymentNodeModel<M extends AnyAux = AnyAux> extends AbstractDeploymentElementModel<M> {
    readonly $model: LikeC4DeploymentModel<M>;
    readonly $node: DeploymentNode;
    id: M['DeploymentFqn'];
    title: string;
    hierarchyLevel: number;
    constructor($model: LikeC4DeploymentModel<M>, $node: DeploymentNode);
    get parent(): DeploymentNodeModel<M> | null;
    get kind(): DeploymentNodeKind;
    children(): ReadonlySet<DeploymentElementModel<M>>;
    descendants(sort?: 'asc' | 'desc'): DeploymentElementsIterator<M>;
    isDeploymentNode(): this is DeploymentNodeModel<M>;
    /**
     * Iterate over all instances nested in this deployment node.
     */
    instances(): DeployedInstancesIterator<M>;
    /**
     * Returns deployed instance inside this deployment node
     * if only there are no more instances
     */
    onlyOneInstance(): DeployedInstanceModel<M> | null;
    /**
     * Cached result of relationships from instances
     */
    private _relationshipsFromInstances;
    private relationshipsFromInstances;
    /**
     * We return only relationships that are not already present in nested instances
     */
    outgoingModelRelationships(): RelationshipsIterator<M>;
    /**
     * We return only relationships that are not already present in nested instances
     */
    incomingModelRelationships(): RelationshipsIterator<M>;
    /**
     * Returns an iterator of relationships between nested instances
     */
    internalModelRelationships(): ReadonlySet<RelationshipModel<M>>;
}
declare class DeployedInstanceModel<M extends AnyAux = AnyAux> extends AbstractDeploymentElementModel<M> {
    readonly $model: LikeC4DeploymentModel<M>;
    readonly $instance: DeployedInstance;
    readonly element: ElementModel<M>;
    readonly id: M['DeploymentFqn'];
    readonly title: string;
    readonly hierarchyLevel: number;
    constructor($model: LikeC4DeploymentModel<M>, $instance: DeployedInstance, element: ElementModel<M>);
    get $node(): DeployedInstance;
    get parent(): DeploymentNodeModel<M>;
    get style(): SetRequired<DeploymentElementStyle, 'shape' | 'color' | 'size'>;
    get shape(): ElementShape;
    get color(): ThemeColor;
    get tags(): ReadonlyArray<Tag>;
    get kind(): ElementKind;
    get description(): string | null;
    get technology(): string | null;
    get links(): ReadonlyArray<Link>;
    isInstance(): this is DeployedInstanceModel<M>;
    outgoingModelRelationships(): RelationshipsIterator<M>;
    incomingModelRelationships(): RelationshipsIterator<M>;
    /**
     * Iterate over all views that include this instance.
     * (Some views may include the parent deployment node instead of the instance.)
     */
    views(): IteratorLike<LikeC4ViewModel<M, ComputedDeploymentView>>;
}
declare class NestedElementOfDeployedInstanceModel<M extends AnyAux> {
    readonly instance: DeployedInstanceModel<M>;
    readonly element: ElementModel<M>;
    constructor(instance: DeployedInstanceModel<M>, element: ElementModel<M>);
    get id(): M['DeploymentFqn'];
    get style(): SetRequired<DeploymentElementStyle, 'shape' | 'color'>;
    get shape(): ElementShape;
    get color(): ThemeColor;
    get title(): string;
    get description(): string | null;
    get technology(): string | null;
    isDeploymentNode(): this is DeploymentNodeModel<M>;
    isInstance(): this is DeployedInstanceModel<M>;
}
type DeploymentRelationEndpoint<M extends AnyAux> = DeploymentElementModel<M> | NestedElementOfDeployedInstanceModel<M>;
declare class DeploymentRelationModel<M extends AnyAux = AnyAux> {
    readonly $model: LikeC4DeploymentModel<M>;
    readonly $relationship: DeploymentRelation;
    boundary: DeploymentNodeModel<M> | null;
    source: DeploymentRelationEndpoint<M>;
    target: DeploymentRelationEndpoint<M>;
    constructor($model: LikeC4DeploymentModel<M>, $relationship: DeploymentRelation);
    get id(): M['RelationId'];
    get expression(): string;
    get title(): string | null;
    get technology(): string | null;
    get description(): string | null;
    get tags(): ReadonlyArray<Tag>;
    get kind(): RelationshipKind | null;
    get navigateTo(): LikeC4ViewModel<M> | null;
    get links(): ReadonlyArray<Link>;
    get color(): Color;
    get line(): RelationshipLineType;
    views(): IteratorLike<LikeC4ViewModel<M, ComputedDeploymentView>>;
    isDeploymentRelation(): this is DeploymentRelationModel<M>;
}
declare class RelationshipsAccum<M extends AnyAux> {
    readonly model: ReadonlySet<RelationshipModel<M>>;
    readonly deployment: ReadonlySet<DeploymentRelationModel<M>>;
    static empty<M extends AnyAux>(): RelationshipsAccum<M>;
    static from<M extends AnyAux>(model: Iterable<RelationshipModel<M>> | undefined, deployment?: Iterable<DeploymentRelationModel<M>>): RelationshipsAccum<M>;
    /**
     * @param model relationships from logical model
     * @param deployment relationships from deployment model
     */
    constructor(model?: ReadonlySet<RelationshipModel<M>>, deployment?: ReadonlySet<DeploymentRelationModel<M>>);
    get isEmpty(): boolean;
    get nonEmpty(): boolean;
    get size(): number;
    /**
     * Returns new Accum containing all the elements which are both in this and otherAccum
     */
    intersect(otherAccum: RelationshipsAccum<M>): RelationshipsAccum<M>;
    /**
     * Returns new Accum containing all the elements which are both in this and otherAccum
     */
    difference(otherAccum: RelationshipsAccum<M>): RelationshipsAccum<M>;
    /**
     * Returns new Accum containing all the elements from both
     */
    union(otherAccum: RelationshipsAccum<M>): RelationshipsAccum<M>;
}

type ElementsIterator<M extends AnyAux> = IteratorLike<ElementModel<M>>;
declare class ElementModel<M extends AnyAux = AnyAux> {
    readonly $model: LikeC4Model<M>;
    readonly $element: Element;
    readonly id: M['Fqn'];
    readonly _literalId: M['Element'];
    readonly hierarchyLevel: number;
    readonly imported: null | {
        from: ProjectId;
        fqn: string;
    };
    constructor($model: LikeC4Model<M>, $element: Element);
    get parent(): ElementModel<M> | null;
    get kind(): ElementKind;
    get shape(): ElementShape;
    get color(): ThemeColor;
    get icon(): IconUrl | null;
    get tags(): ReadonlyArray<Tag>;
    get title(): string;
    get description(): string | null;
    get technology(): string | null;
    get links(): ReadonlyArray<Link>;
    get defaultView(): LikeC4ViewModel<M> | null;
    get isRoot(): boolean;
    get style(): SetRequired<ElementStyle, 'size'>;
    isAncestorOf(another: ElementModel<M>): boolean;
    isDescendantOf(another: ElementModel<M>): boolean;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(): ElementsIterator<M>;
    /**
     * Returns the common ancestor of this element and another element.
     */
    commonAncestor(another: ElementModel<M>): ElementModel<M> | null;
    children(): ReadonlySet<ElementModel<M>>;
    /**
     * Get all descendant elements (i.e. children, children’s children, etc.)
     */
    descendants(sort?: 'asc' | 'desc'): ElementsIterator<M>;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(): ElementsIterator<M>;
    /**
     * Resolve siblings of the element and its ancestors
     *  (from closest to root)
     */
    ascendingSiblings(): ElementsIterator<M>;
    /**
     * Resolve siblings of the element and its ancestors
     *  (from root to closest)
     */
    descendingSiblings(): ElementsIterator<M>;
    incoming(filter?: IncomingFilter): RelationshipsIterator<M>;
    incomers(filter?: IncomingFilter): ElementsIterator<M>;
    outgoing(filter?: OutgoingFilter): RelationshipsIterator<M>;
    outgoers(filter?: OutgoingFilter): ElementsIterator<M>;
    protected cachedOutgoing: Set<RelationshipModel<M>> | null;
    protected cachedIncoming: Set<RelationshipModel<M>> | null;
    get allOutgoing(): ReadonlySet<RelationshipModel<M>>;
    get allIncoming(): ReadonlySet<RelationshipModel<M>>;
    /**
     * Iterate over all views that include this element.
     */
    views(): ViewsIterator<M>;
    /**
     * Iterate over all views that scope this element.
     * It is possible that element is not included in the view.
     */
    scopedViews(): ViewsIterator<M>;
    /**
     * @returns true if the element is deployed
     */
    isDeployed(): boolean;
    deployments(): DeployedInstancesIterator<M>;
}

export { type AnyAux as A, type ComputeViewResult as C, DeployedInstanceModel as D, ElementModel as E, LikeC4Model as L, NodeModel as N, RelationshipModel as R, computeViews as a, Aux as b, computeView as c, type DeploymentElementModel as d, DeploymentNodeModel as e, DeploymentRelationModel as f, EdgeModel as g, LikeC4DeploymentModel as h, LikeC4ViewModel as i, RelationshipsAccum as j, unsafeComputeView as u };
