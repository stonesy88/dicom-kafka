import { i as invariant } from './core.C-YXI-43.mjs';

var e={done:true,hasNext:false},s={done:false,hasNext:false},a=()=>e;

function C(t,...o){let n=t,u=o.map(e=>"lazy"in e?y(e):void 0),p=0;for(;p<o.length;){if(u[p]===void 0||!B(n)){let i=o[p];n=i(n),p+=1;continue}let r=[];for(let i=p;i<o.length;i++){let l=u[i];if(l===void 0||(r.push(l),l.isSingle))break}let a=[];for(let i of n)if(f(i,a,r))break;let{isSingle:s}=r.at(-1);n=s?a[0]:a,p+=r.length;}return n}function f(t,o,n){if(n.length===0)return o.push(t),false;let u=t,p=s,e=false;for(let[r,a]of n.entries()){let{index:s,items:i}=a;if(i.push(u),p=a(u,s,i),a.index+=1,p.hasNext){if(p.hasMany??false){for(let l of p.next)if(f(l,o,n.slice(r+1)))return  true;return e}u=p.next;}if(!p.hasNext)break;p.done&&(e=true);}return p.hasNext&&o.push(u),e}function y(t){let{lazy:o,lazyArgs:n}=t,u=o(...n);return Object.assign(u,{isSingle:o.single??false,index:0,items:[]})}function B(t){return typeof t=="string"||typeof t=="object"&&t!==null&&Symbol.iterator in t}

function t$1(r){return typeof r=="string"}

function t(n){return typeof n=="function"}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

/**
 * Mnemonist DefaultMap
 * =====================
 *
 * JavaScript implementation of a default map that will return a constructed
 * value any time one tries to access an inexisting key. It's quite similar
 * to python's defaultdict.
 */

var defaultMap;
var hasRequiredDefaultMap;

function requireDefaultMap () {
	if (hasRequiredDefaultMap) return defaultMap;
	hasRequiredDefaultMap = 1;
	/**
	 * DefaultMap.
	 *
	 * @constructor
	 */
	function DefaultMap(factory) {
	  if (typeof factory !== 'function')
	    throw new Error('mnemonist/DefaultMap.constructor: expecting a function.');

	  this.items = new Map();
	  this.factory = factory;
	  this.size = 0;
	}

	/**
	 * Method used to clear the structure.
	 *
	 * @return {undefined}
	 */
	DefaultMap.prototype.clear = function() {

	  // Properties
	  this.items.clear();
	  this.size = 0;
	};

	/**
	 * Method used to get the value set for given key. If the key does not exist,
	 * the value will be created using the provided factory.
	 *
	 * @param  {any} key - Target key.
	 * @return {any}
	 */
	DefaultMap.prototype.get = function(key) {
	  var value = this.items.get(key);

	  if (typeof value === 'undefined') {
	    value = this.factory(key, this.size);
	    this.items.set(key, value);
	    this.size++;
	  }

	  return value;
	};

	/**
	 * Method used to get the value set for given key. If the key does not exist,
	 * a value won't be created.
	 *
	 * @param  {any} key - Target key.
	 * @return {any}
	 */
	DefaultMap.prototype.peek = function(key) {
	  return this.items.get(key);
	};

	/**
	 * Method used to set a value for given key.
	 *
	 * @param  {any} key   - Target key.
	 * @param  {any} value - Value.
	 * @return {DefaultMap}
	 */
	DefaultMap.prototype.set = function(key, value) {
	  this.items.set(key, value);
	  this.size = this.items.size;

	  return this;
	};

	/**
	 * Method used to test the existence of a key in the map.
	 *
	 * @param  {any} key   - Target key.
	 * @return {boolean}
	 */
	DefaultMap.prototype.has = function(key) {
	  return this.items.has(key);
	};

	/**
	 * Method used to delete target key.
	 *
	 * @param  {any} key   - Target key.
	 * @return {boolean}
	 */
	DefaultMap.prototype.delete = function(key) {
	  var deleted = this.items.delete(key);

	  this.size = this.items.size;

	  return deleted;
	};

	/**
	 * Method used to iterate over each of the key/value pairs.
	 *
	 * @param  {function}  callback - Function to call for each item.
	 * @param  {object}    scope    - Optional scope.
	 * @return {undefined}
	 */
	DefaultMap.prototype.forEach = function(callback, scope) {
	  scope = arguments.length > 1 ? scope : this;

	  this.items.forEach(callback, scope);
	};

	/**
	 * Iterators.
	 */
	DefaultMap.prototype.entries = function() {
	  return this.items.entries();
	};

	DefaultMap.prototype.keys = function() {
	  return this.items.keys();
	};

	DefaultMap.prototype.values = function() {
	  return this.items.values();
	};

	/**
	 * Attaching the #.entries method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined')
	  DefaultMap.prototype[Symbol.iterator] = DefaultMap.prototype.entries;

	/**
	 * Convenience known methods.
	 */
	DefaultMap.prototype.inspect = function() {
	  return this.items;
	};

	if (typeof Symbol !== 'undefined')
	  DefaultMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = DefaultMap.prototype.inspect;

	/**
	 * Typical factories.
	 */
	DefaultMap.autoIncrement = function() {
	  var i = 0;

	  return function() {
	    return i++;
	  };
	};

	/**
	 * Exporting.
	 */
	defaultMap = DefaultMap;
	return defaultMap;
}

var defaultMapExports = /*@__PURE__*/ requireDefaultMap();
const DefaultMap = /*@__PURE__*/getDefaultExportFromCjs(defaultMapExports);

var naturalCompareLite = {exports: {}};

var hasRequiredNaturalCompareLite;

function requireNaturalCompareLite () {
	if (hasRequiredNaturalCompareLite) return naturalCompareLite.exports;
	hasRequiredNaturalCompareLite = 1;
	/*
	 * @version    1.4.0
	 * @date       2015-10-26
	 * @stability  3 - Stable
	 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
	 * @license    MIT License
	 */


	var naturalCompare = function(a, b) {
		var i, codeA
		, codeB = 1
		, posA = 0
		, posB = 0
		, alphabet = String.alphabet;

		function getCode(str, pos, code) {
			if (code) {
				for (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;
				return +str.slice(pos - 1, i)
			}
			code = alphabet && alphabet.indexOf(str.charAt(pos));
			return code > -1 ? code + 76 : ((code = str.charCodeAt(pos) || 0), code < 45 || code > 127) ? code
				: code < 46 ? 65               // -
				: code < 48 ? code - 1
				: code < 58 ? code + 18        // 0-9
				: code < 65 ? code - 11
				: code < 91 ? code + 11        // A-Z
				: code < 97 ? code - 37
				: code < 123 ? code + 5        // a-z
				: code - 63
		}


		if ((a+="") != (b+="")) for (;codeB;) {
			codeA = getCode(a, posA++);
			codeB = getCode(b, posB++);

			if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
				codeA = getCode(a, posA, posA);
				codeB = getCode(b, posB, posA = i);
				posB = i;
			}

			if (codeA != codeB) return (codeA < codeB) ? -1 : 1
		}
		return 0
	};

	try {
		naturalCompareLite.exports = naturalCompare;
	} catch (e) {
		String.naturalCompare = naturalCompare;
	}
	return naturalCompareLite.exports;
}

var naturalCompareLiteExports = requireNaturalCompareLite();
const compare = /*@__PURE__*/getDefaultExportFromCjs(naturalCompareLiteExports);

function compareNatural(a, b) {
  if (a === b) return 0;
  if (t$1(a)) {
    if (t$1(b)) {
      return compare(a, b);
    }
    return 1;
  }
  return t$1(b) ? -1 : 0;
}

function isString(value) {
  return value != null && typeof value === "string";
}
function isNonEmptyArray(arr) {
  return !!arr && Array.isArray(arr) && arr.length > 0;
}

function parentFqn(fqn) {
  const lastDot = fqn.lastIndexOf(".");
  if (lastDot > 0) {
    return fqn.slice(0, lastDot);
  }
  return null;
}
function nameFromFqn(fqn) {
  const lastDot = fqn.lastIndexOf(".");
  if (lastDot > 0) {
    return fqn.slice(lastDot + 1);
  } else {
    return fqn;
  }
}
const asString = (e) => isString(e) ? e : e.id;
function isAncestor(arg1, arg2) {
  const arg1Id = asString(arg1);
  if (arg2) {
    const arg2Id = asString(arg2);
    return arg2Id.startsWith(arg1Id + ".");
  }
  return (ancestor) => {
    const ancestorId = asString(ancestor);
    return arg1Id.startsWith(ancestorId + ".");
  };
}
function isSameHierarchy(one, another) {
  if (!another) {
    return (b) => isSameHierarchy(one, b);
  }
  const first = asString(one);
  const second = asString(another);
  return first === second || second.startsWith(first + ".") || first.startsWith(second + ".");
}
function isDescendantOf(descedant, ancestor) {
  if (!ancestor) {
    return (d) => isAncestor(descedant, d);
  }
  return isAncestor(ancestor, descedant);
}
function hierarchyLevel(elementOfFqn) {
  const first = isString(elementOfFqn) ? elementOfFqn : elementOfFqn.id;
  return first.split(".").length;
}
function hierarchyDistance(one, another) {
  const first = isString(one) ? one : one.id;
  const second = isString(another) ? another : another.id;
  if (first === second) {
    return 0;
  }
  const firstDepth = hierarchyLevel(first);
  const secondDepth = hierarchyLevel(second);
  if (isSameHierarchy(first, second)) {
    return Math.abs(firstDepth - secondDepth);
  }
  const ancestor = commonAncestor(first, second);
  const ancestorDepth = ancestor ? hierarchyLevel(ancestor) : 0;
  return firstDepth + secondDepth - (2 * ancestorDepth + 1);
}
function commonAncestor(first, second) {
  const a = first.split(".");
  if (a.length < 2) {
    return null;
  }
  const b = second.split(".");
  if (b.length < 2) {
    return null;
  }
  let ancestor = [];
  for (let i = 0; i < Math.min(a.length, b.length) - 1 && a[i] === b[i]; i++) {
    ancestor.push(a[i]);
  }
  if (ancestor.length === 0) {
    return null;
  }
  return ancestor.join(".");
}
function ancestorsFqn(fqn) {
  const path = fqn.split(".");
  path.pop();
  if (path.length === 0) {
    return [];
  }
  return path.reduce((acc, part, idx) => {
    if (idx === 0) {
      acc.push(part);
      return acc;
    }
    acc.unshift(`${acc[0]}.${part}`);
    return acc;
  }, []);
}
function compareFqnHierarchically(a, b) {
  const depthA = a.split(".").length;
  const depthB = b.split(".").length;
  switch (true) {
    case depthA > depthB: {
      return 1;
    }
    case depthA < depthB: {
      return -1;
    }
    default: {
      return 0;
    }
  }
}
function compareByFqnHierarchically(a, b) {
  return compareFqnHierarchically(a.id, b.id);
}
function sortByFqnHierarchically(array) {
  return array.map((item) => ({ item, fqn: item.id.split(".") })).sort((a, b) => {
    return a.fqn.length - b.fqn.length;
  }).map(({ item }) => item);
}
function findTopAncestor(items, item) {
  let parent = item;
  for (const e of items) {
    if (isAncestor(e, parent)) {
      parent = e;
    }
  }
  return parent !== item ? parent : null;
}
function sortParentsFirst(array) {
  const result = [];
  const items = [...array];
  let item;
  while (item = items.shift()) {
    let parent;
    while (parent = findTopAncestor(items, item)) {
      result.push(items.splice(items.indexOf(parent), 1)[0]);
    }
    result.push(item);
  }
  return result;
}
function sortNaturalByFqn(array, sort) {
  if (!array || isString(array)) {
    const dir2 = array ?? "asc";
    return (arr) => sortNaturalByFqn(arr, dir2);
  }
  const dir = sort === "desc" ? -1 : 1;
  return array.map((item) => ({ item, fqn: item.id.split(".") })).sort((a, b) => {
    if (a.fqn.length !== b.fqn.length) {
      return (a.fqn.length - b.fqn.length) * dir;
    }
    for (let i = 0; i < a.fqn.length; i++) {
      const compare = compareNatural(a.fqn[i], b.fqn[i]);
      if (compare !== 0) {
        return compare;
      }
    }
    return 0;
  }).map(({ item }) => item);
}

function ifilter(arg1, arg2) {
  const pred = arg2 ?? arg1;
  invariant(t(pred));
  function* _filter(iter) {
    for (const value of iter) {
      if (pred(value)) {
        yield value;
      }
    }
    return;
  }
  if (!arg2) {
    return _filter;
  }
  return _filter(arg1);
}

function imap(arg1, arg2) {
  const mapper = arg2 ?? arg1;
  invariant(t(mapper));
  function* _map(iter) {
    for (const value of iter) {
      yield mapper(value);
    }
    return;
  }
  if (!arg2) {
    return _map;
  }
  return _map(arg1);
}

function toArray(iterable) {
  if (iterable) {
    return Array.from(iterable);
  }
  return (it) => Array.from(it);
}
function toSet(iterable) {
  if (iterable) {
    return new Set(iterable);
  }
  return (it) => new Set(it);
}

export { C, DefaultMap as D, isAncestor as a, toArray as b, ifilter as c, imap as d, isNonEmptyArray as e, t$1 as f, isSameHierarchy as g, t as h, isDescendantOf as i, getDefaultExportFromCjs as j, compareNatural as k, ancestorsFqn as l, commonAncestor as m, nameFromFqn as n, compareByFqnHierarchically as o, parentFqn as p, compareFqnHierarchically as q, hierarchyDistance as r, sortParentsFirst as s, toSet as t, hierarchyLevel as u, sortByFqnHierarchically as v, sortNaturalByFqn as w, isString as x, s as y, a as z };
