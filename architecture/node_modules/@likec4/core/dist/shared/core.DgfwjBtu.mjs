import { i as invariant, a as nonexhaustive } from './core.C-YXI-43.mjs';
import { u } from './core.DbRvwARP.mjs';

function n$1(e){return !!e}

function o$1(a){return t=>!a(t)}

function n(e){return e==null}

function o(r){return Array.isArray(r)}

function t(...a){return u(e,a)}var e=(a,o)=>o.every(l=>l(a));

function y(...a){return u(r,a)}var r=(a,o)=>o.some(e=>e(a));

const BorderStyles = ["solid", "dashed", "dotted", "none"];
var ElementKind;
((ElementKind2) => {
  ElementKind2.Group = "@group";
})(ElementKind || (ElementKind = {}));
const ElementShapes = [
  "rectangle",
  "person",
  "browser",
  "mobile",
  "cylinder",
  "storage",
  "queue"
];
const DefaultThemeColor = "primary";
const DefaultElementShape = "rectangle";
const DefaultShapeSize = "md";
const DefaultPaddingSize = "md";
const DefaultTextSize = "md";

function AsFqn(name, parent) {
  return parent ? parent + "." + name : name;
}
function GlobalFqn(projectId, name) {
  invariant(n$1(projectId), "Project ID must start with @");
  return "@" + projectId + "." + name;
}
function isGlobalFqn(fqn) {
  return fqn.startsWith("@");
}
function splitGlobalFqn(fqn) {
  if (!fqn.startsWith("@")) {
    return [null, fqn];
  }
  const firstDot = fqn.indexOf(".");
  if (firstDot < 2) {
    throw new Error("Invalid global FQN");
  }
  const projectId = fqn.slice(1, firstDot);
  const name = fqn.slice(firstDot + 1);
  return [projectId, name];
}

var DeploymentElement;
((DeploymentElement2) => {
  DeploymentElement2.isDeploymentNode = (el) => {
    return "kind" in el && !("element" in el);
  };
  DeploymentElement2.isInstance = (el) => {
    return "element" in el && !("kind" in el);
  };
})(DeploymentElement || (DeploymentElement = {}));

var FqnRef;
((FqnRef2) => {
  FqnRef2.isInsideInstanceRef = (ref) => {
    return "deployment" in ref && "element" in ref;
  };
  FqnRef2.isDeploymentElementRef = (ref) => {
    return "deployment" in ref && !("element" in ref);
  };
  FqnRef2.isDeploymentRef = (ref) => {
    return !(0, FqnRef2.isModelRef)(ref) && !(0, FqnRef2.isImportRef)(ref);
  };
  FqnRef2.isModelRef = (ref) => {
    return "model" in ref && !("project" in ref);
  };
  FqnRef2.isImportRef = (ref) => {
    return "project" in ref && "model" in ref;
  };
  FqnRef2.toDeploymentRef = (ref) => {
    invariant((0, FqnRef2.isDeploymentRef)(ref), "Expected DeploymentRef");
    return (0, FqnRef2.isInsideInstanceRef)(ref) ? {
      id: ref.deployment,
      element: ref.element
    } : {
      id: ref.deployment
    };
  };
  FqnRef2.toModelFqn = (ref) => {
    if ((0, FqnRef2.isImportRef)(ref)) {
      return GlobalFqn(ref.project, ref.model);
    }
    if ((0, FqnRef2.isModelRef)(ref)) {
      return ref.model;
    }
    throw new Error("Expected FqnRef.ModelRef or FqnRef.ImportRef");
  };
})(FqnRef || (FqnRef = {}));
var FqnExpr;
((FqnExpr2) => {
  FqnExpr2.isWildcard = (expr) => {
    return "wildcard" in expr && expr.wildcard === true;
  };
  FqnExpr2.isModelRef = (ref) => {
    return "ref" in ref && (FqnRef.isModelRef(ref.ref) || FqnRef.isImportRef(ref.ref));
  };
  FqnExpr2.isDeploymentRef = (ref) => {
    return "ref" in ref && FqnRef.isDeploymentRef(ref.ref);
  };
  function isElementKindExpr(expr) {
    return "elementKind" in expr && "isEqual" in expr;
  }
  FqnExpr2.isElementKindExpr = isElementKindExpr;
  function isElementTagExpr(expr) {
    return "elementTag" in expr && "isEqual" in expr;
  }
  FqnExpr2.isElementTagExpr = isElementTagExpr;
  FqnExpr2.isWhere = (expr) => {
    return "where" in expr && (0, FqnExpr2.is)(expr.where.expr);
  };
  FqnExpr2.isCustom = (expr) => {
    return "custom" in expr && ((0, FqnExpr2.is)(expr.custom.expr) || (0, FqnExpr2.isWhere)(expr.custom.expr));
  };
  FqnExpr2.is = (expr) => {
    return (0, FqnExpr2.isWildcard)(expr) || (0, FqnExpr2.isModelRef)(expr) || (0, FqnExpr2.isDeploymentRef)(expr) || isElementKindExpr(expr) || isElementTagExpr(expr);
  };
  FqnExpr2.unwrap = (expr) => {
    if ((0, FqnExpr2.isCustom)(expr)) {
      expr = expr.custom.expr;
    }
    if ((0, FqnExpr2.isWhere)(expr)) {
      expr = expr.where.expr;
    }
    return expr;
  };
})(FqnExpr || (FqnExpr = {}));
var RelationExpr;
((RelationExpr2) => {
  RelationExpr2.isDirect = (expr) => {
    return "source" in expr && "target" in expr;
  };
  RelationExpr2.isIncoming = (expr) => {
    return "incoming" in expr;
  };
  RelationExpr2.isOutgoing = (expr) => {
    return "outgoing" in expr;
  };
  RelationExpr2.isInOut = (expr) => {
    return "inout" in expr;
  };
  RelationExpr2.isWhere = (expr) => {
    return "where" in expr && ((0, RelationExpr2.isDirect)(expr.where.expr) || (0, RelationExpr2.isIncoming)(expr.where.expr) || (0, RelationExpr2.isOutgoing)(expr.where.expr) || (0, RelationExpr2.isInOut)(expr.where.expr));
  };
  RelationExpr2.isCustom = (expr) => {
    return "customRelation" in expr;
  };
  RelationExpr2.is = (expr) => {
    return (0, RelationExpr2.isDirect)(expr) || (0, RelationExpr2.isIncoming)(expr) || (0, RelationExpr2.isOutgoing)(expr) || (0, RelationExpr2.isInOut)(expr);
  };
  RelationExpr2.unwrap = (expr) => {
    if ((0, RelationExpr2.isCustom)(expr)) {
      expr = expr.customRelation.expr;
    }
    if ((0, RelationExpr2.isWhere)(expr)) {
      expr = expr.where.expr;
    }
    return expr;
  };
})(RelationExpr || (RelationExpr = {}));
var ExpressionV2;
((ExpressionV22) => {
  ExpressionV22.isWhere = (expr) => {
    return "where" in expr;
  };
  ExpressionV22.isRelationWhere = (expr) => {
    return RelationExpr.isWhere(expr);
  };
  ExpressionV22.isFqnExprWhere = (expr) => {
    return FqnExpr.isWhere(expr);
  };
  ExpressionV22.isFqnExpr = (expr) => {
    return FqnExpr.is(expr) || FqnExpr.isWhere(expr) || FqnExpr.isCustom(expr);
  };
  ExpressionV22.isRelation = (expr) => {
    return RelationExpr.is(expr) || RelationExpr.isWhere(expr) || RelationExpr.isCustom(expr);
  };
})(ExpressionV2 || (ExpressionV2 = {}));

var ModelLayer;
((ModelLayer2) => {
  ((FqnRef2) => {
    FqnRef2.isModelRef = (ref) => {
      return "model" in ref && !("project" in ref);
    };
    FqnRef2.isImportRef = (ref) => {
      return "project" in ref && "model" in ref;
    };
    FqnRef2.toFqn = (ref) => {
      if ((0, FqnRef2.isImportRef)(ref)) {
        return GlobalFqn(ref.project, ref.model);
      }
      if ((0, FqnRef2.isModelRef)(ref)) {
        return ref.model;
      }
      throw new Error("Expected FqnRef.ModelRef or FqnRef.ImportRef");
    };
  })(ModelLayer2.FqnRef || (ModelLayer2.FqnRef = {}));
  let FqnExpr;
  ((FqnExpr2) => {
    FqnExpr2.isWildcard = (expr) => {
      return "wildcard" in expr && expr.wildcard === true;
    };
    FqnExpr2.isModelRef = (ref) => {
      return "ref" in ref;
    };
    function isElementKindExpr(expr) {
      return "elementKind" in expr && "isEqual" in expr;
    }
    FqnExpr2.isElementKindExpr = isElementKindExpr;
    function isElementTagExpr(expr) {
      return "elementTag" in expr && "isEqual" in expr;
    }
    FqnExpr2.isElementTagExpr = isElementTagExpr;
    FqnExpr2.isWhere = (expr) => {
      return "where" in expr && (0, FqnExpr2.is)(expr.where.expr);
    };
    FqnExpr2.isCustom = (expr) => {
      return "custom" in expr && ((0, FqnExpr2.is)(expr.custom.expr) || (0, FqnExpr2.isWhere)(expr.custom.expr));
    };
    FqnExpr2.is = (expr) => {
      return (0, FqnExpr2.isWildcard)(expr) || (0, FqnExpr2.isModelRef)(expr) || isElementKindExpr(expr) || isElementTagExpr(expr);
    };
  })(FqnExpr = ModelLayer2.FqnExpr || (ModelLayer2.FqnExpr = {}));
  function isAnyFqnExpr(expr) {
    return FqnExpr.is(expr) || FqnExpr.isWhere(expr) || FqnExpr.isCustom(expr);
  }
  ModelLayer2.isAnyFqnExpr = isAnyFqnExpr;
  let RelationExpr;
  ((RelationExpr2) => {
    RelationExpr2.isDirect = (expr) => {
      return "source" in expr && "target" in expr;
    };
    RelationExpr2.isIncoming = (expr) => {
      return "incoming" in expr;
    };
    RelationExpr2.isOutgoing = (expr) => {
      return "outgoing" in expr;
    };
    RelationExpr2.isInOut = (expr) => {
      return "inout" in expr;
    };
    RelationExpr2.isWhere = (expr) => {
      return "where" in expr && (0, RelationExpr2.is)(expr.where.expr);
    };
    RelationExpr2.isCustom = (expr) => {
      return "customRelation" in expr;
    };
    RelationExpr2.is = (expr) => {
      return (0, RelationExpr2.isDirect)(expr) || (0, RelationExpr2.isIncoming)(expr) || (0, RelationExpr2.isOutgoing)(expr) || (0, RelationExpr2.isInOut)(expr);
    };
  })(RelationExpr = ModelLayer2.RelationExpr || (ModelLayer2.RelationExpr = {}));
  function isAnyRelationExpr(expr) {
    return RelationExpr.is(expr) || RelationExpr.isWhere(expr) || RelationExpr.isCustom(expr);
  }
  ModelLayer2.isAnyRelationExpr = isAnyRelationExpr;
  function isExpression(expr) {
    return isAnyFqnExpr(expr) || isAnyRelationExpr(expr);
  }
  ModelLayer2.isExpression = isExpression;
  ((Expression2) => {
    Expression2.isWhere = (expr) => {
      return "where" in expr;
    };
    Expression2.isCustomFqnExpr = (expr) => {
      return FqnExpr.isCustom(expr);
    };
    Expression2.isCustomRelationExpr = (expr) => {
      return RelationExpr.isCustom(expr);
    };
    Expression2.isFqnExpr = (expr) => {
      return FqnExpr.is(expr);
    };
    Expression2.isRelation = (expr) => {
      return RelationExpr.is(expr);
    };
  })(ModelLayer2.Expression || (ModelLayer2.Expression = {}));
})(ModelLayer || (ModelLayer = {}));

const isTagEqual = (operator) => {
  return "tag" in operator;
};
const isKindEqual = (operator) => {
  return "kind" in operator;
};
const isParticipantOperator = (operator) => {
  return "participant" in operator;
};
const isNotOperator = (operator) => {
  return "not" in operator;
};
const isAndOperator = (operator) => {
  return "and" in operator;
};
const isOrOperator = (operator) => {
  return "or" in operator;
};
function whereOperatorAsPredicate(operator) {
  switch (true) {
    case isParticipantOperator(operator): {
      const participant = operator.participant;
      const participantPredicate = whereOperatorAsPredicate(operator.operator);
      return participantIs(participant, participantPredicate);
    }
    case isTagEqual(operator): {
      if ("eq" in operator.tag) {
        const tag2 = operator.tag.eq;
        return (value) => {
          return Array.isArray(value.tags) && value.tags.includes(tag2);
        };
      }
      const tag = operator.tag.neq;
      return (value) => {
        return !Array.isArray(value.tags) || !value.tags.includes(tag);
      };
    }
    case isKindEqual(operator): {
      if ("eq" in operator.kind) {
        const kind2 = operator.kind.eq;
        return (value) => {
          return value.kind === kind2;
        };
      }
      const kind = operator.kind.neq;
      return (value) => {
        return n(value.kind) || value.kind !== kind;
      };
    }
    case isNotOperator(operator): {
      const predicate = whereOperatorAsPredicate(operator.not);
      return o$1(predicate);
    }
    case isAndOperator(operator): {
      const predicates = operator.and.map(whereOperatorAsPredicate);
      return t(predicates);
    }
    case isOrOperator(operator): {
      const predicates = operator.or.map(whereOperatorAsPredicate);
      return y(predicates);
    }
    default:
      nonexhaustive(operator);
  }
}
function participantIs(participant, predicate) {
  return (value) => {
    if (!value.source || !value.target) {
      return false;
    }
    switch (participant) {
      case "source": {
        return predicate(value.source);
      }
      case "target": {
        return predicate(value.target);
      }
    }
  };
}

const DefaultLineStyle = "dashed";
const DefaultArrowType = "normal";
const DefaultRelationshipColor = "gray";

function isViewRulePredicate(rule) {
  return "include" in rule && Array.isArray(rule.include) || "exclude" in rule && Array.isArray(rule.exclude);
}
function isViewRuleGlobalPredicateRef(rule) {
  return "predicateId" in rule;
}
function isViewRuleStyle(rule) {
  return "style" in rule && "targets" in rule && Array.isArray(rule.targets);
}
function isViewRuleGlobalStyle(rule) {
  return "styleId" in rule;
}
function isAutoLayoutDirection(autoLayout) {
  return autoLayout === "TB" || autoLayout === "BT" || autoLayout === "LR" || autoLayout === "RL";
}
function isViewRuleAutoLayout(rule) {
  return "direction" in rule;
}
function isViewRuleGroup(rule) {
  return "title" in rule && "groupRules" in rule && Array.isArray(rule.groupRules);
}
function isDynamicViewParallelSteps(step) {
  return "__parallel" in step && o(step.__parallel);
}
function isDeploymentView(view) {
  return view.__ === "deployment";
}
function isDynamicView(view) {
  return view.__ === "dynamic";
}
function isElementView(view) {
  return n(view.__) || view.__ === "element";
}
function isExtendsElementView(view) {
  return isElementView(view) && "extends" in view;
}
function isScopedElementView(view) {
  return isElementView(view) && "viewOf" in view;
}
function stepEdgeId(step, parallelStep) {
  const id = `step-${String(step).padStart(2, "0")}`;
  return parallelStep ? `${id}.${parallelStep}` : id;
}
function isStepEdgeId(id) {
  return id.startsWith("step-");
}
function extractStep(id) {
  if (!isStepEdgeId(id)) {
    throw new Error(`Invalid step edge id: ${id}`);
  }
  return parseFloat(id.slice("step-".length));
}
function getParallelStepsPrefix(id) {
  if (isStepEdgeId(id) && id.includes(".")) {
    return id.slice(0, id.indexOf(".") + 1);
  }
  return null;
}
var ComputedNode;
((ComputedNode2) => {
  function modelRef(node) {
    return node.modelRef === 1 ? node.id : node.modelRef ?? null;
  }
  ComputedNode2.modelRef = modelRef;
  function deploymentRef(node) {
    return node.deploymentRef === 1 ? node.id : node.deploymentRef ?? null;
  }
  ComputedNode2.deploymentRef = deploymentRef;
  function isNodesGroup(node) {
    return node.kind === ElementKind.Group;
  }
  ComputedNode2.isNodesGroup = isNodesGroup;
})(ComputedNode || (ComputedNode = {}));
var ComputedView;
((ComputedView2) => {
  function isDeployment(view) {
    return view.__ === "deployment";
  }
  ComputedView2.isDeployment = isDeployment;
  function isDynamic(view) {
    return view.__ === "dynamic";
  }
  ComputedView2.isDynamic = isDynamic;
  function isElement(view) {
    return n(view.__) || view.__ === "element";
  }
  ComputedView2.isElement = isElement;
})(ComputedView || (ComputedView = {}));
function getBBoxCenter({
  x,
  y,
  width,
  height
}) {
  return {
    x: x + width / 2,
    y: y + height / 2
  };
}
var DiagramNode;
((DiagramNode2) => {
  function modelRef(node) {
    return node.modelRef === 1 ? node.id : node.modelRef ?? null;
  }
  DiagramNode2.modelRef = modelRef;
  function deploymentRef(node) {
    return node.deploymentRef === 1 ? node.id : node.deploymentRef ?? null;
  }
  DiagramNode2.deploymentRef = deploymentRef;
  function isNodesGroup(node) {
    return node.kind === ElementKind.Group;
  }
  DiagramNode2.isNodesGroup = isNodesGroup;
})(DiagramNode || (DiagramNode = {}));

export { y as $, AsFqn as A, BorderStyles as B, ComputedNode as C, DefaultElementShape as D, ElementKind as E, FqnExpr as F, GlobalFqn as G, DiagramNode as H, extractStep as I, getBBoxCenter as J, getParallelStepsPrefix as K, isAutoLayoutDirection as L, ModelLayer as M, isDeploymentView as N, isDynamicView as O, isDynamicViewParallelSteps as P, isStepEdgeId as Q, RelationExpr as R, isViewRuleAutoLayout as S, isViewRuleGlobalPredicateRef as T, isViewRuleGlobalStyle as U, isViewRuleGroup as V, isViewRulePredicate as W, isViewRuleStyle as X, stepEdgeId as Y, n$1 as Z, o$1 as _, isElementView as a, DefaultThemeColor as b, DeploymentElement as c, isScopedElementView as d, isGlobalFqn as e, DefaultPaddingSize as f, DefaultShapeSize as g, DefaultTextSize as h, isExtendsElementView as i, ElementShapes as j, ExpressionV2 as k, FqnRef as l, isAndOperator as m, n, o, isKindEqual as p, isNotOperator as q, isOrOperator as r, splitGlobalFqn as s, isParticipantOperator as t, isTagEqual as u, DefaultArrowType as v, whereOperatorAsPredicate as w, DefaultLineStyle as x, DefaultRelationshipColor as y, ComputedView as z };
