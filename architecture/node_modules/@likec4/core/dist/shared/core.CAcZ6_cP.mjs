import { s as splitGlobalFqn, D as DefaultElementShape, b as DefaultThemeColor, g as DefaultShapeSize, Z as n$3, y as DefaultRelationshipColor, x as DefaultLineStyle, _ as o$8, M as ModelLayer, w as whereOperatorAsPredicate, n as n$4, X as isViewRuleStyle, $ as y$2, C as ComputedNode, E as ElementKind, v as DefaultArrowType, F as FqnExpr, R as RelationExpr, o as o$9, W as isViewRulePredicate, S as isViewRuleAutoLayout, V as isViewRuleGroup, T as isViewRuleGlobalPredicateRef, U as isViewRuleGlobalStyle, Y as stepEdgeId, P as isDynamicViewParallelSteps, a as isElementView, O as isDynamicView, N as isDeploymentView, c as DeploymentElement, I as extractStep, Q as isStepEdgeId, d as isScopedElementView, e as isGlobalFqn, G as GlobalFqn } from './core.DgfwjBtu.mjs';
import { C, y as s$1, z as a$5, u as hierarchyLevel, a as isAncestor, m as commonAncestor, w as sortNaturalByFqn, j as getDefaultExportFromCjs, i as isDescendantOf, x as isString, g as isSameHierarchy, c as ifilter, t as toSet, s as sortParentsFirst, b as toArray, D as DefaultMap, d as imap, p as parentFqn, o as compareByFqnHierarchically, e as isNonEmptyArray, k as compareNatural, n as nameFromFqn, f as t$6, v as sortByFqnHierarchically, l as ancestorsFqn } from './core.CQXU9DF7.mjs';
import { u as u$6 } from './core.DbRvwARP.mjs';
import { n as nonNullable, i as invariant, a as nonexhaustive } from './core.C-YXI-43.mjs';
import { m as m$3, c as commonHead, r as requireForeach, p as requireIterator, q as u$7, o as objectHash, k as intersection, h as difference, u as union, n as stringHash, j as equals, e as isome, d as isIterable, i as i$9, t as d$6, v as n$5, l as l$7, w as hasIntersection, S as Stack, f as iunique, b as iflat, g as getOrCreate, a as ifind } from './core.Cu-UdkSl.mjs';

function y$1(t,i){let a=i.length-t.length;if(a===1){let[n,...r]=i;return C(n,{lazy:t,lazyArgs:r})}if(a===0){let n={lazy:t,lazyArgs:i};return Object.assign(e=>C(e,n),n)}throw new Error("Wrong number of arguments")}

function r$3(...t){return u$6(Object.values,t)}

function d$5(...e){return e.length===2?(n,...r)=>t$5(n,...e,...r):t$5(...e)}var t$5=(e,n,r,...a)=>n(e,...a)?typeof r=="function"?r(e,...a):r.onTrue(e,...a):typeof r=="function"?e:r.onFalse(e,...a);

function i$8(...e){return y$1(a$4,e)}function a$4(){let e=new Set;return t=>e.has(t)?s$1:(e.add(t),{done:false,hasNext:true,next:t})}

function l$6(...r){return u$6(o$7,r,u$5)}var o$7=(r,e)=>e<0?[]:r.slice(0,e);function u$5(r){if(r<=0)return a$5;let e=r;return a=>(e-=1,{done:e<=0,hasNext:true,next:a})}

var T$1={asc:(r,n)=>r>n,desc:(r,n)=>r<n};function s(r,n){let[e,...o]=n;if(!m$2(e)){let t=u$4(...o);return r(e,t)}let a=u$4(e,...o);return t=>r(t,a)}function u$4(r,n,...e){let o=typeof r=="function"?r:r[0],a=typeof r=="function"?"asc":r[1],{[a]:t}=T$1,i=n===void 0?void 0:u$4(n,...e);return (y,c)=>{let p=o(y),l=o(c);return t(p,l)?1:t(l,p)?-1:i?.(y,c)??0}}function m$2(r){if(d$4(r))return  true;if(typeof r!="object"||!Array.isArray(r))return  false;let[n,e,...o]=r;return d$4(n)&&typeof e=="string"&&e in T$1&&o.length===0}var d$4=r=>typeof r=="function"&&r.length===1;

function m$1(...r){return u$6(o$6,r)}function o$6(r,t){let e=[...r];return e.sort(t),e}

function a$3(...r){return s(n$2,r)}var n$2=(r,t)=>[...r].sort(t);

function l$5(...e){return u$6(u$3,e)}var u$3=(e,a,n)=>e.reduce(a,n);

function t$4(...e){return u$6(r$2,e)}function r$2(e){return [...e].reverse()}

function p$1(...e){return u$6(t$3,e)}var t$3=(e,o)=>e[o];

function d$3(...r){return u$6(i$7,r)}var i$7=(r,t)=>{let a=[[],[]];for(let[o,e]of r.entries())t(e,o,r)?a[0].push(e):a[1].push(e);return a};

function i$6(...e){return u$6(o$5,e)}function o$5(e,n){let t={};for(let r of n)r in e&&(t[r]=e[r]);return t}

function d$2(...e){return u$6(i$5,e)}function i$5(e,o){let t={};for(let[r,n]of Object.entries(e))o(n,r,e)&&(t[r]=n);return t}

function i$4(...n){return o=>C(o,...n)}

function d$1(...e){return u$6(l$4,e)}function l$4(e,a){let t={...e};for(let[n,o]of Object.entries(t))a(o,n,e)&&delete t[n];return t}

function t$2(...n){return u$6(o$4,n)}var o$4=n=>n.length===1?n[0]:void 0;

function i$3(...e){return u$6(o$3,e)}function o$3(e,r){let a={};for(let[n,u]of Object.entries(e)){let l=r(u,n,e);a[n]=l;}return a}

function a$2(...e){return u$6(n$1,e)}var n$1=e=>e.at(-1);

function l$3(...n){return u$6(d,n)}function d(n,o){let e={};for(let[a,t]of n.entries()){let[y,u]=o(t,a,n);e[y]=u;}return e}

function e$1(r){return typeof r=="number"&&!Number.isNaN(r)}

function n(e){return e===void 0?true:typeof e=="string"||Array.isArray(e)?e.length===0:Object.keys(e).length===0}

function e(o){return typeof o=="boolean"}

function i$2(...e){return u$6(p,e)}var p=(e,a)=>{let n=new Map;for(let[d,t]of e.entries()){let y=a(t,d,e);if(y!==void 0){let r=n.get(y);r===void 0&&(r=[],n.set(y,r)),r.push(t);}}return Object.fromEntries(n)};

function k(...n){return u$6(u$2,n)}function u$2(n,e){if(n===e||Object.is(n,e))return  true;if(typeof n!="object"||typeof e!="object"||n===null||e===null||Object.getPrototypeOf(n)!==Object.getPrototypeOf(e))return  false;if(Array.isArray(n))return l$2(n,e);if(n instanceof Map)return a$1(n,e);if(n instanceof Set)return c(n,e);if(n instanceof Date)return n.getTime()===e.getTime();if(n instanceof RegExp)return n.toString()===e.toString();if(Object.keys(n).length!==Object.keys(e).length)return  false;for(let[r,t]of Object.entries(n))if(!(r in e)||!u$2(t,e[r]))return  false;return  true}function l$2(n,e){if(n.length!==e.length)return  false;for(let[r,t]of n.entries())if(!u$2(t,e[r]))return  false;return  true}function a$1(n,e){if(n.size!==e.size)return  false;for(let[r,t]of n.entries())if(!e.has(r)||!u$2(t,e.get(r)))return  false;return  true}function c(n,e){if(n.size!==e.size)return  false;let r=[...e];for(let t of n){let o=false;for(let[s,f]of r.entries())if(u$2(t,f)){o=true,r.splice(s,1);break}if(!o)return  false}return  true}

function u$1(...a){return u$6(o$2,a,l$1)}var o$2=(a,r)=>a.flatMap(r),l$1=a=>(r,t,y)=>{let n=a(r,t,y);return Array.isArray(n)?{done:false,hasNext:true,hasMany:true,next:n}:{done:false,hasNext:true,next:n}};

function u(...e){return u$6(o$1,e,i$1)}function o$1(e,a){return e.forEach(a),e}var i$1=e=>(a,n,t)=>(e(a,n,t),{done:false,hasNext:true,next:a});

function t$1(...r){return u$6(Object.entries,r)}

function T(...a){return u$6(l,a,y)}var l=(a,r)=>a.filter(r),y=a=>(r,t,o)=>a(r,t,o)?{done:false,hasNext:true,next:r}:s$1;

function o(...e){return u$6(t,e)}var t=(e,r)=>{for(let n=e.length-1;n>=0;n--){let a=e[n];if(r(a,n,e))return a}};

function m(...e){return u$6(i,e)}function i(e,t){for(let[n,o]of e.entries())if(!t(o,n,e))return e.slice(n);return []}

function a(...e){return u$6(r$1,e)}var r$1=(e,t)=>[...e,...t];

function r(n){return ()=>n}

class ElementModel {
  constructor($model, $element) {
    this.$model = $model;
    this.$element = $element;
    this.id = this.$element.id;
    this._literalId = this.$element.id;
    const [projectId, fqn] = splitGlobalFqn(this.id);
    if (projectId) {
      this.imported = {
        from: projectId,
        fqn
      };
      this.hierarchyLevel = hierarchyLevel(fqn);
    } else {
      this.imported = null;
      this.hierarchyLevel = hierarchyLevel(this.id);
    }
  }
  id;
  _literalId;
  hierarchyLevel;
  imported;
  get parent() {
    return this.$model.parent(this);
  }
  get kind() {
    return this.$element.kind;
  }
  get shape() {
    return this.$element.shape ?? DefaultElementShape;
  }
  get color() {
    return this.$element.color ?? DefaultThemeColor;
  }
  get icon() {
    return this.$element.icon ?? null;
  }
  get tags() {
    return this.$element.tags ?? [];
  }
  get title() {
    return this.$element.title;
  }
  get description() {
    return this.$element.description;
  }
  get technology() {
    return this.$element.technology;
  }
  get links() {
    return this.$element.links ?? [];
  }
  get defaultView() {
    return this.scopedViews().next().value ?? null;
  }
  get isRoot() {
    return this.parent === null;
  }
  get style() {
    return {
      size: DefaultShapeSize,
      ...this.$element.style
    };
  }
  isAncestorOf(another) {
    return isAncestor(this, another);
  }
  isDescendantOf(another) {
    return isAncestor(another, this);
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors() {
    return this.$model.ancestors(this);
  }
  /**
   * Returns the common ancestor of this element and another element.
   */
  commonAncestor(another) {
    const common = commonAncestor(this.id, another.id);
    return common ? this.$model.element(common) : null;
  }
  children() {
    return this.$model.children(this);
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  descendants(sort) {
    if (sort) {
      const sorted = sortNaturalByFqn([...this.$model.descendants(this)], sort);
      return sorted[Symbol.iterator]();
    }
    return this.$model.descendants(this);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  siblings() {
    return this.$model.siblings(this);
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from closest to root)
   */
  *ascendingSiblings() {
    yield* this.siblings();
    for (const ancestor of this.ancestors()) {
      yield* ancestor.siblings();
    }
    return;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from root to closest)
   */
  *descendingSiblings() {
    for (const ancestor of [...this.ancestors()].reverse()) {
      yield* ancestor.siblings();
    }
    yield* this.siblings();
    return;
  }
  incoming(filter = "all") {
    return this.$model.incoming(this, filter);
  }
  *incomers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.incoming(filter)) {
      if (unique.has(r.source.id)) {
        continue;
      }
      unique.add(r.source.id);
      yield r.source;
    }
    return;
  }
  outgoing(filter = "all") {
    return this.$model.outgoing(this, filter);
  }
  *outgoers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.outgoing(filter)) {
      if (unique.has(r.target.id)) {
        continue;
      }
      unique.add(r.target.id);
      yield r.target;
    }
    return;
  }
  cachedOutgoing = null;
  cachedIncoming = null;
  get allOutgoing() {
    this.cachedOutgoing ??= new Set(this.outgoing());
    return this.cachedOutgoing;
  }
  get allIncoming() {
    this.cachedIncoming ??= new Set(this.incoming());
    return this.cachedIncoming;
  }
  /**
   * Iterate over all views that include this element.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (view.includesElement(this.id)) {
        yield view;
      }
    }
    return;
  }
  /**
   * Iterate over all views that scope this element.
   * It is possible that element is not included in the view.
   */
  *scopedViews() {
    for (const vm of this.$model.views()) {
      if (vm.isElementView() && vm.$view.viewOf === this.id) {
        yield vm;
      }
    }
    return;
  }
  /**
   * @returns true if the element is deployed
   */
  isDeployed() {
    return n$3(this.deployments().next().value);
  }
  deployments() {
    return this.$model.deployment.instancesOf(this);
  }
}
function isElementModel(element) {
  return element instanceof ElementModel;
}

function buildElementNotations(nodes) {
  return C(
    nodes,
    i$2(p$1("notation")),
    i$3(
      i$4(
        i$2(p$1("shape")),
        i$3(
          i$4(
            i$2(p$1("color")),
            i$3(
              i$4(
                m$3(p$1("kind")),
                i$8()
              )
            ),
            t$1(),
            m$3(([color, kinds]) => ({
              kinds,
              color
            }))
          )
        ),
        t$1(),
        u$1(
          ([shape, colors]) => colors.map(({ color, kinds }) => ({
            shape,
            color,
            kinds
          }))
        )
      )
    ),
    t$1(),
    u$1(
      ([title, shapes]) => shapes.map(({ shape, color, kinds }) => ({
        title,
        shape,
        color,
        kinds
      }))
    ),
    a$3(
      p$1("shape"),
      p$1("title"),
      [
        (n) => n.kinds.length,
        "desc"
      ]
    )
  );
}

function ancestorsOfNode(node, nodes) {
  const ancestors = [];
  let parentId = node.parent;
  while (parentId) {
    const parentNode = nonNullable(nodes.get(parentId), `Parent node ${parentId} not found`);
    ancestors.push(parentNode);
    parentId = parentNode.parent;
  }
  return ancestors;
}

function linkNodesWithEdges(nodesMap, edges) {
  for (const edge of edges) {
    const source = nodesMap.get(edge.source);
    const target = nodesMap.get(edge.target);
    invariant(source, `Source node ${edge.source} not found`);
    invariant(target, `Target node ${edge.target} not found`);
    source.outEdges.push(edge.id);
    target.inEdges.push(edge.id);
    const sourceAncestors = ancestorsOfNode(source, nodesMap);
    const targetAncestors = ancestorsOfNode(target, nodesMap);
    const hasAncestors = sourceAncestors.length > 0 && targetAncestors.length > 0;
    const edgeParent = hasAncestors ? a$2(
      commonHead(
        t$4(sourceAncestors),
        t$4(targetAncestors)
      )
    ) : null;
    edge.parent = edgeParent ? edgeParent.id : null;
    for (const sourceAncestor of sourceAncestors) {
      if (sourceAncestor === edgeParent) {
        break;
      }
      sourceAncestor.outEdges.push(edge.id);
    }
    for (const targetAncestor of targetAncestors) {
      if (targetAncestor === edgeParent) {
        break;
      }
      targetAncestor.inEdges.push(edge.id);
    }
  }
}

var graphology_umd_min$1 = {exports: {}};

var graphology_umd_min = graphology_umd_min$1.exports;

var hasRequiredGraphology_umd_min;

function requireGraphology_umd_min () {
	if (hasRequiredGraphology_umd_min) return graphology_umd_min$1.exports;
	hasRequiredGraphology_umd_min = 1;
	(function (module, exports) {
		!function(t,e){module.exports=e();}(graphology_umd_min,(function(){function t(e){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},t(e)}function e(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,r(t,e);}function n(t){return n=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},n(t)}function r(t,e){return r=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},r(t,e)}function i(){if("undefined"==typeof Reflect||!Reflect.construct)return  false;if(Reflect.construct.sham)return  false;if("function"==typeof Proxy)return  true;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return  false}}function o(t,e,n){return o=i()?Reflect.construct.bind():function(t,e,n){var i=[null];i.push.apply(i,e);var o=new(Function.bind.apply(t,i));return n&&r(o,n.prototype),o},o.apply(null,arguments)}function a(t){var e="function"==typeof Map?new Map:void 0;return a=function(t){if(null===t||(i=t,-1===Function.toString.call(i).indexOf("[native code]")))return t;var i;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,a);}function a(){return o(t,arguments,n(this).constructor)}return a.prototype=Object.create(t.prototype,{constructor:{value:a,enumerable:false,writable:true,configurable:true}}),r(a,t)},a(t)}function c(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var u=function(){for(var t=arguments[0],e=1,n=arguments.length;e<n;e++)if(arguments[e])for(var r in arguments[e])t[r]=arguments[e][r];return t};function d(t,e,n,r){var i=t._nodes.get(e),o=null;return i?o="mixed"===r?i.out&&i.out[n]||i.undirected&&i.undirected[n]:"directed"===r?i.out&&i.out[n]:i.undirected&&i.undirected[n]:o}function s(e){return "object"===t(e)&&null!==e}function h(t){var e;for(e in t)return  false;return  true}function p(t,e,n){Object.defineProperty(t,e,{enumerable:false,configurable:false,writable:true,value:n});}function f(t,e,n){var r={enumerable:true,configurable:true};"function"==typeof n?r.get=n:(r.value=n,r.writable=false),Object.defineProperty(t,e,r);}function l(t){return !!s(t)&&!(t.attributes&&!Array.isArray(t.attributes))}"function"==typeof Object.assign&&(u=Object.assign);var g,y={exports:{}},w="object"==typeof Reflect?Reflect:null,v=w&&"function"==typeof w.apply?w.apply:function(t,e,n){return Function.prototype.apply.call(t,e,n)};g=w&&"function"==typeof w.ownKeys?w.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var b=Number.isNaN||function(t){return t!=t};function m(){m.init.call(this);}y.exports=m,y.exports.once=function(t,e){return new Promise((function(n,r){function i(n){t.removeListener(e,o),r(n);}function o(){"function"==typeof t.removeListener&&t.removeListener("error",i),n([].slice.call(arguments));}U(t,e,o,{once:true}),"error"!==e&&function(t,e,n){"function"==typeof t.on&&U(t,"error",e,n);}(t,i,{once:true});}))},m.EventEmitter=m,m.prototype._events=void 0,m.prototype._eventsCount=0,m.prototype._maxListeners=void 0;var k=10;function _(t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t)}function G(t){return void 0===t._maxListeners?m.defaultMaxListeners:t._maxListeners}function x(t,e,n,r){var i,o,a,c;if(_(n),void 0===(o=t._events)?(o=t._events=Object.create(null),t._eventsCount=0):(void 0!==o.newListener&&(t.emit("newListener",e,n.listener?n.listener:n),o=t._events),a=o[e]),void 0===a)a=o[e]=n,++t._eventsCount;else if("function"==typeof a?a=o[e]=r?[n,a]:[a,n]:r?a.unshift(n):a.push(n),(i=G(t))>0&&a.length>i&&!a.warned){a.warned=true;var u=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=t,u.type=e,u.count=a.length,c=u,console&&console.warn&&console.warn(c);}return t}function E(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=true,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function A(t,e,n){var r={fired:false,wrapFn:void 0,target:t,type:e,listener:n},i=E.bind(r);return i.listener=n,r.wrapFn=i,i}function L(t,e,n){var r=t._events;if(void 0===r)return [];var i=r[e];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(t){for(var e=new Array(t.length),n=0;n<e.length;++n)e[n]=t[n].listener||t[n];return e}(i):D(i,i.length)}function S(t){var e=this._events;if(void 0!==e){var n=e[t];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function D(t,e){for(var n=new Array(e),r=0;r<e;++r)n[r]=t[r];return n}function U(t,e,n,r){if("function"==typeof t.on)r.once?t.once(e,n):t.on(e,n);else {if("function"!=typeof t.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof t);t.addEventListener(e,(function i(o){r.once&&t.removeEventListener(e,i),n(o);}));}}function N(t){if("function"!=typeof t)throw new Error("obliterator/iterator: expecting a function!");this.next=t;}Object.defineProperty(m,"defaultMaxListeners",{enumerable:true,get:function(){return k},set:function(t){if("number"!=typeof t||t<0||b(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");k=t;}}),m.init=function(){ void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0;},m.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||b(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},m.prototype.getMaxListeners=function(){return G(this)},m.prototype.emit=function(t){for(var e=[],n=1;n<arguments.length;n++)e.push(arguments[n]);var r="error"===t,i=this._events;if(void 0!==i)r=r&&void 0===i.error;else if(!r)return  false;if(r){var o;if(e.length>0&&(o=e[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var c=i[t];if(void 0===c)return  false;if("function"==typeof c)v(c,this,e);else {var u=c.length,d=D(c,u);for(n=0;n<u;++n)v(d[n],this,e);}return  true},m.prototype.addListener=function(t,e){return x(this,t,e,false)},m.prototype.on=m.prototype.addListener,m.prototype.prependListener=function(t,e){return x(this,t,e,true)},m.prototype.once=function(t,e){return _(e),this.on(t,A(this,t,e)),this},m.prototype.prependOnceListener=function(t,e){return _(e),this.prependListener(t,A(this,t,e)),this},m.prototype.removeListener=function(t,e){var n,r,i,o,a;if(_(e),void 0===(r=this._events))return this;if(void 0===(n=r[t]))return this;if(n===e||n.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete r[t],r.removeListener&&this.emit("removeListener",t,n.listener||e));else if("function"!=typeof n){for(i=-1,o=n.length-1;o>=0;o--)if(n[o]===e||n[o].listener===e){a=n[o].listener,i=o;break}if(i<0)return this;0===i?n.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop();}(n,i),1===n.length&&(r[t]=n[0]),void 0!==r.removeListener&&this.emit("removeListener",t,a||e);}return this},m.prototype.off=m.prototype.removeListener,m.prototype.removeAllListeners=function(t){var e,n,r;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[t]),this;if(0===arguments.length){var i,o=Object.keys(n);for(r=0;r<o.length;++r)"removeListener"!==(i=o[r])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=n[t]))this.removeListener(t,e);else if(void 0!==e)for(r=e.length-1;r>=0;r--)this.removeListener(t,e[r]);return this},m.prototype.listeners=function(t){return L(this,t,true)},m.prototype.rawListeners=function(t){return L(this,t,false)},m.listenerCount=function(t,e){return "function"==typeof t.listenerCount?t.listenerCount(e):S.call(t,e)},m.prototype.listenerCount=S,m.prototype.eventNames=function(){return this._eventsCount>0?g(this._events):[]},"undefined"!=typeof Symbol&&(N.prototype[Symbol.iterator]=function(){return this}),N.of=function(){var t=arguments,e=t.length,n=0;return new N((function(){return n>=e?{done:true}:{done:false,value:t[n++]}}))},N.empty=function(){return new N((function(){return {done:true}}))},N.fromSequence=function(t){var e=0,n=t.length;return new N((function(){return e>=n?{done:true}:{done:false,value:t[e++]}}))},N.is=function(t){return t instanceof N||"object"==typeof t&&null!==t&&"function"==typeof t.next};var O=N,j={};j.ARRAY_BUFFER_SUPPORT="undefined"!=typeof ArrayBuffer,j.SYMBOL_SUPPORT="undefined"!=typeof Symbol;var C=O,M=j,z=M.ARRAY_BUFFER_SUPPORT,W=M.SYMBOL_SUPPORT;var P=function(t){var e=function(t){return "string"==typeof t||Array.isArray(t)||z&&ArrayBuffer.isView(t)?C.fromSequence(t):"object"!=typeof t||null===t?null:W&&"function"==typeof t[Symbol.iterator]?t[Symbol.iterator]():"function"==typeof t.next?t:null}(t);if(!e)throw new Error("obliterator: target is not iterable nor a valid iterator.");return e},R=P,K=function(t,e){for(var n,r=arguments.length>1?e:1/0,i=r!==1/0?new Array(r):[],o=0,a=R(t);;){if(o===r)return i;if((n=a.next()).done)return o!==e&&(i.length=o),i;i[o++]=n.value;}},T=function(t){function n(e){var n;return (n=t.call(this)||this).name="GraphError",n.message=e,n}return e(n,t),n}(a(Error)),B=function(t){function n(e){var r;return (r=t.call(this,e)||this).name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(c(r),n.prototype.constructor),r}return e(n,t),n}(T),F=function(t){function n(e){var r;return (r=t.call(this,e)||this).name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(c(r),n.prototype.constructor),r}return e(n,t),n}(T),I=function(t){function n(e){var r;return (r=t.call(this,e)||this).name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(c(r),n.prototype.constructor),r}return e(n,t),n}(T);function Y(t,e){this.key=t,this.attributes=e,this.clear();}function q(t,e){this.key=t,this.attributes=e,this.clear();}function J(t,e){this.key=t,this.attributes=e,this.clear();}function V(t,e,n,r,i){this.key=e,this.attributes=i,this.undirected=t,this.source=n,this.target=r;}Y.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={};},q.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={};},J.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={};},V.prototype.attach=function(){var t="out",e="in";this.undirected&&(t=e="undirected");var n=this.source.key,r=this.target.key;this.source[t][r]=this,this.undirected&&n===r||(this.target[e][n]=this);},V.prototype.attachMulti=function(){var t="out",e="in",n=this.source.key,r=this.target.key;this.undirected&&(t=e="undirected");var i=this.source[t],o=i[r];if(void 0===o)return i[r]=this,void(this.undirected&&n===r||(this.target[e][n]=this));o.previous=this,this.next=o,i[r]=this,this.target[e][n]=this;},V.prototype.detach=function(){var t=this.source.key,e=this.target.key,n="out",r="in";this.undirected&&(n=r="undirected"),delete this.source[n][e],delete this.target[r][t];},V.prototype.detachMulti=function(){var t=this.source.key,e=this.target.key,n="out",r="in";this.undirected&&(n=r="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[n][e],delete this.target[r][t]):(this.next.previous=void 0,this.source[n][e]=this.next,this.target[r][t]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous));};function H(t,e,n,r,i,o,a){var c,u,d,s;if(r=""+r,0===n){if(!(c=t._nodes.get(r)))throw new F("Graph.".concat(e,': could not find the "').concat(r,'" node in the graph.'));d=i,s=o;}else if(3===n){if(i=""+i,!(u=t._edges.get(i)))throw new F("Graph.".concat(e,': could not find the "').concat(i,'" edge in the graph.'));var h=u.source.key,p=u.target.key;if(r===h)c=u.target;else {if(r!==p)throw new F("Graph.".concat(e,': the "').concat(r,'" node is not attached to the "').concat(i,'" edge (').concat(h,", ").concat(p,")."));c=u.source;}d=o,s=a;}else {if(!(u=t._edges.get(r)))throw new F("Graph.".concat(e,': could not find the "').concat(r,'" edge in the graph.'));c=1===n?u.source:u.target,d=i,s=o;}return [c,d,s]}var Q=[{name:function(t){return "get".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=H(this,e,n,t,r,i),a=o[0],c=o[1];return a.attributes[c]};}},{name:function(t){return "get".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r){return H(this,e,n,t,r)[0].attributes};}},{name:function(t){return "has".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=H(this,e,n,t,r,i),a=o[0],c=o[1];return a.attributes.hasOwnProperty(c)};}},{name:function(t){return "set".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i,o){var a=H(this,e,n,t,r,i,o),c=a[0],u=a[1],d=a[2];return c.attributes[u]=d,this.emit("nodeAttributesUpdated",{key:c.key,type:"set",attributes:c.attributes,name:u}),this};}},{name:function(t){return "update".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i,o){var a=H(this,e,n,t,r,i,o),c=a[0],u=a[1],d=a[2];if("function"!=typeof d)throw new B("Graph.".concat(e,": updater should be a function."));var s=c.attributes,h=d(s[u]);return s[u]=h,this.emit("nodeAttributesUpdated",{key:c.key,type:"set",attributes:c.attributes,name:u}),this};}},{name:function(t){return "remove".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=H(this,e,n,t,r,i),a=o[0],c=o[1];return delete a.attributes[c],this.emit("nodeAttributesUpdated",{key:a.key,type:"remove",attributes:a.attributes,name:c}),this};}},{name:function(t){return "replace".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=H(this,e,n,t,r,i),a=o[0],c=o[1];if(!s(c))throw new B("Graph.".concat(e,": provided attributes are not a plain object."));return a.attributes=c,this.emit("nodeAttributesUpdated",{key:a.key,type:"replace",attributes:a.attributes}),this};}},{name:function(t){return "merge".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=H(this,e,n,t,r,i),a=o[0],c=o[1];if(!s(c))throw new B("Graph.".concat(e,": provided attributes are not a plain object."));return u(a.attributes,c),this.emit("nodeAttributesUpdated",{key:a.key,type:"merge",attributes:a.attributes,data:c}),this};}},{name:function(t){return "update".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=H(this,e,n,t,r,i),a=o[0],c=o[1];if("function"!=typeof c)throw new B("Graph.".concat(e,": provided updater is not a function."));return a.attributes=c(a.attributes),this.emit("nodeAttributesUpdated",{key:a.key,type:"update",attributes:a.attributes}),this};}}];var X=[{name:function(t){return "get".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=d(this,o,a,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return i.attributes[r]};}},{name:function(t){return "get".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t){var r;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var i=""+t,o=""+arguments[1];if(!(r=d(this,i,o,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(i,'" - "').concat(o,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(r=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return r.attributes};}},{name:function(t){return "has".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=d(this,o,a,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return i.attributes.hasOwnProperty(r)};}},{name:function(t){return "set".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+t,c=""+r;if(r=arguments[2],i=arguments[3],!(o=d(this,a,c,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(a,'" - "').concat(c,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(o=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return o.attributes[r]=i,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this};}},{name:function(t){return "update".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+t,c=""+r;if(r=arguments[2],i=arguments[3],!(o=d(this,a,c,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(a,'" - "').concat(c,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(o=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}if("function"!=typeof i)throw new B("Graph.".concat(e,": updater should be a function."));return o.attributes[r]=i(o.attributes[r]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this};}},{name:function(t){return "remove".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=d(this,o,a,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return delete i.attributes[r],this.emit("edgeAttributesUpdated",{key:i.key,type:"remove",attributes:i.attributes,name:r}),this};}},{name:function(t){return "replace".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=d(this,o,a,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}if(!s(r))throw new B("Graph.".concat(e,": provided attributes are not a plain object."));return i.attributes=r,this.emit("edgeAttributesUpdated",{key:i.key,type:"replace",attributes:i.attributes}),this};}},{name:function(t){return "merge".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=d(this,o,a,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}if(!s(r))throw new B("Graph.".concat(e,": provided attributes are not a plain object."));return u(i.attributes,r),this.emit("edgeAttributesUpdated",{key:i.key,type:"merge",attributes:i.attributes,data:r}),this};}},{name:function(t){return "update".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new I("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new I("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=d(this,o,a,n)))throw new F("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else {if("mixed"!==n)throw new I("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new F("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}if("function"!=typeof r)throw new B("Graph.".concat(e,": provided updater is not a function."));return i.attributes=r(i.attributes),this.emit("edgeAttributesUpdated",{key:i.key,type:"update",attributes:i.attributes}),this};}}];var Z=O,$=P,tt=function(){var t=arguments,e=null,n=-1;return new Z((function(){for(var r=null;;){if(null===e){if(++n>=t.length)return {done:true};e=$(t[n]);}if(true!==(r=e.next()).done)break;e=null;}return r}))},et=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function nt(t,e,n,r){var i=false;for(var o in e)if(o!==r){var a=e[o];if(i=n(a.key,a.attributes,a.source.key,a.target.key,a.source.attributes,a.target.attributes,a.undirected),t&&i)return a.key}}function rt(t,e,n,r){var i,o,a,c=false;for(var u in e)if(u!==r){i=e[u];do{if(o=i.source,a=i.target,c=n(i.key,i.attributes,o.key,a.key,o.attributes,a.attributes,i.undirected),t&&c)return i.key;i=i.next;}while(void 0!==i)}}function it(t,e){var n,r=Object.keys(t),i=r.length,o=0;return new O((function(){do{if(n)n=n.next;else {if(o>=i)return {done:true};var a=r[o++];if(a===e){n=void 0;continue}n=t[a];}}while(!n);return {done:false,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}}}))}function ot(t,e,n,r){var i=e[n];if(i){var o=i.source,a=i.target;return r(i.key,i.attributes,o.key,a.key,o.attributes,a.attributes,i.undirected)&&t?i.key:void 0}}function at(t,e,n,r){var i=e[n];if(i){var o=false;do{if(o=r(i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,i.target.attributes,i.undirected),t&&o)return i.key;i=i.next;}while(void 0!==i)}}function ct(t,e){var n=t[e];return void 0!==n.next?new O((function(){if(!n)return {done:true};var t={edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected};return n=n.next,{done:false,value:t}})):O.of({edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected})}function ut(t,e){if(0===t.size)return [];if("mixed"===e||e===t.type)return "function"==typeof Array.from?Array.from(t._edges.keys()):K(t._edges.keys(),t._edges.size);for(var n,r,i="undirected"===e?t.undirectedSize:t.directedSize,o=new Array(i),a="undirected"===e,c=t._edges.values(),u=0;true!==(n=c.next()).done;)(r=n.value).undirected===a&&(o[u++]=r.key);return o}function dt(t,e,n,r){if(0!==e.size)for(var i,o,a="mixed"!==n&&n!==e.type,c="undirected"===n,u=false,d=e._edges.values();true!==(i=d.next()).done;)if(o=i.value,!a||o.undirected===c){var s=o,h=s.key,p=s.attributes,f=s.source,l=s.target;if(u=r(h,p,f.key,l.key,f.attributes,l.attributes,o.undirected),t&&u)return h}}function st(t,e){if(0===t.size)return O.empty();var n="mixed"!==e&&e!==t.type,r="undirected"===e,i=t._edges.values();return new O((function(){for(var t,e;;){if((t=i.next()).done)return t;if(e=t.value,!n||e.undirected===r)break}return {value:{edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected},done:false}}))}function ht(t,e,n,r,i,o){var a,c=e?rt:nt;if("undirected"!==n){if("out"!==r&&(a=c(t,i.in,o),t&&a))return a;if("in"!==r&&(a=c(t,i.out,o,r?void 0:i.key),t&&a))return a}if("directed"!==n&&(a=c(t,i.undirected,o),t&&a))return a}function pt(t,e,n,r){var i=[];return ht(false,t,e,n,r,(function(t){i.push(t);})),i}function ft(t,e,n){var r=O.empty();return "undirected"!==t&&("out"!==e&&void 0!==n.in&&(r=tt(r,it(n.in))),"in"!==e&&void 0!==n.out&&(r=tt(r,it(n.out,e?void 0:n.key)))),"directed"!==t&&void 0!==n.undirected&&(r=tt(r,it(n.undirected))),r}function lt(t,e,n,r,i,o,a){var c,u=n?at:ot;if("undirected"!==e){if(void 0!==i.in&&"out"!==r&&(c=u(t,i.in,o,a),t&&c))return c;if(void 0!==i.out&&"in"!==r&&(r||i.key!==o)&&(c=u(t,i.out,o,a),t&&c))return c}if("directed"!==e&&void 0!==i.undirected&&(c=u(t,i.undirected,o,a),t&&c))return c}function gt(t,e,n,r,i){var o=[];return lt(false,t,e,n,r,i,(function(t){o.push(t);})),o}function yt(t,e,n,r){var i=O.empty();return "undirected"!==t&&(void 0!==n.in&&"out"!==e&&r in n.in&&(i=tt(i,ct(n.in,r))),void 0!==n.out&&"in"!==e&&r in n.out&&(e||n.key!==r)&&(i=tt(i,ct(n.out,r)))),"directed"!==t&&void 0!==n.undirected&&r in n.undirected&&(i=tt(i,ct(n.undirected,r))),i}var wt=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function vt(){this.A=null,this.B=null;}function bt(t,e,n,r,i){for(var o in r){var a=r[o],c=a.source,u=a.target,d=c===n?u:c;if(!e||!e.has(d.key)){var s=i(d.key,d.attributes);if(t&&s)return d.key}}}function mt(t,e,n,r,i){if("mixed"!==e){if("undirected"===e)return bt(t,null,r,r.undirected,i);if("string"==typeof n)return bt(t,null,r,r[n],i)}var o,a=new vt;if("undirected"!==e){if("out"!==n){if(o=bt(t,null,r,r.in,i),t&&o)return o;a.wrap(r.in);}if("in"!==n){if(o=bt(t,a,r,r.out,i),t&&o)return o;a.wrap(r.out);}}if("directed"!==e&&(o=bt(t,a,r,r.undirected,i),t&&o))return o}function kt(t,e,n){var r=Object.keys(n),i=r.length,o=0;return new O((function(){var a=null;do{if(o>=i)return t&&t.wrap(n),{done:true};var c=n[r[o++]],u=c.source,d=c.target;a=u===e?d:u,t&&t.has(a.key)&&(a=null);}while(null===a);return {done:false,value:{neighbor:a.key,attributes:a.attributes}}}))}function _t(t,e){var n=e.name,r=e.type,i=e.direction;t.prototype[n]=function(t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return [];t=""+t;var e=this._nodes.get(t);if(void 0===e)throw new F("Graph.".concat(n,': could not find the "').concat(t,'" node in the graph.'));return function(t,e,n){if("mixed"!==t){if("undirected"===t)return Object.keys(n.undirected);if("string"==typeof e)return Object.keys(n[e])}var r=[];return mt(false,t,e,n,(function(t){r.push(t);})),r}("mixed"===r?this.type:r,i,e)};}function Gt(t,e){var n=e.name,r=e.type,i=e.direction,o=n.slice(0,-1)+"Entries";t.prototype[o]=function(t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return O.empty();t=""+t;var e=this._nodes.get(t);if(void 0===e)throw new F("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));return function(t,e,n){if("mixed"!==t){if("undirected"===t)return kt(null,n,n.undirected);if("string"==typeof e)return kt(null,n,n[e])}var r=O.empty(),i=new vt;return "undirected"!==t&&("out"!==e&&(r=tt(r,kt(i,n,n.in))),"in"!==e&&(r=tt(r,kt(i,n,n.out)))),"directed"!==t&&(r=tt(r,kt(i,n,n.undirected))),r}("mixed"===r?this.type:r,i,e)};}function xt(t,e,n,r,i){for(var o,a,c,u,d,s,h,p=r._nodes.values(),f=r.type;true!==(o=p.next()).done;){var l=false;if(a=o.value,"undirected"!==f)for(c in u=a.out){d=u[c];do{if(s=d.target,l=true,h=i(a.key,s.key,a.attributes,s.attributes,d.key,d.attributes,d.undirected),t);d=d.next;}while(d)}if("directed"!==f)for(c in u=a.undirected)if(!(e&&a.key>c)){d=u[c];do{if((s=d.target).key!==c&&(s=d.source),l=true,h=i(a.key,s.key,a.attributes,s.attributes,d.key,d.attributes,d.undirected),t);d=d.next;}while(d)}if(n&&!l&&(h=i(a.key,null,a.attributes,null,null,null,null),t));}}function Et(t){if(!s(t))throw new B('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in t))throw new B("Graph.import: serialized node is missing its key.");if("attributes"in t&&(!s(t.attributes)||null===t.attributes))throw new B("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function At(t){if(!s(t))throw new B('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in t))throw new B("Graph.import: serialized edge is missing its source.");if(!("target"in t))throw new B("Graph.import: serialized edge is missing its target.");if("attributes"in t&&(!s(t.attributes)||null===t.attributes))throw new B("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in t&&"boolean"!=typeof t.undirected)throw new B("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}vt.prototype.wrap=function(t){null===this.A?this.A=t:null===this.B&&(this.B=t);},vt.prototype.has=function(t){return null!==this.A&&t in this.A||null!==this.B&&t in this.B};var Lt,St=(Lt=255&Math.floor(256*Math.random()),function(){return Lt++}),Dt=new Set(["directed","undirected","mixed"]),Ut=new Set(["domain","_events","_eventsCount","_maxListeners"]),Nt={allowSelfLoops:true,multi:false,type:"mixed"};function Ot(t,e,n){var r=new t.NodeDataClass(e,n);return t._nodes.set(e,r),t.emit("nodeAdded",{key:e,attributes:n}),r}function jt(t,e,n,r,i,o,a,c){if(!r&&"undirected"===t.type)throw new I("Graph.".concat(e,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(r&&"directed"===t.type)throw new I("Graph.".concat(e,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(c&&!s(c))throw new B("Graph.".concat(e,': invalid attributes. Expecting an object but got "').concat(c,'"'));if(o=""+o,a=""+a,c=c||{},!t.allowSelfLoops&&o===a)throw new I("Graph.".concat(e,': source & target are the same ("').concat(o,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var u=t._nodes.get(o),d=t._nodes.get(a);if(!u)throw new F("Graph.".concat(e,': source node "').concat(o,'" not found.'));if(!d)throw new F("Graph.".concat(e,': target node "').concat(a,'" not found.'));var h={key:null,undirected:r,source:o,target:a,attributes:c};if(n)i=t._edgeKeyGenerator();else if(i=""+i,t._edges.has(i))throw new I("Graph.".concat(e,': the "').concat(i,'" edge already exists in the graph.'));if(!t.multi&&(r?void 0!==u.undirected[a]:void 0!==u.out[a]))throw new I("Graph.".concat(e,': an edge linking "').concat(o,'" to "').concat(a,"\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option."));var p=new V(r,i,u,d,c);t._edges.set(i,p);var f=o===a;return r?(u.undirectedDegree++,d.undirectedDegree++,f&&(u.undirectedLoops++,t._undirectedSelfLoopCount++)):(u.outDegree++,d.inDegree++,f&&(u.directedLoops++,t._directedSelfLoopCount++)),t.multi?p.attachMulti():p.attach(),r?t._undirectedSize++:t._directedSize++,h.key=i,t.emit("edgeAdded",h),i}function Ct(t,e,n,r,i,o,a,c,d){if(!r&&"undirected"===t.type)throw new I("Graph.".concat(e,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(r&&"directed"===t.type)throw new I("Graph.".concat(e,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(c)if(d){if("function"!=typeof c)throw new B("Graph.".concat(e,': invalid updater function. Expecting a function but got "').concat(c,'"'))}else if(!s(c))throw new B("Graph.".concat(e,': invalid attributes. Expecting an object but got "').concat(c,'"'));var h;if(o=""+o,a=""+a,d&&(h=c,c=void 0),!t.allowSelfLoops&&o===a)throw new I("Graph.".concat(e,': source & target are the same ("').concat(o,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var p,f,l=t._nodes.get(o),g=t._nodes.get(a);if(!n&&(p=t._edges.get(i))){if(!(p.source.key===o&&p.target.key===a||r&&p.source.key===a&&p.target.key===o))throw new I("Graph.".concat(e,': inconsistency detected when attempting to merge the "').concat(i,'" edge with "').concat(o,'" source & "').concat(a,'" target vs. ("').concat(p.source.key,'", "').concat(p.target.key,'").'));f=p;}if(f||t.multi||!l||(f=r?l.undirected[a]:l.out[a]),f){var y=[f.key,false,false,false];if(d?!h:!c)return y;if(d){var w=f.attributes;f.attributes=h(w),t.emit("edgeAttributesUpdated",{type:"replace",key:f.key,attributes:f.attributes});}else u(f.attributes,c),t.emit("edgeAttributesUpdated",{type:"merge",key:f.key,attributes:f.attributes,data:c});return y}c=c||{},d&&h&&(c=h(c));var v={key:null,undirected:r,source:o,target:a,attributes:c};if(n)i=t._edgeKeyGenerator();else if(i=""+i,t._edges.has(i))throw new I("Graph.".concat(e,': the "').concat(i,'" edge already exists in the graph.'));var b=false,m=false;l||(l=Ot(t,o,{}),b=true,o===a&&(g=l,m=true)),g||(g=Ot(t,a,{}),m=true),p=new V(r,i,l,g,c),t._edges.set(i,p);var k=o===a;return r?(l.undirectedDegree++,g.undirectedDegree++,k&&(l.undirectedLoops++,t._undirectedSelfLoopCount++)):(l.outDegree++,g.inDegree++,k&&(l.directedLoops++,t._directedSelfLoopCount++)),t.multi?p.attachMulti():p.attach(),r?t._undirectedSize++:t._directedSize++,v.key=i,t.emit("edgeAdded",v),[i,true,b,m]}function Mt(t,e){t._edges.delete(e.key);var n=e.source,r=e.target,i=e.attributes,o=e.undirected,a=n===r;o?(n.undirectedDegree--,r.undirectedDegree--,a&&(n.undirectedLoops--,t._undirectedSelfLoopCount--)):(n.outDegree--,r.inDegree--,a&&(n.directedLoops--,t._directedSelfLoopCount--)),t.multi?e.detachMulti():e.detach(),o?t._undirectedSize--:t._directedSize--,t.emit("edgeDropped",{key:e.key,attributes:i,source:n.key,target:r.key,undirected:o});}var zt=function(n){function r(t){var e;if(e=n.call(this)||this,"boolean"!=typeof(t=u({},Nt,t)).multi)throw new B("Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"".concat(t.multi,'".'));if(!Dt.has(t.type))throw new B('Graph.constructor: invalid \'type\' option. Should be one of "mixed", "directed" or "undirected" but got "'.concat(t.type,'".'));if("boolean"!=typeof t.allowSelfLoops)throw new B("Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"".concat(t.allowSelfLoops,'".'));var r="mixed"===t.type?Y:"directed"===t.type?q:J;p(c(e),"NodeDataClass",r);var i="geid_"+St()+"_",o=0;return p(c(e),"_attributes",{}),p(c(e),"_nodes",new Map),p(c(e),"_edges",new Map),p(c(e),"_directedSize",0),p(c(e),"_undirectedSize",0),p(c(e),"_directedSelfLoopCount",0),p(c(e),"_undirectedSelfLoopCount",0),p(c(e),"_edgeKeyGenerator",(function(){var t;do{t=i+o++;}while(e._edges.has(t));return t})),p(c(e),"_options",t),Ut.forEach((function(t){return p(c(e),t,e[t])})),f(c(e),"order",(function(){return e._nodes.size})),f(c(e),"size",(function(){return e._edges.size})),f(c(e),"directedSize",(function(){return e._directedSize})),f(c(e),"undirectedSize",(function(){return e._undirectedSize})),f(c(e),"selfLoopCount",(function(){return e._directedSelfLoopCount+e._undirectedSelfLoopCount})),f(c(e),"directedSelfLoopCount",(function(){return e._directedSelfLoopCount})),f(c(e),"undirectedSelfLoopCount",(function(){return e._undirectedSelfLoopCount})),f(c(e),"multi",e._options.multi),f(c(e),"type",e._options.type),f(c(e),"allowSelfLoops",e._options.allowSelfLoops),f(c(e),"implementation",(function(){return "graphology"})),e}e(r,n);var i=r.prototype;return i._resetInstanceCounters=function(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0;},i.hasNode=function(t){return this._nodes.has(""+t)},i.hasDirectedEdge=function(t,e){if("undirected"===this.type)return  false;if(1===arguments.length){var n=""+t,r=this._edges.get(n);return !!r&&!r.undirected}if(2===arguments.length){t=""+t,e=""+e;var i=this._nodes.get(t);return !!i&&i.out.hasOwnProperty(e)}throw new B("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.hasUndirectedEdge=function(t,e){if("directed"===this.type)return  false;if(1===arguments.length){var n=""+t,r=this._edges.get(n);return !!r&&r.undirected}if(2===arguments.length){t=""+t,e=""+e;var i=this._nodes.get(t);return !!i&&i.undirected.hasOwnProperty(e)}throw new B("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.hasEdge=function(t,e){if(1===arguments.length){var n=""+t;return this._edges.has(n)}if(2===arguments.length){t=""+t,e=""+e;var r=this._nodes.get(t);return !!r&&(void 0!==r.out&&r.out.hasOwnProperty(e)||void 0!==r.undirected&&r.undirected.hasOwnProperty(e))}throw new B("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.directedEdge=function(t,e){if("undirected"!==this.type){if(t=""+t,e=""+e,this.multi)throw new I("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var n=this._nodes.get(t);if(!n)throw new F('Graph.directedEdge: could not find the "'.concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new F('Graph.directedEdge: could not find the "'.concat(e,'" target node in the graph.'));var r=n.out&&n.out[e]||void 0;return r?r.key:void 0}},i.undirectedEdge=function(t,e){if("directed"!==this.type){if(t=""+t,e=""+e,this.multi)throw new I("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var n=this._nodes.get(t);if(!n)throw new F('Graph.undirectedEdge: could not find the "'.concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new F('Graph.undirectedEdge: could not find the "'.concat(e,'" target node in the graph.'));var r=n.undirected&&n.undirected[e]||void 0;return r?r.key:void 0}},i.edge=function(t,e){if(this.multi)throw new I("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new F('Graph.edge: could not find the "'.concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new F('Graph.edge: could not find the "'.concat(e,'" target node in the graph.'));var r=n.out&&n.out[e]||n.undirected&&n.undirected[e]||void 0;if(r)return r.key},i.areDirectedNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new F('Graph.areDirectedNeighbors: could not find the "'.concat(t,'" node in the graph.'));return "undirected"!==this.type&&(e in n.in||e in n.out)},i.areOutNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new F('Graph.areOutNeighbors: could not find the "'.concat(t,'" node in the graph.'));return "undirected"!==this.type&&e in n.out},i.areInNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new F('Graph.areInNeighbors: could not find the "'.concat(t,'" node in the graph.'));return "undirected"!==this.type&&e in n.in},i.areUndirectedNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new F('Graph.areUndirectedNeighbors: could not find the "'.concat(t,'" node in the graph.'));return "directed"!==this.type&&e in n.undirected},i.areNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new F('Graph.areNeighbors: could not find the "'.concat(t,'" node in the graph.'));return "undirected"!==this.type&&(e in n.in||e in n.out)||"directed"!==this.type&&e in n.undirected},i.areInboundNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new F('Graph.areInboundNeighbors: could not find the "'.concat(t,'" node in the graph.'));return "undirected"!==this.type&&e in n.in||"directed"!==this.type&&e in n.undirected},i.areOutboundNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new F('Graph.areOutboundNeighbors: could not find the "'.concat(t,'" node in the graph.'));return "undirected"!==this.type&&e in n.out||"directed"!==this.type&&e in n.undirected},i.inDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.inDegree: could not find the "'.concat(t,'" node in the graph.'));return "undirected"===this.type?0:e.inDegree},i.outDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.outDegree: could not find the "'.concat(t,'" node in the graph.'));return "undirected"===this.type?0:e.outDegree},i.directedDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.directedDegree: could not find the "'.concat(t,'" node in the graph.'));return "undirected"===this.type?0:e.inDegree+e.outDegree},i.undirectedDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.undirectedDegree: could not find the "'.concat(t,'" node in the graph.'));return "directed"===this.type?0:e.undirectedDegree},i.inboundDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.inboundDegree: could not find the "'.concat(t,'" node in the graph.'));var n=0;return "directed"!==this.type&&(n+=e.undirectedDegree),"undirected"!==this.type&&(n+=e.inDegree),n},i.outboundDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.outboundDegree: could not find the "'.concat(t,'" node in the graph.'));var n=0;return "directed"!==this.type&&(n+=e.undirectedDegree),"undirected"!==this.type&&(n+=e.outDegree),n},i.degree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.degree: could not find the "'.concat(t,'" node in the graph.'));var n=0;return "directed"!==this.type&&(n+=e.undirectedDegree),"undirected"!==this.type&&(n+=e.inDegree+e.outDegree),n},i.inDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));return "undirected"===this.type?0:e.inDegree-e.directedLoops},i.outDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));return "undirected"===this.type?0:e.outDegree-e.directedLoops},i.directedDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));return "undirected"===this.type?0:e.inDegree+e.outDegree-2*e.directedLoops},i.undirectedDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));return "directed"===this.type?0:e.undirectedDegree-2*e.undirectedLoops},i.inboundDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));var n=0,r=0;return "directed"!==this.type&&(n+=e.undirectedDegree,r+=2*e.undirectedLoops),"undirected"!==this.type&&(n+=e.inDegree,r+=e.directedLoops),n-r},i.outboundDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));var n=0,r=0;return "directed"!==this.type&&(n+=e.undirectedDegree,r+=2*e.undirectedLoops),"undirected"!==this.type&&(n+=e.outDegree,r+=e.directedLoops),n-r},i.degreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new F('Graph.degreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));var n=0,r=0;return "directed"!==this.type&&(n+=e.undirectedDegree,r+=2*e.undirectedLoops),"undirected"!==this.type&&(n+=e.inDegree+e.outDegree,r+=2*e.directedLoops),n-r},i.source=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new F('Graph.source: could not find the "'.concat(t,'" edge in the graph.'));return e.source.key},i.target=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new F('Graph.target: could not find the "'.concat(t,'" edge in the graph.'));return e.target.key},i.extremities=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new F('Graph.extremities: could not find the "'.concat(t,'" edge in the graph.'));return [e.source.key,e.target.key]},i.opposite=function(t,e){t=""+t,e=""+e;var n=this._edges.get(e);if(!n)throw new F('Graph.opposite: could not find the "'.concat(e,'" edge in the graph.'));var r=n.source.key,i=n.target.key;if(t===r)return i;if(t===i)return r;throw new F('Graph.opposite: the "'.concat(t,'" node is not attached to the "').concat(e,'" edge (').concat(r,", ").concat(i,")."))},i.hasExtremity=function(t,e){t=""+t,e=""+e;var n=this._edges.get(t);if(!n)throw new F('Graph.hasExtremity: could not find the "'.concat(t,'" edge in the graph.'));return n.source.key===e||n.target.key===e},i.isUndirected=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new F('Graph.isUndirected: could not find the "'.concat(t,'" edge in the graph.'));return e.undirected},i.isDirected=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new F('Graph.isDirected: could not find the "'.concat(t,'" edge in the graph.'));return !e.undirected},i.isSelfLoop=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new F('Graph.isSelfLoop: could not find the "'.concat(t,'" edge in the graph.'));return e.source===e.target},i.addNode=function(t,e){var n=function(t,e,n){if(n&&!s(n))throw new B('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(n,'"'));if(e=""+e,n=n||{},t._nodes.has(e))throw new I('Graph.addNode: the "'.concat(e,'" node already exist in the graph.'));var r=new t.NodeDataClass(e,n);return t._nodes.set(e,r),t.emit("nodeAdded",{key:e,attributes:n}),r}(this,t,e);return n.key},i.mergeNode=function(t,e){if(e&&!s(e))throw new B('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(e,'"'));t=""+t,e=e||{};var n=this._nodes.get(t);return n?(e&&(u(n.attributes,e),this.emit("nodeAttributesUpdated",{type:"merge",key:t,attributes:n.attributes,data:e})),[t,false]):(n=new this.NodeDataClass(t,e),this._nodes.set(t,n),this.emit("nodeAdded",{key:t,attributes:e}),[t,true])},i.updateNode=function(t,e){if(e&&"function"!=typeof e)throw new B('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(e,'"'));t=""+t;var n=this._nodes.get(t);if(n){if(e){var r=n.attributes;n.attributes=e(r),this.emit("nodeAttributesUpdated",{type:"replace",key:t,attributes:n.attributes});}return [t,false]}var i=e?e({}):{};return n=new this.NodeDataClass(t,i),this._nodes.set(t,n),this.emit("nodeAdded",{key:t,attributes:i}),[t,true]},i.dropNode=function(t){t=""+t;var e,n=this._nodes.get(t);if(!n)throw new F('Graph.dropNode: could not find the "'.concat(t,'" node in the graph.'));if("undirected"!==this.type){for(var r in n.out){e=n.out[r];do{Mt(this,e),e=e.next;}while(e)}for(var i in n.in){e=n.in[i];do{Mt(this,e),e=e.next;}while(e)}}if("directed"!==this.type)for(var o in n.undirected){e=n.undirected[o];do{Mt(this,e),e=e.next;}while(e)}this._nodes.delete(t),this.emit("nodeDropped",{key:t,attributes:n.attributes});},i.dropEdge=function(t){var e;if(arguments.length>1){var n=""+arguments[0],r=""+arguments[1];if(!(e=d(this,n,r,this.type)))throw new F('Graph.dropEdge: could not find the "'.concat(n,'" -> "').concat(r,'" edge in the graph.'))}else if(t=""+t,!(e=this._edges.get(t)))throw new F('Graph.dropEdge: could not find the "'.concat(t,'" edge in the graph.'));return Mt(this,e),this},i.dropDirectedEdge=function(t,e){if(arguments.length<2)throw new I("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new I("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var n=d(this,t=""+t,e=""+e,"directed");if(!n)throw new F('Graph.dropDirectedEdge: could not find a "'.concat(t,'" -> "').concat(e,'" edge in the graph.'));return Mt(this,n),this},i.dropUndirectedEdge=function(t,e){if(arguments.length<2)throw new I("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new I("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var n=d(this,t,e,"undirected");if(!n)throw new F('Graph.dropUndirectedEdge: could not find a "'.concat(t,'" -> "').concat(e,'" edge in the graph.'));return Mt(this,n),this},i.clear=function(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared");},i.clearEdges=function(){for(var t,e=this._nodes.values();true!==(t=e.next()).done;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared");},i.getAttribute=function(t){return this._attributes[t]},i.getAttributes=function(){return this._attributes},i.hasAttribute=function(t){return this._attributes.hasOwnProperty(t)},i.setAttribute=function(t,e){return this._attributes[t]=e,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this},i.updateAttribute=function(t,e){if("function"!=typeof e)throw new B("Graph.updateAttribute: updater should be a function.");var n=this._attributes[t];return this._attributes[t]=e(n),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this},i.removeAttribute=function(t){return delete this._attributes[t],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:t}),this},i.replaceAttributes=function(t){if(!s(t))throw new B("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=t,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},i.mergeAttributes=function(t){if(!s(t))throw new B("Graph.mergeAttributes: provided attributes are not a plain object.");return u(this._attributes,t),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:t}),this},i.updateAttributes=function(t){if("function"!=typeof t)throw new B("Graph.updateAttributes: provided updater is not a function.");return this._attributes=t(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this},i.updateEachNodeAttributes=function(t,e){if("function"!=typeof t)throw new B("Graph.updateEachNodeAttributes: expecting an updater function.");if(e&&!l(e))throw new B("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var n,r,i=this._nodes.values();true!==(n=i.next()).done;)(r=n.value).attributes=t(r.key,r.attributes);this.emit("eachNodeAttributesUpdated",{hints:e||null});},i.updateEachEdgeAttributes=function(t,e){if("function"!=typeof t)throw new B("Graph.updateEachEdgeAttributes: expecting an updater function.");if(e&&!l(e))throw new B("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var n,r,i,o,a=this._edges.values();true!==(n=a.next()).done;)i=(r=n.value).source,o=r.target,r.attributes=t(r.key,r.attributes,i.key,o.key,i.attributes,o.attributes,r.undirected);this.emit("eachEdgeAttributesUpdated",{hints:e||null});},i.forEachAdjacencyEntry=function(t){if("function"!=typeof t)throw new B("Graph.forEachAdjacencyEntry: expecting a callback.");xt(false,false,false,this,t);},i.forEachAdjacencyEntryWithOrphans=function(t){if("function"!=typeof t)throw new B("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");xt(false,false,true,this,t);},i.forEachAssymetricAdjacencyEntry=function(t){if("function"!=typeof t)throw new B("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");xt(false,true,false,this,t);},i.forEachAssymetricAdjacencyEntryWithOrphans=function(t){if("function"!=typeof t)throw new B("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");xt(false,true,true,this,t);},i.nodes=function(){return "function"==typeof Array.from?Array.from(this._nodes.keys()):K(this._nodes.keys(),this._nodes.size)},i.forEachNode=function(t){if("function"!=typeof t)throw new B("Graph.forEachNode: expecting a callback.");for(var e,n,r=this._nodes.values();true!==(e=r.next()).done;)t((n=e.value).key,n.attributes);},i.findNode=function(t){if("function"!=typeof t)throw new B("Graph.findNode: expecting a callback.");for(var e,n,r=this._nodes.values();true!==(e=r.next()).done;)if(t((n=e.value).key,n.attributes))return n.key},i.mapNodes=function(t){if("function"!=typeof t)throw new B("Graph.mapNode: expecting a callback.");for(var e,n,r=this._nodes.values(),i=new Array(this.order),o=0;true!==(e=r.next()).done;)n=e.value,i[o++]=t(n.key,n.attributes);return i},i.someNode=function(t){if("function"!=typeof t)throw new B("Graph.someNode: expecting a callback.");for(var e,n,r=this._nodes.values();true!==(e=r.next()).done;)if(t((n=e.value).key,n.attributes))return  true;return  false},i.everyNode=function(t){if("function"!=typeof t)throw new B("Graph.everyNode: expecting a callback.");for(var e,n,r=this._nodes.values();true!==(e=r.next()).done;)if(!t((n=e.value).key,n.attributes))return  false;return  true},i.filterNodes=function(t){if("function"!=typeof t)throw new B("Graph.filterNodes: expecting a callback.");for(var e,n,r=this._nodes.values(),i=[];true!==(e=r.next()).done;)t((n=e.value).key,n.attributes)&&i.push(n.key);return i},i.reduceNodes=function(t,e){if("function"!=typeof t)throw new B("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new B("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");for(var n,r,i=e,o=this._nodes.values();true!==(n=o.next()).done;)i=t(i,(r=n.value).key,r.attributes);return i},i.nodeEntries=function(){var t=this._nodes.values();return new O((function(){var e=t.next();if(e.done)return e;var n=e.value;return {value:{node:n.key,attributes:n.attributes},done:false}}))},i.export=function(){var t=this,e=new Array(this._nodes.size),n=0;this._nodes.forEach((function(t,r){e[n++]=function(t,e){var n={key:t};return h(e.attributes)||(n.attributes=u({},e.attributes)),n}(r,t);}));var r=new Array(this._edges.size);return n=0,this._edges.forEach((function(e,i){r[n++]=function(t,e,n){var r={key:e,source:n.source.key,target:n.target.key};return h(n.attributes)||(r.attributes=u({},n.attributes)),"mixed"===t&&n.undirected&&(r.undirected=true),r}(t.type,i,e);})),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}},i.import=function(t){var e,n,i,o,a,c=this,u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t instanceof r)return t.forEachNode((function(t,e){u?c.mergeNode(t,e):c.addNode(t,e);})),t.forEachEdge((function(t,e,n,r,i,o,a){u?a?c.mergeUndirectedEdgeWithKey(t,n,r,e):c.mergeDirectedEdgeWithKey(t,n,r,e):a?c.addUndirectedEdgeWithKey(t,n,r,e):c.addDirectedEdgeWithKey(t,n,r,e);})),this;if(!s(t))throw new B("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(t.attributes){if(!s(t.attributes))throw new B("Graph.import: invalid attributes. Expecting a plain object.");u?this.mergeAttributes(t.attributes):this.replaceAttributes(t.attributes);}if(t.nodes){if(i=t.nodes,!Array.isArray(i))throw new B("Graph.import: invalid nodes. Expecting an array.");for(e=0,n=i.length;e<n;e++){Et(o=i[e]);var d=o,h=d.key,p=d.attributes;u?this.mergeNode(h,p):this.addNode(h,p);}}if(t.edges){var f=false;if("undirected"===this.type&&(f=true),i=t.edges,!Array.isArray(i))throw new B("Graph.import: invalid edges. Expecting an array.");for(e=0,n=i.length;e<n;e++){At(a=i[e]);var l=a,g=l.source,y=l.target,w=l.attributes,v=l.undirected,b=void 0===v?f:v;"key"in a?(u?b?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:b?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,a.key,g,y,w):(u?b?this.mergeUndirectedEdge:this.mergeDirectedEdge:b?this.addUndirectedEdge:this.addDirectedEdge).call(this,g,y,w);}}return this},i.nullCopy=function(t){var e=new r(u({},this._options,t));return e.replaceAttributes(u({},this.getAttributes())),e},i.emptyCopy=function(t){var e=this.nullCopy(t);return this._nodes.forEach((function(t,n){var r=u({},t.attributes);t=new e.NodeDataClass(n,r),e._nodes.set(n,t);})),e},i.copy=function(t){if("string"==typeof(t=t||{}).type&&t.type!==this.type&&"mixed"!==t.type)throw new I('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(t.type,'" because this would mean losing information about the current graph.'));if("boolean"==typeof t.multi&&t.multi!==this.multi&&true!==t.multi)throw new I("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof t.allowSelfLoops&&t.allowSelfLoops!==this.allowSelfLoops&&true!==t.allowSelfLoops)throw new I("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");for(var e,n,r=this.emptyCopy(t),i=this._edges.values();true!==(e=i.next()).done;)jt(r,"copy",false,(n=e.value).undirected,n.key,n.source.key,n.target.key,u({},n.attributes));return r},i.toJSON=function(){return this.export()},i.toString=function(){return "[object Graph]"},i.inspect=function(){var e=this,n={};this._nodes.forEach((function(t,e){n[e]=t.attributes;}));var r={},i={};this._edges.forEach((function(t,n){var o,a=t.undirected?"--":"->",c="",u=t.source.key,d=t.target.key;t.undirected&&u>d&&(o=u,u=d,d=o);var s="(".concat(u,")").concat(a,"(").concat(d,")");n.startsWith("geid_")?e.multi&&(void 0===i[s]?i[s]=0:i[s]++,c+="".concat(i[s],". ")):c+="[".concat(n,"]: "),r[c+=s]=t.attributes;}));var o={};for(var a in this)this.hasOwnProperty(a)&&!Ut.has(a)&&"function"!=typeof this[a]&&"symbol"!==t(a)&&(o[a]=this[a]);return o.attributes=this._attributes,o.nodes=n,o.edges=r,p(o,"constructor",this.constructor),o},r}(y.exports.EventEmitter);"undefined"!=typeof Symbol&&(zt.prototype[Symbol.for("nodejs.util.inspect.custom")]=zt.prototype.inspect),[{name:function(t){return "".concat(t,"Edge")},generateKey:true},{name:function(t){return "".concat(t,"DirectedEdge")},generateKey:true,type:"directed"},{name:function(t){return "".concat(t,"UndirectedEdge")},generateKey:true,type:"undirected"},{name:function(t){return "".concat(t,"EdgeWithKey")}},{name:function(t){return "".concat(t,"DirectedEdgeWithKey")},type:"directed"},{name:function(t){return "".concat(t,"UndirectedEdgeWithKey")},type:"undirected"}].forEach((function(t){["add","merge","update"].forEach((function(e){var n=t.name(e),r="add"===e?jt:Ct;t.generateKey?zt.prototype[n]=function(i,o,a){return r(this,n,true,"undirected"===(t.type||this.type),null,i,o,a,"update"===e)}:zt.prototype[n]=function(i,o,a,c){return r(this,n,false,"undirected"===(t.type||this.type),i,o,a,c,"update"===e)};}));})),function(t){Q.forEach((function(e){var n=e.name,r=e.attacher;r(t,n("Node"),0),r(t,n("Source"),1),r(t,n("Target"),2),r(t,n("Opposite"),3);}));}(zt),function(t){X.forEach((function(e){var n=e.name,r=e.attacher;r(t,n("Edge"),"mixed"),r(t,n("DirectedEdge"),"directed"),r(t,n("UndirectedEdge"),"undirected");}));}(zt),function(t){et.forEach((function(e){!function(t,e){var n=e.name,r=e.type,i=e.direction;t.prototype[n]=function(t,e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return [];if(!arguments.length)return ut(this,r);if(1===arguments.length){t=""+t;var o=this._nodes.get(t);if(void 0===o)throw new F("Graph.".concat(n,': could not find the "').concat(t,'" node in the graph.'));return pt(this.multi,"mixed"===r?this.type:r,i,o)}if(2===arguments.length){t=""+t,e=""+e;var a=this._nodes.get(t);if(!a)throw new F("Graph.".concat(n,':  could not find the "').concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new F("Graph.".concat(n,':  could not find the "').concat(e,'" target node in the graph.'));return gt(r,this.multi,i,a,e)}throw new B("Graph.".concat(n,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))};}(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[o]=function(t,e,n){if("mixed"===r||"mixed"===this.type||r===this.type){if(1===arguments.length)return dt(false,this,r,n=t);if(2===arguments.length){t=""+t,n=e;var a=this._nodes.get(t);if(void 0===a)throw new F("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));return ht(false,this.multi,"mixed"===r?this.type:r,i,a,n)}if(3===arguments.length){t=""+t,e=""+e;var c=this._nodes.get(t);if(!c)throw new F("Graph.".concat(o,':  could not find the "').concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new F("Graph.".concat(o,':  could not find the "').concat(e,'" target node in the graph.'));return lt(false,r,this.multi,i,c,e,n)}throw new B("Graph.".concat(o,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};var a="map"+n[0].toUpperCase()+n.slice(1);t.prototype[a]=function(){var t,e=Array.prototype.slice.call(arguments),n=e.pop();if(0===e.length){var i=0;"directed"!==r&&(i+=this.undirectedSize),"undirected"!==r&&(i+=this.directedSize),t=new Array(i);var a=0;e.push((function(e,r,i,o,c,u,d){t[a++]=n(e,r,i,o,c,u,d);}));}else t=[],e.push((function(e,r,i,o,a,c,u){t.push(n(e,r,i,o,a,c,u));}));return this[o].apply(this,e),t};var c="filter"+n[0].toUpperCase()+n.slice(1);t.prototype[c]=function(){var t=Array.prototype.slice.call(arguments),e=t.pop(),n=[];return t.push((function(t,r,i,o,a,c,u){e(t,r,i,o,a,c,u)&&n.push(t);})),this[o].apply(this,t),n};var u="reduce"+n[0].toUpperCase()+n.slice(1);t.prototype[u]=function(){var t,e,n=Array.prototype.slice.call(arguments);if(n.length<2||n.length>4)throw new B("Graph.".concat(u,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(n.length,")."));if("function"==typeof n[n.length-1]&&"function"!=typeof n[n.length-2])throw new B("Graph.".concat(u,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));2===n.length?(t=n[0],e=n[1],n=[]):3===n.length?(t=n[1],e=n[2],n=[n[0]]):4===n.length&&(t=n[2],e=n[3],n=[n[0],n[1]]);var r=e;return n.push((function(e,n,i,o,a,c,u){r=t(r,e,n,i,o,a,c,u);})),this[o].apply(this,n),r};}(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o="find"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[o]=function(t,e,n){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return  false;if(1===arguments.length)return dt(true,this,r,n=t);if(2===arguments.length){t=""+t,n=e;var a=this._nodes.get(t);if(void 0===a)throw new F("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));return ht(true,this.multi,"mixed"===r?this.type:r,i,a,n)}if(3===arguments.length){t=""+t,e=""+e;var c=this._nodes.get(t);if(!c)throw new F("Graph.".concat(o,':  could not find the "').concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new F("Graph.".concat(o,':  could not find the "').concat(e,'" target node in the graph.'));return lt(true,r,this.multi,i,c,e,n)}throw new B("Graph.".concat(o,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};var a="some"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[a]=function(){var t=Array.prototype.slice.call(arguments),e=t.pop();return t.push((function(t,n,r,i,o,a,c){return e(t,n,r,i,o,a,c)})),!!this[o].apply(this,t)};var c="every"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[c]=function(){var t=Array.prototype.slice.call(arguments),e=t.pop();return t.push((function(t,n,r,i,o,a,c){return !e(t,n,r,i,o,a,c)})),!this[o].apply(this,t)};}(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o=n.slice(0,-1)+"Entries";t.prototype[o]=function(t,e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return O.empty();if(!arguments.length)return st(this,r);if(1===arguments.length){t=""+t;var n=this._nodes.get(t);if(!n)throw new F("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));return ft(r,i,n)}if(2===arguments.length){t=""+t,e=""+e;var a=this._nodes.get(t);if(!a)throw new F("Graph.".concat(o,':  could not find the "').concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new F("Graph.".concat(o,':  could not find the "').concat(e,'" target node in the graph.'));return yt(r,i,a,e)}throw new B("Graph.".concat(o,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))};}(t,e);}));}(zt),function(t){wt.forEach((function(e){_t(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[o]=function(t,e){if("mixed"===r||"mixed"===this.type||r===this.type){t=""+t;var n=this._nodes.get(t);if(void 0===n)throw new F("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));mt(false,"mixed"===r?this.type:r,i,n,e);}};var a="map"+n[0].toUpperCase()+n.slice(1);t.prototype[a]=function(t,e){var n=[];return this[o](t,(function(t,r){n.push(e(t,r));})),n};var c="filter"+n[0].toUpperCase()+n.slice(1);t.prototype[c]=function(t,e){var n=[];return this[o](t,(function(t,r){e(t,r)&&n.push(t);})),n};var u="reduce"+n[0].toUpperCase()+n.slice(1);t.prototype[u]=function(t,e,n){if(arguments.length<3)throw new B("Graph.".concat(u,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));var r=n;return this[o](t,(function(t,n){r=e(r,t,n);})),r};}(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o=n[0].toUpperCase()+n.slice(1,-1),a="find"+o;t.prototype[a]=function(t,e){if("mixed"===r||"mixed"===this.type||r===this.type){t=""+t;var n=this._nodes.get(t);if(void 0===n)throw new F("Graph.".concat(a,': could not find the "').concat(t,'" node in the graph.'));return mt(true,"mixed"===r?this.type:r,i,n,e)}};var c="some"+o;t.prototype[c]=function(t,e){return !!this[a](t,e)};var u="every"+o;t.prototype[u]=function(t,e){return !this[a](t,(function(t,n){return !e(t,n)}))};}(t,e),Gt(t,e);}));}(zt);var Wt=function(t){function n(e){var n=u({type:"directed"},e);if("multi"in n&&false!==n.multi)throw new B("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==n.type)throw new B('DirectedGraph.from: inconsistent "'+n.type+'" type in given options!');return t.call(this,n)||this}return e(n,t),n}(zt),Pt=function(t){function n(e){var n=u({type:"undirected"},e);if("multi"in n&&false!==n.multi)throw new B("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==n.type)throw new B('UndirectedGraph.from: inconsistent "'+n.type+'" type in given options!');return t.call(this,n)||this}return e(n,t),n}(zt),Rt=function(t){function n(e){var n=u({multi:true},e);if("multi"in n&&true!==n.multi)throw new B("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return t.call(this,n)||this}return e(n,t),n}(zt),Kt=function(t){function n(e){var n=u({type:"directed",multi:true},e);if("multi"in n&&true!==n.multi)throw new B("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==n.type)throw new B('MultiDirectedGraph.from: inconsistent "'+n.type+'" type in given options!');return t.call(this,n)||this}return e(n,t),n}(zt),Tt=function(t){function n(e){var n=u({type:"undirected",multi:true},e);if("multi"in n&&true!==n.multi)throw new B("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==n.type)throw new B('MultiUndirectedGraph.from: inconsistent "'+n.type+'" type in given options!');return t.call(this,n)||this}return e(n,t),n}(zt);function Bt(t){t.from=function(e,n){var r=u({},e.options,n),i=new t(r);return i.import(e),i};}return Bt(zt),Bt(Wt),Bt(Pt),Bt(Rt),Bt(Kt),Bt(Tt),zt.Graph=zt,zt.DirectedGraph=Wt,zt.UndirectedGraph=Pt,zt.MultiGraph=Rt,zt.MultiDirectedGraph=Kt,zt.MultiUndirectedGraph=Tt,zt.InvalidArgumentsGraphError=B,zt.NotFoundGraphError=F,zt.UsageGraphError=I,zt}));
		
	} (graphology_umd_min$1));
	return graphology_umd_min$1.exports;
}

var graphology_umd_minExports = requireGraphology_umd_min();
const Graph = /*@__PURE__*/getDefaultExportFromCjs(graphology_umd_minExports);

var topologicalSort$1 = {};

/**
 * Graphology isGraph
 * ===================
 *
 * Very simple function aiming at ensuring the given variable is a
 * graphology instance.
 */

var isGraph;
var hasRequiredIsGraph;

function requireIsGraph () {
	if (hasRequiredIsGraph) return isGraph;
	hasRequiredIsGraph = 1;
	/**
	 * Checking the value is a graphology instance.
	 *
	 * @param  {any}     value - Target value.
	 * @return {boolean}
	 */
	isGraph = function isGraph(value) {
	  return (
	    value !== null &&
	    typeof value === 'object' &&
	    typeof value.addUndirectedEdgeWithKey === 'function' &&
	    typeof value.dropNode === 'function' &&
	    typeof value.multi === 'boolean'
	  );
	};
	return isGraph;
}

var iterables = {};

var typedArrays = {};

/**
 * Mnemonist Typed Array Helpers
 * ==============================
 *
 * Miscellaneous helpers related to typed arrays.
 */

var hasRequiredTypedArrays;

function requireTypedArrays () {
	if (hasRequiredTypedArrays) return typedArrays;
	hasRequiredTypedArrays = 1;
	(function (exports) {
		/**
		 * When using an unsigned integer array to store pointers, one might want to
		 * choose the optimal word size in regards to the actual numbers of pointers
		 * to store.
		 *
		 * This helpers does just that.
		 *
		 * @param  {number} size - Expected size of the array to map.
		 * @return {TypedArray}
		 */
		var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,
		    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,
		    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;

		var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,
		    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,
		    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;

		exports.getPointerArray = function(size) {
		  var maxIndex = size - 1;

		  if (maxIndex <= MAX_8BIT_INTEGER)
		    return Uint8Array;

		  if (maxIndex <= MAX_16BIT_INTEGER)
		    return Uint16Array;

		  if (maxIndex <= MAX_32BIT_INTEGER)
		    return Uint32Array;

		  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');
		};

		exports.getSignedPointerArray = function(size) {
		  var maxIndex = size - 1;

		  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
		    return Int8Array;

		  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
		    return Int16Array;

		  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
		    return Int32Array;

		  return Float64Array;
		};

		/**
		 * Function returning the minimal type able to represent the given number.
		 *
		 * @param  {number} value - Value to test.
		 * @return {TypedArrayClass}
		 */
		exports.getNumberType = function(value) {

		  // <= 32 bits itnteger?
		  if (value === (value | 0)) {

		    // Negative
		    if (Math.sign(value) === -1) {
		      if (value <= 127 && value >= -128)
		        return Int8Array;

		      if (value <= 32767 && value >= -32768)
		        return Int16Array;

		      return Int32Array;
		    }
		    else {

		      if (value <= 255)
		        return Uint8Array;

		      if (value <= 65535)
		        return Uint16Array;

		      return Uint32Array;
		    }
		  }

		  // 53 bits integer & floats
		  // NOTE: it's kinda hard to tell whether we could use 32bits or not...
		  return Float64Array;
		};

		/**
		 * Function returning the minimal type able to represent the given array
		 * of JavaScript numbers.
		 *
		 * @param  {array}    array  - Array to represent.
		 * @param  {function} getter - Optional getter.
		 * @return {TypedArrayClass}
		 */
		var TYPE_PRIORITY = {
		  Uint8Array: 1,
		  Int8Array: 2,
		  Uint16Array: 3,
		  Int16Array: 4,
		  Uint32Array: 5,
		  Int32Array: 6,
		  Float32Array: 7,
		  Float64Array: 8
		};

		// TODO: make this a one-shot for one value
		exports.getMinimalRepresentation = function(array, getter) {
		  var maxType = null,
		      maxPriority = 0,
		      p,
		      t,
		      v,
		      i,
		      l;

		  for (i = 0, l = array.length; i < l; i++) {
		    v = getter ? getter(array[i]) : array[i];
		    t = exports.getNumberType(v);
		    p = TYPE_PRIORITY[t.name];

		    if (p > maxPriority) {
		      maxPriority = p;
		      maxType = t;
		    }
		  }

		  return maxType;
		};

		/**
		 * Function returning whether the given value is a typed array.
		 *
		 * @param  {any} value - Value to test.
		 * @return {boolean}
		 */
		exports.isTypedArray = function(value) {
		  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);
		};

		/**
		 * Function used to concat byte arrays.
		 *
		 * @param  {...ByteArray}
		 * @return {ByteArray}
		 */
		exports.concat = function() {
		  var length = 0,
		      i,
		      o,
		      l;

		  for (i = 0, l = arguments.length; i < l; i++)
		    length += arguments[i].length;

		  var array = new (arguments[0].constructor)(length);

		  for (i = 0, o = 0; i < l; i++) {
		    array.set(arguments[i], o);
		    o += arguments[i].length;
		  }

		  return array;
		};

		/**
		 * Function used to initialize a byte array of indices.
		 *
		 * @param  {number}    length - Length of target.
		 * @return {ByteArray}
		 */
		exports.indices = function(length) {
		  var PointerArray = exports.getPointerArray(length);

		  var array = new PointerArray(length);

		  for (var i = 0; i < length; i++)
		    array[i] = i;

		  return array;
		}; 
	} (typedArrays));
	return typedArrays;
}

/**
 * Mnemonist Iterable Function
 * ============================
 *
 * Harmonized iteration helpers over mixed iterable targets.
 */

var hasRequiredIterables;

function requireIterables () {
	if (hasRequiredIterables) return iterables;
	hasRequiredIterables = 1;
	var forEach = requireForeach();

	var typed = /*@__PURE__*/ requireTypedArrays();

	/**
	 * Function used to determine whether the given object supports array-like
	 * random access.
	 *
	 * @param  {any} target - Target object.
	 * @return {boolean}
	 */
	function isArrayLike(target) {
	  return Array.isArray(target) || typed.isTypedArray(target);
	}

	/**
	 * Function used to guess the length of the structure over which we are going
	 * to iterate.
	 *
	 * @param  {any} target - Target object.
	 * @return {number|undefined}
	 */
	function guessLength(target) {
	  if (typeof target.length === 'number')
	    return target.length;

	  if (typeof target.size === 'number')
	    return target.size;

	  return;
	}

	/**
	 * Function used to convert an iterable to an array.
	 *
	 * @param  {any}   target - Iteration target.
	 * @return {array}
	 */
	function toArray(target) {
	  var l = guessLength(target);

	  var array = typeof l === 'number' ? new Array(l) : [];

	  var i = 0;

	  // TODO: we could optimize when given target is array like
	  forEach(target, function(value) {
	    array[i++] = value;
	  });

	  return array;
	}

	/**
	 * Same as above but returns a supplementary indices array.
	 *
	 * @param  {any}   target - Iteration target.
	 * @return {array}
	 */
	function toArrayWithIndices(target) {
	  var l = guessLength(target);

	  var IndexArray = typeof l === 'number' ?
	    typed.getPointerArray(l) :
	    Array;

	  var array = typeof l === 'number' ? new Array(l) : [];
	  var indices = typeof l === 'number' ? new IndexArray(l) : [];

	  var i = 0;

	  // TODO: we could optimize when given target is array like
	  forEach(target, function(value) {
	    array[i] = value;
	    indices[i] = i++;
	  });

	  return [array, indices];
	}

	/**
	 * Exporting.
	 */
	iterables.isArrayLike = isArrayLike;
	iterables.guessLength = guessLength;
	iterables.toArray = toArray;
	iterables.toArrayWithIndices = toArrayWithIndices;
	return iterables;
}

/**
 * Mnemonist FixedDeque
 * =====================
 *
 * Fixed capacity double-ended queue implemented as ring deque.
 */

var fixedDeque;
var hasRequiredFixedDeque;

function requireFixedDeque () {
	if (hasRequiredFixedDeque) return fixedDeque;
	hasRequiredFixedDeque = 1;
	var iterables = /*@__PURE__*/ requireIterables(),
	    Iterator = requireIterator();

	/**
	 * FixedDeque.
	 *
	 * @constructor
	 */
	function FixedDeque(ArrayClass, capacity) {

	  if (arguments.length < 2)
	    throw new Error('mnemonist/fixed-deque: expecting an Array class and a capacity.');

	  if (typeof capacity !== 'number' || capacity <= 0)
	    throw new Error('mnemonist/fixed-deque: `capacity` should be a positive number.');

	  this.ArrayClass = ArrayClass;
	  this.capacity = capacity;
	  this.items = new ArrayClass(this.capacity);
	  this.clear();
	}

	/**
	 * Method used to clear the structure.
	 *
	 * @return {undefined}
	 */
	FixedDeque.prototype.clear = function() {

	  // Properties
	  this.start = 0;
	  this.size = 0;
	};

	/**
	 * Method used to append a value to the deque.
	 *
	 * @param  {any}    item - Item to append.
	 * @return {number}      - Returns the new size of the deque.
	 */
	FixedDeque.prototype.push = function(item) {
	  if (this.size === this.capacity)
	    throw new Error('mnemonist/fixed-deque.push: deque capacity (' + this.capacity + ') exceeded!');

	  var index = this.start + this.size;

	  if (index >= this.capacity)
	    index -= this.capacity;

	  this.items[index] = item;

	  return ++this.size;
	};

	/**
	 * Method used to prepend a value to the deque.
	 *
	 * @param  {any}    item - Item to prepend.
	 * @return {number}      - Returns the new size of the deque.
	 */
	FixedDeque.prototype.unshift = function(item) {
	  if (this.size === this.capacity)
	    throw new Error('mnemonist/fixed-deque.unshift: deque capacity (' + this.capacity + ') exceeded!');

	  var index = this.start - 1;

	  if (this.start === 0)
	    index = this.capacity - 1;

	  this.items[index] = item;
	  this.start = index;

	  return ++this.size;
	};

	/**
	 * Method used to pop the deque.
	 *
	 * @return {any} - Returns the popped item.
	 */
	FixedDeque.prototype.pop = function() {
	  if (this.size === 0)
	    return;

	  this.size--;

	  var index = this.start + this.size;

	  if (index >= this.capacity)
	    index -= this.capacity;

	  return this.items[index];
	};

	/**
	 * Method used to shift the deque.
	 *
	 * @return {any} - Returns the shifted item.
	 */
	FixedDeque.prototype.shift = function() {
	  if (this.size === 0)
	    return;

	  var index = this.start;

	  this.size--;
	  this.start++;

	  if (this.start === this.capacity)
	    this.start = 0;

	  return this.items[index];
	};

	/**
	 * Method used to peek the first value of the deque.
	 *
	 * @return {any}
	 */
	FixedDeque.prototype.peekFirst = function() {
	  if (this.size === 0)
	    return;

	  return this.items[this.start];
	};

	/**
	 * Method used to peek the last value of the deque.
	 *
	 * @return {any}
	 */
	FixedDeque.prototype.peekLast = function() {
	  if (this.size === 0)
	    return;

	  var index = this.start + this.size - 1;

	  if (index >= this.capacity)
	    index -= this.capacity;

	  return this.items[index];
	};

	/**
	 * Method used to get the desired value of the deque.
	 *
	 * @param  {number} index
	 * @return {any}
	 */
	FixedDeque.prototype.get = function(index) {
	  if (this.size === 0 || index >= this.capacity)
	    return;

	  index = this.start + index;

	  if (index >= this.capacity)
	    index -= this.capacity;

	  return this.items[index];
	};

	/**
	 * Method used to iterate over the deque.
	 *
	 * @param  {function}  callback - Function to call for each item.
	 * @param  {object}    scope    - Optional scope.
	 * @return {undefined}
	 */
	FixedDeque.prototype.forEach = function(callback, scope) {
	  scope = arguments.length > 1 ? scope : this;

	  var c = this.capacity,
	      l = this.size,
	      i = this.start,
	      j = 0;

	  while (j < l) {
	    callback.call(scope, this.items[i], j, this);
	    i++;
	    j++;

	    if (i === c)
	      i = 0;
	  }
	};

	/**
	 * Method used to convert the deque to a JavaScript array.
	 *
	 * @return {array}
	 */
	// TODO: optional array class as argument?
	FixedDeque.prototype.toArray = function() {

	  // Optimization
	  var offset = this.start + this.size;

	  if (offset < this.capacity)
	    return this.items.slice(this.start, offset);

	  var array = new this.ArrayClass(this.size),
	      c = this.capacity,
	      l = this.size,
	      i = this.start,
	      j = 0;

	  while (j < l) {
	    array[j] = this.items[i];
	    i++;
	    j++;

	    if (i === c)
	      i = 0;
	  }

	  return array;
	};

	/**
	 * Method used to create an iterator over the deque's values.
	 *
	 * @return {Iterator}
	 */
	FixedDeque.prototype.values = function() {
	  var items = this.items,
	      c = this.capacity,
	      l = this.size,
	      i = this.start,
	      j = 0;

	  return new Iterator(function() {
	    if (j >= l)
	      return {
	        done: true
	      };

	    var value = items[i];

	    i++;
	    j++;

	    if (i === c)
	      i = 0;

	    return {
	      value: value,
	      done: false
	    };
	  });
	};

	/**
	 * Method used to create an iterator over the deque's entries.
	 *
	 * @return {Iterator}
	 */
	FixedDeque.prototype.entries = function() {
	  var items = this.items,
	      c = this.capacity,
	      l = this.size,
	      i = this.start,
	      j = 0;

	  return new Iterator(function() {
	    if (j >= l)
	      return {
	        done: true
	      };

	    var value = items[i];

	    i++;

	    if (i === c)
	      i = 0;

	    return {
	      value: [j++, value],
	      done: false
	    };
	  });
	};

	/**
	 * Attaching the #.values method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined')
	  FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;

	/**
	 * Convenience known methods.
	 */
	FixedDeque.prototype.inspect = function() {
	  var array = this.toArray();

	  array.type = this.ArrayClass.name;
	  array.capacity = this.capacity;

	  // Trick so that node displays the name of the constructor
	  Object.defineProperty(array, 'constructor', {
	    value: FixedDeque,
	    enumerable: false
	  });

	  return array;
	};

	if (typeof Symbol !== 'undefined')
	  FixedDeque.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedDeque.prototype.inspect;

	/**
	 * Static @.from function taking an arbitrary iterable & converting it into
	 * a deque.
	 *
	 * @param  {Iterable} iterable   - Target iterable.
	 * @param  {function} ArrayClass - Array class to use.
	 * @param  {number}   capacity   - Desired capacity.
	 * @return {FiniteStack}
	 */
	FixedDeque.from = function(iterable, ArrayClass, capacity) {
	  if (arguments.length < 3) {
	    capacity = iterables.guessLength(iterable);

	    if (typeof capacity !== 'number')
	      throw new Error('mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.');
	  }

	  var deque = new FixedDeque(ArrayClass, capacity);

	  if (iterables.isArrayLike(iterable)) {
	    var i, l;

	    for (i = 0, l = iterable.length; i < l; i++)
	      deque.items[i] = iterable[i];

	    deque.size = l;

	    return deque;
	  }

	  iterables.forEach(iterable, function(value) {
	    deque.push(value);
	  });

	  return deque;
	};

	/**
	 * Exporting.
	 */
	fixedDeque = FixedDeque;
	return fixedDeque;
}

/**
 * Graphology Topological Sort
 * ============================
 *
 * Function performing topological sort over the given DAG using Kahn's
 * algorithm.
 *
 * This function also works on disconnected graphs.
 *
 * [Reference]:
 * https://en.wikipedia.org/wiki/Topological_sorting
 */

var hasRequiredTopologicalSort;

function requireTopologicalSort () {
	if (hasRequiredTopologicalSort) return topologicalSort$1;
	hasRequiredTopologicalSort = 1;
	const isGraph = requireIsGraph();
	const FixedDeque = /*@__PURE__*/ requireFixedDeque();

	function simpleInDegree(graph, node) {
	  let degree = 0;

	  graph.forEachInNeighbor(node, () => {
	    degree++;
	  });

	  return degree;
	}

	function forEachNodeInTopologicalOrder(graph, callback) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/topological-sort: the given graph is not a valid graphology instance.'
	    );

	  // NOTE: falsely mixed graph representing directed graphs will work
	  if (graph.type === 'undirected' || graph.undirectedSize !== 0)
	    throw new Error(
	      'graphology-dag/topological-sort: cannot work if graph is not directed.'
	    );

	  if (graph.order === 0) return;

	  const queue = new FixedDeque(Array, graph.order);
	  const inDegrees = {};
	  let total = 0;

	  graph.forEachNode((node, attr) => {
	    const inDegree = graph.multi
	      ? simpleInDegree(graph, node)
	      : graph.inDegree(node);

	    if (inDegree === 0) {
	      queue.push([node, attr, 0]);
	    } else {
	      inDegrees[node] = inDegree;
	      total += inDegree;
	    }
	  });

	  let currentGeneration = 0;

	  function neighborCallback(neighbor, attr) {
	    const neighborInDegree = --inDegrees[neighbor];

	    total--;

	    if (neighborInDegree === 0)
	      queue.push([neighbor, attr, currentGeneration + 1]);

	    inDegrees[neighbor] = neighborInDegree;

	    // NOTE: key deletion is expensive in JS and in this case pointless so
	    // we just skip it for performance reasons
	  }

	  while (queue.size !== 0) {
	    const [node, attr, gen] = queue.shift();
	    currentGeneration = gen;

	    callback(node, attr, gen);

	    graph.forEachOutNeighbor(node, neighborCallback);
	  }

	  if (total !== 0)
	    throw new Error(
	      'graphology-dag/topological-sort: given graph is not acyclic.'
	    );
	}

	function topologicalSort(graph) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/topological-sort: the given graph is not a valid graphology instance.'
	    );

	  const sortedNodes = new Array(graph.order);
	  let i = 0;

	  forEachNodeInTopologicalOrder(graph, node => {
	    sortedNodes[i++] = node;
	  });

	  return sortedNodes;
	}

	function forEachTopologicalGeneration(graph, callback) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/topological-generations: the given graph is not a valid graphology instance.'
	    );

	  if (graph.order === 0) return;

	  let lastGenLevel = 0;
	  let lastGen = [];

	  forEachNodeInTopologicalOrder(graph, (node, _, gen) => {
	    if (gen > lastGenLevel) {
	      callback(lastGen);
	      lastGenLevel = gen;
	      lastGen = [];
	    }

	    lastGen.push(node);
	  });

	  callback(lastGen);
	}

	function topologicalGenerations(graph) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/topological-generations: the given graph is not a valid graphology instance.'
	    );

	  const generations = [];

	  forEachTopologicalGeneration(graph, generation => {
	    generations.push(generation);
	  });

	  return generations;
	}

	/**
	 * Exporting.
	 */
	topologicalSort$1.topologicalSort = topologicalSort;
	topologicalSort$1.forEachNodeInTopologicalOrder = forEachNodeInTopologicalOrder;
	topologicalSort$1.topologicalGenerations = topologicalGenerations;
	topologicalSort$1.forEachTopologicalGeneration = forEachTopologicalGeneration;
	return topologicalSort$1;
}

var topologicalSortExports = requireTopologicalSort();

/**
 * Graphology Cycle Creation Checker
 * ==================================
 *
 * Function returning whether adding the given directed edge to a DAG will
 * create a cycle.
 *
 * Note that this function requires the given graph to be a valid DAG forest
 * and will not check it beforehand for performance reasons.
 */

var willCreateCycle$1;
var hasRequiredWillCreateCycle;

function requireWillCreateCycle () {
	if (hasRequiredWillCreateCycle) return willCreateCycle$1;
	hasRequiredWillCreateCycle = 1;
	const isGraph = requireIsGraph();

	willCreateCycle$1 = function willCreateCycle(graph, source, target) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/will-create-cycle: the given graph is not a valid graphology instance.'
	    );

	  source = '' + source;
	  target = '' + target;

	  // If the edge is a self loop, it will obviously add a cycle
	  if (source === target) return true;

	  // If any of the pointed nodes isn't in the graph yet,
	  // then no cycle can be created by adding this edge
	  if (!graph.hasNode(source) || !graph.hasNode(target)) return false;

	  // Early exit for existing edge or mutual one
	  if (graph.hasDirectedEdge(source, target)) return false;
	  if (graph.hasDirectedEdge(target, source)) return true;

	  // Else, we need to assess whether a directed path between target and source
	  // can be found. We will use DFS traversal because it is usually less
	  // costly than BFS (stack vs. queue).
	  const stack = graph.outNeighbors(target);

	  function push(neighbor) {
	    // NOTE: we don't check whether pushed neighbors have not been seen
	    // because this is not necessary in a DAG. This could result in
	    // undefined behavior for cyclic graphs, ranging from infinite loop to
	    // overkill memory usage.
	    stack.push(neighbor);
	  }

	  while (stack.length !== 0) {
	    const node = stack.pop();

	    if (node === source) return true;

	    graph.forEachOutNeighbor(node, push);
	  }

	  return false;
	};
	return willCreateCycle$1;
}

var willCreateCycleExports = requireWillCreateCycle();
const willCreateCycle = /*@__PURE__*/getDefaultExportFromCjs(willCreateCycleExports);

function ensureParentsFirst(array) {
  const result = [];
  const items = [...array];
  let item;
  while (item = items.shift()) {
    let parent = item.parent;
    if (parent) {
      const ancestors = [];
      while (parent) {
        const parentIndx = items.findIndex((i) => i.id === parent);
        if (parentIndx < 0) {
          break;
        }
        const [parentItem] = items.splice(parentIndx, 1);
        if (!parentItem) {
          throw new Error("Invalid state, should not happen");
        }
        ancestors.unshift(parentItem);
        parent = parentItem.parent;
      }
      result.push(...ancestors);
    }
    result.push(item);
  }
  return result;
}
function updateChildren(nodes) {
  nodes.forEach((parent) => {
    if (parent.children.length > 0) {
      parent.children = nodes.reduce((acc, n) => {
        if (n.parent === parent.id) {
          acc.push(n.id);
        }
        return acc;
      }, []);
    }
  });
  return nodes;
}
function topologicalSort(param) {
  let nodes = ensureParentsFirst([...param.nodes.values()]);
  let edges = [...param.edges];
  if (nodes.length < 2 || edges.length === 0) {
    return {
      nodes,
      edges
    };
  }
  const getNode = (id) => nonNullable(param.nodes.get(id));
  const g = new Graph({
    multi: true,
    allowSelfLoops: true,
    type: "directed"
  });
  const enrichedEdges = C(
    edges,
    m$3((edge, __dirname) => {
      const source = getNode(edge.source), target = getNode(edge.target), parent = edge.parent ? getNode(edge.parent) : null;
      return {
        id: edge.id,
        edge,
        parent,
        source,
        target
      };
    })
    // sortBy(
    //   [prop('sourceIndex'), 'asc'],
    //   // [prop('sourceInCount'), 'asc'],
    //   // [prop('sourceLevel'), 'asc'],
    // ),
  );
  const [edgesBetweenLeafs, edgesWithCompounds] = d$3(
    enrichedEdges,
    ({ source, target }) => source.children.length === 0 && target.children.length === 0
  );
  const sortedEdges = [];
  const addEdgeToGraph = (edge) => {
    g.mergeNode(edge.source);
    g.mergeNode(edge.target);
    sortedEdges.push(edge);
    if (!willCreateCycle(g, edge.source, edge.target)) {
      g.mergeDirectedEdge(edge.source, edge.target);
    }
  };
  for (const { edge, source, target } of edgesBetweenLeafs) {
    addEdgeToGraph(edge);
    if (target.parent && target.parent !== edge.parent) {
      C(
        ancestorsOfNode(target, param.nodes),
        u$7((ancestor) => ancestor.inEdges.includes(edge.id)),
        u((ancestor) => {
          g.mergeNode(ancestor.id);
          if (!willCreateCycle(g, edge.source, ancestor.id)) {
            g.mergeDirectedEdge(edge.source, ancestor.id);
          }
          if (!willCreateCycle(g, ancestor.id, edge.target)) {
            g.mergeDirectedEdge(ancestor.id, edge.target);
          }
        })
      );
    }
    if (source.parent) {
      const sourceParent = getNode(source.parent);
      g.mergeNode(sourceParent.id);
      if (!willCreateCycle(g, sourceParent.id, source.id)) {
        g.mergeDirectedEdge(sourceParent.id, source.id);
      }
      if (target.parent && target.parent !== source.parent) {
        if (!willCreateCycle(g, sourceParent.id, target.parent)) {
          g.mergeDirectedEdge(sourceParent.id, target.parent);
        }
      }
    }
  }
  for (const { edge } of edgesWithCompounds) {
    addEdgeToGraph(edge);
  }
  invariant(sortedEdges.length === edges.length, "Not all edges were added to the graph");
  const sortedIds = topologicalSortExports.topologicalSort(g);
  let sorted = [];
  let unsorted = nodes.slice();
  for (const sortedId of sortedIds) {
    const indx = unsorted.findIndex((n) => n.id === sortedId);
    invariant(indx >= 0, `Node "${sortedId}" not found`);
    sorted.push(...unsorted.splice(indx, 1));
  }
  if (unsorted.length > 0 && sorted.length > 0) {
    sorted = sorted.flatMap((node) => {
      if (unsorted.length === 0) {
        return node;
      }
      const wereBefore = nodes.slice(0, nodes.indexOf(node)).filter((n) => unsorted.includes(n));
      if (wereBefore.length > 0) {
        unsorted = unsorted.filter((n) => !wereBefore.includes(n));
        return [...wereBefore, node];
      }
      return node;
    });
  }
  sorted.push(...unsorted);
  return {
    nodes: updateChildren(
      ensureParentsFirst(sorted)
    ),
    edges: sortedEdges
  };
}

function calcViewLayoutHash(view) {
  const tohash = {
    id: view.id,
    __: view.__ ?? "element",
    autoLayout: view.autoLayout,
    nodes: C(
      view.nodes,
      m$3(i$6(["id", "title", "description", "technology", "shape", "icon", "children"])),
      l$3(({ id, icon, ...node }) => [id, { ...node, icon: n$3(icon) ? "Y" : "N" }])
    ),
    edges: C(
      view.edges,
      m$3(i$6(["source", "target", "label", "description", "technology", "dir", "head", "tail", "line"])),
      l$3(({ source, target, ...edge }) => [`${source}:${target}`, edge])
    )
  };
  view.hash = objectHash(tohash);
  return view;
}

class AbstractMemory {
  constructor(state) {
    this.state = state;
  }
  /**
   * Provides access to context types
   * !IMPORTANT: Should not be called in runtime
   *
   * @example
   * ```ts
   *   type State = SomeMemory['Ctx']['MutableState']
   * ```
   */
  get Ctx() {
    throw new Error("Should not be called in runtime");
  }
  get elements() {
    return this.state.elements;
  }
  get explicits() {
    return this.state.explicits;
  }
  get final() {
    return this.state.final;
  }
  get connections() {
    return this.state.connections;
  }
  isEmpty() {
    return this.elements.size === 0 && this.connections.length === 0 && this.explicits.size === 0 && this.final.size === 0;
  }
}

var Connection;
((Connection2) => {
  Connection2.isInside = (fqn) => {
    return (connection) => isAncestor(fqn, connection.source.id) && isAncestor(fqn, connection.target.id);
  };
  Connection2.isDirectedBetween = (source, target) => {
    return (connection) => (connection.source.id === source || isAncestor(source, connection.source.id)) && (connection.target.id === target || isAncestor(target, connection.target.id));
  };
  Connection2.isAnyBetween = (source, target) => {
    const forward = (0, Connection2.isDirectedBetween)(source, target), backward = (0, Connection2.isDirectedBetween)(target, source);
    return (connection) => forward(connection) || backward(connection);
  };
  Connection2.isIncoming = (target) => {
    return (connection) => (connection.target.id === target || isAncestor(target, connection.target.id)) && !isAncestor(target, connection.source.id);
  };
  Connection2.isOutgoing = (source) => {
    return (connection) => (connection.source.id === source || isAncestor(source, connection.source.id)) && !isAncestor(source, connection.target.id);
  };
  Connection2.isAnyInOut = (source) => {
    const isIn = (0, Connection2.isIncoming)(source), isOut = (0, Connection2.isOutgoing)(source);
    return (connection) => isIn(connection) || isOut(connection);
  };
})(Connection || (Connection = {}));

const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");

class AbstractDeploymentElementModel {
  get style() {
    return {
      shape: DefaultElementShape,
      color: DefaultThemeColor,
      size: DefaultShapeSize,
      ...this.$node.style
    };
  }
  get shape() {
    return this.$node.style?.shape ?? DefaultElementShape;
  }
  get color() {
    return this.$node.style?.color ?? DefaultThemeColor;
  }
  get tags() {
    return this.$node.tags ?? [];
  }
  get description() {
    return this.$node.description ?? null;
  }
  get technology() {
    return this.$node.technology ?? null;
  }
  get links() {
    return this.$node.links ?? [];
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors() {
    return this.$model.ancestors(this);
  }
  /**
   * Returns the common ancestor of this element and another element.
   */
  commonAncestor(another) {
    const common = commonAncestor(this.id, another.id);
    return common ? this.$model.node(common) : null;
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  siblings() {
    return this.$model.siblings(this);
  }
  /**
   * Check if the element is a sibling of another element
   */
  isSibling(other) {
    return this.parent === other.parent;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from closest to root)
   */
  *ascendingSiblings() {
    yield* this.siblings();
    for (const ancestor of this.ancestors()) {
      yield* ancestor.siblings();
    }
    return;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from root to closest)
   */
  *descendingSiblings() {
    for (const ancestor of [...this.ancestors()].reverse()) {
      yield* ancestor.siblings();
    }
    yield* this.siblings();
    return;
  }
  incoming(filter = "all") {
    return this.$model.incoming(this, filter);
  }
  outgoing(filter = "all") {
    return this.$model.outgoing(this, filter);
  }
  *incomers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.incoming(filter)) {
      if (unique.has(r.source.id)) {
        continue;
      }
      unique.add(r.source.id);
      yield r.source;
    }
    return;
  }
  *outgoers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.outgoing(filter)) {
      if (unique.has(r.target.id)) {
        continue;
      }
      unique.add(r.target.id);
      yield r.target;
    }
    return;
  }
  /**
   * Iterate over all views that include this deployment element.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (!view.isDeploymentView()) {
        continue;
      }
      if (view.includesDeployment(this.id)) {
        yield view;
      }
    }
  }
  // type guard
  isDeploymentNode() {
    return false;
  }
  // type guard
  isInstance() {
    return false;
  }
  cachedOutgoing = null;
  cachedIncoming = null;
  get allOutgoing() {
    this.cachedOutgoing ??= RelationshipsAccum.from(
      new Set(this.outgoingModelRelationships()),
      new Set(this.outgoing())
    );
    return this.cachedOutgoing;
  }
  get allIncoming() {
    this.cachedIncoming ??= RelationshipsAccum.from(
      new Set(this.incomingModelRelationships()),
      new Set(this.incoming())
    );
    return this.cachedIncoming;
  }
}
class DeploymentNodeModel extends AbstractDeploymentElementModel {
  constructor($model, $node) {
    super();
    this.$model = $model;
    this.$node = $node;
    this.id = $node.id;
    this.title = $node.title;
    this.hierarchyLevel = hierarchyLevel($node.id);
  }
  id;
  title;
  hierarchyLevel;
  get parent() {
    return this.$model.parent(this);
  }
  get kind() {
    return this.$node.kind;
  }
  children() {
    return this.$model.children(this);
  }
  descendants(sort = "desc") {
    return this.$model.descendants(this, sort);
  }
  isDeploymentNode() {
    return true;
  }
  /**
   * Iterate over all instances nested in this deployment node.
   */
  *instances() {
    for (const nested of this.descendants("desc")) {
      if (nested.isInstance()) {
        yield nested;
      }
    }
    return;
  }
  /**
   * Returns deployed instance inside this deployment node
   * if only there are no more instances
   */
  onlyOneInstance() {
    const children = this.children();
    if (children.size !== 1) {
      return null;
    }
    const child = t$2([...children]);
    return child?.isInstance() ? child : null;
  }
  /**
   * Cached result of relationships from instances
   */
  _relationshipsFromInstances = null;
  relationshipsFromInstances() {
    if (this._relationshipsFromInstances) {
      return this._relationshipsFromInstances;
    }
    const {
      outgoing,
      incoming
    } = this._relationshipsFromInstances = {
      outgoing: /* @__PURE__ */ new Set(),
      incoming: /* @__PURE__ */ new Set()
    };
    for (const instance of this.instances()) {
      for (const r of instance.element.outgoing()) {
        outgoing.add(r);
      }
      for (const r of instance.element.incoming()) {
        incoming.add(r);
      }
    }
    return this._relationshipsFromInstances;
  }
  /**
   * We return only relationships that are not already present in nested instances
   */
  outgoingModelRelationships() {
    return this.relationshipsFromInstances().outgoing.values();
  }
  /**
   * We return only relationships that are not already present in nested instances
   */
  incomingModelRelationships() {
    return this.relationshipsFromInstances().incoming.values();
  }
  /**
   * Returns an iterator of relationships between nested instances
   */
  internalModelRelationships() {
    const {
      outgoing,
      incoming
    } = this.relationshipsFromInstances();
    return intersection(incoming, outgoing);
  }
}
class DeployedInstanceModel extends AbstractDeploymentElementModel {
  constructor($model, $instance, element) {
    super();
    this.$model = $model;
    this.$instance = $instance;
    this.element = element;
    this.id = $instance.id;
    this.title = $instance.title ?? element.title;
    this.hierarchyLevel = hierarchyLevel($instance.id);
  }
  id;
  title;
  hierarchyLevel;
  get $node() {
    return this.$instance;
  }
  get parent() {
    return nonNullable(this.$model.parent(this), `Parent of ${this.id} not found`);
  }
  get style() {
    const { icon, style } = this.element.$element;
    return {
      shape: this.element.shape,
      color: this.element.color,
      size: DefaultShapeSize,
      ...icon && { icon },
      ...style,
      ...this.$instance.style
    };
  }
  get shape() {
    return this.$instance.style?.shape ?? this.element.shape;
  }
  get color() {
    return this.$instance.style?.color ?? this.element.color;
  }
  get tags() {
    return this.$instance.tags ?? [];
  }
  get kind() {
    return this.element.kind;
  }
  get description() {
    return this.$instance.description ?? this.element.description;
  }
  get technology() {
    return this.$instance.technology ?? this.element.technology;
  }
  get links() {
    return this.$instance.links ?? this.element.links;
  }
  isInstance() {
    return true;
  }
  outgoingModelRelationships() {
    return this.element.outgoing();
  }
  incomingModelRelationships() {
    return this.element.incoming();
  }
  /**
   * Iterate over all views that include this instance.
   * (Some views may include the parent deployment node instead of the instance.)
   */
  *views() {
    for (const view of this.$model.views()) {
      if (!view.isDeploymentView()) {
        continue;
      }
      if (view.includesDeployment(this.id)) {
        yield view;
        continue;
      }
      if (view.includesDeployment(this.parent.id) && this.parent.onlyOneInstance()) {
        yield view;
      }
    }
  }
}
class NestedElementOfDeployedInstanceModel {
  constructor(instance, element) {
    this.instance = instance;
    this.element = element;
  }
  get id() {
    return this.instance.id;
  }
  get style() {
    const { icon, style } = this.element.$element;
    return {
      shape: this.element.shape,
      color: this.element.color,
      ...icon && { icon },
      ...style
    };
  }
  get shape() {
    return this.element.shape;
  }
  get color() {
    return this.element.color;
  }
  get title() {
    return this.element.title;
  }
  get description() {
    return this.element.description;
  }
  get technology() {
    return this.element.technology;
  }
  isDeploymentNode() {
    return false;
  }
  isInstance() {
    return false;
  }
}
class DeploymentRelationModel {
  constructor($model, $relationship) {
    this.$model = $model;
    this.$relationship = $relationship;
    this.source = $model.deploymentRef($relationship.source);
    this.target = $model.deploymentRef($relationship.target);
    const parent = commonAncestor(this.source.id, this.target.id);
    this.boundary = parent ? this.$model.node(parent) : null;
  }
  boundary;
  source;
  target;
  get id() {
    return this.$relationship.id;
  }
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  get title() {
    if (n(this.$relationship.title)) {
      return null;
    }
    return this.$relationship.title;
  }
  get technology() {
    if (n(this.$relationship.technology)) {
      return null;
    }
    return this.$relationship.technology;
  }
  get description() {
    if (n(this.$relationship.description)) {
      return null;
    }
    return this.$relationship.description;
  }
  get tags() {
    return this.$relationship.tags ?? [];
  }
  get kind() {
    return this.$relationship.kind ?? null;
  }
  get navigateTo() {
    return this.$relationship.navigateTo ? this.$model.$model.view(this.$relationship.navigateTo) : null;
  }
  get links() {
    return this.$relationship.links ?? [];
  }
  get color() {
    return this.$relationship.color ?? DefaultRelationshipColor;
  }
  get line() {
    return this.$relationship.line ?? DefaultLineStyle;
  }
  *views() {
    for (const view of this.$model.views()) {
      if (view.includesRelation(this.id)) {
        yield view;
      }
    }
    return;
  }
  isDeploymentRelation() {
    return true;
  }
}
class RelationshipsAccum {
  /**
   * @param model relationships from logical model
   * @param deployment relationships from deployment model
   */
  constructor(model = /* @__PURE__ */ new Set(), deployment = /* @__PURE__ */ new Set()) {
    this.model = model;
    this.deployment = deployment;
  }
  static empty() {
    return new RelationshipsAccum();
  }
  static from(model, deployment) {
    return new RelationshipsAccum(
      new Set(model),
      new Set(deployment)
    );
  }
  get isEmpty() {
    return this.model.size === 0 && this.deployment.size === 0;
  }
  get nonEmpty() {
    return this.model.size > 0 || this.deployment.size > 0;
  }
  get size() {
    return this.model.size + this.deployment.size;
  }
  /**
   * Returns new Accum containing all the elements which are both in this and otherAccum
   */
  intersect(otherAccum) {
    return RelationshipsAccum.from(
      intersection(this.model, otherAccum.model),
      intersection(this.deployment, otherAccum.deployment)
    );
  }
  /**
   * Returns new Accum containing all the elements which are both in this and otherAccum
   */
  difference(otherAccum) {
    return RelationshipsAccum.from(
      difference(this.model, otherAccum.model),
      difference(this.deployment, otherAccum.deployment)
    );
  }
  /**
   * Returns new Accum containing all the elements from both
   */
  union(otherAccum) {
    return RelationshipsAccum.from(
      union(this.model, otherAccum.model),
      union(this.deployment, otherAccum.deployment)
    );
  }
}

class DeploymentConnectionModel {
  constructor(source, target, relations) {
    this.source = source;
    this.target = target;
    this.relations = relations;
    this.id = stringHash(`deployment:${source.id}:${target.id}`);
  }
  id;
  /**
   * Human readable expression of the connection
   * Mostly used for testing and debugging
   */
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  _boundary;
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the connection.
   */
  get boundary() {
    this._boundary ??= this.source.commonAncestor(this.target);
    return this._boundary;
  }
  nonEmpty() {
    return this.relations.nonEmpty;
  }
  [customInspectSymbol](depth, inspectOptions, inspect) {
    const asString = this.toString();
    Object.defineProperty(asString, "constructor", {
      value: DeploymentConnectionModel,
      enumerable: false
    });
    return asString;
  }
  toString() {
    const model = [...this.relations.model].map((c) => "    " + c.expression);
    if (model.length) {
      model.unshift("  model:");
    } else {
      model.unshift("  model: []");
    }
    const deployment = [...this.relations.deployment].map((c) => "    " + c.expression);
    if (deployment.length) {
      deployment.unshift("  deployment:");
    } else {
      deployment.unshift("  deployment: []");
    }
    return [
      this.expression,
      ...model,
      ...deployment
    ].join("\n");
  }
  /**
   * Check if connection contains deployment relation,
   * that is directly connected to source or target.
   */
  hasDirectDeploymentRelation() {
    for (const relation of this.relations.deployment) {
      if (relation.source.id === this.source.id || relation.target.id === this.target.id) {
        return true;
      }
    }
    return false;
  }
  *values() {
    yield* this.relations.model;
    yield* this.relations.deployment;
  }
  mergeWith(other) {
    if (Array.isArray(other)) {
      return other.reduce((acc, o) => acc.mergeWith(o), this);
    }
    invariant(this.source.id === other.source.id, "Cannot merge connections with different sources");
    invariant(this.target.id === other.target.id, "Cannot merge connections with different targets");
    return new DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.union(other.relations)
    );
  }
  difference(other) {
    return new DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.difference(other.relations)
    );
  }
  intersect(other) {
    return new DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.intersect(other.relations)
    );
  }
  equals(other) {
    invariant(other instanceof DeploymentConnectionModel, "Other should ne DeploymentConnectionModel");
    return this.id === other.id && this.source.id === other.source.id && this.target.id === other.target.id && equals(this.relations.model, other.relations.model) && equals(this.relations.deployment, other.relations.deployment);
  }
  /**
   * Creates a clone of the current `DeploymentConnectionModel` instance with optional overrides.
   * if `null` is provided in overrides, the corresponding relation set will be empty.
   */
  update(overrides) {
    if (overrides) {
      overrides = {
        model: this.relations.model,
        deployment: this.relations.deployment,
        ...overrides
      };
    }
    return new DeploymentConnectionModel(
      this.source,
      this.target,
      overrides ? new RelationshipsAccum(
        overrides.model ?? /* @__PURE__ */ new Set(),
        overrides.deployment ?? /* @__PURE__ */ new Set()
      ) : this.relations
    );
  }
}

function isNestedConnection(nested, parent) {
  if (!parent) {
    const p = nested;
    return (n) => isNestedConnection(n, p);
  }
  const isSameSource = nested.source === parent.source;
  const isSameTarget = nested.target === parent.target;
  if (isSameSource && isSameTarget) {
    return false;
  }
  const isSourceNested = isAncestor(parent.source.id, nested.source.id);
  const isTargetNested = isAncestor(parent.target.id, nested.target.id);
  return isSourceNested && isTargetNested || isSameSource && isTargetNested || isSameTarget && isSourceNested;
}
function findDeepestNestedConnection(connections, connection) {
  let deepest = connection;
  for (const c of connections) {
    if (isNestedConnection(c, deepest)) {
      deepest = c;
    }
  }
  return deepest !== connection ? deepest : null;
}
function sortDeepestFirst(connections) {
  const sorted = [];
  const unsorted = connections.slice();
  let next;
  while (next = unsorted.shift()) {
    let deepest;
    while (deepest = findDeepestNestedConnection(unsorted, next)) {
      const index = unsorted.indexOf(deepest);
      sorted.push(unsorted.splice(index, 1)[0]);
    }
    sorted.push(next);
  }
  return sorted;
}
const boundaryHierarchy = (conn) => conn.boundary?.id ? `.${conn.boundary.id}` : "";
function sortConnectionsByBoundaryHierarchy(connections, sort) {
  if (!connections || isString(connections)) {
    const dir = connections ?? "asc";
    return (arr) => _sortByBoundary(arr, dir);
  }
  return _sortByBoundary(connections, sort ?? "asc");
}
function _sortByBoundary(connections, order) {
  return C(
    connections,
    m$3((conn) => ({
      id: boundaryHierarchy(conn),
      conn
    })),
    sortNaturalByFqn(order),
    m$3(p$1("conn"))
  );
}
function findAscendingConnections(connections, connection) {
  return connections.filter((c) => isNestedConnection(connection, c));
}
function findDescendantConnections(connections, connection) {
  return connections.filter(isNestedConnection(connection));
}
function mergeConnections(connections) {
  const map2 = /* @__PURE__ */ new Map();
  for (const conn of connections) {
    const existing = map2.get(conn.id);
    if (existing) {
      map2.set(conn.id, conn.mergeWith(existing));
    } else {
      map2.set(conn.id, conn);
    }
  }
  return [...map2.values()];
}
function differenceConnections(source, exclude) {
  const minus = new Map([...exclude].map((c) => [c.id, c]));
  return [...source].reduce((acc, c) => {
    const other = minus.get(c.id);
    if (!other) {
      acc.push(c);
      return acc;
    }
    const updated = c.difference(other);
    if (updated.nonEmpty()) {
      acc.push(updated);
    }
    return acc;
  }, []);
}
function hasSameSourceTarget(a, b) {
  if (b) {
    return a.source === b.source && a.target === b.target;
  }
  return (b2) => a.source === b2.source && a.target === b2.target;
}
function hasSameSource(a, b) {
  if (b) {
    return a.source === b.source;
  }
  return (b2) => a.source === b2.source;
}
function hasSameTarget(a, b) {
  if (b) {
    return a.target === b.target;
  }
  return (b2) => a.target === b2.target;
}
function isOutgoing(a, source) {
  if (!source) {
    const _source = a;
    return (b) => isOutgoing(b, _source);
  }
  const at = a;
  return isDescendantOf(at.source, source) && !isDescendantOf(at.target, source);
}
function isIncoming(a, target) {
  if (!target) {
    const _target = a;
    return (b) => isIncoming(b, _target);
  }
  const at = a;
  return isDescendantOf(at.target, target) && !isDescendantOf(at.source, target);
}
function isAnyInOut(a, source) {
  if (!source) {
    const _source = a;
    return (b) => isAnyInOut(b, _source);
  }
  const at = a;
  return isDescendantOf(at.source, source) !== isDescendantOf(at.target, source);
}

function findConnection$1(source, target, direction = "directed") {
  if (source === target) {
    return [];
  }
  if (isSameHierarchy(source, target)) {
    return [];
  }
  const directedIntersection = intersection(source.allOutgoing, target.allIncoming);
  const directed = directedIntersection.size > 0 ? new ConnectionModel(
    source,
    target,
    directedIntersection
  ) : null;
  if (direction === "directed") {
    return directed ? [directed] : [];
  }
  const reverseIntersection = intersection(source.allIncoming, target.allOutgoing);
  const reverse = reverseIntersection.size > 0 ? new ConnectionModel(
    target,
    source,
    reverseIntersection
  ) : null;
  if (directed && reverse) {
    return [directed, reverse];
  }
  if (directed) {
    return [directed];
  }
  if (reverse) {
    return [reverse];
  }
  return [];
}
function findConnectionsBetween$1(element, others, direction = "both") {
  if (element.allIncoming.size === 0 && element.allOutgoing.size === 0) {
    return [];
  }
  const outgoing = [];
  const incoming = [];
  for (const _other of others) {
    if (element === _other) {
      continue;
    }
    for (const found of findConnection$1(element, _other, direction)) {
      if (found.source === element) {
        outgoing.push(found);
      } else {
        incoming.push(found);
      }
    }
  }
  return [
    ...outgoing,
    ...incoming
  ];
}
function findConnectionsWithin$1(elements) {
  return [...elements].reduce((acc, el, index, array) => {
    if (index === array.length - 1) {
      return acc;
    }
    acc.push(
      ...findConnectionsBetween$1(el, array.slice(index + 1), "both")
    );
    return acc;
  }, []);
}

const find$1 = {
  __proto__: null,
  findConnection: findConnection$1,
  findConnectionsBetween: findConnectionsBetween$1,
  findConnectionsWithin: findConnectionsWithin$1
};

class ConnectionModel {
  constructor(source, target, relations = /* @__PURE__ */ new Set()) {
    this.source = source;
    this.target = target;
    this.relations = relations;
    this.id = stringHash(`model:${source.id}:${target.id}`);
  }
  id;
  _boundary;
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the connection.
   */
  get boundary() {
    return this._boundary ??= this.source.commonAncestor(this.target);
  }
  /**
   * Human readable expression of the connection
   * Mostly used for testing and debugging
   */
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  /**
   * Returns true if only includes relations between the source and target elements.
   */
  get isDirect() {
    return this.nonEmpty() && !this.isImplicit;
  }
  /**
   * Returns true if includes relations between nested elements of the source and target elements.
   */
  get isImplicit() {
    return this.nonEmpty() && isome(this.relations, o$8(hasSameSourceTarget(this)));
  }
  get directRelations() {
    return new Set(ifilter(this.relations, hasSameSourceTarget(this)));
  }
  nonEmpty() {
    return this.relations.size > 0;
  }
  mergeWith(other) {
    invariant(this.source.id === other.source.id, "Cannot merge connections with different sources");
    invariant(this.target.id === other.target.id, "Cannot merge connections with different targets");
    return new ConnectionModel(
      this.source,
      this.target,
      union(this.relations, other.relations)
    );
  }
  difference(other) {
    return new ConnectionModel(
      this.source,
      this.target,
      difference(this.relations, other.relations)
    );
  }
  intersect(other) {
    invariant(other instanceof ConnectionModel, "Cannot intersect connection with different type");
    return new ConnectionModel(
      this.source,
      this.target,
      intersection(this.relations, other.relations)
    );
  }
  equals(other) {
    invariant(other instanceof ConnectionModel, "Cannot merge connection with different type");
    return this.id === other.id && this.source.id === other.source.id && this.target.id === other.target.id && equals(this.relations, other.relations);
  }
  /**
   * Returns a new instance with the updated relations.
   *
   * @param relations - A readonly set of `RelationshipModel` instances representing the new relations.
   * @returns A new `ConnectionModel` instance with the updated relations.
   */
  update(relations) {
    return new ConnectionModel(
      this.source,
      this.target,
      relations
    );
  }
  [customInspectSymbol](depth, inspectOptions, inspect) {
    const asString = this.toString();
    Object.defineProperty(asString, "constructor", {
      value: ConnectionModel,
      enumerable: false
    });
    return asString;
  }
  toString() {
    return [
      this.expression,
      this.relations.size ? "  relations:" : "  relations: [ ]",
      ...[...this.relations].map((c) => "    " + c.expression)
    ].join("\n");
  }
  /**
   * Creates a new connection with reversed direction (target becomes source and vice versa)
   * @param search - When true, attempts to find an existing connection between the reversed nodes
   */
  reversed(search = false) {
    if (!search) {
      return new ConnectionModel(this.target, this.source);
    }
    const [found] = findConnection$1(this.target, this.source, "directed");
    return found ?? new ConnectionModel(this.target, this.source, /* @__PURE__ */ new Set());
  }
}

function findConnection(source, target, direction = "directed") {
  if (source === target) {
    return [];
  }
  if (isSameHierarchy(source, target)) {
    return [];
  }
  const directedIntersection = source.allOutgoing.intersect(target.allIncoming);
  const directed = directedIntersection.nonEmpty ? [
    new DeploymentConnectionModel(
      source,
      target,
      directedIntersection
    )
  ] : [];
  if (direction === "directed") {
    return directed;
  }
  return [
    ...directed,
    ...findConnection(target, source, "directed")
  ];
}
function findConnectionsBetween(element, others, direction = "both") {
  if (element.allIncoming.isEmpty && element.allOutgoing.isEmpty) {
    return [];
  }
  const outgoing = [];
  const incoming = [];
  for (const _other of others) {
    if (element === _other) {
      continue;
    }
    for (const found of findConnection(element, _other, direction)) {
      if (found.source === element) {
        outgoing.push(found);
      } else {
        incoming.push(found);
      }
    }
  }
  return [
    ...outgoing,
    ...incoming
  ];
}
function findConnectionsWithin(elements) {
  return [...elements].reduce((acc, el, index, array) => {
    if (index === array.length - 1) {
      return acc;
    }
    acc.push(
      ...findConnectionsBetween(el, array.slice(index + 1), "both")
    );
    return acc;
  }, []);
}

const find = {
  __proto__: null,
  findConnection: findConnection,
  findConnectionsBetween: findConnectionsBetween,
  findConnectionsWithin: findConnectionsWithin
};

class AbstractStageExclude {
  constructor(memory, expression) {
    this.memory = memory;
    this.expression = expression;
  }
  // Removed elements
  excluded = {
    elements: /* @__PURE__ */ new Set(),
    connections: []
  };
  markedToMoveExplicitToImplicit = false;
  _removeElement(element) {
    this.excluded.elements.add(element);
  }
  exclude(element) {
    if (!element) {
      return this;
    }
    if (isIterable(element)) {
      for (const el of element) {
        this._removeElement(el);
      }
      return this;
    }
    this._removeElement(element);
    return this;
  }
  _removeConnection(connection) {
    this.excluded.connections.push(connection);
  }
  /**
   * Excludes from the memory relationships from given connections (still connection may be included, but without given relationships)
   * @param moveExplicitToImplicit - if true, disconnected explicit elements will be moved to implicit
   * @default false
   */
  excludeConnections(connection, moveExplicitToImplicit) {
    if (e(moveExplicitToImplicit)) {
      invariant(!this.markedToMoveExplicitToImplicit, "Already marked to move explicits");
      this.markedToMoveExplicitToImplicit = moveExplicitToImplicit;
    }
    if (isIterable(connection)) {
      for (const c of connection) {
        this._removeConnection(c);
      }
      return this;
    }
    this._removeConnection(connection);
    return this;
  }
  isDirty() {
    return this.excluded.elements.size > 0 || this.excluded.connections.length > 0;
  }
  isEmpty() {
    return !this.isDirty();
  }
  /**
   * Determines whether disconnected explicits should become implicits.
   * By default moves all disconnected explicits to implicits, if there were operation to exclude elements.
   *
   * Override this method to change the behavior.
   */
  filterForMoveToImplicits(disconnectedExplicits) {
    if (this.markedToMoveExplicitToImplicit || this.excluded.elements.size > 0) {
      return disconnectedExplicits;
    }
    return /* @__PURE__ */ new Set();
  }
  // Check if Leaf EXPLICIT elements are becoming IMPLICIT
  // (it means that they are not connected anymore)
  moveDisconnectedExplicitsToImplicits(state) {
    let disconnected = difference(
      new Set(this.memory.connections.flatMap((c) => [c.source, c.target])),
      new Set(state.connections.flatMap((c) => [c.source, c.target]))
    );
    disconnected = intersection(
      disconnected,
      state.elements
    );
    disconnected = C(
      disconnected,
      ifilter((el) => {
        return state.explicits.has(el) && !isome(state.final, isDescendantOf(el));
      }),
      toSet()
    );
    if (disconnected.size > 0) {
      disconnected = this.filterForMoveToImplicits(disconnected);
      state.explicits = difference(state.explicits, disconnected);
      state.final = difference(state.final, disconnected);
    }
    return state;
  }
  removeElements(state) {
    state.elements = difference(state.elements, this.excluded.elements);
    state.explicits = difference(state.explicits, this.excluded.elements);
    state.final = difference(state.final, this.excluded.elements);
    return state;
  }
  removeConnections(state) {
    const excludedMap = this.excluded.connections.reduce((acc, c) => {
      const existing = acc.get(c.id);
      if (existing) {
        acc.set(c.id, existing.mergeWith(c));
      } else {
        acc.set(c.id, c);
      }
      return acc;
    }, /* @__PURE__ */ new Map());
    let disconnected = /* @__PURE__ */ new Set();
    state.connections = state.connections.reduce((acc, c) => {
      const excluded = excludedMap.get(c.id);
      if (excluded) {
        disconnected.add(c.source);
        disconnected.add(c.target);
        const diff = c.difference(excluded);
        if (diff.nonEmpty()) {
          acc.push(diff);
        }
      } else {
        acc.push(c);
      }
      return acc;
    }, []);
    for (const stillExists of state.connections) {
      disconnected.delete(stillExists.source);
      disconnected.delete(stillExists.target);
      if (stillExists.boundary && state.elements.has(stillExists.boundary)) {
        disconnected.delete(stillExists.boundary);
      }
    }
    if (disconnected.size === 0) {
      return state;
    }
    disconnected = difference(disconnected, state.explicits);
    state.final = difference(state.final, disconnected);
    return state;
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    return state;
  }
  /**
   * Postcommit hook
   */
  postcommit(state) {
    invariant(difference(state.explicits, state.elements).size === 0, "Explicits must be subset of elements");
    invariant(difference(state.final, state.elements).size === 0, "Final elements must be subset of elements");
    return state;
  }
  commit() {
    let state = this.precommit(this.memory.mutableState());
    if (this.excluded.elements.size > 0) {
      const excludedConnections = state.connections.filter((c) => this.excluded.elements.has(c.source) || this.excluded.elements.has(c.target)).flatMap((c) => [
        c,
        ...findAscendingConnections(state.connections, c).map((asc) => asc.intersect(c))
      ]).filter((asc) => asc.nonEmpty());
      this.excludeConnections(excludedConnections);
    }
    if (this.excluded.connections.length > 0) {
      state = this.removeConnections(state);
    }
    if (this.excluded.elements.size > 0) {
      state = this.removeElements(state);
    }
    return this.memory.update(this.postcommit(state));
  }
}

class AbstractStageInclude {
  constructor(memory, expression) {
    this.memory = memory;
    this.expression = expression;
  }
  // New elements
  explicits = /* @__PURE__ */ new Set();
  implicits = /* @__PURE__ */ new Set();
  // Ordered Set of explicit and implicit elements
  _ordered = /* @__PURE__ */ new Set();
  _connections = [];
  get elements() {
    return this.explicits;
  }
  /**
   * Connections from this stage
   */
  get connections() {
    return this._connections;
  }
  mergedConnections() {
    return mergeConnections([
      ...this.memory.connections,
      ...this._connections
    ]);
  }
  connectWithExisting(_element, _direction) {
    throw new Error("Method not implements, depends on the model");
  }
  /**
   * Possible to override
   */
  _addExplicit(elements) {
    this._ordered.add(elements);
    this.explicits.add(elements);
    this.implicits.delete(elements);
  }
  addExplicit(element) {
    if (!element) {
      return this;
    }
    if (isIterable(element)) {
      for (const el of element) {
        this._addExplicit(el);
      }
      return this;
    }
    this._addExplicit(element);
    return this;
  }
  /**
   * Possible to override
   */
  _addImplicit(elements) {
    if (this.explicits.has(elements)) {
      return;
    }
    this._ordered.add(elements);
    this.implicits.add(elements);
  }
  addImplicit(elements) {
    if (!elements) {
      return this;
    }
    if (isIterable(elements)) {
      for (const el of elements) {
        this._addImplicit(el);
      }
      return this;
    }
    this._addImplicit(elements);
    return this;
  }
  /**
   * Possible to override
   */
  _addConnection(connection) {
    this._connections.push(connection);
    this._addImplicit(connection.source);
    this._addImplicit(connection.target);
  }
  addConnections(connection) {
    if (isIterable(connection)) {
      for (const c of connection) {
        this._addConnection(c);
      }
      return this;
    }
    this._addConnection(connection);
    return this;
  }
  isDirty() {
    return this.explicits.size > 0 || this.implicits.size > 0 || this._connections.length > 0;
  }
  isEmpty() {
    return !this.isDirty();
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    return state;
  }
  /**
   * Postcommit hook
   */
  postcommit(state) {
    return state;
  }
  processConnections(connections) {
    return connections;
  }
  commit() {
    let state = this.precommit(this.memory.mutableState());
    let fromConnections = /* @__PURE__ */ new Set();
    if (this._connections.length > 0) {
      const [fromKnown, rest] = d$3(
        this._connections,
        (c) => state.final.has(c.source)
      );
      state.connections = this.processConnections(
        mergeConnections([
          ...state.connections,
          ...fromKnown,
          ...rest
        ])
      );
      fromConnections = new Set(state.connections.flatMap((c) => [c.source, c.target]));
    }
    state.elements = union(
      state.elements,
      this._ordered,
      this.explicits,
      fromConnections,
      this.implicits
    );
    state.explicits = intersection(
      state.elements,
      union(
        state.explicits,
        this.explicits
      )
    );
    state.final = intersection(
      state.elements,
      union(
        state.final,
        this.explicits,
        fromConnections
      )
    );
    return this.memory.update(this.postcommit(state));
  }
}

function treeFromMemoryState(memory, filter = "final") {
  const sorted = sortParentsFirst(toArray(filter === "final" ? memory.final : memory.elements));
  const connected = new Set(memory.connections.flatMap((c) => [c.source, c.target]));
  const root = new Set(sorted);
  const parents = new DefaultMap(() => null);
  const children = sorted.reduce((acc, parent, index, all) => {
    acc.set(
      parent,
      all.slice(index + 1).filter((e) => isAncestor(parent, e)).map((e) => {
        root.delete(e);
        return e;
      }).reduce((acc2, el) => {
        if (!acc2.some((e) => isAncestor(e, el))) {
          acc2.push(el);
          parents.set(el, parent);
        }
        return acc2;
      }, [])
    );
    return acc;
  }, new DefaultMap(() => []));
  return {
    root,
    connected,
    hasInOut: (el) => memory.connections.some(Connection.isAnyInOut(el.id)),
    parent: (el) => parents.get(el),
    children: (el) => children.get(el)
  };
}

let StageExclude$1 = class StageExclude extends AbstractStageExclude {
};

T((c) => c.nonEmpty());
function findCrossBoundarySameSourceOrTarget(connections) {
  const groupedByRelation = new DefaultMap(() => []);
  for (const conn of connections) {
    for (const relation of conn.relations.model) {
      groupedByRelation.get(relation).push(conn);
    }
  }
  const excludedRelations = new DefaultMap(() => /* @__PURE__ */ new Set());
  for (const [relation, sameRelationGroup] of groupedByRelation) {
    if (!i$9(sameRelationGroup, 2)) {
      continue;
    }
    C(
      sameRelationGroup,
      u$1((conn) => [
        { group: `$source-${conn.source.id}`, conn },
        { group: `$target-${conn.target.id}`, conn }
      ]),
      i$2(p$1("group")),
      r$3(),
      T(i$9(2)),
      u(
        // In each group, sort by hierarchy, first are deepest
        i$4(
          m$3(p$1("conn")),
          sortConnectionsByBoundaryHierarchy("desc"),
          // Drop first, as it is the deepest
          // Drop if boundary is same as previous
          m((conn, i, all) => i === 0 || conn.boundary === all[i - 1].boundary),
          // Drop relations from boundaries above
          u((conn) => {
            excludedRelations.get(conn).add(relation);
          })
        )
      )
    );
  }
  return excludedRelations;
}
function findCrossBoundaryConnections(connections) {
  connections = mergeConnections(connections);
  const excludedRelations = findCrossBoundarySameSourceOrTarget(connections);
  for (const c of connections) {
    const { source, target } = c;
    const connectionModelRelations = c.relations.model;
    if (source.isDeploymentNode() !== target.isDeploymentNode()) {
      const node = source.isDeploymentNode() ? source : c.target;
      invariant(node.isDeploymentNode());
      const nodeInternals = node.internalModelRelationships();
      const toExclude = intersection(
        connectionModelRelations,
        nodeInternals
      );
      for (const relation of toExclude) {
        excludedRelations.get(c).add(relation);
      }
      continue;
    }
    if (source.isDeploymentNode() && target.isDeploymentNode()) {
      const toExclude = union(
        // Exclude node internals (otherwise thay are cross-boundary)
        intersection(
          c.relations.model,
          source.internalModelRelationships()
        ),
        intersection(
          c.relations.model,
          target.internalModelRelationships()
        )
      );
      for (const relation of toExclude) {
        excludedRelations.get(c).add(relation);
      }
    }
  }
  return C(
    excludedRelations.entries(),
    imap(
      ([c, excluded]) => c.update({
        model: excluded,
        deployment: null
      })
    ),
    toArray()
  );
}
function cleanCrossBoundary(connections) {
  return differenceConnections(
    connections,
    findCrossBoundaryConnections(connections)
  );
}
function findRedundantConnections$1(connections) {
  return C(
    connections,
    mergeConnections,
    l$5((redundants, connection) => {
      const { source, target, relations } = connection;
      if (source.isInstance() && target.isInstance()) {
        return redundants;
      }
      let redundantAccum = RelationshipsAccum.empty();
      if (source.isDeploymentNode() && target.isDeploymentNode()) {
        const [reversed] = findConnection(target, source, "directed");
        if (reversed) {
          redundantAccum = relations.intersect(reversed.relations);
        }
      }
      for (const c of connections) {
        if (isNestedConnection(c, connection)) {
          redundantAccum = redundantAccum.union(
            relations.intersect(c.relations)
          );
        }
      }
      if (redundantAccum.nonEmpty) {
        redundants.push(
          new DeploymentConnectionModel(
            source,
            target,
            redundantAccum
          )
        );
      }
      return redundants;
    }, [])
  );
}
function cleanRedundantRelationships(connections) {
  return differenceConnections(
    connections,
    findRedundantConnections$1(connections)
  );
}

let StageInclude$1 = class StageInclude extends AbstractStageInclude {
  /**
   * Connects elements with existing ones in the memory
   */
  connectWithExisting(elements, direction = "both") {
    const before = this._connections.length;
    const hasChanged = () => this._connections.length > before;
    if (!isIterable(elements)) {
      if (direction === "in" || direction === "both") {
        for (const el of this.memory.elements) {
          this.addConnections(
            findConnection(el, elements, "directed")
          );
        }
      }
      if (direction === "out" || direction === "both") {
        this.addConnections(
          findConnectionsBetween(elements, this.memory.elements, "directed")
        );
      }
      return hasChanged();
    }
    const targets = [...elements];
    if (direction === "in" || direction === "both") {
      for (const el of this.memory.elements) {
        this.addConnections(
          findConnectionsBetween(el, targets, "directed")
        );
      }
    }
    if (direction === "out" || direction === "both") {
      for (const el of targets) {
        this.addConnections(
          findConnectionsBetween(el, this.memory.elements, "directed")
        );
      }
    }
    return hasChanged();
  }
  processConnections(connections) {
    const clean = C(
      connections,
      cleanCrossBoundary,
      cleanRedundantRelationships
    );
    C(
      clean,
      // Process only connection from this stage
      // filter(c => this._connections.some(c2 => c2.id === c.id)),
      u(({ source, target, boundary }) => {
        C(
          d$6(
            [...toArray(source.ancestors()).reverse(), source],
            [...toArray(target.ancestors()).reverse(), target]
          ),
          // Filter out common ancestors
          m(([sourceAncestor, targetAncestor]) => sourceAncestor === targetAncestor),
          l$6(1),
          u(([sourceAncestor, targetAncestor]) => {
            if (source === sourceAncestor && target === targetAncestor) {
              this.addImplicit(boundary);
              return;
            }
            if (sourceAncestor !== source && sourceAncestor.isDeploymentNode() && !sourceAncestor.onlyOneInstance()) {
              this.addImplicit(sourceAncestor);
            }
            if (targetAncestor !== target && targetAncestor.isDeploymentNode() && !targetAncestor.onlyOneInstance()) {
              this.addImplicit(targetAncestor);
            }
          })
        );
      })
    );
    return clean;
  }
};

let Memory$1 = class Memory extends AbstractMemory {
  static empty() {
    return new Memory({
      elements: /* @__PURE__ */ new Set(),
      explicits: /* @__PURE__ */ new Set(),
      final: /* @__PURE__ */ new Set(),
      connections: []
    });
  }
  stageInclude(expr) {
    return new StageInclude$1(this, expr);
  }
  stageExclude(expr) {
    return new StageExclude$1(this, expr);
  }
  mutableState() {
    return {
      elements: new Set(this.state.elements),
      explicits: new Set(this.state.explicits),
      final: new Set(this.state.final),
      connections: [...this.state.connections]
    };
  }
  update(newstate) {
    return new Memory({
      ...this.state,
      ...newstate
    });
  }
  equals(other) {
    return other instanceof Memory && k(this.state, other.state);
  }
  diff(state) {
    const current = this;
    return {
      added: {
        elements: toArray(difference(state.elements, current.elements)),
        explicits: toArray(difference(state.explicits, current.explicits)),
        final: toArray(difference(state.final, current.final)),
        connections: toArray(differenceConnections(state.connections, current.connections))
      },
      removed: {
        elements: toArray(difference(current.elements, state.elements)),
        explicits: toArray(difference(current.explicits, state.explicits)),
        final: toArray(difference(current.final, state.final)),
        connections: differenceConnections(current.connections, state.connections)
      }
    };
  }
  toString() {
    return [
      "final:",
      ...[...this.final].map((e) => "  " + e.id),
      "connections:",
      ...this.connections.map((c) => "  " + c.expression)
    ].join("\n");
  }
  [customInspectSymbol](_depth, _inspectOptions, _inspect) {
    const asString = this.toString();
    return asString;
  }
};

function elementExprToPredicate(target) {
  if (ModelLayer.FqnExpr.isCustom(target)) {
    return elementExprToPredicate(target.custom.expr);
  }
  if (ModelLayer.FqnExpr.isWhere(target)) {
    const predicate = elementExprToPredicate(target.where.expr);
    const where = whereOperatorAsPredicate(target.where.condition);
    return (n) => predicate(n) && where(n);
  }
  if (ModelLayer.FqnExpr.isElementKindExpr(target)) {
    return target.isEqual ? (n) => n.kind === target.elementKind : (n) => n.kind !== target.elementKind;
  }
  if (ModelLayer.FqnExpr.isElementTagExpr(target)) {
    return target.isEqual ? ({ tags }) => !!tags && tags.includes(target.elementTag) : ({ tags }) => n$4(tags) || !tags.includes(target.elementTag);
  }
  if (ModelLayer.FqnExpr.isWildcard(target)) {
    return () => true;
  }
  if (ModelLayer.FqnExpr.isModelRef(target)) {
    const fqn = ModelLayer.FqnRef.toFqn(target.ref);
    if (target.selector === "expanded") {
      return (n) => {
        return n.id === fqn || parentFqn(n.id) === fqn;
      };
    }
    if (target.selector === "descendants" || target.selector === "children") {
      const fqnWithDot = fqn + ".";
      return (n) => {
        return n.id.startsWith(fqnWithDot);
      };
    }
    return (n) => {
      return n.id === fqn;
    };
  }
  nonexhaustive(target);
}

function applyViewRuleStyle(rule, predicates, nodes) {
  C(
    nodes,
    T(o$8(ComputedNode.isNodesGroup)),
    T(y$2(predicates)),
    u((n) => {
      n.shape = rule.style.shape ?? n.shape;
      n.color = rule.style.color ?? n.color;
      if (n$5(rule.style.icon)) {
        n.icon = rule.style.icon;
      }
      if (n$5(rule.notation)) {
        n.notation = rule.notation;
      }
      let styleOverride;
      if (n$5(rule.style.border)) {
        styleOverride = { border: rule.style.border };
      }
      if (n$5(rule.style.opacity)) {
        styleOverride = { ...styleOverride, opacity: rule.style.opacity };
      }
      if (n$5(rule.style.multiple)) {
        styleOverride = { ...styleOverride, multiple: rule.style.multiple };
      }
      if (n$5(rule.style.padding)) {
        styleOverride = { ...styleOverride, padding: rule.style.padding };
      }
      if (n$5(rule.style.size)) {
        styleOverride = { ...styleOverride, size: rule.style.size };
      }
      if (n$5(rule.style.textSize)) {
        styleOverride = { ...styleOverride, textSize: rule.style.textSize };
      }
      if (styleOverride) {
        n.style = {
          ...n.style,
          ...styleOverride
        };
      }
    })
  );
}
function applyViewRuleStyles(rules, nodes) {
  for (const rule of rules) {
    if (!isViewRuleStyle(rule) || rule.targets.length === 0) {
      continue;
    }
    const predicates = rule.targets.map(elementExprToPredicate);
    applyViewRuleStyle(rule, predicates, nodes);
  }
  return nodes;
}

function updateDepthOfAncestors(node, nodes) {
  let parentNd;
  while (!!node.parent && (parentNd = nodes.get(node.parent))) {
    const depth = parentNd.depth ?? 1;
    parentNd.depth = Math.max(depth, (node.depth ?? 0) + 1);
    if (parentNd.depth === depth) {
      break;
    }
    node = parentNd;
  }
}
const modelElementAsNodeSource = (element) => {
  return {
    ...element,
    modelRef: 1
  };
};
function buildComputedNodesFromElements(elements, groups) {
  return buildComputedNodes(elements.map(modelElementAsNodeSource), groups);
}
function buildComputedNodes(elements, groups) {
  const nodesMap = /* @__PURE__ */ new Map();
  const elementToGroup = /* @__PURE__ */ new Map();
  groups?.forEach(({ id, parent, viewRule, elements: elements2 }) => {
    if (parent) {
      nonNullable(nodesMap.get(parent), `Parent group node ${parent} not found`).children.push(id);
    }
    nodesMap.set(id, {
      id,
      parent,
      kind: ElementKind.Group,
      title: viewRule.title ?? "",
      color: viewRule.color ?? "muted",
      shape: "rectangle",
      children: [],
      inEdges: [],
      outEdges: [],
      level: 0,
      depth: 0,
      description: null,
      technology: null,
      tags: null,
      links: null,
      style: {
        border: viewRule.border ?? "dashed",
        opacity: viewRule.opacity ?? 0,
        size: viewRule.size ?? "md",
        multiple: viewRule.multiple ?? false,
        padding: viewRule.padding ?? "md",
        textSize: viewRule.textSize ?? "md"
      }
    });
    for (const e of elements2) {
      elementToGroup.set(e.id, id);
    }
  });
  Array.from(elements).sort(compareByFqnHierarchically).forEach(({ id, style, kind, title, color, shape, ...el }) => {
    let parent = parentFqn(id);
    let level = 0;
    let parentNd;
    while (parent) {
      parentNd = nodesMap.get(parent);
      if (parentNd) {
        break;
      }
      parent = parentFqn(parent);
    }
    if (!parentNd && elementToGroup.has(id)) {
      parent = elementToGroup.get(id);
      parentNd = nodesMap.get(parent);
    }
    if (parentNd) {
      if (parentNd.children.length == 0) {
        parentNd.depth = 1;
        updateDepthOfAncestors(parentNd, nodesMap);
      }
      parentNd.children.push(id);
      level = parentNd.level + 1;
    }
    const node = {
      id,
      parent,
      kind,
      title,
      level,
      color: color ?? DefaultThemeColor,
      shape: shape ?? DefaultElementShape,
      description: null,
      technology: null,
      tags: null,
      links: null,
      children: [],
      inEdges: [],
      outEdges: [],
      ...el,
      style: {
        ...style
      }
    };
    nodesMap.set(id, node);
  });
  const orderedMap = /* @__PURE__ */ new Map();
  groups?.forEach(({ id }) => {
    orderedMap.set(id, nonNullable(nodesMap.get(id)));
  });
  elements.forEach(({ id }) => {
    orderedMap.set(id, nonNullable(nodesMap.get(id)));
  });
  return orderedMap;
}

function pickRelationshipProps(relation) {
  const {
    title,
    description = null,
    technology = null,
    kind = null,
    color = null,
    line = null,
    head = null,
    tail = null,
    navigateTo = null
  } = relation;
  return {
    // Pick description only if title is present
    ...title && {
      title,
      description
    },
    technology,
    kind,
    color,
    line,
    head,
    tail,
    navigateTo
  };
}
function mergePropsFromRelationships(relations, prefer) {
  const allprops = C(
    relations,
    l$5(
      (acc, r) => {
        if (n$3(r.title) && !acc.title.includes(r.title)) {
          acc.title.push(r.title);
        }
        if (n$3(r.description) && !acc.description.includes(r.description)) {
          acc.description.push(r.description);
        }
        if (n$3(r.technology) && !acc.technology.includes(r.technology)) {
          acc.technology.push(r.technology);
        }
        if (n$3(r.kind) && !acc.kind.includes(r.kind)) {
          acc.kind.push(r.kind);
        }
        if (n$3(r.color) && !acc.color.includes(r.color)) {
          acc.color.push(r.color);
        }
        if (n$3(r.line) && !acc.line.includes(r.line)) {
          acc.line.push(r.line);
        }
        if (n$3(r.head) && !acc.head.includes(r.head)) {
          acc.head.push(r.head);
        }
        if (n$3(r.tail) && !acc.tail.includes(r.tail)) {
          acc.tail.push(r.tail);
        }
        if (n$3(r.navigateTo) && !acc.navigateTo.includes(r.navigateTo)) {
          acc.navigateTo.push(r.navigateTo);
        }
        if (r.tags) {
          acc.tags.push(...r.tags);
        }
        if (r.links) {
          acc.links.push(...r.links);
        }
        return acc;
      },
      {
        title: [],
        description: [],
        technology: [],
        kind: [],
        head: [],
        tail: [],
        color: [],
        tags: [],
        links: [],
        line: [],
        navigateTo: []
      }
    )
  );
  let technology = t$2(allprops.technology);
  let title = t$2(allprops.title) ?? (allprops.title.length > 1 ? "[...]" : null);
  const tags = i$8(allprops.tags);
  let merged = d$2(
    {
      // If there is no title, but there is technology, use technology as title
      title: title ?? (technology ? `[${technology}]` : null),
      description: t$2(allprops.description),
      technology,
      kind: t$2(allprops.kind),
      head: t$2(allprops.head),
      tail: t$2(allprops.tail),
      color: t$2(allprops.color),
      line: t$2(allprops.line),
      navigateTo: t$2(allprops.navigateTo),
      ...isNonEmptyArray(allprops.links) && { links: allprops.links },
      ...isNonEmptyArray(tags) && { tags }
    },
    n$3
  );
  if (prefer) {
    return {
      ...merged,
      ...d$2(pickRelationshipProps(prefer), n$3)
    };
  }
  return merged;
}

function uniqueTags(elements) {
  const tags = C(
    elements,
    u$1((e) => e.tags ?? []),
    i$8(),
    m$1(compareNatural)
  );
  return i$9(tags, 1) ? tags : null;
}

function resolveElements$1(model, expr) {
  const ref = model.element(expr.ref.deployment);
  if (ref.isDeploymentNode()) {
    if (expr.selector === "children") {
      return [...ref.children()];
    }
    if (expr.selector === "expanded") {
      return [ref, ...ref.children()];
    }
    if (expr.selector === "descendants") {
      return [...ref.descendants()];
    }
  }
  return [ref];
}
function resolveModelElements(model, expr) {
  const ref = model.$model.element(expr.ref.model);
  if (expr.selector === "children") {
    return [...ref.children()];
  }
  if (expr.selector === "expanded") {
    return [ref, ...ref.children()];
  }
  if (expr.selector === "descendants") {
    return [...ref.descendants()];
  }
  return [ref];
}
function deploymentExpressionToPredicate(target) {
  if (FqnExpr.isWildcard(target)) {
    return () => true;
  }
  if (FqnExpr.isElementTagExpr(target) || FqnExpr.isElementKindExpr(target)) {
    throw new Error("element kind and tag expressions are not supported in deployment view rules");
  }
  if (FqnExpr.isDeploymentRef(target)) {
    const fqn = target.ref.deployment;
    if (target.selector === "expanded") {
      const fqnWithDot = fqn + ".";
      return (n) => n.id === fqn || n.id.startsWith(fqnWithDot);
    }
    if (target.selector === "descendants") {
      const fqnWithDot = fqn + ".";
      return (n) => n.id.startsWith(fqnWithDot);
    }
    if (target.selector === "children") {
      return (n) => parentFqn(n.id) === fqn;
    }
    return (n) => n.id === fqn;
  }
  if (FqnExpr.isModelRef(target)) {
    const modelFqn = (node) => {
      if (t$6(node.modelRef)) {
        return node.modelRef;
      }
      if (e$1(node.modelRef)) {
        return node.id;
      }
      return null;
    };
    const fqn = target.ref.model;
    if (target.selector === "expanded") {
      const fqnWithDot = fqn + ".";
      return (n) => {
        const m = modelFqn(n);
        if (!m) {
          return true;
        }
        return m === fqn || m.startsWith(fqnWithDot);
      };
    }
    if (target.selector === "descendants") {
      const fqnWithDot = fqn + ".";
      return (n) => {
        const m = modelFqn(n);
        if (!m) {
          return true;
        }
        return m.startsWith(fqnWithDot);
      };
    }
    if (target.selector === "children") {
      return (n) => {
        const m = modelFqn(n);
        if (!m) {
          return true;
        }
        return parentFqn(m) === fqn;
      };
    }
    return (n) => {
      const m = modelFqn(n);
      if (!m) {
        return true;
      }
      return m === fqn;
    };
  }
  nonexhaustive(target);
}
function toNodeSource$1(el) {
  if (el.isDeploymentNode()) {
    const onlyOneInstance = el.onlyOneInstance();
    let { title, kind, id, ...$node } = el.$node;
    const { icon: icon2, color: color2, shape: shape2, ...style } = el.$node.style ?? {};
    if (onlyOneInstance && title === nameFromFqn(el.id)) {
      title = onlyOneInstance.title;
    }
    return {
      ...onlyOneInstance && {
        ...toNodeSource$1(onlyOneInstance),
        modelRef: onlyOneInstance.element.id
      },
      title,
      ...$node,
      ...icon2 && { icon: icon2 },
      ...color2 && { color: color2 },
      ...shape2 && { shape: shape2 },
      style: {
        ...style
      },
      deploymentRef: 1,
      kind,
      id
    };
  }
  invariant(el.isInstance(), "Expected Instance");
  const instance = el.$instance;
  const element = el.element.$element;
  const icon = instance.style?.icon ?? element.icon;
  const color = instance.style?.color ?? element.color;
  const shape = instance.style?.shape ?? element.shape;
  const links = [
    ...element.links ?? [],
    ...instance.links ?? []
  ];
  const metadata = {
    ...element.metadata,
    ...instance.metadata
  };
  const notation = instance.notation ?? element.notation;
  return {
    id: el.id,
    kind: "instance",
    title: instance.title ?? element.title,
    description: instance.description ?? element.description,
    technology: instance.technology ?? element.technology,
    tags: uniqueTags([element, instance]),
    links: i$9(links, 1) ? links : null,
    ...icon && { icon },
    ...color && { color },
    ...shape && { shape },
    style: {
      ...element.style,
      ...instance.style
    },
    deploymentRef: el.id === instance.id ? 1 : instance.id,
    modelRef: el.id === element.id ? 1 : element.id,
    ...notation && { notation },
    ...!n(metadata) && { metadata }
  };
}
function toComputedEdges$1(connections) {
  return connections.reduce((acc, e) => {
    const relations = [
      ...e.relations.model,
      ...e.relations.deployment
    ];
    invariant(i$9(relations, 1), "Edge must have at least one relation");
    const source = e.source.id;
    const target = e.target.id;
    const {
      title,
      ...props
    } = mergePropsFromRelationships(relations.map((r) => r.$relationship));
    const edge = {
      id: e.id,
      parent: e.boundary?.id ?? null,
      source,
      target,
      label: title ?? null,
      relations: relations.map((r) => r.id),
      ...props
    };
    const existing = acc.find((e2) => e2.source === target && e2.target === source);
    if (existing && edge.label === existing.label) {
      existing.dir = "both";
      const head = existing.head ?? edge.head ?? DefaultArrowType;
      existing.head ??= head;
      existing.tail ??= head;
      if (edge.color) {
        existing.color ??= edge.color;
      }
      if (edge.line) {
        existing.line ??= edge.line;
      }
      return acc;
    }
    acc.push(edge);
    return acc;
  }, []);
}
function buildNodes$1(memory) {
  return buildComputedNodes([...memory.final].map(toNodeSource$1));
}
function applyDeploymentViewRuleStyles(rules, nodes) {
  for (const rule of rules) {
    if (!isViewRuleStyle(rule) || rule.targets.length === 0) {
      continue;
    }
    const predicates = rule.targets.map(deploymentExpressionToPredicate);
    applyViewRuleStyle(rule, predicates, nodes);
  }
  return nodes;
}

function isDeploymentNode(model) {
  return model.isDeploymentNode();
}
function isDeployedInstance(model) {
  return model.isInstance();
}
function isNestedElementOfDeployedInstanceModel(model) {
  return !model.isInstance() && !model.isDeploymentNode();
}
function isDeploymentElementModel(x) {
  return x instanceof DeploymentNodeModel || x instanceof DeployedInstanceModel;
}

const WhereDeploymentRefPredicate = {
  include: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("include", { expr: expr.where.expr, model, stage, memory, where });
  },
  exclude: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("exclude", { expr: expr.where.expr, model, stage, memory, where });
  }
};

const IncomingRelationPredicate = {
  include: ({ expr, model, memory, stage, where }) => {
    const sources = [...memory.elements];
    if (FqnExpr.isWildcard(expr.incoming)) {
      for (const source of sources) {
        if (source.allOutgoing.isEmpty) {
          continue;
        }
        const targets2 = [...resolveAscendingSiblings(source)];
        const toInclude = applyPredicate(findConnectionsBetween(source, targets2, "directed"), where);
        stage.addConnections(toInclude);
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.incoming), "Only deployment refs are supported in include");
    const targets = resolveElements$1(model, expr.incoming);
    for (const source of sources) {
      const toInclude = applyPredicate(findConnectionsBetween(source, targets, "directed"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.incoming) || FqnExpr.isElementKindExpr(expr.incoming)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.incoming)) {
      const excludedRelations = resolveAllImcomingRelations(model, expr.incoming);
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.incoming)) {
      return stage;
    }
    const isIncoming = filterIncomingConnections(resolveElements$1(model, expr.incoming));
    const toExclude = C(
      memory.connections,
      T(isIncoming),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};
function filterIncomingConnections(targets) {
  return y$2(
    targets.map((target) => {
      const satisfies = (el) => el === target || isAncestor(target, el);
      return (connection) => {
        return !satisfies(connection.source) && satisfies(connection.target);
      };
    })
  );
}
function resolveAllImcomingRelations(model, moodelRef) {
  const targets = resolveModelElements(model, moodelRef);
  return new Set(targets.flatMap((e) => [...e.allIncoming]));
}

const OutgoingRelationPredicate = {
  include: ({ expr, model, memory, stage, where }) => {
    const targets = [...memory.elements];
    if (FqnExpr.isWildcard(expr.outgoing)) {
      for (const target of targets) {
        if (target.allIncoming.isEmpty) {
          continue;
        }
        for (const source of resolveAscendingSiblings(target)) {
          const toInclude = applyPredicate(findConnection(source, target, "directed"), where);
          stage.addConnections(toInclude);
        }
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.outgoing), "Only deployment refs are supported in include");
    const sources = resolveElements$1(model, expr.outgoing);
    for (const source of sources) {
      const toInclude = applyPredicate(findConnectionsBetween(source, targets, "directed"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.outgoing) || FqnExpr.isElementKindExpr(expr.outgoing)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.outgoing)) {
      const excludedRelations = resolveAllOutgoingRelations(model, expr.outgoing);
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.outgoing)) {
      return stage;
    }
    const isOutgoing = filterOutgoingConnections(resolveElements$1(model, expr.outgoing));
    const toExclude = C(
      memory.connections,
      T(isOutgoing),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};
function filterOutgoingConnections(sources) {
  return y$2(
    sources.map((source) => {
      const satisfies = (el) => el === source || isAncestor(source, el);
      return (connection) => {
        return satisfies(connection.source) && !satisfies(connection.target);
      };
    })
  );
}
function resolveAllOutgoingRelations(model, moodelRef) {
  const targets = resolveModelElements(model, moodelRef);
  return new Set(targets.flatMap((e) => [...e.allOutgoing]));
}

const resolveAscendingSiblings = (element) => {
  const siblings = /* @__PURE__ */ new Set();
  for (let sibling of element.descendingSiblings()) {
    siblings.add(sibling);
  }
  return siblings;
};
const DirectRelationPredicate = {
  include: ({ expr: { source, target, isBidirectional = false }, model, stage, where }) => {
    if (FqnExpr.isElementTagExpr(source) || FqnExpr.isElementKindExpr(source)) {
      throw new Error("element kind and tag expressions are not supported in include");
    }
    if (FqnExpr.isElementTagExpr(target) || FqnExpr.isElementKindExpr(target)) {
      throw new Error("element kind and tag expressions are not supported in include");
    }
    invariant(!FqnExpr.isModelRef(source), "Invalid source model ref in direct relation");
    invariant(!FqnExpr.isModelRef(target), "Invalid target model ref in direct relation");
    const sourceIsWildcard = FqnExpr.isWildcard(source);
    const targetIsWildcard = FqnExpr.isWildcard(target);
    const dir = isBidirectional ? "both" : "directed";
    let connections;
    switch (true) {
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        connections = C(
          findConnectionsWithin(model.instances()),
          applyPredicate(where),
          m$3((c) => {
            stage.addImplicit(c.boundary);
            return c;
          })
        );
        break;
      }
      // source -> *; source <-> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const sources = resolveElements$1(model, source);
        const isSource = filterOutgoingConnections(sources);
        let postFilter = isSource;
        if (isBidirectional) {
          const isTarget = filterIncomingConnections(sources);
          postFilter = (c) => isSource(c) !== isTarget(c);
        }
        connections = C(
          sources,
          u$1((source2) => {
            const targets = resolveAscendingSiblings(source2);
            return findConnectionsBetween(source2, targets, dir);
          }),
          T(postFilter),
          applyPredicate(where)
        );
        break;
      }
      // * -> target; * <-> target
      case (sourceIsWildcard && !targetIsWildcard): {
        const targets = resolveElements$1(model, target);
        const isTarget = filterIncomingConnections(targets);
        let postFilter = isTarget;
        if (isBidirectional) {
          const isSource = filterOutgoingConnections(targets);
          postFilter = (c) => isSource(c) !== isTarget(c);
        }
        connections = C(
          targets,
          u$1((target2) => {
            const sources = resolveAscendingSiblings(target2);
            return [...sources].flatMap((source2) => findConnection(source2, target2, dir));
          }),
          T(postFilter),
          applyPredicate(where)
        );
        break;
      }
      default: {
        invariant(!sourceIsWildcard, "Inferrence failed - source should be a deployment ref");
        invariant(!targetIsWildcard, "Inferrence failed - target should be a deployment ref");
        const sources = resolveElements$1(model, source);
        const targets = resolveElements$1(model, target);
        const isSource = filterOutgoingConnections(sources);
        const isTarget = filterIncomingConnections(targets);
        connections = C(
          sources,
          u$1((s) => findConnectionsBetween(s, targets, dir)),
          T((c) => isSource(c) && isTarget(c)),
          applyPredicate(where)
        );
      }
    }
    stage.addConnections(connections);
    if (FqnExpr.isDeploymentRef(source) && l$7(source.selector)) {
      stage.addImplicit(model.element(source.ref.deployment));
    }
    if (FqnExpr.isDeploymentRef(target) && l$7(target.selector)) {
      stage.addImplicit(model.element(target.ref.deployment));
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    const isTarget = deploymentExpressionToPredicate(expr.target);
    const isSource = deploymentExpressionToPredicate(expr.source);
    let modelRelationsToExclude;
    switch (true) {
      // * -> *
      case (FqnExpr.isWildcard(expr.source) && FqnExpr.isWildcard(expr.target)):
        stage.excludeConnections(applyPredicate(memory.connections, where));
        return stage;
      // model -> model
      case (FqnExpr.isModelRef(expr.source) && FqnExpr.isModelRef(expr.target)):
        modelRelationsToExclude = resolveRelationsBetweenModelElements({
          source: expr.source,
          target: expr.target,
          expr,
          model
        });
        return excludeModelRelations(modelRelationsToExclude, { stage, memory }, where);
      // model -> *
      case (FqnExpr.isModelRef(expr.source) && FqnExpr.isWildcard(expr.target)):
        modelRelationsToExclude = resolveAllOutgoingRelations(model, expr.source);
        return excludeModelRelations(modelRelationsToExclude, { stage, memory }, where);
      // model -> deployment
      case FqnExpr.isModelRef(expr.source):
        modelRelationsToExclude = resolveAllOutgoingRelations(model, expr.source);
        return excludeModelRelations(
          modelRelationsToExclude,
          { stage, memory },
          where,
          (c) => isTarget(c.target)
        );
      // deployment -> model
      case FqnExpr.isModelRef(expr.target):
        modelRelationsToExclude = resolveAllImcomingRelations(model, expr.target);
        return excludeModelRelations(
          modelRelationsToExclude,
          { stage, memory },
          where,
          (c) => isSource(c.source)
        );
      // deployment -> deployment
      default:
        const satisfies = (connection) => {
          return isSource(connection.source) && isTarget(connection.target) || expr.isBidirectional === true && isSource(connection.target) && isTarget(connection.source);
        };
        const deploymentRelationsToExclude = C(
          memory.connections,
          T(satisfies),
          applyPredicate(where)
        );
        if (deploymentRelationsToExclude.length === 0) {
          return stage;
        }
        stage.excludeConnections(deploymentRelationsToExclude);
        return stage;
    }
  }
};
function resolveRelationsBetweenModelElements({
  source,
  target,
  expr,
  model
}) {
  const sources = resolveModelElements(model, source);
  const targets = resolveModelElements(model, target);
  const dir = expr.isBidirectional ? "both" : "directed";
  const modelConnections = [];
  for (const source2 of sources) {
    modelConnections.push(...findConnectionsBetween$1(source2, targets, dir));
  }
  return new Set(modelConnections.flatMap((c) => [...c.relations]));
}

const InOutRelationPredicate$1 = {
  include: ({ expr, model, memory, stage, where }) => {
    const sources = [...memory.elements];
    if (FqnExpr.isWildcard(expr.inout)) {
      for (const source of sources) {
        const targets2 = [...resolveAscendingSiblings(source)];
        const toInclude = matchConnections(findConnectionsBetween(source, targets2, "both"), where);
        stage.addConnections(toInclude);
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.inout), "Only deployment refs are supported in include");
    const targets = resolveElements$1(model, expr.inout);
    for (const source of sources) {
      const toInclude = matchConnections(findConnectionsBetween(source, targets, "both"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.inout) || FqnExpr.isElementKindExpr(expr.inout)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.inout)) {
      const elements2 = resolveModelElements(model, expr.inout);
      if (elements2.length === 0) {
        return stage;
      }
      const excludedRelations = union(
        /* @__PURE__ */ new Set(),
        ...elements2.flatMap((e) => [e.allIncoming, e.allOutgoing])
      );
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.inout)) {
      return stage;
    }
    const elements = resolveElements$1(model, expr.inout);
    const isIncoming = filterIncomingConnections(elements);
    const isOutgoing = filterOutgoingConnections(elements);
    const toExclude = C(
      memory.connections,
      T((c) => isIncoming(c) !== isOutgoing(c)),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};

const WhereRelationPredicate = {
  include: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("include", { expr: expr.where.expr, model, stage, memory, where });
  },
  exclude: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("exclude", { expr: expr.where.expr, model, stage, memory, where });
  }
};

const WildcardPredicate$1 = {
  include: ({ model, stage, where }) => {
    const children = [];
    const rootElements = C(
      [...model.roots()],
      applyElementPredicate(where),
      m$3((root) => {
        if (!root.onlyOneInstance()) {
          children.push(...root.children());
        }
        return root;
      })
    );
    stage.addExplicit(rootElements);
    if (children.length > 1) {
      stage.addConnections(findConnectionsWithin([
        ...rootElements,
        ...children
      ]));
    }
    return stage;
  },
  exclude: ({ stage, memory, where }) => {
    const elementsToExclude = C(
      [...memory.elements],
      applyElementPredicate(where)
    );
    stage.exclude(elementsToExclude);
    return stage;
  }
};

function predicateToPatch(op, { expr, where, ...ctx }) {
  switch (true) {
    case FqnExpr.isElementTagExpr(expr):
    case FqnExpr.isElementKindExpr(expr):
      throw new Error("element kind and tag expressions are not supported in deployment view rules");
    case RelationExpr.isCustom(expr):
    case FqnExpr.isCustom(expr):
    case FqnExpr.isModelRef(expr):
      return void 0;
    case FqnExpr.isWhere(expr):
      return WhereDeploymentRefPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isWhere(expr):
      return WhereRelationPredicate[op]({ ...ctx, expr, where });
    case FqnExpr.isDeploymentRef(expr):
      return DeploymentRefPredicate[op]({ ...ctx, expr, where });
    case FqnExpr.isWildcard(expr):
      return WildcardPredicate$1[op]({ ...ctx, expr, where });
    case RelationExpr.isDirect(expr):
      return DirectRelationPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isInOut(expr):
      return InOutRelationPredicate$1[op]({ ...ctx, expr, where });
    case RelationExpr.isOutgoing(expr):
      return OutgoingRelationPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isIncoming(expr):
      return IncomingRelationPredicate[op]({ ...ctx, expr, where });
    default:
      nonexhaustive(expr);
  }
}
function excludeModelRelations(relationsToExclude, { stage, memory }, where, filterConnections = () => true) {
  if (relationsToExclude.size === 0) {
    return stage;
  }
  const toExclude = C(
    memory.connections,
    T((c) => filterConnections(c)),
    // Find connections that have at least one relation in common with the excluded relations
    T((c) => hasIntersection(c.relations.model, relationsToExclude)),
    m$3(
      (c) => c.update({
        deployment: null,
        model: intersection(c.relations.model, relationsToExclude)
      })
    ),
    applyPredicate(where),
    T((c) => c.nonEmpty())
  );
  if (toExclude.length === 0) {
    return stage;
  }
  return stage.excludeConnections(toExclude);
}
function matchConnection(c, where) {
  return applyPredicate(c, where).nonEmpty();
}
function applyPredicate(...args) {
  if (args.length === 1) {
    return (x) => applyPredicate(x, args[0]);
  }
  const [c, where] = args;
  if (where === null) {
    return c;
  }
  if (o$9(c)) {
    return c.map((x) => applyPredicate(x, where)).filter((x) => x.nonEmpty());
  }
  return c.update({
    model: new Set([...c.relations.model.values()].filter((r) => where(toFilterableRelation(c)(r)))),
    deployment: new Set([...c.relations.deployment.values()].filter((r) => where(toFilterableRelation(c)(r))))
  });
}
function applyElementPredicate(...args) {
  if (args.length === 1) {
    return (x) => applyElementPredicate(x, args[0]);
  }
  const [c, where] = args;
  if (o$9(c)) {
    return c.filter((x) => applyElementPredicate(x, where));
  }
  return where?.(toFilterable(c, c)) ?? true;
}
function matchConnections(connections, where) {
  if (!where) {
    return connections;
  }
  return C(
    connections,
    T((c) => matchConnection(c, where))
  );
}
function toFilterable(relationEndpoint, connectionEndpoint) {
  if (isElementModel(relationEndpoint)) {
    const deployedInstance = isDeploymentElementModel(connectionEndpoint) && isDeployedInstance(connectionEndpoint) ? connectionEndpoint : null;
    return {
      kind: relationEndpoint.kind,
      tags: [...relationEndpoint.tags, ...deployedInstance?.tags ?? []]
    };
  }
  if (isNestedElementOfDeployedInstanceModel(relationEndpoint)) {
    return i$6(relationEndpoint.element, ["tags", "kind"]);
  }
  if (isDeployedInstance(relationEndpoint)) {
    return {
      kind: relationEndpoint.element.kind,
      tags: [...relationEndpoint.tags, ...relationEndpoint.element.tags]
    };
  }
  if (isDeploymentNode(relationEndpoint)) {
    return i$6(relationEndpoint, ["tags", "kind"]);
  }
  nonexhaustive(relationEndpoint);
}
function toFilterableRelation(c) {
  return (relation) => ({
    tags: relation.tags,
    kind: relation.kind,
    source: toFilterable(relation.source, c.source),
    target: toFilterable(relation.target, c.target)
  });
}

const DeploymentRefPredicate = {
  include: (ctx) => {
    const { expr, where } = ctx;
    const el = ctx.model.element(expr.ref.deployment);
    if (isDeployedInstance(el)) {
      if (applyElementPredicate(el, where)) {
        ctx.stage.addExplicit(el);
        ctx.stage.connectWithExisting(el);
      }
      return ctx.stage;
    }
    switch (true) {
      case expr.selector === "expanded":
        includeDeployedNodeWithExpanded(el, ctx);
        break;
      case expr.selector === "children":
        includeDeployedNodeChildren(el, ctx);
        break;
      case expr.selector === "descendants":
        includeDeployedNodeDescendants(el, ctx);
        break;
      default: {
        if (applyElementPredicate(el, where)) {
          ctx.stage.addExplicit(el);
          ctx.stage.connectWithExisting(el);
        }
      }
    }
    return ctx.stage;
  },
  exclude: ({ expr, stage, memory, where }) => {
    const exprPredicate = deploymentExpressionToPredicate(expr);
    const toExclude = C(
      [...memory.elements],
      T(exprPredicate),
      applyElementPredicate(where)
    );
    stage.exclude(toExclude);
    return stage;
  }
};
function includeDeployedNodeChildren(node, { stage, where }) {
  const children = applyElementPredicate([...node.children()], where);
  if (children.length === 0) {
    return;
  }
  stage.addImplicit(node);
  stage.addConnections(findConnectionsWithin(children));
  stage.connectWithExisting(children);
  stage.addExplicit(children);
}
function includeDeployedNodeWithExpanded(node, { memory, stage, where }) {
  stage.addImplicit(node);
  stage.connectWithExisting(node);
  const children = applyElementPredicate([...node.children()], where);
  let hasConnectionsWithVisible = false;
  for (const child of children) {
    if (findConnectionsBetween(child, memory.elements).length > 0) {
      hasConnectionsWithVisible = true;
      break;
    }
  }
  if (hasConnectionsWithVisible) {
    stage.connectWithExisting(children, "in");
    stage.addConnections(findConnectionsWithin(children));
    stage.connectWithExisting(children, "out");
  }
  stage.addImplicit(children);
  if (stage.connections.length > 0) {
    stage.addExplicit(node);
  }
}
function includeDeployedNodeDescendants(node, { stage, where }) {
  const dfs = (node2) => {
    const children = [];
    for (const child of node2.children()) {
      if (child.isDeploymentNode()) {
        children.push(...dfs(child));
      }
      if (applyElementPredicate(child, where)) {
        children.push(child);
      }
    }
    stage.connectWithExisting(children, "in");
    stage.addConnections(findConnectionsWithin(children));
    stage.addImplicit(children);
    return children;
  };
  const descendants = dfs(node);
  if (descendants.length === 0) {
    return;
  }
  stage.connectWithExisting(descendants, "out");
  const allConnected = findConnectedElements(stage);
  C(
    descendants,
    T((desc) => allConnected.has(desc)),
    u((desc) => stage.addExplicit(desc))
  );
}
function findConnectedElements(stage) {
  return C(
    stage.mergedConnections(),
    cleanCrossBoundary,
    cleanRedundantRelationships,
    l$5((acc, c) => {
      acc.add(c.source);
      acc.add(c.target);
      return acc;
    }, /* @__PURE__ */ new Set())
  );
}

let StageFinal$1 = class StageFinal {
  constructor(memory) {
    this.memory = memory;
  }
  static for(memory) {
    return new StageFinal(memory);
  }
  step1CleanConnections(memory) {
    if (memory.connections.length < 2) {
      return memory;
    }
    const connections = C(
      memory.connections,
      // Keep connections
      // - between leafs
      // - has direct deployment relation
      // filter(c => {
      //   return (leafs.has(c.source) && leafs.has(c.target)) || c.hasDirectDeploymentRelation()
      // }),
      cleanCrossBoundary,
      cleanRedundantRelationships
    );
    const connectionsToExclude = differenceConnections(
      memory.connections,
      connections
    );
    if (connectionsToExclude.length === 0) {
      return memory;
    }
    const stage = memory.stageExclude({});
    stage.excludeConnections(connectionsToExclude, true);
    return stage.commit();
  }
  step2ProcessImplicits(memory) {
    const implicits = union(this.memory.elements, memory.elements);
    const final = union(memory.final, this.memory.explicits);
    const groupedByRelation = new DefaultMap(() => /* @__PURE__ */ new Set());
    for (const conn of memory.connections) {
      if (conn.boundary) {
        for (const relation of conn.relations.model) {
          groupedByRelation.get(relation).add(conn.boundary);
        }
      }
    }
    for (const [_, boundaries] of groupedByRelation) {
      if (boundaries.size < 2) {
        continue;
      }
      for (const boundary of boundaries) {
        if (implicits.delete(boundary)) {
          final.add(boundary);
        }
      }
    }
    const snapshot = new Set(final);
    const isFinalOrHasIncludedDescendant = (el) => {
      for (const final2 of snapshot) {
        if (el === final2 || isAncestor(el, final2)) {
          return true;
        }
      }
      return false;
    };
    C(
      difference(implicits, snapshot),
      ifilter((e) => e.isDeploymentNode()),
      toArray(),
      sortByFqnHierarchically,
      u((el) => {
        const childrensToWrap = [...el.children()].filter(isFinalOrHasIncludedDescendant).length;
        if (childrensToWrap >= 2) {
          final.add(el);
          return;
        }
        if (childrensToWrap === 1 && isome(el.siblings(), isFinalOrHasIncludedDescendant)) {
          final.add(el);
        }
      })
    );
    return memory.update({ final });
  }
  step3ProcessBoundaries(memory) {
    const boundaries = /* @__PURE__ */ new Set();
    for (const conn of memory.connections) {
      if (conn.boundary) {
        boundaries.add(conn.boundary);
      }
    }
    const tree = treeFromMemoryState(memory, "final");
    const stage = memory.stageExclude({});
    const isRemovable = (el) => !(boundaries.has(el) || memory.explicits.has(el) || tree.hasInOut(el) || tree.root.has(el));
    const singleRoot = t$2([...tree.root]);
    if (singleRoot && !memory.explicits.has(singleRoot)) {
      stage.exclude(singleRoot);
    }
    for (const el of memory.final) {
      const singleChild = t$2(tree.children(el));
      if (singleChild && !tree.hasInOut(singleChild) && isRemovable(el)) {
        stage.exclude(el);
      }
    }
    if (stage.isDirty()) {
      return stage.commit();
    }
    return memory;
  }
  // TODO: Lot of corner cases to cover, skip for now
  // public step3FlatNodes(memory: Memory): Memory {
  //   // final implicits
  //   const explicits = new Set<Elem>([
  //     ...memory.explicits,
  //     ...memory.connections.flatMap(c => [c.source, c.target]),
  //   ])
  //   const sorted = sortParentsFirst(toArray(memory.final))
  //   const toplevel = new Set<Elem>(sorted)
  //   const children = sorted.reduce((acc, el, index, all) => {
  //     acc.set(
  //       el,
  //       new Set(
  //         all
  //           .slice(index + 1)
  //           .filter(e => isAncestor(el, e))
  //           .reduce((acc, el) => {
  //             if (!acc.some(e => isAncestor(e, el))) {
  //               toplevel.delete(el)
  //               acc.push(el)
  //             }
  //             return acc
  //           }, [] as Elem[]),
  //       ),
  //     )
  //     return acc
  //   }, new DefaultMap<Elem, Set<Elem>>(() => new Set()))
  //   const state = memory.mutableState()
  //   function flattenNode(node: Elem) {
  //     const _children = [...children.get(node)]
  //     if (_children.length > 1) {
  //       for (const child of _children) {
  //         flattenNode(child)
  //       }
  //       return !explicits.has(node)
  //     }
  //     if (hasAtLeast(_children, 1)) {
  //       if (flattenNode(_children[0])) {
  //         state.final.delete(_children[0])
  //       }
  //     }
  //     return !explicits.has(node)
  //   }
  //   const root = [...toplevel]
  //   for (const node of root) {
  //     flattenNode(node)
  //     if (!explicits.has(node) && children.get(node).size === 1) {
  //       state.final.delete(node)
  //     }
  //   }
  //   if (root.length === 1 && !explicits.has(root[0]!)) {
  //     state.final.delete(root[0]!)
  //   }
  //   return memory.update(state)
  // }
  commit() {
    const step1 = this.step1CleanConnections(this.memory);
    const step2 = this.step2ProcessImplicits(step1);
    return this.step3ProcessBoundaries(step2);
  }
};

function processPredicates$1(model, rules) {
  let memory = Memory$1.empty();
  for (const rule of rules) {
    if (isViewRulePredicate(rule)) {
      const op = "include" in rule ? "include" : "exclude";
      const exprs = rule.include ?? rule.exclude;
      for (const expr of exprs) {
        let stage = op === "include" ? memory.stageInclude(expr) : memory.stageExclude(expr);
        const ctx = { expr, model, stage, memory, where: null };
        stage = predicateToPatch(op, ctx) ?? stage;
        memory = stage.commit();
      }
    }
  }
  return StageFinal$1.for(memory).commit();
}
function computeDeploymentView(likec4model, {
  docUri: _docUri,
  // exclude docUri
  rules,
  // exclude rules
  ...view
}) {
  const memory = processPredicates$1(likec4model.deployment, rules);
  const nodesMap = buildNodes$1(memory);
  const computedEdges = toComputedEdges$1(memory.connections);
  linkNodesWithEdges(nodesMap, computedEdges);
  const sorted = topologicalSort({
    nodes: nodesMap,
    edges: computedEdges
  });
  const nodes = applyDeploymentViewRuleStyles(
    rules,
    sorted.nodes
  );
  const autoLayoutRule = o(rules, isViewRuleAutoLayout);
  const elementNotations = buildElementNotations(nodes);
  return calcViewLayoutHash({
    ...view,
    autoLayout: {
      direction: autoLayoutRule?.direction ?? "TB",
      ...autoLayoutRule?.nodeSep && { nodeSep: autoLayoutRule.nodeSep },
      ...autoLayoutRule?.rankSep && { rankSep: autoLayoutRule.rankSep }
    },
    edges: sorted.edges,
    nodes: m$3(nodes, (n) => {
      if (n.icon === "none") {
        delete n.icon;
      }
      return n;
    }),
    ...elementNotations.length > 0 && {
      notation: {
        elements: elementNotations
      }
    }
  });
}

function flattenGroupRules(guard) {
  return (rule) => {
    if (isViewRuleGroup(rule)) {
      return rule.groupRules.flatMap(flattenGroupRules(guard));
    }
    if (isViewRulePredicate(rule)) {
      return "include" in rule ? rule.include.filter(guard) : [];
    }
    return [];
  };
}
function applyCustomElementProperties(_rules, _nodes) {
  const rules = _rules.flatMap(flattenGroupRules(ModelLayer.FqnExpr.isCustom));
  if (rules.length === 0) {
    return _nodes;
  }
  const nodes = [..._nodes];
  for (const {
    custom: { expr, ...props }
  } of rules) {
    const {
      border,
      opacity,
      multiple,
      padding,
      size,
      textSize,
      ...rest
    } = d$1(props, n$4);
    const notEmpty = !n(rest);
    const satisfies = elementExprToPredicate(expr);
    nodes.forEach((node, i) => {
      if (ComputedNode.isNodesGroup(node) || !satisfies(node)) {
        return;
      }
      if (notEmpty) {
        node = {
          ...node,
          isCustomized: true,
          ...rest
        };
      }
      let styleOverride;
      if (border !== void 0) {
        styleOverride = { border };
      }
      if (opacity !== void 0) {
        styleOverride = { ...styleOverride, opacity };
      }
      if (multiple !== void 0) {
        styleOverride = { ...styleOverride, multiple };
      }
      if (padding !== void 0) {
        styleOverride = { ...styleOverride, padding };
      }
      if (size !== void 0) {
        styleOverride = { ...styleOverride, size };
      }
      if (textSize !== void 0) {
        styleOverride = { ...styleOverride, textSize };
      }
      if (styleOverride) {
        node = {
          ...node,
          isCustomized: true,
          style: {
            ...node.style,
            ...styleOverride
          }
        };
      }
      nodes[i] = node;
    });
  }
  return nodes;
}

function resolveGlobalRulesInElementView(rules, globals) {
  return rules.reduce((acc, rule) => {
    if (isViewRuleGlobalPredicateRef(rule)) {
      const globalPredicates = globals.predicates[rule.predicateId];
      if (n$4(globalPredicates)) {
        return acc;
      }
      return acc.concat(globalPredicates);
    }
    if (isViewRuleGlobalStyle(rule)) {
      const globalStyles = globals.styles[rule.styleId];
      if (n$4(globalStyles)) {
        return acc;
      }
      return acc.concat(globalStyles);
    }
    acc.push(rule);
    return acc;
  }, []);
}
function resolveGlobalRulesInDynamicView(rules, globals) {
  return rules.reduce((acc, rule) => {
    if (isViewRuleGlobalPredicateRef(rule)) {
      const globalPredicates = globals.dynamicPredicates[rule.predicateId];
      if (n$4(globalPredicates)) {
        return acc;
      }
      return acc.concat(globalPredicates);
    }
    if (isViewRuleGlobalStyle(rule)) {
      const globalStyles = globals.styles[rule.styleId];
      if (n$4(globalStyles)) {
        return acc;
      }
      return acc.concat(globalStyles);
    }
    acc.push(rule);
    return acc;
  }, []);
}

class DynamicViewCompute {
  constructor(model, view) {
    this.model = model;
    this.view = view;
  }
  // Intermediate state
  explicits = /* @__PURE__ */ new Set();
  steps = [];
  addStep({
    source: stepSource,
    target: stepTarget,
    title: stepTitle,
    isBackward,
    navigateTo: stepNavigateTo,
    ...step
  }, index, parent) {
    const id = parent ? stepEdgeId(parent, index) : stepEdgeId(index);
    const source = this.model.element(stepSource);
    const target = this.model.element(stepTarget);
    this.explicits.add(source);
    this.explicits.add(target);
    const {
      title,
      relations,
      tags,
      navigateTo: derivedNavigateTo,
      color,
      line
    } = this.findRelations(source, target);
    const navigateTo = n$3(stepNavigateTo) && stepNavigateTo !== this.view.id ? stepNavigateTo : derivedNavigateTo;
    this.steps.push({
      id,
      ...step,
      source,
      target,
      title: stepTitle ?? title,
      relations: relations ?? [],
      isBackward: isBackward ?? false,
      ...navigateTo ? { navigateTo } : {},
      ...tags ? { tags } : {},
      ...color ? { color } : {},
      ...line ? { line } : {}
    });
  }
  compute() {
    const {
      docUri: _docUri,
      // exclude docUri
      rules: _rules,
      // exclude rules
      steps: viewSteps,
      ...view
    } = this.view;
    let stepNum = 1;
    for (const step of viewSteps) {
      if (isDynamicViewParallelSteps(step)) {
        if (step.__parallel.length === 0) {
          continue;
        }
        if (step.__parallel.length === 1) {
          this.addStep(step.__parallel[0], stepNum);
        } else {
          step.__parallel.forEach((s, i) => this.addStep(s, i + 1, stepNum));
        }
      } else {
        this.addStep(step, stepNum);
      }
      stepNum++;
    }
    const rules = resolveGlobalRulesInDynamicView(_rules, this.model.globals());
    for (const rule of rules) {
      if (isViewRulePredicate(rule)) {
        for (const expr of rule.include) {
          const satisfies = elementExprToPredicate(expr);
          for (const e of this.model.elements()) {
            if (satisfies(e)) {
              this.explicits.add(e);
            }
          }
        }
      }
    }
    const elements = [...this.explicits].map((e) => e.$element);
    const nodesMap = buildComputedNodesFromElements(elements);
    const edges = this.steps.map(({ source, target, relations, title, isBackward, ...step }) => {
      const sourceNode = nonNullable(nodesMap.get(source.id), `Source node ${source.id} not found`);
      const targetNode = nonNullable(nodesMap.get(target.id), `Target node ${target.id} not found`);
      const edge = {
        parent: commonAncestor(source.id, target.id),
        source: source.id,
        target: target.id,
        label: title,
        relations,
        color: DefaultRelationshipColor,
        line: DefaultLineStyle,
        head: DefaultArrowType,
        ...step
      };
      if (isBackward) {
        edge.dir = "back";
      }
      while (edge.parent && !nodesMap.has(edge.parent)) {
        edge.parent = parentFqn(edge.parent);
      }
      sourceNode.outEdges.push(edge.id);
      targetNode.inEdges.push(edge.id);
      for (const sourceAncestor of ancestorsFqn(edge.source)) {
        if (sourceAncestor === edge.parent) {
          break;
        }
        nodesMap.get(sourceAncestor)?.outEdges.push(edge.id);
      }
      for (const targetAncestor of ancestorsFqn(edge.target)) {
        if (targetAncestor === edge.parent) {
          break;
        }
        nodesMap.get(targetAncestor)?.inEdges.push(edge.id);
      }
      return edge;
    });
    const nodes = applyCustomElementProperties(
      rules,
      applyViewRuleStyles(
        rules,
        // Keep order of elements
        elements.map((e) => nonNullable(nodesMap.get(e.id)))
      )
    );
    const autoLayoutRule = o(rules, isViewRuleAutoLayout);
    const elementNotations = buildElementNotations(nodes);
    return calcViewLayoutHash({
      ...view,
      autoLayout: {
        direction: autoLayoutRule?.direction ?? "LR",
        ...autoLayoutRule?.nodeSep && { nodeSep: autoLayoutRule.nodeSep },
        ...autoLayoutRule?.rankSep && { rankSep: autoLayoutRule.rankSep }
      },
      nodes: m$3(nodes, (n) => {
        if (n.icon === "none") {
          delete n.icon;
        }
        return n;
      }),
      edges,
      ...elementNotations.length > 0 && {
        notation: {
          elements: elementNotations
        }
      }
    });
  }
  findRelations(source, target) {
    const relationships = findConnection$1(source, target, "directed").flatMap((r) => [...r.relations]);
    if (relationships.length === 0) {
      return {
        title: null,
        tags: null,
        relations: null,
        navigateTo: null,
        color: null,
        line: null
      };
    }
    const alltags = C(
      relationships,
      u$1((r) => r.tags),
      T(n$3),
      i$8()
    );
    const tags = i$9(alltags, 1) ? alltags : null;
    const relations = i$9(relationships, 1) ? m$3(relationships, (r) => r.id) : null;
    const relation = t$2(relationships) || relationships.find((r) => r.source === source && r.target === target);
    const relationNavigateTo = relation?.$relationship.navigateTo ?? null;
    const navigateTo = relationNavigateTo && relationNavigateTo !== this.view.id ? relationNavigateTo : C(
      relationships,
      m$3((r) => r.$relationship.navigateTo),
      T(n$3),
      T((v) => v !== this.view.id),
      i$8(),
      t$2()
    );
    const commonProperties = C(
      relationships,
      l$5((acc, { title, $relationship: r }) => {
        n$3(title) && acc.title.add(title);
        n$3(r.color) && acc.color.add(r.color);
        n$3(r.line) && acc.line.add(r.line);
        return acc;
      }, {
        color: /* @__PURE__ */ new Set(),
        line: /* @__PURE__ */ new Set(),
        title: /* @__PURE__ */ new Set()
      })
    );
    return {
      tags,
      relations,
      navigateTo: navigateTo ?? null,
      title: t$2([...commonProperties.title]) ?? null,
      color: t$2([...commonProperties.color]) ?? null,
      line: t$2([...commonProperties.line]) ?? null
    };
  }
}
function computeDynamicView(model, view) {
  return new DynamicViewCompute(model, view).compute();
}

function relationExpressionToPredicates(expr) {
  switch (true) {
    case ModelLayer.RelationExpr.isCustom(expr): {
      return relationExpressionToPredicates(expr.customRelation.expr);
    }
    case ModelLayer.RelationExpr.isWhere(expr): {
      const predicate = relationExpressionToPredicates(expr.where.expr);
      const where = whereOperatorAsPredicate(expr.where.condition);
      return (e) => predicate(e) && where({
        source: { tags: e.source.tags, kind: e.source.kind },
        target: { tags: e.target.tags, kind: e.target.kind },
        ...e.tags && { tags: e.tags },
        ...e.kind && { kind: e.kind }
      });
    }
    case ModelLayer.RelationExpr.isDirect(expr): {
      const isSource = elementExprToPredicate(expr.source);
      const isTarget = elementExprToPredicate(expr.target);
      return (edge) => {
        return isSource(edge.source) && isTarget(edge.target) || !!expr.isBidirectional && isSource(edge.target) && isTarget(edge.source);
      };
    }
    case ModelLayer.RelationExpr.isInOut(expr): {
      const isInOut = elementExprToPredicate(expr.inout);
      return (edge) => isInOut(edge.source) || isInOut(edge.target);
    }
    case ModelLayer.RelationExpr.isIncoming(expr): {
      const isTarget = elementExprToPredicate(expr.incoming);
      return (edge) => isTarget(edge.target);
    }
    case ModelLayer.RelationExpr.isOutgoing(expr): {
      const isSource = elementExprToPredicate(expr.outgoing);
      return (edge) => isSource(edge.source);
    }
    default:
      nonexhaustive(expr);
  }
}

function applyCustomRelationProperties(_rules, nodes, _edges) {
  const rules = _rules.flatMap(flattenGroupRules(ModelLayer.RelationExpr.isCustom));
  const edges = Array.from(_edges);
  if (rules.length === 0 || edges.length === 0) {
    return edges;
  }
  for (const {
    customRelation: {
      expr,
      title,
      ...customprops
    }
  } of rules) {
    const props = d$1(customprops, n$4);
    const satisfies = relationExpressionToPredicates(expr);
    edges.forEach((edge, i) => {
      const source = nodes.find((n) => n.id === edge.source);
      const target = nodes.find((n) => n.id === edge.target);
      if (!source || !target) {
        return;
      }
      if (satisfies({ source, target, ...i$6(edge, ["kind", "tags"]) })) {
        edges[i] = {
          ...edge,
          ...props,
          label: title ?? edge.label,
          isCustomized: true
        };
      }
    });
  }
  return edges;
}

class NodesGroup {
  constructor(id, viewRule, parent = null, elements = /* @__PURE__ */ new Set()) {
    this.id = id;
    this.viewRule = viewRule;
    this.parent = parent;
    this.elements = elements;
  }
  static kind = ElementKind.Group;
  isEmpty() {
    return this.elements.size === 0;
  }
  update(elements) {
    return new NodesGroup(
      this.id,
      this.viewRule,
      this.parent,
      elements
    );
  }
  clone() {
    return new NodesGroup(this.id, this.viewRule, this.parent, new Set(this.elements));
  }
}

class StageExclude extends AbstractStageExclude {
  excludeRelations(excluded) {
    C(
      this.memory.connections,
      T((c) => hasIntersection(c.relations, excluded)),
      u((c) => {
        this.excludeConnections(
          c.update(intersection(c.relations, excluded))
        );
      })
    );
    return this;
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    if (this.excluded.elements.size > 0) {
      const excludeRelationships = new Set(
        [...this.excluded.elements].flatMap((el) => [
          ...el.incoming("direct"),
          ...el.outgoing("direct")
        ])
      );
      this.excludeRelations(excludeRelationships);
    }
    return state;
  }
  postcommit(state) {
    const leftExplicits = difference(this.memory.explicits, state.explicits);
    for (const explicit of leftExplicits) {
      state.explicitFirstSeenIn.delete(explicit);
    }
    const left = difference(this.memory.elements, state.elements);
    for (const el of left) {
      state.lastSeenIn.delete(el);
    }
    return state;
  }
}
class ActiveGroupStageExclude extends StageExclude {
  constructor(memory, expression) {
    super(memory, expression);
    this.memory = memory;
    this.expression = expression;
  }
}

class StageInclude extends AbstractStageInclude {
  /**
   * Connects elements with existing ones in the memory
   */
  connectWithExisting(elements, direction = "both") {
    const before = this._connections.length;
    const hasChanged = () => this._connections.length > before;
    if (!isIterable(elements)) {
      if (direction === "in" || direction === "both") {
        for (const el of this.memory.elements) {
          this.addConnections(
            findConnection$1(el, elements, "directed")
          );
        }
      }
      if (direction === "out" || direction === "both") {
        this.addConnections(
          findConnectionsBetween$1(elements, this.memory.elements, "directed")
        );
      }
      return hasChanged();
    }
    const targets = [...elements];
    if (direction === "in" || direction === "both") {
      for (const el of this.memory.elements) {
        this.addConnections(
          findConnectionsBetween$1(el, targets, "directed")
        );
      }
    }
    if (direction === "out" || direction === "both") {
      for (const el of targets) {
        this.addConnections(
          findConnectionsBetween$1(el, this.memory.elements, "directed")
        );
      }
    }
    return hasChanged();
  }
  addImplicitWithinScope(element) {
    if (!element) {
      return;
    }
    if (!this.memory.scope || isAncestor(this.memory.scope, element)) {
      this.addImplicit(element);
    }
  }
  processConnections(connections) {
    if (ModelLayer.isAnyRelationExpr(this.expression)) {
      return connections;
    }
    C(
      connections,
      u(({ source, target, boundary }) => {
        C(
          d$6(
            [...toArray(source.ancestors()).reverse(), source],
            [...toArray(target.ancestors()).reverse(), target]
          ),
          // Filter out common ancestors
          m(([sourceAncestor, targetAncestor]) => sourceAncestor === targetAncestor),
          l$6(1),
          u(([sourceAncestor, targetAncestor]) => {
            if (sourceAncestor === source && targetAncestor === target) {
              this.addImplicitWithinScope(boundary);
              return;
            }
            if (sourceAncestor !== source) {
              this.addImplicitWithinScope(sourceAncestor);
            }
            if (targetAncestor !== target) {
              this.addImplicitWithinScope(targetAncestor);
            }
          })
        );
      })
    );
    return connections;
  }
  postcommit(state) {
    const newExplicits = difference(state.explicits, this.memory.explicits);
    for (const explicit of newExplicits) {
      state.explicitFirstSeenIn.set(explicit, "@root");
    }
    return state;
  }
}
class ActiveGroupStageInclude extends StageInclude {
  constructor(memory, expression) {
    super(memory, expression);
    this.memory = memory;
    this.expression = expression;
  }
  postcommit(state) {
    const newExplicits = difference(state.explicits, this.memory.explicits);
    for (const explicit of newExplicits) {
      state.explicitFirstSeenIn.set(explicit, this.memory.activeGroupId);
    }
    for (const implicit of [...this.explicits, ...this.implicits]) {
      state.lastSeenIn.set(implicit, this.memory.activeGroupId);
    }
    return state;
  }
}

class Memory extends AbstractMemory {
  constructor(state, scope) {
    super(state);
    this.state = state;
    this.scope = scope;
  }
  static empty(scope) {
    return new Memory({
      elements: /* @__PURE__ */ new Set(),
      explicits: /* @__PURE__ */ new Set(),
      final: /* @__PURE__ */ new Set(),
      connections: [],
      groups: [],
      explicitFirstSeenIn: /* @__PURE__ */ new Map(),
      lastSeenIn: /* @__PURE__ */ new Map()
    }, scope);
  }
  get groups() {
    return this.state.groups;
  }
  get explicitFirstSeenIn() {
    return this.state.explicitFirstSeenIn;
  }
  get lastSeenIn() {
    return this.state.lastSeenIn;
  }
  stageInclude(expr) {
    return new StageInclude(this, expr);
  }
  stageExclude(expr) {
    return new StageExclude(this, expr);
  }
  mutableState() {
    return {
      elements: new Set(this.state.elements),
      explicits: new Set(this.state.explicits),
      final: new Set(this.state.final),
      connections: [...this.state.connections],
      groups: this.state.groups.map((g) => g.clone()),
      explicitFirstSeenIn: new Map(this.state.explicitFirstSeenIn),
      lastSeenIn: new Map(this.state.lastSeenIn)
    };
  }
  update(newstate) {
    return new Memory({
      ...this.state,
      ...newstate
    }, this.scope);
  }
}
class ActiveGroupMemory extends Memory {
  constructor(state, scope, stack) {
    super(state, scope);
    this.state = state;
    this.scope = scope;
    this.stack = stack;
  }
  static enter(memory, rule) {
    const groupId = `@gr${memory.groups.length + 1}`;
    if (memory instanceof ActiveGroupMemory) {
      const stack2 = Stack.from([...memory.stack].reverse());
      const state2 = memory.mutableState();
      state2.groups.push(new NodesGroup(groupId, rule, memory.activeGroupId));
      stack2.push(groupId);
      return new ActiveGroupMemory(state2, memory.scope, stack2);
    }
    const state = memory.mutableState();
    state.groups.push(new NodesGroup(groupId, rule, null));
    const stack = Stack.of(groupId);
    return new ActiveGroupMemory(state, memory.scope, stack);
  }
  get activeGroupId() {
    return nonNullable(this.stack.peek(), "Stack must not be empty");
  }
  mutableState() {
    const state = super.mutableState();
    return {
      ...state
      // activeGroup: this.findActiveGroup(state.groups)
    };
  }
  // private findActiveGroup(groups: NodesGroup[]): NodesGroup {
  //   return nonNullable(groups.find(g => g.id === this.activeGroup.id), 'Active group not found in groups')
  // }
  update(newstate) {
    const nextstate = {
      ...this.state,
      ...newstate
    };
    return new ActiveGroupMemory(nextstate, this.scope, this.stack);
  }
  stageInclude(expr) {
    return new ActiveGroupStageInclude(this, expr);
  }
  stageExclude(expr) {
    return new ActiveGroupStageExclude(this, expr);
  }
  leave() {
    const state = this.mutableState();
    this.stack.pop();
    const prevgroup = this.stack.peek();
    if (prevgroup) {
      return new ActiveGroupMemory(state, this.scope, this.stack);
    }
    return new Memory(state, this.scope);
  }
}

function findRedundantConnections(connections) {
  return C(
    [...connections],
    mergeConnections,
    l$5((reducedConnections, connection, _, all) => {
      const descendants = findDescendantConnections(all, connection);
      const nestedRelations = union(
        ...descendants.map(p$1("relations"))
      );
      let accum = intersection(connection.relations, nestedRelations);
      if (descendants.length > 0) {
        accum = union(accum, connection.directRelations);
      }
      if (findDeepestNestedConnection(all, connection.reversed(false))) {
        accum = union(accum, connection.directRelations);
      }
      if (accum.size < connection.relations.size) {
        const isSourceExpanded = all.some(isAnyInOut(connection.source));
        const isTargetExpanded = all.some(isAnyInOut(connection.target));
        if (isSourceExpanded) {
          accum = union(
            accum,
            toSet(
              ifilter(
                connection.relations,
                isOutgoing(connection.source)
              )
            )
          );
        }
        if (isTargetExpanded) {
          accum = union(
            accum,
            toSet(
              ifilter(
                connection.relations,
                isIncoming(connection.target)
              )
            )
          );
        }
      }
      if (accum.size > 0) {
        reducedConnections.push(connection.update(accum));
      }
      return reducedConnections;
    }, [])
  );
}

class StageFinal {
  constructor(memory) {
    this.memory = memory;
  }
  static for(memory) {
    return new StageFinal(memory);
  }
  step1CleanConnections(memory) {
    if (memory.connections.length < 2) {
      return memory;
    }
    const connectionsToExclude = findRedundantConnections(memory.connections);
    if (connectionsToExclude.length === 0) {
      return memory;
    }
    const stage = memory.stageExclude({});
    stage.excludeConnections(connectionsToExclude, true);
    return stage.commit();
  }
  step2ProcessImplicits(memory) {
    const implicits = union(this.memory.elements, memory.elements);
    const final = union(memory.final, this.memory.explicits);
    const snapshot = new Set(final);
    const isFinalOrHasIncludedDescendant = (el) => {
      for (const final2 of snapshot) {
        if (el === final2 || isAncestor(el, final2)) {
          return true;
        }
      }
      return false;
    };
    C(
      difference(implicits, snapshot),
      toArray(),
      sortByFqnHierarchically,
      u((el) => {
        const childrensToWrap = [...el.children()].filter(isFinalOrHasIncludedDescendant).length;
        if (childrensToWrap >= 2) {
          final.add(el);
          return;
        }
        if (childrensToWrap === 1 && isome(el.siblings(), isFinalOrHasIncludedDescendant)) {
          final.add(el);
        }
      })
    );
    return memory.update({ final });
  }
  step3ProcessBoundaries(memory) {
    const boundaries = /* @__PURE__ */ new Set();
    for (const conn of memory.connections) {
      if (conn.boundary && conn.boundary !== conn.source && conn.boundary !== conn.target) {
        boundaries.add(conn.boundary);
      }
    }
    const tree = treeFromMemoryState(memory, "final");
    const stage = memory.stageExclude({});
    const isRemovable = (el) => !(boundaries.has(el) || memory.explicits.has(el) || tree.hasInOut(el) || tree.root.has(el));
    const singleRoot = t$2([...tree.root]);
    if (singleRoot && !memory.explicits.has(singleRoot)) {
      stage.exclude(singleRoot);
    }
    for (const el of memory.final) {
      const singleChild = t$2(tree.children(el));
      if (singleChild && !tree.hasInOut(singleChild) && isRemovable(el)) {
        stage.exclude(el);
      }
    }
    if (stage.isDirty()) {
      return stage.commit();
    }
    return memory;
  }
  commit() {
    const step1 = this.step1CleanConnections(this.memory);
    const step2 = this.step2ProcessImplicits(step1);
    return this.step3ProcessBoundaries(step2);
  }
}

function resolveElements(model, expr) {
  switch (true) {
    case ModelLayer.FqnExpr.isElementKindExpr(expr): {
      return [...ifilter(model.elements(), (el) => {
        return expr.isEqual === (el.kind === expr.elementKind);
      })];
    }
    case ModelLayer.FqnExpr.isElementTagExpr(expr): {
      return [...ifilter(model.elements(), (el) => {
        return expr.isEqual === el.tags.includes(expr.elementTag);
      })];
    }
    case expr.selector === "expanded": {
      const element = model.element(ModelLayer.FqnRef.toFqn(expr.ref));
      return [
        element,
        ...element.children()
      ];
    }
    case expr.selector === "children":
    case expr.selector === "descendants": {
      const element = model.element(ModelLayer.FqnRef.toFqn(expr.ref));
      let children = expr.selector === "children" ? toArray(element.children()) : toArray(element.descendants());
      return children && children.length > 0 ? children : [element];
    }
    case ModelLayer.FqnExpr.isModelRef(expr): {
      return [model.element(ModelLayer.FqnRef.toFqn(expr.ref))];
    }
    default:
      nonexhaustive(expr);
  }
}
function includeDescendantsFromMemory(elements, memory) {
  if (memory.isEmpty() || elements.length === 0) {
    return elements;
  }
  const descedantsOf = y$2(elements.map((e) => isDescendantOf(e)));
  const fromMemory = toArray(
    ifilter(
      memory.elements,
      (el) => !elements.includes(el) && descedantsOf(el)
    )
  );
  return [
    ...elements,
    ...fromMemory
  ];
}
function resolveAndIncludeFromMemory(nonWildcard, { memory, model }) {
  const resolved = resolveElements(model, nonWildcard);
  if (ModelLayer.FqnExpr.isModelRef(nonWildcard)) {
    if (nonWildcard.selector === "descendants") {
      return resolved;
    }
    return includeDescendantsFromMemory(resolved, memory);
  }
  return resolved;
}

const ExpandedElementPredicate = {
  include: ({ expr, model, stage, where }) => {
    const parent = model.element(ModelLayer.FqnRef.toFqn(expr.ref));
    if (where(parent)) {
      stage.addExplicit(parent);
      stage.connectWithExisting(parent);
    }
    const children = [...parent.children()].filter(where);
    const expanded = [];
    for (const child of children) {
      stage.addImplicit(child);
      if (stage.connectWithExisting(child)) {
        expanded.push(child);
      }
    }
    stage.addConnections(findConnectionsWithin$1(expanded));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};

const ElementKindOrTagPredicate = {
  include: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    if (elements.length === 0) {
      return;
    }
    stage.addExplicit(elements);
    stage.connectWithExisting(elements);
    stage.addConnections(findConnectionsWithin$1(elements));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};

const ElementRefPredicate = {
  include: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    if (elements.length === 0) {
      return;
    }
    stage.addExplicit(elements);
    stage.connectWithExisting(elements);
    stage.addConnections(findConnectionsWithin$1(elements));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};

const NoWhere = () => true;
const NoFilter = (x) => x;
function toNodeSource(el) {
  return {
    ...el.$element,
    modelRef: 1
  };
}
function toComputedEdges(connections) {
  return connections.reduce((acc, e) => {
    const relations = [
      ...e.relations
    ];
    invariant(i$9(relations, 1), "Edge must have at least one relation");
    const source = e.source.id;
    const target = e.target.id;
    const {
      title,
      ...props
    } = mergePropsFromRelationships(
      relations.map((r) => r.$relationship),
      // Prefer only single relationship
      // https://github.com/likec4/likec4/issues/1423
      t$2(
        T(relations, (r) => r.source.id === source && r.target.id === target)
      )?.$relationship
    );
    const edge = {
      id: e.id,
      parent: e.boundary?.id ?? null,
      source,
      target,
      label: title ?? null,
      relations: relations.map((r) => r.id),
      ...props
    };
    acc.push(edge);
    return acc;
  }, []);
}
function buildNodes(memory) {
  return buildComputedNodes([...memory.final].map(toNodeSource), memory.groups);
}

const isWildcard = ModelLayer.FqnExpr.isWildcard;
const DirectRelationExprPredicate = {
  include: ({ expr: { source, target, isBidirectional = false }, memory, model, stage, where, filterWhere }) => {
    const sourceIsWildcard = isWildcard(source);
    const targetIsWildcard = isWildcard(target);
    const connections = [];
    switch (true) {
      // This is a special case, we look for all relationships that satisfy the where clause
      // * -> * ; Empty memory; Where clause
      case (sourceIsWildcard && targetIsWildcard && memory.isEmpty() && where !== NoWhere): {
        const connections2 = C(
          model.relationships(),
          ifilter(where),
          toArray(),
          m$3((r) => new ConnectionModel(r.source, r.target, /* @__PURE__ */ new Set([r])))
        );
        stage.addConnections(connections2);
        return stage;
      }
      // This is a special case, we look for all relationships between elements that satisfy the where clause
      // * -> *; Not empty memory; Where clause
      case (sourceIsWildcard && targetIsWildcard && !memory.isEmpty() && where !== NoWhere): {
        connections.push(
          ...findConnectionsWithin$1(memory.elements)
        );
        break;
      }
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        connections.push(
          ...findConnectionsWithin$1(model.roots())
        );
        break;
      }
      // This is a special case, we look for all relationships that satisfy the where clause
      // element -> *; Where clause
      case (!sourceIsWildcard && targetIsWildcard && where !== NoWhere): {
        const sources = resolveElements(model, source);
        const connections2 = C(
          sources,
          u$1(
            (source2) => C(
              source2,
              d$5(r(isBidirectional === true), {
                onTrue: (s) => union(s.allIncoming, s.allOutgoing),
                onFalse: (s) => s.allOutgoing
              }),
              ifilter(where),
              iunique(),
              toArray(),
              d$3((r) => r.source === source2),
              ([outgoing, incoming]) => a(
                C(
                  outgoing,
                  m$3(
                    (outgoing2) => new ConnectionModel(
                      source2,
                      outgoing2.target,
                      /* @__PURE__ */ new Set([outgoing2])
                    )
                  )
                ),
                C(
                  incoming,
                  m$3(
                    (incoming2) => new ConnectionModel(
                      incoming2.source,
                      source2,
                      /* @__PURE__ */ new Set([incoming2])
                    )
                  )
                )
              )
            )
          )
        );
        stage.addConnections(connections2);
        return stage;
      }
      // element -> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const [sources, targets] = resolveWildcard(source, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween$1(source2, targets, dir)
          );
        }
        break;
      }
      // This is a special case, we look for all relationships that satisfy the where clause
      // * -> element; Where clause
      case (sourceIsWildcard && !targetIsWildcard && where !== NoWhere): {
        const targets = resolveElements(model, target);
        const connections2 = C(
          targets,
          u$1(
            (target2) => C(
              target2,
              d$5(r(isBidirectional === true), {
                onTrue: (s) => union(s.allIncoming, s.allOutgoing),
                onFalse: (s) => s.allIncoming
              }),
              ifilter(where),
              toArray(),
              d$3((r) => r.target === target2),
              ([incoming, outgoing]) => a(
                C(
                  outgoing,
                  m$3(
                    (outgoing2) => new ConnectionModel(
                      target2,
                      outgoing2.target,
                      /* @__PURE__ */ new Set([outgoing2])
                    )
                  )
                ),
                C(
                  incoming,
                  m$3(
                    (incoming2) => new ConnectionModel(
                      incoming2.source,
                      target2,
                      /* @__PURE__ */ new Set([incoming2])
                    )
                  )
                )
              )
            )
          )
        );
        stage.addConnections(connections2);
        return stage;
      }
      // * -> element
      case (sourceIsWildcard && !targetIsWildcard): {
        const [targets, sources] = resolveWildcard(target, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween$1(source2, targets, dir)
          );
        }
        break;
      }
      default: {
        invariant(!isWildcard(source), "Inference failed - source must be not a wildcard");
        invariant(!isWildcard(target), "Inference failed - target must be not a wildcard");
        const sources = resolveAndIncludeFromMemory(source, { memory, model });
        const targets = resolveAndIncludeFromMemory(target, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween$1(source2, targets, dir)
          );
        }
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { source, target, isBidirectional }, model, memory, stage, where }) => {
    const sourceIsWildcard = isWildcard(source);
    const targetIsWildcard = isWildcard(target);
    let relations;
    switch (true) {
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        relations = C(
          memory.connections,
          u$1(i$4(
            p$1("relations"),
            ifilter(where),
            toArray()
          )),
          toSet()
        );
        break;
      }
      // element -> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const sources = resolveElements(model, source);
        relations = C(
          sources,
          u$1(
            (source2) => C(
              source2,
              d$5(r(isBidirectional === true), {
                onTrue: (s) => union(s.allIncoming, s.allOutgoing),
                onFalse: (s) => s.allOutgoing
              }),
              ifilter(where),
              toArray()
            )
          ),
          toSet()
        );
        break;
      }
      // * -> element
      case (sourceIsWildcard && !targetIsWildcard): {
        const targets = resolveElements(model, target);
        relations = C(
          targets,
          u$1(
            (target2) => C(
              target2,
              d$5(r(isBidirectional === true), {
                onTrue: (s) => union(s.allIncoming, s.allOutgoing),
                onFalse: (s) => s.allIncoming
              }),
              ifilter(where),
              toArray()
            )
          ),
          toSet()
        );
        break;
      }
      default: {
        invariant(!isWildcard(source), "Inferrence failed - source must be not a wildcard");
        invariant(!isWildcard(target), "Inferrence failed - target must be not a wildcard");
        const sources = resolveElements(model, source);
        const targets = resolveElements(model, target);
        let accum = /* @__PURE__ */ new Set();
        for (const source2 of sources) {
          for (const target2 of targets) {
            if (isSameHierarchy(source2, target2)) {
              continue;
            }
            accum = union(
              accum,
              intersection(source2.allOutgoing, target2.allIncoming),
              isBidirectional ? intersection(target2.allOutgoing, source2.allIncoming) : /* @__PURE__ */ new Set()
            );
          }
        }
        relations = toSet(ifilter(accum, where));
      }
    }
    stage.excludeRelations(relations);
    return stage;
  }
};
function resolveWildcard(nonWildcard, { memory, model }) {
  let sources = resolveElements(model, nonWildcard);
  if (!i$9(sources, 1)) {
    return [[], []];
  }
  if (ModelLayer.FqnExpr.isModelRef(nonWildcard)) {
    const parent = model.element(ModelLayer.FqnRef.toFqn(nonWildcard.ref));
    const targets2 = toArray(parent.ascendingSiblings());
    return [
      includeDescendantsFromMemory(sources, memory),
      includeDescendantsFromMemory(targets2, memory)
    ];
  }
  const targets = C(
    sources,
    m$3((el) => el.ascendingSiblings()),
    iflat(),
    iunique(),
    toArray(),
    (all) => includeDescendantsFromMemory(all, memory)
  );
  return [sources, targets];
}

const IncomingExprPredicate = {
  include: ({ expr, scope, model, memory, stage, filterWhere }) => {
    const target = expr.incoming;
    const connections = [];
    if (ModelLayer.FqnExpr.isWildcard(target)) {
      if (!scope) {
        return;
      }
      for (const sibling of scope.ascendingSiblings()) {
        connections.push(
          ...findConnection$1(
            sibling,
            scope,
            "directed"
          )
        );
      }
    } else {
      const targets = resolveAndIncludeFromMemory(target, { memory, model });
      const visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements.push(
          ...i$8(
            targets.flatMap((el) => [...el.ascendingSiblings()])
          )
        );
      }
      const ensureIncoming = incomingConnectionPredicate(model, target);
      for (const visible of visibleElements) {
        connections.push(
          ...findConnectionsBetween$1(
            visible,
            targets,
            "directed"
          ).filter(ensureIncoming)
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { incoming }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelLayer.FqnExpr.isWildcard(incoming)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allIncoming);
    } else {
      const elements = resolveElements(model, incoming);
      excluded.push(
        ...elements.flatMap((e) => [...e.allIncoming])
      );
    }
    stage.excludeRelations(new Set(excluded.filter(where)));
    return stage;
  }
};
function incomingConnectionPredicate(model, expr) {
  switch (true) {
    case ModelLayer.FqnExpr.isElementKindExpr(expr):
    case ModelLayer.FqnExpr.isElementTagExpr(expr): {
      const isElement = elementExprToPredicate(expr);
      return (connection) => isElement(connection.target);
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "children"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y$2(
        [...model.children(fqn)].map(
          (el) => Connection.isIncoming(el.id)
        )
      );
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "descendants"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y$2([
        Connection.isInside(fqn),
        ...[...model.children(fqn)].map(
          (el) => Connection.isIncoming(el.id)
        )
      ]);
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y$2([
        Connection.isIncoming(fqn),
        Connection.isInside(fqn)
      ]);
    }
    case ModelLayer.FqnExpr.isModelRef(expr): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return Connection.isIncoming(fqn);
    }
    default:
      nonexhaustive(expr);
  }
}

const InOutRelationPredicate = {
  include: ({ expr: { inout }, scope, model, memory, stage, filterWhere }) => {
    const connections = [];
    if (ModelLayer.FqnExpr.isWildcard(inout)) {
      if (!scope) {
        return;
      }
      connections.push(
        ...findConnectionsBetween$1(
          scope,
          scope.ascendingSiblings()
        )
      );
    } else {
      const elements = resolveAndIncludeFromMemory(inout, { memory, model });
      let visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements = i$8(
          elements.flatMap((el) => toArray(el.ascendingSiblings()))
        );
      }
      for (const el of elements) {
        connections.push(
          ...findConnectionsBetween$1(
            el,
            visibleElements
          )
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { inout }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelLayer.FqnExpr.isWildcard(inout)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allOutgoing);
      excluded.push(...scope.allIncoming);
    } else {
      const elements = resolveElements(model, inout);
      excluded.push(
        ...elements.flatMap((e) => [...e.allOutgoing, ...e.allIncoming])
      );
    }
    stage.excludeRelations(toSet(excluded.filter(where)));
    return stage;
  }
};

const OutgoingExprPredicate = {
  include: ({ expr, scope, model, memory, stage, filterWhere }) => {
    const target = expr.outgoing;
    const connections = [];
    if (ModelLayer.FqnExpr.isWildcard(target)) {
      if (!scope) {
        return;
      }
      connections.push(
        ...findConnectionsBetween$1(
          scope,
          scope.ascendingSiblings(),
          "directed"
        )
      );
    } else {
      const elements = resolveAndIncludeFromMemory(target, { memory, model });
      const visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements.push(
          ...i$8(
            elements.flatMap((el) => [...el.ascendingSiblings()])
          )
        );
      }
      const ensureOutgoing = outgoingConnectionPredicate(model, target);
      for (const source of elements) {
        connections.push(
          ...findConnectionsBetween$1(
            source,
            visibleElements,
            "directed"
          ).filter(ensureOutgoing)
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { outgoing }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelLayer.FqnExpr.isWildcard(outgoing)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allOutgoing);
    } else {
      const elements = resolveElements(model, outgoing);
      excluded.push(
        ...elements.flatMap((e) => [...e.allOutgoing])
      );
    }
    stage.excludeRelations(
      toSet(excluded.filter(where))
    );
    return stage;
  }
};
function outgoingConnectionPredicate(model, expr) {
  switch (true) {
    case ModelLayer.FqnExpr.isElementKindExpr(expr):
    case ModelLayer.FqnExpr.isElementTagExpr(expr): {
      const isElement = elementExprToPredicate(expr);
      return (connection) => isElement(connection.source);
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "children"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y$2(
        [...model.children(fqn)].map(
          (el) => Connection.isOutgoing(el.id)
        )
      );
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "descendants"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y$2([
        Connection.isInside(fqn),
        ...[...model.children(fqn)].map(
          (el) => Connection.isOutgoing(el.id)
        )
      ]);
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return y$2([
        Connection.isOutgoing(fqn),
        Connection.isInside(fqn)
      ]);
    }
    case ModelLayer.FqnExpr.isModelRef(expr): {
      const fqn = ModelLayer.FqnRef.toFqn(expr.ref);
      return Connection.isOutgoing(fqn);
    }
    default:
      nonexhaustive(expr);
  }
}

const WildcardPredicate = {
  include: ({ scope, model, stage, memory, where }) => {
    if (!scope) {
      const rootElements = [...model.roots()].filter(where);
      if (rootElements.length === 0) {
        return;
      }
      stage.addExplicit(rootElements);
      stage.addConnections(findConnectionsWithin$1(rootElements));
      stage.connectWithExisting(rootElements);
      return stage;
    }
    const root = where(scope) ? scope : null;
    const children = toArray(ifilter(scope.children(), where));
    const hasChildren = children.length > 0;
    if (!hasChildren) {
      if (!root) {
        return stage;
      } else {
        const edgesWithSiblings = findConnectionsBetween$1(root, root.siblings());
        if (edgesWithSiblings.length === 0) {
          const parent = root.parent;
          if (parent && where(parent)) {
            stage.addExplicit(parent);
          }
        }
        children.push(root);
      }
    }
    if (root) {
      stage.addExplicit(root);
    }
    const neighbours = toSet([
      ...memory.elements,
      ...scope.descendingSiblings()
    ]);
    for (const neighbour of neighbours) {
      stage.addConnections(findConnectionsBetween$1(neighbour, children, "directed"));
    }
    if (hasChildren) {
      stage.addConnections(findConnectionsWithin$1(children));
      stage.addExplicit(children);
    }
    for (const child of children) {
      stage.addConnections(findConnectionsBetween$1(child, neighbours, "directed"));
    }
    return stage;
  },
  exclude: ({ scope, memory, stage, where }) => {
    if (where !== NoWhere) {
      stage.exclude(
        T(
          [...memory.elements],
          where
        )
      );
      return stage;
    }
    if (scope) {
      stage.exclude([scope, ...scope.descendants()]);
      return stage;
    }
    return Memory.empty(memory.scope).stageExclude(stage.expression);
  }
};

function processElementPredicate(expr, op, ctx) {
  switch (true) {
    case ModelLayer.FqnExpr.isCustom(expr): {
      if (op === "include") {
        return processElementPredicate(expr.custom.expr, op, ctx);
      }
      return ctx.stage;
    }
    case ModelLayer.FqnExpr.isWhere(expr): {
      const where = whereOperatorAsPredicate(expr.where.condition);
      const filterWhere = T(where);
      return processElementPredicate(expr.where.expr, op, { ...ctx, where, filterWhere });
    }
    case (ModelLayer.FqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      return ExpandedElementPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.FqnExpr.isWildcard(expr): {
      return WildcardPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.FqnExpr.isElementKindExpr(expr):
    case ModelLayer.FqnExpr.isElementTagExpr(expr): {
      return ElementKindOrTagPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.FqnExpr.isModelRef(expr): {
      return ElementRefPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    default:
      nonexhaustive(expr);
  }
}
function processRelationtPredicate(expr, op, ctx) {
  switch (true) {
    case ModelLayer.RelationExpr.isCustom(expr): {
      if (op === "include") {
        return processRelationtPredicate(expr.customRelation.expr, op, ctx);
      }
      return ctx.stage;
    }
    case ModelLayer.RelationExpr.isWhere(expr): {
      const where = whereOperatorAsPredicate(expr.where.condition);
      const filterRelations = (relations) => {
        return new Set(T([...relations], where));
      };
      const filterWhere = (connections) => {
        return C(
          connections,
          m$3((c) => new ConnectionModel(c.source, c.target, filterRelations(c.relations))),
          T((c) => c.nonEmpty())
        );
      };
      return processRelationtPredicate(expr.where.expr, op, {
        ...ctx,
        where,
        filterWhere
      });
    }
    case ModelLayer.RelationExpr.isInOut(expr): {
      return InOutRelationPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.RelationExpr.isDirect(expr): {
      return DirectRelationExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.RelationExpr.isOutgoing(expr): {
      return OutgoingExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelLayer.RelationExpr.isIncoming(expr): {
      return IncomingExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    default:
      nonexhaustive(expr);
  }
}
function processPredicates(model, memory, rules) {
  const ctx = {
    model,
    scope: memory.scope,
    where: NoWhere,
    filterWhere: NoFilter
  };
  for (const rule of rules) {
    if (isViewRuleGroup(rule)) {
      const groupMemory = ActiveGroupMemory.enter(memory, rule);
      memory = processPredicates(model, groupMemory, rule.groupRules);
      invariant(memory instanceof ActiveGroupMemory, "processPredicates must return ActiveGroupMemory");
      memory = memory.leave();
      continue;
    }
    if (isViewRulePredicate(rule)) {
      const op = "include" in rule ? "include" : "exclude";
      const exprs = rule.include ?? rule.exclude;
      for (const expr of exprs) {
        let stage = op === "include" ? memory.stageInclude(expr) : memory.stageExclude(expr);
        switch (true) {
          case ModelLayer.isAnyFqnExpr(expr):
            stage = processElementPredicate(expr, op, {
              ...ctx,
              stage,
              memory
            }) ?? stage;
            break;
          case ModelLayer.isAnyRelationExpr(expr):
            stage = processRelationtPredicate(expr, op, {
              ...ctx,
              stage,
              memory
            }) ?? stage;
            break;
          default:
            nonexhaustive(expr);
        }
        memory = stage.commit();
      }
    }
  }
  return StageFinal.for(memory).commit();
}
function computeElementView(likec4model, {
  docUri: _docUri,
  // exclude docUri
  rules,
  // exclude rules
  ...view
}) {
  rules = resolveGlobalRulesInElementView(rules, likec4model.globals());
  const scope = view.viewOf ? likec4model.element(view.viewOf) : null;
  let memory = processPredicates(
    likec4model,
    Memory.empty(scope),
    rules
  );
  if (memory.isEmpty() && scope) {
    memory = memory.update({
      final: /* @__PURE__ */ new Set([scope])
    });
  }
  memory = assignElementsToGroups(memory);
  const nodesMap = buildNodes(memory);
  const computedEdges = toComputedEdges(memory.connections);
  linkNodesWithEdges(nodesMap, computedEdges);
  const sorted = topologicalSort({
    nodes: nodesMap,
    edges: computedEdges
  });
  const nodes = applyCustomElementProperties(
    rules,
    applyViewRuleStyles(
      rules,
      sorted.nodes
    )
  );
  const autoLayoutRule = o(rules, isViewRuleAutoLayout);
  const elementNotations = buildElementNotations(nodes);
  return calcViewLayoutHash({
    ...view,
    autoLayout: {
      direction: autoLayoutRule?.direction ?? "TB",
      ...autoLayoutRule?.nodeSep && { nodeSep: autoLayoutRule.nodeSep },
      ...autoLayoutRule?.rankSep && { rankSep: autoLayoutRule.rankSep }
    },
    edges: applyCustomRelationProperties(rules, nodes, sorted.edges),
    nodes: m$3(nodes, (n) => {
      if (n.icon === "none") {
        delete n.icon;
      }
      return n;
    }),
    ...elementNotations.length > 0 && {
      notation: {
        elements: elementNotations
      }
    }
  });
}
function assignElementsToGroups(memory) {
  if (memory.groups.length === 0) {
    return memory;
  }
  const groupAssignments = new DefaultMap(() => /* @__PURE__ */ new Set());
  const assignedTo = /* @__PURE__ */ new Map();
  const isAncestorAssigned = (el) => {
    for (const parent of el.ancestors()) {
      const groupId = assignedTo.get(parent);
      if (groupId) {
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
        return true;
      }
    }
    return false;
  };
  const isDescendantAssigned = (el) => {
    for (const descendant of el.descendants("asc")) {
      const groupId = assignedTo.get(descendant);
      if (groupId) {
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
        return true;
      }
    }
    return false;
  };
  C(
    sortParentsFirst([...memory.explicitFirstSeenIn.keys()]),
    u((el) => {
      if (!isAncestorAssigned(el)) {
        const groupId = nonNullable(memory.explicitFirstSeenIn.get(el));
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
      }
    })
  );
  C(
    sortParentsFirst([...memory.lastSeenIn.keys()]),
    T((el) => !assignedTo.has(el)),
    u((el) => {
      if (isAncestorAssigned(el)) {
        return;
      }
      if (isDescendantAssigned(el)) {
        return;
      }
      const groupId = nonNullable(memory.lastSeenIn.get(el));
      assignedTo.set(el, groupId);
      groupAssignments.get(groupId).add(el);
    })
  );
  if (groupAssignments.size === 0) {
    return memory;
  }
  let groups = memory.groups.map((group) => {
    const explicits = groupAssignments.get(group.id);
    if (!explicits) {
      return group;
    }
    return group.update(explicits);
  });
  return memory.update({ groups });
}

function unsafeComputeView(viewsource, likec4model) {
  switch (true) {
    case isDeploymentView(viewsource): {
      return computeDeploymentView(likec4model, viewsource);
    }
    case isDynamicView(viewsource):
      return computeDynamicView(likec4model, viewsource);
    case isElementView(viewsource):
      return computeElementView(likec4model, viewsource);
    default:
      nonexhaustive(viewsource);
  }
}
function computeView(viewsource, likec4model) {
  try {
    return {
      isSuccess: true,
      view: unsafeComputeView(viewsource, likec4model)
    };
  } catch (e) {
    return {
      isSuccess: false,
      error: e instanceof Error ? e : new Error(`Unknown error: ${e}`),
      view: void 0
    };
  }
}
function computeViews(parsed) {
  const { views, ...rest } = parsed;
  const likec4model = LikeC4Model.create({
    ...rest,
    views: {}
  });
  const compute = (source) => {
    const result = computeView(source, likec4model);
    if (result.isSuccess) {
      return result.view;
    } else {
      throw result.error;
    }
  };
  return {
    ...rest,
    __: "computed",
    views: i$3(parsed.views, compute)
  };
}

function getId(element) {
  return isString(element) ? element : element.id;
}

class LikeC4DeploymentModel {
  constructor($model, $deployments) {
    this.$model = $model;
    this.$deployments = $deployments;
    for (const element of sortParentsFirst(r$3($deployments.elements))) {
      const el = this.addElement(element);
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
      if (el.isInstance()) {
        this.#instancesOf.get(el.element.id).add(el);
      }
    }
    for (const relation of r$3($deployments.relations)) {
      const el = this.addRelation(relation);
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
    }
  }
  #elements = /* @__PURE__ */ new Map();
  // Parent element for given FQN
  #parents = /* @__PURE__ */ new Map();
  // Children elements for given FQN
  #children = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Keep track of instances of the logical element
  #instancesOf = new DefaultMap(() => /* @__PURE__ */ new Set());
  #rootElements = /* @__PURE__ */ new Set();
  #relations = /* @__PURE__ */ new Map();
  // Incoming to an element or its descendants
  #incoming = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Outgoing from an element or its descendants
  #outgoing = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Relationships inside the element, among descendants
  #internal = new DefaultMap(() => /* @__PURE__ */ new Set());
  // readonly #views = new Map<ViewID, LikeC4ViewModel<M>>()
  #allTags = new DefaultMap(
    () => /* @__PURE__ */ new Set()
  );
  #nestedElementsOfDeployment = /* @__PURE__ */ new Map();
  element(el) {
    if (el instanceof DeploymentNodeModel || el instanceof DeployedInstanceModel) {
      return el;
    }
    const id = getId(el);
    return nonNullable(this.#elements.get(id), `Element ${id} not found`);
  }
  findElement(el) {
    return this.#elements.get(el) ?? null;
  }
  node(el) {
    const element = this.element(el);
    invariant(element.isDeploymentNode(), `Element ${element.id} is not a deployment node`);
    return element;
  }
  findNode(el) {
    const element = this.findElement(el);
    if (!element) {
      return null;
    }
    invariant(element.isDeploymentNode(), `Element ${element?.id} is not a deployment node`);
    return element;
  }
  instance(el) {
    const element = this.element(el);
    invariant(element.isInstance(), `Element ${element.id} is not a deployed instance`);
    return element;
  }
  findInstance(el) {
    const element = this.findElement(el);
    if (!element) {
      return null;
    }
    invariant(element.isInstance(), `Element ${element?.id} is not a deployed instance`);
    return element;
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return this.#rootElements.values();
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return this.#elements.values();
  }
  /**
   * Returns all elements in the model.
   */
  *nodes() {
    for (const element of this.#elements.values()) {
      if (element.isDeploymentNode()) {
        yield element;
      }
    }
    return;
  }
  *instances() {
    for (const element of this.#elements.values()) {
      if (element.isInstance()) {
        yield element;
      }
    }
    return;
  }
  /**
   * Iterate over all instances of the given logical element.
   */
  *instancesOf(element) {
    const id = getId(element);
    const instances = this.#instancesOf.get(id);
    if (instances) {
      yield* instances;
    }
    return;
  }
  deploymentRef(ref) {
    if ("element" in ref) {
      const { id, element } = ref;
      return getOrCreate(this.#nestedElementsOfDeployment, `${id}@${element}`, () => {
        return new NestedElementOfDeployedInstanceModel(this.instance(id), this.$model.element(element));
      });
    }
    return this.element(ref);
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return this.#relations.values();
  }
  /**
   * Returns a specific relationship by its ID.
   */
  relationship(id) {
    return nonNullable(this.#relations.get(id), `DeploymentRelationModel ${id} not found`);
  }
  findRelationship(id) {
    return this.#relations.get(id) ?? null;
  }
  /**
   * Returns all deployment views in the model.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (view.isDeploymentView()) {
        yield view;
      }
    }
    return;
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id = getId(element);
    return this.#parents.get(id) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id = getId(element);
    return this.#children.get(id);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  *siblings(element) {
    const id = getId(element);
    const siblings = this.parent(element)?.children() ?? this.roots();
    for (const sibling of siblings) {
      if (sibling.id !== id) {
        yield sibling;
      }
    }
    return;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors(element) {
    let id = isString(element) ? element : element.id;
    let parent;
    while (parent = this.#parents.get(id)) {
      yield parent;
      id = parent.id;
    }
    return;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  *descendants(element, sort = "desc") {
    for (const child of this.children(element)) {
      if (sort === "asc") {
        yield child;
        yield* this.descendants(child.id);
      } else {
        yield* this.descendants(child.id);
        yield child;
      }
    }
    return;
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  *incoming(element, filter = "all") {
    const id = getId(element);
    for (const rel of this.#incoming.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.target.id === id):
        case (filter === "to-descendants" && rel.target.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  *outgoing(element, filter = "all") {
    const id = getId(element);
    for (const rel of this.#outgoing.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.source.id === id):
        case (filter === "from-descendants" && rel.source.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  addElement(element) {
    if (this.#elements.has(element.id)) {
      throw new Error(`Element ${element.id} already exists`);
    }
    const el = DeploymentElement.isDeploymentNode(element) ? new DeploymentNodeModel(this, Object.freeze(element)) : new DeployedInstanceModel(this, Object.freeze(element), this.$model.element(element.element));
    this.#elements.set(el.id, el);
    const parentId = parentFqn(el.id);
    if (parentId) {
      invariant(this.#elements.has(parentId), `Parent ${parentId} of ${el.id} not found`);
      this.#parents.set(el.id, this.node(parentId));
      this.#children.get(parentId).add(el);
    } else {
      invariant(el.isDeploymentNode(), `Root element ${el.id} is not a deployment node`);
      this.#rootElements.add(el);
    }
    return el;
  }
  addRelation(relation) {
    if (this.#relations.has(relation.id)) {
      throw new Error(`Relation ${relation.id} already exists`);
    }
    const rel = new DeploymentRelationModel(
      this,
      Object.freeze(relation)
    );
    this.#relations.set(rel.id, rel);
    this.#incoming.get(rel.target.id).add(rel);
    this.#outgoing.get(rel.source.id).add(rel);
    const relParent = rel.boundary?.id ?? null;
    if (relParent) {
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)]) {
        this.#internal.get(ancestor).add(rel);
      }
    }
    for (const sourceAncestor of ancestorsFqn(rel.source.id)) {
      if (sourceAncestor === relParent) {
        break;
      }
      this.#outgoing.get(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(rel.target.id)) {
      if (targetAncestor === relParent) {
        break;
      }
      this.#incoming.get(targetAncestor).add(rel);
    }
    return rel;
  }
}

class RelationshipModel {
  constructor(model, $relationship) {
    this.model = model;
    this.$relationship = $relationship;
    this.source = model.element($relationship.source);
    this.target = model.element($relationship.target);
    const parent = commonAncestor(this.source.id, this.target.id);
    this.boundary = parent ? this.model.element(parent) : null;
  }
  source;
  target;
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the Relation.
   */
  boundary;
  get id() {
    return this.$relationship.id;
  }
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  get title() {
    if (n(this.$relationship.title)) {
      return null;
    }
    return this.$relationship.title;
  }
  get technology() {
    if (n(this.$relationship.technology)) {
      return null;
    }
    return this.$relationship.technology;
  }
  get description() {
    if (n(this.$relationship.description)) {
      return null;
    }
    return this.$relationship.description;
  }
  get navigateTo() {
    return this.$relationship.navigateTo ? this.model.view(this.$relationship.navigateTo) : null;
  }
  get tags() {
    return this.$relationship.tags ?? [];
  }
  get kind() {
    return this.$relationship.kind ?? null;
  }
  get links() {
    return this.$relationship.links ?? [];
  }
  get color() {
    return this.$relationship.color ?? DefaultRelationshipColor;
  }
  get line() {
    return this.$relationship.line ?? DefaultLineStyle;
  }
  /**
   * Iterate over all views that include this relationship.
   */
  *views() {
    for (const view of this.model.views()) {
      if (view.includesRelation(this.id)) {
        yield view;
      }
    }
    return;
  }
  isDeploymentRelation() {
    return false;
  }
}

class EdgeModel {
  constructor(view, $edge, source, target) {
    this.view = view;
    this.$edge = $edge;
    this.source = source;
    this.target = target;
  }
  get id() {
    return this.$edge.id;
  }
  get parent() {
    return this.$edge.parent ? this.view.node(this.$edge.parent) : null;
  }
  get label() {
    return this.$edge.label;
  }
  get description() {
    return this.$edge.description ?? null;
  }
  get technology() {
    return this.$edge.technology ?? null;
  }
  hasParent() {
    return this.$edge.parent !== null;
  }
  get tags() {
    return this.$edge.tags ?? [];
  }
  get stepNumber() {
    return this.isStep() ? extractStep(this.id) : null;
  }
  get navigateTo() {
    return this.$edge.navigateTo ? this.view.$model.view(this.$edge.navigateTo) : null;
  }
  get color() {
    return this.$edge.color ?? "gray";
  }
  get line() {
    return this.$edge.line ?? "dashed";
  }
  isStep() {
    return isStepEdgeId(this.id);
  }
  *relationships(type) {
    for (const id of this.$edge.relations) {
      if (type) {
        const rel = this.view.$model.findRelationship(id, type);
        if (rel) {
          yield rel;
        }
      } else {
        yield this.view.$model.relationship(id);
      }
    }
    return;
  }
  includesRelation(rel) {
    return this.$edge.relations.includes(rel);
  }
}

class NodeModel {
  constructor($view, $node) {
    this.$view = $view;
    this.$node = $node;
  }
  get id() {
    return this.$node.id;
  }
  get title() {
    return this.$node.title;
  }
  get kind() {
    return this.$node.kind;
  }
  get description() {
    return this.$node.description;
  }
  get technology() {
    return this.$node.technology;
  }
  get parent() {
    return this.$node.parent ? this.$view.node(this.$node.parent) : null;
  }
  get element() {
    const modelRef = ComputedNode.modelRef(this.$node);
    return modelRef ? this.$view.$model.element(modelRef) : null;
  }
  get deployment() {
    const modelRef = ComputedNode.deploymentRef(this.$node);
    return modelRef ? this.$view.$model.deployment.element(modelRef) : null;
  }
  get shape() {
    return this.$node.shape;
  }
  get color() {
    return this.$node.color;
  }
  get icon() {
    return this.$node.icon ?? null;
  }
  get tags() {
    return this.$node.tags ?? [];
  }
  get links() {
    return this.$node.links ?? [];
  }
  get navigateTo() {
    return this.$node.navigateTo ? this.$view.$model.view(this.$node.navigateTo) : null;
  }
  get style() {
    return this.$node.style;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors() {
    let parent = this.parent;
    while (parent) {
      yield parent;
      parent = parent.parent;
    }
    return;
  }
  *children() {
    for (const child of this.$node.children) {
      yield this.$view.node(child);
    }
    return;
  }
  *sublings() {
    const sublings = this.parent?.children() ?? this.$view.roots();
    for (const subling of sublings) {
      if (subling.id !== this.id) {
        yield subling;
      }
    }
    return;
  }
  *incoming(filter = "all") {
    for (const edgeId of this.$node.inEdges) {
      const edge = this.$view.edge(edgeId);
      switch (true) {
        case filter === "all":
        case (filter === "direct" && edge.target.id === this.id):
        case (filter === "to-descendants" && edge.target.id !== this.id):
          yield edge;
          break;
      }
    }
    return;
  }
  *incomers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.incoming(filter)) {
      if (unique.has(r.source.id)) {
        continue;
      }
      unique.add(r.source.id);
      yield r.source;
    }
    return;
  }
  *outgoing(filter = "all") {
    for (const edgeId of this.$node.outEdges) {
      const edge = this.$view.edge(edgeId);
      switch (true) {
        case filter === "all":
        case (filter === "direct" && edge.source.id === this.id):
        case (filter === "from-descendants" && edge.source.id !== this.id):
          yield edge;
          break;
      }
    }
    return;
  }
  *outgoers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.outgoing(filter)) {
      if (unique.has(r.target.id)) {
        continue;
      }
      unique.add(r.target.id);
      yield r.target;
    }
    return;
  }
  isDiagramNode() {
    return "width" in this.$node && "height" in this.$node;
  }
  hasChildren() {
    return this.$node.children.length > 0;
  }
  hasParent() {
    return this.$node.parent !== null;
  }
  /**
   * Check if this node references to logical model element.
   */
  hasElement() {
    return ComputedNode.modelRef(this.$node) !== null;
  }
  /**
   * Check if this node references to deployment element (Node or Instance).
   */
  hasDeployment() {
    return ComputedNode.deploymentRef(this.$node) !== null;
  }
  /**
   * Check if this node references to deployed instance
   * Deployed instance always references to element and deployment element.
   */
  hasDeployedInstance() {
    return this.hasElement() && this.hasDeployment();
  }
  isGroup() {
    return ComputedNode.isNodesGroup(this.$node);
  }
}

class LikeC4ViewModel {
  constructor($model, $view) {
    this.$model = $model;
    this.$view = $view;
    for (const node of $view.nodes) {
      const el = new NodeModel(this, Object.freeze(node));
      this.#nodes.set(node.id, el);
      if (!node.parent) {
        this.#rootnodes.add(el);
      }
      if (el.hasDeployment()) {
        this.#includeDeployments.add(el.deployment.id);
      }
      if (el.hasElement()) {
        this.#includeElements.add(el.element.id);
      }
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
    }
    for (const edge of $view.edges) {
      const edgeModel = new EdgeModel(
        this,
        Object.freeze(edge),
        this.node(edge.source),
        this.node(edge.target)
      );
      for (const tag of edgeModel.tags) {
        this.#allTags.get(tag).add(edgeModel);
      }
      for (const rel of edge.relations) {
        this.#includeRelations.add(rel);
      }
      this.#edges.set(edge.id, edgeModel);
    }
  }
  #rootnodes = /* @__PURE__ */ new Set();
  #nodes = /* @__PURE__ */ new Map();
  #edges = /* @__PURE__ */ new Map();
  #includeElements = /* @__PURE__ */ new Set();
  #includeDeployments = /* @__PURE__ */ new Set();
  #includeRelations = /* @__PURE__ */ new Set();
  #allTags = new DefaultMap((_key) => /* @__PURE__ */ new Set());
  get __() {
    return this.$view.__ ?? "element";
  }
  get id() {
    return this.$view.id;
  }
  get title() {
    return this.$view.title;
  }
  get tags() {
    return this.$view.tags ?? [];
  }
  get links() {
    return this.$view.links ?? [];
  }
  get viewOf() {
    const v = this.$view;
    if (isScopedElementView(v)) {
      return this.$model.element(v.viewOf);
    }
    return null;
  }
  /**
   * All tags from nodes and edges.
   */
  get includedTags() {
    return [...this.#allTags.keys()];
  }
  roots() {
    return this.#rootnodes.values();
  }
  /**
   * Iterate over all nodes that have children.
   */
  *compounds() {
    for (const node of this.#nodes.values()) {
      if (node.hasChildren()) {
        yield node;
      }
    }
    return;
  }
  /**
   * Get node by id.
   * @throws Error if node is not found.
   */
  node(node) {
    const nodeId = getId(node);
    return nonNullable(this.#nodes.get(nodeId), `Node ${nodeId} not found in view ${this.$view.id}`);
  }
  /**
   * Find node by id.
   */
  findNode(node) {
    return this.#nodes.get(getId(node)) ?? null;
  }
  findNodeWithElement(fqn) {
    const nd = ifind(this.#nodes.values(), (node) => node.element?.id === fqn) ?? null;
    return nd && nd.hasElement() ? nd : null;
  }
  /**
   * Iterate over all nodes.
   */
  nodes() {
    return this.#nodes.values();
  }
  /**
   * Find edge by id.
   * @param edge Edge or id
   * @returns EdgeModel
   */
  edge(edge) {
    const edgeId = getId(edge);
    return nonNullable(this.#edges.get(edgeId), `Edge ${edgeId} not found in view ${this.$view.id}`);
  }
  findEdge(edge) {
    return this.#edges.get(getId(edge)) ?? null;
  }
  /**
   * Iterate over all edges.
   */
  edges() {
    return this.#edges.values();
  }
  /**
   * Iterate over all edges.
   */
  *edgesWithRelation(relation) {
    for (const edge of this.#edges.values()) {
      if (edge.includesRelation(relation)) {
        yield edge;
      }
    }
    return;
  }
  /**
   * Nodes that have references to elements from logical model.
   */
  *elements() {
    for (const node of this.#nodes.values()) {
      if (node.hasElement()) {
        yield node;
      }
    }
    return;
  }
  includesElement(elementId) {
    return this.#includeElements.has(elementId);
  }
  includesDeployment(deploymentId) {
    return this.#includeDeployments.has(deploymentId);
  }
  includesRelation(relationId) {
    return this.#includeRelations.has(relationId);
  }
  /**
   * Below are type guards.
   */
  isComputed() {
    return true;
  }
  isDiagram() {
    return "bounds" in this.$view;
  }
  isElementView() {
    return isElementView(this.$view);
  }
  isDeploymentView() {
    return isDeploymentView(this.$view);
  }
  isDynamicView() {
    return isDynamicView(this.$view);
  }
}

class LikeC4Model {
  constructor($model) {
    this.$model = $model;
    for (const element of r$3($model.elements)) {
      const el = this.addElement(element);
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
    }
    for (const [projectId, elements] of t$1($model.imports ?? {})) {
      for (const element of sortParentsFirst(elements)) {
        const el = this.addImportedElement(projectId, element);
        for (const tag of el.tags) {
          this.#allTags.get(tag).add(el);
        }
      }
    }
    for (const relation of r$3($model.relations)) {
      const el = this.addRelation(relation);
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
    }
    this.deployment = new LikeC4DeploymentModel(this, $model.deployments);
    const views = C(
      r$3($model.views),
      m$1((a, b) => compareNatural(a.title ?? "untitled", b.title ?? "untitled"))
    );
    for (const view of views) {
      const vm = new LikeC4ViewModel(this, Object.freeze(view));
      this.#views.set(view.id, vm);
      for (const tag of vm.tags) {
        this.#allTags.get(tag).add(vm);
      }
    }
  }
  /**
   * Don't use in runtime, only for type inference
   */
  Aux = {};
  #elements = /* @__PURE__ */ new Map();
  // Parent element for given FQN
  #parents = /* @__PURE__ */ new Map();
  // Children elements for given FQN
  #children = new DefaultMap(() => /* @__PURE__ */ new Set());
  #rootElements = /* @__PURE__ */ new Set();
  #relations = /* @__PURE__ */ new Map();
  // Incoming to an element or its descendants
  #incoming = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Outgoing from an element or its descendants
  #outgoing = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Relationships inside the element, among descendants
  #internal = new DefaultMap(() => /* @__PURE__ */ new Set());
  #views = /* @__PURE__ */ new Map();
  #allTags = new DefaultMap(
    () => /* @__PURE__ */ new Set()
  );
  deployment;
  /**
   * Computes views from the parsed model
   * Creates a new LikeC4Model instance from a parsed model.
   *
   * May throw an error if the model is invalid.
   *
   * @typeParam M - The type of the parsed LikeC4 model, must extend ParsedLikeC4Model
   * @param parsed - The parsed LikeC4 model to compute from
   * @returns A new LikeC4Model instance with computed relationships and structure
   */
  static compute(parsed) {
    let { views, ...rest } = parsed;
    const model = new LikeC4Model({ ...rest, views: {} });
    return new LikeC4Model({
      ...rest,
      views: i$3(views, (view) => unsafeComputeView(view, model))
    });
  }
  /**
   * Creates a function that computes a view using the data from the model.
   *
   * @example
   * const compute = LikeC4Model.makeCompute(parsedModel);
   * const result = compute(viewSource);
   */
  static makeCompute(parsed) {
    let { views, ...rest } = parsed;
    const model = new LikeC4Model({ ...rest, views: {} });
    return (viewsource) => computeView(viewsource, model);
  }
  /**
   * Creates a new LikeC4Model instance from the provided model data.
   *
   * @typeParam M - Type parameter constrained to AnyLikeC4Model
   * @param model - The model data to create a LikeC4Model from
   * @returns A new LikeC4Model instance with the type derived from the input model
   */
  static create(model) {
    return new LikeC4Model(model);
  }
  /**
   * Creates a new LikeC4Model instance from a model dump.
   *
   * @typeParam M - A constant type parameter extending LikeC4ModelDump
   * @param dump - The model dump to create the instance from
   * @returns A new LikeC4Model instance with types inferred from the dump
   */
  static fromDump(dump) {
    return new LikeC4Model(dump);
  }
  get type() {
    return this.$model.__ ?? "computed";
  }
  element(el) {
    if (el instanceof ElementModel) {
      return el;
    }
    const id = getId(el);
    return nonNullable(this.findElement(id), `Element ${getId(el)} not found`);
  }
  findElement(el) {
    return this.#elements.get(el) ?? null;
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return this.#rootElements.values();
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return this.#elements.values();
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return this.#relations.values();
  }
  relationship(id, type) {
    if (type === "deployment") {
      return this.deployment.relationship(id);
    }
    let model = this.#relations.get(id) ?? null;
    if (model || type === "model") {
      return nonNullable(model, `Model relation ${id} not found`);
    }
    return nonNullable(this.deployment.findRelationship(id), `No model/deployment relation ${id} not found`);
  }
  findRelationship(id, type) {
    if (type === "deployment") {
      return this.deployment.findRelationship(id);
    }
    let model = this.#relations.get(id) ?? null;
    if (model || type === "model") {
      return model;
    }
    return this.deployment.findRelationship(id);
  }
  /**
   * Returns all views in the model.
   */
  views() {
    return this.#views.values();
  }
  /**
   * Returns a specific view by its ID.
   */
  view(viewId) {
    return nonNullable(this.#views.get(viewId), `View ${viewId} not found`);
  }
  findView(viewId) {
    return this.#views.get(viewId) ?? null;
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id = getId(element);
    return this.#parents.get(id) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id = getId(element);
    return this.#children.get(id);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  *siblings(element) {
    const id = getId(element);
    const parent = this.#parents.get(id);
    const siblings = parent ? this.#children.get(parent.id).values() : this.roots();
    for (const sibling of siblings) {
      if (sibling.id !== id) {
        yield sibling;
      }
    }
    return;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors(element) {
    let id = getId(element);
    let parent;
    while (parent = this.#parents.get(id)) {
      yield parent;
      id = parent.id;
    }
    return;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  *descendants(element) {
    for (const child of this.children(element)) {
      yield child;
      yield* this.descendants(child.id);
    }
    return;
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  *incoming(element, filter = "all") {
    const id = getId(element);
    for (const rel of this.#incoming.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.target.id === id):
        case (filter === "to-descendants" && rel.target.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  *outgoing(element, filter = "all") {
    const id = getId(element);
    for (const rel of this.#outgoing.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.source.id === id):
        case (filter === "from-descendants" && rel.source.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  globals() {
    return {
      predicates: {
        ...this.$model.globals?.predicates
      },
      dynamicPredicates: {
        ...this.$model.globals?.dynamicPredicates
      },
      styles: {
        ...this.$model.globals?.styles
      }
    };
  }
  allTags() {
    return Array.from(this.#allTags.keys());
  }
  addElement(element) {
    if (this.#elements.has(element.id)) {
      throw new Error(`Element ${element.id} already exists`);
    }
    const el = new ElementModel(this, Object.freeze(element));
    this.#elements.set(el.id, el);
    const parentId = parentFqn(el.id);
    if (parentId) {
      invariant(this.#elements.has(parentId), `Parent ${parentId} of ${el.id} not found`);
      this.#parents.set(el.id, this.element(parentId));
      this.#children.get(parentId).add(el);
    } else {
      this.#rootElements.add(el);
    }
    return el;
  }
  addImportedElement(projectId, element) {
    invariant(!isGlobalFqn(element.id), `Imported element already has global FQN`);
    const id = GlobalFqn(projectId, element.id);
    if (this.#elements.has(id)) {
      throw new Error(`Element ${id} already exists`);
    }
    const el = new ElementModel(
      this,
      Object.freeze({
        ...element,
        id
      })
    );
    this.#elements.set(el.id, el);
    let parentId = parentFqn(el.id);
    while (parentId) {
      if (parentId.includes(".") && this.#elements.has(parentId)) {
        this.#parents.set(el.id, this.element(parentId));
        this.#children.get(parentId).add(el);
        return el;
      }
      parentId = parentFqn(parentId);
    }
    this.#rootElements.add(el);
    return el;
  }
  addRelation(relation) {
    if (this.#relations.has(relation.id)) {
      throw new Error(`Relation ${relation.id} already exists`);
    }
    const rel = new RelationshipModel(
      this,
      Object.freeze(relation)
    );
    const { source, target } = rel;
    this.#relations.set(rel.id, rel);
    this.#incoming.get(target.id).add(rel);
    this.#outgoing.get(source.id).add(rel);
    const relParent = commonAncestor(source.id, target.id);
    if (relParent) {
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)]) {
        this.#internal.get(ancestor).add(rel);
      }
    }
    for (const sourceAncestor of ancestorsFqn(relation.source)) {
      if (sourceAncestor === relParent) {
        break;
      }
      this.#outgoing.get(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(relation.target)) {
      if (targetAncestor === relParent) {
        break;
      }
      this.#incoming.get(targetAncestor).add(rel);
    }
    return rel;
  }
}
((LikeC4Model2) => {
  LikeC4Model2.EMPTY = LikeC4Model2.create({
    projectId: "default",
    specification: {
      elements: {},
      relationships: {},
      deployments: {},
      tags: []
    },
    globals: {
      predicates: {},
      dynamicPredicates: {},
      styles: {}
    },
    deployments: {
      elements: {},
      relations: {}
    },
    elements: {},
    relations: {},
    views: {},
    imports: {}
  });
})(LikeC4Model || (LikeC4Model = {}));

export { isIncoming as A, isNestedConnection as B, Connection as C, DeployedInstanceModel as D, EdgeModel as E, isOutgoing as F, Graph as G, mergeConnections as H, find$1 as I, sortConnectionsByBoundaryHierarchy as J, sortDeepestFirst as K, LikeC4Model as L, isDeployedInstance as M, NodeModel as N, isDeploymentNode as O, RelationshipModel as R, i$3 as a, computeViews as b, computeView as c, d$2 as d, ConnectionModel as e, DeploymentConnectionModel as f, DeploymentNodeModel as g, DeploymentRelationModel as h, i$8 as i, ElementModel as j, LikeC4DeploymentModel as k, l$3 as l, LikeC4ViewModel as m, find as n, differenceConnections as o, findAscendingConnections as p, findDeepestNestedConnection as q, r$3 as r, findDescendantConnections as s, topologicalSortExports as t, unsafeComputeView as u, hasSameSource as v, willCreateCycle as w, hasSameSourceTarget as x, hasSameTarget as y, isAnyInOut as z };
