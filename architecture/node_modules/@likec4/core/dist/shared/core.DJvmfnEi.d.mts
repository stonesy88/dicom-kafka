import { d as IconUrl, F as Fqn, N as NonEmptyArray, T as Tag, E as ExclusiveUnion, e as ProjectId, P as Point, X as XYPoint } from './core.SjLhMA7a.mjs';
import { LiteralUnion, TupleToUnion, Tagged, NonEmptyTuple, Simplify, MergeExclusive } from 'type-fest';

declare const ThemeColors: readonly ["amber", "blue", "gray", "slate", "green", "indigo", "muted", "primary", "red", "secondary", "sky"];
type ThemeColor = typeof ThemeColors[number];
type HexColorLiteral = `#${string}`;
type ColorLiteral = HexColorLiteral;
type Color = LiteralUnion<ThemeColor, string>;
type ShapeSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
/**
 * For padding, margin, etc.
 */
type SpacingSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type TextSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
declare function isThemeColor(color: Color): color is ThemeColor;
interface ElementThemeColorValues {
    fill: ColorLiteral;
    stroke: ColorLiteral;
    hiContrast: ColorLiteral;
    loContrast: ColorLiteral;
}
type ElementThemeColors = {
    [key in ThemeColor]: ElementThemeColorValues;
};
interface RelationshipThemeColorValues {
    lineColor: ColorLiteral;
    labelBgColor: ColorLiteral;
    labelColor: ColorLiteral;
}
interface ThemeColorValues {
    elements: ElementThemeColorValues;
    relationships: RelationshipThemeColorValues;
}
type RelationshipThemeColors = {
    [key in ThemeColor]: RelationshipThemeColorValues;
};
interface LikeC4Theme {
    font: 'Arial';
    shadow: ColorLiteral;
    relationships: RelationshipThemeColors;
    elements: ElementThemeColors;
    sizes: {
        [key in ShapeSize]: {
            width: number;
            height: number;
        };
    };
    spacing: {
        [key in SpacingSize]: number;
    };
    textSizes: {
        [key in TextSize]: number;
    };
}

declare const BorderStyles: readonly ["solid", "dashed", "dotted", "none"];
type BorderStyle = TupleToUnion<typeof BorderStyles>;
type ElementKind<Kinds extends string = string> = Tagged<Kinds, 'ElementKind'>;
declare namespace ElementKind {
    const Group: ElementKind;
}
declare const ElementShapes: readonly ["rectangle", "person", "browser", "mobile", "cylinder", "storage", "queue"];
type ElementShape = TupleToUnion<typeof ElementShapes>;
declare const DefaultThemeColor: ThemeColor;
declare const DefaultElementShape: ElementShape;
declare const DefaultShapeSize: ShapeSize;
declare const DefaultPaddingSize: SpacingSize;
declare const DefaultTextSize: TextSize;
interface ElementStyle {
    readonly border?: BorderStyle;
    /**
     * In percentage 0-100, 0 is fully transparent
     *
     * @default 100
     */
    readonly opacity?: number;
    /**
     * If true, the element is rendered as multiple shapes
     * @default false
     */
    readonly multiple?: boolean;
    /**
     * Shape size
     *
     * @default 'md'
     */
    readonly size?: ShapeSize;
    readonly padding?: SpacingSize;
    readonly textSize?: TextSize;
}
interface TagSpec {
    readonly id: Tag;
    readonly style: ElementStyle;
}
interface Link {
    readonly title?: string;
    readonly url: string;
    readonly relative?: string;
}
interface TypedElement<Ids extends string, Kinds extends string, Tags extends string, MetadataKeys extends string = never> {
    readonly id: Fqn<Ids>;
    readonly kind: ElementKind<Kinds>;
    readonly title: string;
    readonly description: string | null;
    readonly technology: string | null;
    readonly tags: NonEmptyArray<Tag<Tags>> | null;
    readonly links: NonEmptyArray<Link> | null;
    readonly icon?: IconUrl;
    readonly shape?: ElementShape;
    readonly color?: Color;
    readonly style?: ElementStyle;
    readonly notation?: string;
    readonly metadata?: Record<MetadataKeys, string>;
}
interface Element extends TypedElement<string, string, string, string> {
}
interface ElementKindSpecificationStyle {
    shape?: ElementShape;
    icon?: IconUrl;
    color?: Color;
    border?: BorderStyle;
    opacity?: number;
    size?: ShapeSize;
    padding?: SpacingSize;
    textSize?: TextSize;
}
interface ElementKindSpecification {
    readonly technology?: string;
    readonly notation?: string;
    readonly style: ElementKindSpecificationStyle;
}

type EqualOperator<V> = {
    eq: V;
    neq?: never;
} | {
    eq?: never;
    neq: V;
};
type AllNever = {
    not?: never;
    and?: never;
    or?: never;
    tag?: never;
    kind?: never;
    participant?: never;
};
type TagEqual<Tag> = Omit<AllNever, 'tag'> & {
    tag: EqualOperator<Tag>;
};
declare const isTagEqual: <Tag>(operator: WhereOperator<Tag, any>) => operator is TagEqual<Tag>;
type KindEqual<Kind> = Omit<AllNever, 'kind'> & {
    kind: EqualOperator<Kind>;
};
declare const isKindEqual: <Kind>(operator: WhereOperator<any, Kind>) => operator is KindEqual<Kind>;
type Participant = 'source' | 'target';
type ParticipantOperator<Tag, Kind> = Omit<AllNever, 'participant'> & {
    participant: Participant;
    operator: KindEqual<Kind> | TagEqual<Tag>;
};
declare const isParticipantOperator: <Tag, Kind>(operator: WhereOperator<Tag, any>) => operator is ParticipantOperator<Tag, Kind>;
type NotOperator<Tag, Kind> = Omit<AllNever, 'not'> & {
    not: WhereOperator<Tag, Kind>;
};
declare const isNotOperator: <Tag, Kind>(operator: WhereOperator<Tag, Kind>) => operator is NotOperator<Tag, Kind>;
type AndOperator<Tag, Kind> = Omit<AllNever, 'and'> & {
    and: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
declare const isAndOperator: <Tag, Kind>(operator: WhereOperator<Tag, Kind>) => operator is AndOperator<Tag, Kind>;
type OrOperator<Tag, Kind> = Omit<AllNever, 'or'> & {
    or: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
declare const isOrOperator: <Tag, Kind>(operator: WhereOperator<Tag, Kind>) => operator is OrOperator<Tag, Kind>;
type WhereOperator<Tag, Kind> = TagEqual<Tag> | KindEqual<Kind> | ParticipantOperator<Tag, Kind> | NotOperator<Tag, Kind> | AndOperator<Tag, Kind> | OrOperator<Tag, Kind>;
type Filterable<FTag extends string | null = string | null, FKind extends string | null = string | null> = {
    tags?: readonly FTag[] | null;
    kind?: FKind;
    source?: Filterable<FTag, FKind>;
    target?: Filterable<FTag, FKind>;
};
type OperatorPredicate<V extends Filterable> = (value: V) => boolean;
declare function whereOperatorAsPredicate<FTag extends string | null = string | null, FKind extends string | null = string | null>(operator: WhereOperator<FTag, FKind>): OperatorPredicate<Filterable>;

declare namespace FqnRef {
    /**
     * Represents a reference to an instance within a deployment.
     *
     * @template D - The type representing the deployment fqn. Defaults to `Fqn`.
     * @template M - The type representing the model fqn. Defaults to `Fqn`.
     *
     * @property {D} deployment - TThe fully qualified name (FQN) of the deployed instance.
     * @property {M} element - The element reference within the deployment.
     */
    type InsideInstanceRef<D = Fqn, M = Fqn> = {
        deployment: D;
        element: M;
    };
    const isInsideInstanceRef: (ref: FqnRef) => ref is InsideInstanceRef;
    /**
     * Represents a reference to a deployment element.
     *
     * @template F - The type of the fully qualified name (FQN) of the deployment element. Defaults to `Fqn`.
     * @property {F} deployment - The fully qualified name (FQN) of the deployment element.
     */
    type DeploymentElementRef<F = Fqn> = {
        deployment: F;
    };
    const isDeploymentElementRef: (ref: FqnRef) => ref is DeploymentElementRef;
    type DeploymentRef<D = Fqn, M = Fqn> = DeploymentElementRef<D> | InsideInstanceRef<D, M>;
    const isDeploymentRef: (ref: FqnRef) => ref is DeploymentRef;
    /**
     * Reference to logical model element
     */
    type ModelRef<F = Fqn> = {
        model: F;
    };
    const isModelRef: (ref: FqnRef) => ref is ModelRef;
    /**
     * Reference to imported logical model element
     */
    type ImportRef<F = Fqn> = {
        project: ProjectId;
        model: F;
    };
    const isImportRef: (ref: FqnRef) => ref is ImportRef;
    const toDeploymentRef: (ref: FqnRef) => DeploymentRef;
    const toModelFqn: (ref: FqnRef) => Fqn;
}
type FqnRef<D = Fqn, M = Fqn> = ExclusiveUnion<{
    InsideInstanceRef: FqnRef.InsideInstanceRef<D, M>;
    DeploymentRef: FqnRef.DeploymentRef<D>;
    ModelRef: FqnRef.ModelRef<M>;
    ImportRef: FqnRef.ImportRef<M>;
}>;
declare namespace FqnExpr {
    type Wildcard = {
        wildcard: true;
    };
    const isWildcard: (expr: ExpressionV2) => expr is FqnExpr.Wildcard;
    type ModelRef<M = Fqn> = {
        ref: FqnRef.ModelRef<M> | FqnRef.ImportRef<M>;
        selector?: PredicateSelector;
    };
    const isModelRef: (ref: ExpressionV2) => ref is FqnExpr.ModelRef;
    type DeploymentRef<D = Fqn, M = Fqn> = {
        ref: FqnRef.DeploymentRef<D> | FqnRef.InsideInstanceRef<D, M>;
        selector?: PredicateSelector;
    };
    const isDeploymentRef: (ref: ExpressionV2) => ref is FqnExpr.DeploymentRef;
    type ElementKindExpr = {
        elementKind: ElementKind;
        isEqual: boolean;
    };
    function isElementKindExpr(expr: ExpressionV2): expr is ElementKindExpr;
    type ElementTagExpr = {
        elementTag: Tag;
        isEqual: boolean;
    };
    function isElementTagExpr(expr: ExpressionV2): expr is ElementTagExpr;
    type NonWildcard<D = Fqn, M = Fqn> = ExclusiveUnion<{
        ModelRef: ModelRef<M>;
        DeploymentRef: DeploymentRef<D, M>;
        ElementKind: ElementKindExpr;
        ElementTag: ElementTagExpr;
    }>;
    type Where<D = Fqn, M = Fqn> = {
        where: {
            expr: ExclusiveUnion<{
                Wildcard: Wildcard;
                ModelRef: ModelRef<M>;
                DeploymentRef: DeploymentRef<D, M>;
                ElementKind: ElementKindExpr;
                ElementTag: ElementTagExpr;
            }>;
            condition: WhereOperator<string, string>;
        };
    };
    const isWhere: (expr: ExpressionV2) => expr is FqnExpr.Where;
    type Custom<D = Fqn, M = Fqn> = {
        custom: {
            expr: OrWhere<D, M>;
            title?: string;
            description?: string;
            technology?: string;
            notation?: string;
            shape?: ElementShape;
            color?: Color;
            icon?: IconUrl;
            border?: BorderStyle;
            opacity?: number;
            navigateTo?: ViewId;
            multiple?: boolean;
            size?: ShapeSize;
            padding?: ShapeSize;
            textSize?: ShapeSize;
        };
    };
    const isCustom: (expr: ExpressionV2) => expr is Custom;
    const is: (expr: ExpressionV2) => expr is FqnExpr;
    type OrWhere<D = Fqn, M = Fqn> = ExclusiveUnion<{
        Wildcard: FqnExpr.Wildcard;
        ModelRef: FqnExpr.ModelRef<M>;
        DeploymentRef: FqnExpr.DeploymentRef<D, M>;
        ElementKind: ElementKindExpr;
        ElementTag: ElementTagExpr;
        Where: FqnExpr.Where<D, M>;
    }>;
    type Any<D = Fqn, M = Fqn> = ExclusiveUnion<{
        Wildcard: Wildcard;
        ModelRef: ModelRef<M>;
        DeploymentRef: DeploymentRef<D, M>;
        ElementKind: ElementKindExpr;
        ElementTag: ElementTagExpr;
        Where: Where<D, M>;
        Custom: Custom<D, M>;
    }>;
    const unwrap: (expr: FqnExpr) => Wildcard | ModelRef | DeploymentRef | ElementKindExpr | ElementTagExpr;
}
type FqnExpr<D = Fqn, M = Fqn> = ExclusiveUnion<{
    Wildcard: FqnExpr.Wildcard;
    ModelRef: FqnExpr.ModelRef<M>;
    DeploymentRef: FqnExpr.DeploymentRef<D, M>;
    ElementKind: FqnExpr.ElementKindExpr;
    ElementTag: FqnExpr.ElementTagExpr;
}>;
declare namespace RelationExpr {
    type Endpoint<D = Fqn, M = Fqn> = FqnExpr.Where<D, M>['where']['expr'];
    type Direct<D = Fqn, M = Fqn> = {
        source: Endpoint<D, M>;
        target: Endpoint<D, M>;
        isBidirectional?: boolean;
    };
    const isDirect: (expr: ExpressionV2) => expr is RelationExpr.Direct;
    type Incoming<D = Fqn, M = Fqn> = {
        incoming: Endpoint<D, M>;
    };
    const isIncoming: (expr: ExpressionV2) => expr is RelationExpr.Incoming;
    type Outgoing<D = Fqn, M = Fqn> = {
        outgoing: Endpoint<D, M>;
    };
    const isOutgoing: (expr: ExpressionV2) => expr is RelationExpr.Outgoing;
    type InOut<D = Fqn, M = Fqn> = {
        inout: Endpoint<D, M>;
    };
    const isInOut: (expr: ExpressionV2) => expr is RelationExpr.InOut;
    type Where<D = Fqn, M = Fqn> = {
        where: {
            expr: ExclusiveUnion<{
                Direct: RelationExpr.Direct<D, M>;
                Incoming: RelationExpr.Incoming<D, M>;
                Outgoing: RelationExpr.Outgoing<D, M>;
                InOut: RelationExpr.InOut<D, M>;
            }>;
            condition: WhereOperator<string, string>;
        };
    };
    const isWhere: (expr: ExpressionV2) => expr is RelationExpr.Where;
    type Custom<D = Fqn, M = Fqn> = {
        customRelation: {
            expr: OrWhere<D, M>;
            title?: string;
            description?: string;
            technology?: string;
            notation?: string;
            navigateTo?: ViewId;
            notes?: string;
            color?: Color;
            line?: RelationshipLineType;
            head?: RelationshipArrowType;
            tail?: RelationshipArrowType;
        };
    };
    const isCustom: (expr: ExpressionV2) => expr is Custom;
    const is: (expr: ExpressionV2) => expr is RelationExpr;
    type OrWhere<D = Fqn, M = Fqn> = ExclusiveUnion<{
        Direct: Direct<D, M>;
        Incoming: Incoming<D, M>;
        Outgoing: Outgoing<D, M>;
        InOut: InOut<D, M>;
        Where: Where<D, M>;
    }>;
    type Any<D = Fqn, M = Fqn> = ExclusiveUnion<{
        Direct: Direct<D, M>;
        Incoming: Incoming<D, M>;
        Outgoing: Outgoing<D, M>;
        InOut: InOut<D, M>;
        Where: Where<D, M>;
        Custom: Custom<D, M>;
    }>;
    const unwrap: (expr: RelationExpr) => Direct | Incoming | Outgoing | InOut;
}
type RelationExpr<D = Fqn, M = Fqn> = ExclusiveUnion<{
    Direct: RelationExpr.Direct<D, M>;
    Incoming: RelationExpr.Incoming<D, M>;
    Outgoing: RelationExpr.Outgoing<D, M>;
    InOut: RelationExpr.InOut<D, M>;
}>;
/**
 * Represents a version 2 expression which can be one of several types.
 *
 * @template D - The type for the deployment FQN, defaults to `Fqn`.
 * @template M - The type for the model FQN, defaults to `Fqn`.
 */
type ExpressionV2<D = Fqn, M = Fqn> = ExclusiveUnion<{
    Wildcard: FqnExpr.Wildcard;
    ModelRef: FqnExpr.ModelRef<M>;
    DeploymentRef: FqnExpr.DeploymentRef<D, M>;
    ElementKind: FqnExpr.ElementKindExpr;
    ElementTag: FqnExpr.ElementTagExpr;
    Custom: FqnExpr.Custom<D, M>;
    Direct: RelationExpr.Direct<D, M>;
    Incoming: RelationExpr.Incoming<D, M>;
    Outgoing: RelationExpr.Outgoing<D, M>;
    InOut: RelationExpr.InOut<D, M>;
    Where: ExpressionV2.Where<D, M>;
    CustomRelation: RelationExpr.Custom<D, M>;
}>;
declare namespace ExpressionV2 {
    type Where<D = Fqn, M = Fqn> = FqnExpr.Where<D, M> | RelationExpr.Where<D, M>;
    const isWhere: (expr: ExpressionV2) => expr is ExpressionV2.Where;
    const isRelationWhere: (expr: ExpressionV2) => expr is RelationExpr.Where;
    const isFqnExprWhere: (expr: ExpressionV2) => expr is FqnExpr.Where;
    const isFqnExpr: (expr: ExpressionV2) => expr is FqnExpr.Any;
    const isRelation: (expr: ExpressionV2) => expr is RelationExpr.Any;
}

declare namespace ModelLayer {
    namespace FqnRef {
        /**
         * Reference to logical model element
         */
        type ModelRef<F = Fqn> = {
            model: F;
        };
        const isModelRef: (ref: FqnRef) => ref is ModelRef;
        /**
         * Reference to imported logical model element
         */
        type ImportRef<F = Fqn> = {
            project: ProjectId;
            model: F;
        };
        const isImportRef: (ref: FqnRef) => ref is ImportRef;
        const toFqn: (ref: FqnRef) => Fqn;
    }
    type FqnRef<M = Fqn> = ExclusiveUnion<{
        ModelRef: FqnRef.ModelRef<M>;
        ImportRef: FqnRef.ImportRef<M>;
    }>;
    namespace FqnExpr {
        type Wildcard = {
            wildcard: true;
        };
        const isWildcard: (expr: Expression) => expr is FqnExpr.Wildcard;
        type ModelRef<M = Fqn> = {
            ref: FqnRef.ModelRef<M> | FqnRef.ImportRef<M>;
            selector?: PredicateSelector;
        };
        const isModelRef: (ref: Expression) => ref is FqnExpr.ModelRef;
        type ElementKindExpr = {
            elementKind: ElementKind;
            isEqual: boolean;
        };
        function isElementKindExpr(expr: Expression): expr is ElementKindExpr;
        type ElementTagExpr = {
            elementTag: Tag;
            isEqual: boolean;
        };
        function isElementTagExpr(expr: Expression): expr is ElementTagExpr;
        type NonWildcard<M = Fqn> = ExclusiveUnion<{
            ModelRef: ModelRef<M>;
            ElementKind: ElementKindExpr;
            ElementTag: ElementTagExpr;
        }>;
        type Where<M = Fqn> = {
            where: {
                expr: ExclusiveUnion<{
                    Wildcard: Wildcard;
                    ModelRef: ModelRef<M>;
                    ElementKind: ElementKindExpr;
                    ElementTag: ElementTagExpr;
                }>;
                condition: WhereOperator<string, string>;
            };
        };
        const isWhere: (expr: Expression) => expr is FqnExpr.Where;
        type Custom<M = Fqn> = {
            custom: {
                expr: FqnExprOrWhere<M>;
                title?: string;
                description?: string;
                technology?: string;
                notation?: string;
                shape?: ElementShape;
                color?: Color;
                icon?: IconUrl;
                border?: BorderStyle;
                opacity?: number;
                navigateTo?: ViewId;
                multiple?: boolean;
                size?: ShapeSize;
                padding?: ShapeSize;
                textSize?: ShapeSize;
            };
        };
        const isCustom: (expr: Expression) => expr is FqnExpr.Custom;
        const is: (expr: Expression) => expr is FqnExpr;
    }
    type FqnExpr<M = Fqn> = ExclusiveUnion<{
        Wildcard: FqnExpr.Wildcard;
        ModelRef: FqnExpr.ModelRef<M>;
        ElementKind: FqnExpr.ElementKindExpr;
        ElementTag: FqnExpr.ElementTagExpr;
    }>;
    type FqnExprOrWhere<M = Fqn> = ExclusiveUnion<{
        Wildcard: FqnExpr.Wildcard;
        ModelRef: FqnExpr.ModelRef<M>;
        ElementKind: FqnExpr.ElementKindExpr;
        ElementTag: FqnExpr.ElementTagExpr;
        Where: FqnExpr.Where<M>;
    }>;
    type AnyFqnExpr<M = Fqn> = ExclusiveUnion<{
        Wildcard: FqnExpr.Wildcard;
        ModelRef: FqnExpr.ModelRef<M>;
        ElementKind: FqnExpr.ElementKindExpr;
        ElementTag: FqnExpr.ElementTagExpr;
        Where: FqnExpr.Where<M>;
        Custom: FqnExpr.Custom<M>;
    }>;
    function isAnyFqnExpr(expr: Expression): expr is AnyFqnExpr;
    namespace RelationExpr {
        type Direct<M = Fqn> = {
            source: FqnExpr<M>;
            target: FqnExpr<M>;
            isBidirectional?: boolean;
        };
        const isDirect: (expr: Expression) => expr is RelationExpr.Direct;
        type Incoming<M = Fqn> = {
            incoming: FqnExpr<M>;
        };
        const isIncoming: (expr: Expression) => expr is RelationExpr.Incoming;
        type Outgoing<M = Fqn> = {
            outgoing: FqnExpr<M>;
        };
        const isOutgoing: (expr: Expression) => expr is RelationExpr.Outgoing;
        type InOut<M = Fqn> = {
            inout: FqnExpr<M>;
        };
        const isInOut: (expr: Expression) => expr is RelationExpr.InOut;
        type Where<M = Fqn> = {
            where: {
                expr: ExclusiveUnion<{
                    Direct: RelationExpr.Direct<M>;
                    Incoming: RelationExpr.Incoming<M>;
                    Outgoing: RelationExpr.Outgoing<M>;
                    InOut: RelationExpr.InOut<M>;
                }>;
                condition: WhereOperator<string, string>;
            };
        };
        const isWhere: (expr: Expression) => expr is RelationExpr.Where;
        type Custom<M = Fqn> = {
            customRelation: {
                expr: RelationExprOrWhere<M>;
                title?: string;
                description?: string;
                technology?: string;
                notation?: string;
                navigateTo?: ViewId;
                notes?: string;
                color?: Color;
                line?: RelationshipLineType;
                head?: RelationshipArrowType;
                tail?: RelationshipArrowType;
            };
        };
        const isCustom: (expr: Expression) => expr is Custom;
        const is: (expr: Expression) => expr is RelationExpr;
    }
    type RelationExpr<M = Fqn> = ExclusiveUnion<{
        Direct: RelationExpr.Direct<M>;
        Incoming: RelationExpr.Incoming<M>;
        Outgoing: RelationExpr.Outgoing<M>;
        InOut: RelationExpr.InOut<M>;
    }>;
    type RelationExprOrWhere<M = Fqn> = ExclusiveUnion<{
        Direct: RelationExpr.Direct<M>;
        Incoming: RelationExpr.Incoming<M>;
        Outgoing: RelationExpr.Outgoing<M>;
        InOut: RelationExpr.InOut<M>;
        Where: RelationExpr.Where<M>;
    }>;
    type AnyRelationExpr<M = Fqn> = ExclusiveUnion<{
        Direct: RelationExpr.Direct<M>;
        Incoming: RelationExpr.Incoming<M>;
        Outgoing: RelationExpr.Outgoing<M>;
        InOut: RelationExpr.InOut<M>;
        Where: RelationExpr.Where<M>;
        CustomRelation: RelationExpr.Custom<M>;
    }>;
    function isAnyRelationExpr(expr: Expression): expr is AnyRelationExpr;
    /**
     * Represents a version 2 expression which can be one of several types.
     *
     * @template M - The type for the model FQN, defaults to `Fqn`.
     */
    type Expression<M = Fqn> = ExclusiveUnion<{
        Wildcard: FqnExpr.Wildcard;
        ModelRef: FqnExpr.ModelRef<M>;
        ElementKind: FqnExpr.ElementKindExpr;
        ElementTag: FqnExpr.ElementTagExpr;
        Custom: FqnExpr.Custom<M>;
        Direct: RelationExpr.Direct<M>;
        Incoming: RelationExpr.Incoming<M>;
        Outgoing: RelationExpr.Outgoing<M>;
        InOut: RelationExpr.InOut<M>;
        CustomRelation: RelationExpr.Custom<M>;
        Where: Expression.Where<M>;
    }>;
    function isExpression(expr: any): expr is Expression;
    namespace Expression {
        type Where<M = Fqn> = FqnExpr.Where<M> | RelationExpr.Where<M>;
        const isWhere: (expr: Expression) => expr is Expression.Where;
        const isCustomFqnExpr: (expr: Expression) => expr is FqnExpr.Custom;
        const isCustomRelationExpr: (expr: Expression) => expr is RelationExpr.Custom;
        const isFqnExpr: (expr: Expression) => expr is FqnExpr;
        const isRelation: (expr: Expression) => expr is RelationExpr;
    }
}

type GlobalPredicateId = Tagged<string, 'GlobalPredicateId'>;
type GlobalPredicates = NonEmptyArray<ViewRulePredicate>;
type GlobalDynamicPredicates = NonEmptyArray<DynamicViewIncludeRule>;
type GlobalStyleID = Tagged<string, 'GlobalStyleID'>;
type GlobalStyles = NonEmptyTuple<ViewRuleStyle>;
interface ModelGlobals {
    readonly predicates: Record<GlobalPredicateId, GlobalPredicates>;
    readonly dynamicPredicates: Record<GlobalPredicateId, GlobalDynamicPredicates>;
    readonly styles: Record<GlobalStyleID, GlobalStyles>;
}

type ElementNotation = {
    kinds: string[];
    shape: ElementShape;
    color: Color;
    title: string;
};

type ViewId<Id extends string = string> = Tagged<Id, 'ViewID'>;
type ViewRulePredicate = {
    include: ModelLayer.Expression[];
    exclude?: never;
} | {
    include?: never;
    exclude: ModelLayer.Expression[];
};
declare function isViewRulePredicate(rule: DeploymentViewRule): rule is DeploymentViewRulePredicate;
declare function isViewRulePredicate(rule: DynamicViewRule): rule is DynamicViewIncludeRule;
declare function isViewRulePredicate(rule: ViewRule): rule is ViewRulePredicate;
interface ViewRuleGlobalPredicateRef {
    predicateId: GlobalPredicateId;
}
declare function isViewRuleGlobalPredicateRef(rule: ViewRule): rule is ViewRuleGlobalPredicateRef;
interface ViewRuleStyle {
    targets: ModelLayer.FqnExpr[];
    notation?: string;
    style: ElementStyle & {
        color?: Color;
        shape?: ElementShape;
        icon?: IconUrl;
    };
}
declare function isViewRuleStyle(rule: DeploymentViewRule): rule is DeploymentViewRuleStyle;
declare function isViewRuleStyle(rule: ViewRule): rule is ViewRuleStyle;
interface ViewRuleGlobalStyle {
    styleId: GlobalStyleID;
}
declare function isViewRuleGlobalStyle(rule: ViewRule): rule is ViewRuleGlobalStyle;
type ViewRuleStyleOrGlobalRef = ViewRuleStyle | ViewRuleGlobalStyle;
type AutoLayoutDirection = 'TB' | 'BT' | 'LR' | 'RL';
declare function isAutoLayoutDirection(autoLayout: unknown): autoLayout is AutoLayoutDirection;
interface ViewRuleAutoLayout {
    direction: AutoLayoutDirection;
    nodeSep?: number;
    rankSep?: number;
}
declare function isViewRuleAutoLayout(rule: DeploymentViewRule | DynamicViewRule | ViewRule): rule is ViewRuleAutoLayout;
interface ViewRuleGroup {
    groupRules: Array<ViewRulePredicate | ViewRuleGroup>;
    title: string | null;
    color?: Color;
    border?: BorderStyle;
    opacity?: number;
    multiple?: boolean;
    size?: ShapeSize;
    padding?: SpacingSize;
    textSize?: TextSize;
}
declare function isViewRuleGroup(rule: ViewRule): rule is ViewRuleGroup;
type ViewRule = ViewRulePredicate | ViewRuleGlobalPredicateRef | ViewRuleGroup | ViewRuleStyle | ViewRuleGlobalStyle | ViewRuleAutoLayout;
interface BasicView<ViewType extends 'element' | 'dynamic' | 'deployment', ViewIDs extends string, Tags extends string> {
    readonly __?: ViewType;
    readonly id: ViewId<ViewIDs>;
    readonly title: string | null;
    readonly description: string | null;
    readonly tags: NonEmptyArray<Tag<Tags>> | null;
    readonly links: NonEmptyArray<Link> | null;
    /**
     * URI to the source file of this view.
     * Undefined if the view is auto-generated.
     */
    readonly docUri?: string;
    /**
     * For all views we find common ancestor path.
     * This is used to generate relative paths, i.e.:
     * - "/home/project/index.c4" becomes "index.c4"
     * - "/home/project/subdir/views.c4" becomes "subdir/views.c4"
     *
     * Undefined if the view is auto-generated.
     */
    readonly relativePath?: string;
    /**
     * If the view is changed manually this field contains the layout data.
     */
    readonly manualLayout?: ViewManualLayout | undefined;
    readonly customColorDefinitions: CustomColorDefinitions;
}
interface BasicElementView<ViewIDs extends string, Tags extends string> extends BasicView<'element', ViewIDs, Tags> {
    readonly viewOf?: Fqn;
    readonly rules: ViewRule[];
}
interface ScopedElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
    readonly viewOf: Fqn;
}
interface ExtendsElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
    readonly extends: ViewId<ViewIDs>;
}
type ElementView<ViewIDs extends string = string, Tags extends string = string> = ScopedElementView<ViewIDs, Tags> | ExtendsElementView<ViewIDs, Tags> | BasicElementView<ViewIDs, Tags>;
interface DynamicViewStep {
    readonly source: Fqn;
    readonly target: Fqn;
    readonly title: string | null;
    readonly description?: string;
    readonly technology?: string;
    readonly notation?: string;
    readonly notes?: string;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly isBackward?: boolean;
    readonly navigateTo?: ViewId;
    __parallel?: never;
}
interface DynamicViewParallelSteps {
    readonly __parallel: DynamicViewStep[];
}
type DynamicViewStepOrParallel = DynamicViewStep | DynamicViewParallelSteps;
type DynamicViewIncludeRule = {
    include: ModelLayer.AnyFqnExpr[];
};
type DynamicViewRule = DynamicViewIncludeRule | ViewRuleGlobalPredicateRef | ViewRuleStyle | ViewRuleGlobalStyle | ViewRuleAutoLayout;
interface DynamicView<ViewIDs extends string = string, Tags extends string = string> extends BasicView<'dynamic', ViewIDs, Tags> {
    readonly __: 'dynamic';
    readonly steps: DynamicViewStepOrParallel[];
    readonly rules: DynamicViewRule[];
}
declare function isDynamicViewParallelSteps(step: DynamicViewStepOrParallel): step is DynamicViewParallelSteps;
type CustomColorDefinitions = {
    [key: string]: ThemeColorValues;
};
type DeploymentViewRulePredicate = {
    include: ExpressionV2[];
    exclude?: never;
} | {
    include?: never;
    exclude: ExpressionV2[];
};
type DeploymentViewRuleStyle = {
    targets: FqnExpr[];
    notation?: string;
    style: ElementStyle & {
        color?: Color;
        shape?: ElementShape;
        icon?: IconUrl;
    };
};
type DeploymentViewRule = DeploymentViewRulePredicate | ViewRuleAutoLayout | DeploymentViewRuleStyle;
interface DeploymentView<ViewIDs extends string = string, Tags extends string = string> extends BasicView<'deployment', ViewIDs, Tags> {
    readonly __: 'deployment';
    readonly rules: DeploymentViewRule[];
}
type LikeC4View<ViewIDs extends string = string, Tags extends string = string> = ElementView<ViewIDs, Tags> | DynamicView<ViewIDs, Tags> | DeploymentView<ViewIDs, Tags>;
declare function isDeploymentView(view: LikeC4View): view is DeploymentView;
declare function isDeploymentView<V extends {
    __?: string;
}>(view: V): boolean;
declare function isDynamicView(view: LikeC4View): view is DynamicView;
declare function isElementView(view: LikeC4View): view is ElementView;
declare function isExtendsElementView(view: LikeC4View): view is ExtendsElementView<string, string>;
declare function isScopedElementView(view: LikeC4View): view is ScopedElementView<string, string>;
type NodeId<IDs extends string = string> = Tagged<IDs, 'Fqn'>;
type EdgeId = Tagged<string, 'EdgeId'>;
type StepEdgeIdLiteral = `step-${number}` | `step-${number}.${number}`;
type StepEdgeId = Tagged<StepEdgeIdLiteral, 'EdgeId'>;
declare function stepEdgeId(step: number, parallelStep?: number): StepEdgeId;
declare function isStepEdgeId(id: string): id is StepEdgeId;
declare function extractStep(id: EdgeId): number;
declare function getParallelStepsPrefix(id: string): string | null;
interface ComputedNode {
    id: NodeId;
    kind: string;
    parent: NodeId | null;
    /**
     * Reference to model element
     * If 1 - node id is a reference
     */
    modelRef?: 1 | Fqn;
    /**
     * Reference to deployment element
     * If 1 - node id is a reference
     */
    deploymentRef?: 1 | Fqn;
    title: string;
    description: string | null;
    technology: string | null;
    notation?: string;
    tags: NonEmptyArray<Tag> | null;
    links: NonEmptyArray<Link> | null;
    children: NodeId[];
    inEdges: EdgeId[];
    outEdges: EdgeId[];
    shape: ElementShape;
    color: Color;
    /**
     * @deprecated Use `style` instead
     */
    icon?: IconUrl;
    style: ElementStyle;
    navigateTo?: ViewId | null;
    level: number;
    depth?: number;
    /**
     * If this node was customized in the view
     */
    isCustomized?: boolean;
}
declare namespace ComputedNode {
    function modelRef(node: ComputedNode): Fqn | null;
    function deploymentRef(node: ComputedNode): Fqn | null;
    /**
     * Nodes group is a special kind of node, exisiting only in view
     */
    function isNodesGroup(node: ComputedNode): boolean;
}
interface ComputedEdge {
    id: EdgeId;
    parent: NodeId | null;
    source: NodeId;
    target: NodeId;
    label: string | null;
    description?: string;
    technology?: string;
    relations: RelationId[];
    kind?: RelationshipKind;
    notation?: string;
    notes?: string;
    color?: Color;
    line?: RelationshipLineType;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
    tags?: NonEmptyArray<Tag>;
    navigateTo?: ViewId;
    /**
     * If this edge is derived from custom relationship predicate
     */
    isCustomized?: boolean;
    /**
     * For layouting purposes
     * @default 'forward'
     */
    dir?: 'forward' | 'back' | 'both';
}
interface ViewWithHash {
    /**
     * Hash of the view object.
     * This is used to detect changes in layout
     */
    hash: string;
}
interface ViewWithNotation {
    notation?: {
        elements: ElementNotation[];
    };
}
interface ViewAutoLayout {
    direction: ViewRuleAutoLayout['direction'];
    rankSep?: number;
    nodeSep?: number;
}
interface ComputedElementView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ElementView<ViewIDs, Tags>, 'rules' | 'docUri'>, ViewWithHash, ViewWithNotation {
    readonly extends?: ViewId<ViewIDs>;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode[];
    readonly edges: ComputedEdge[];
    rules?: never;
    docUri?: never;
}
interface ComputedDynamicView<ViewIDs extends string = string, Tags extends string = string> extends Omit<DynamicView<ViewIDs, Tags>, 'rules' | 'steps' | 'docUri'>, ViewWithHash, ViewWithNotation {
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode[];
    readonly edges: ComputedEdge[];
    steps?: never;
    rules?: never;
    docUri?: never;
}
interface ComputedDeploymentView<ViewIDs extends string = string, Tags extends string = string> extends Omit<DeploymentView<ViewIDs, Tags>, 'rules' | 'docUri'>, ViewWithHash, ViewWithNotation {
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode[];
    readonly edges: ComputedEdge[];
    rules?: never;
    docUri?: never;
}
type ComputedView<ViewIDs extends string = string, Tags extends string = string> = ComputedElementView<ViewIDs, Tags> | ComputedDynamicView<ViewIDs, Tags> | ComputedDeploymentView<ViewIDs, Tags>;
declare namespace ComputedView {
    function isDeployment(view: ComputedView): view is ComputedDeploymentView;
    function isDynamic(view: ComputedView): view is ComputedDynamicView;
    function isElement(view: ComputedView): view is ComputedElementView;
}
type BBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};
declare function getBBoxCenter({ x, y, width, height, }: BBox): XYPoint;
interface DiagramNode extends ComputedNode {
    width: number;
    height: number;
    position: Point;
    labelBBox: BBox;
}
declare namespace DiagramNode {
    function modelRef(node: Pick<DiagramNode, 'id' | 'modelRef'>): Fqn | null;
    function deploymentRef(node: Pick<DiagramNode, 'id' | 'deploymentRef'>): Fqn | null;
    /**
     * Nodes group is a special kind of node, exisiting only in view
     */
    function isNodesGroup(node: Pick<DiagramNode, 'kind'>): boolean;
}
interface DiagramEdge extends ComputedEdge {
    points: NonEmptyArray<Point>;
    controlPoints?: NonEmptyArray<XYPoint>;
    labelBBox?: BBox | null;
    dotpos?: string;
}
interface DiagramView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ComputedView<ViewIDs, Tags>, 'nodes' | 'edges' | 'manualLayout'> {
    readonly nodes: DiagramNode[];
    readonly edges: DiagramEdge[];
    readonly bounds: BBox;
    /**
     * If diagram has manual layout
     * But was changed and layout should be recalculated
     */
    hasLayoutDrift?: boolean;
    manualLayout?: never;
}
type ViewManualLayout = {
    readonly hash: string;
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: Record<string, {
        isCompound: boolean;
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    readonly edges: Record<string, {
        dotpos?: string;
        points: NonEmptyArray<Point>;
        controlPoints?: NonEmptyArray<XYPoint>;
        labelBBox?: BBox;
    }>;
};

type RelationId = Tagged<string, 'RelationID'>;
type RelationshipKind<Kinds extends string = string> = Tagged<Kinds, 'RelationshipKind'>;
type RelationshipLineType = 'dashed' | 'solid' | 'dotted';
type RelationshipArrowType = 'none' | 'normal' | 'onormal' | 'dot' | 'odot' | 'diamond' | 'odiamond' | 'crow' | 'open' | 'vee';
declare const DefaultLineStyle: RelationshipLineType;
declare const DefaultArrowType: RelationshipArrowType;
declare const DefaultRelationshipColor: ThemeColor;
interface AbstractRelation {
    readonly id: RelationId;
    readonly title?: string;
    readonly description?: string;
    readonly technology?: string;
    readonly tags?: NonEmptyArray<Tag> | null;
    readonly kind?: RelationshipKind;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly links?: NonEmptyArray<Link> | null;
    readonly navigateTo?: ViewId;
    readonly metadata?: {
        [key: string]: string;
    };
}
interface ModelRelation extends AbstractRelation {
    readonly source: Fqn;
    readonly target: Fqn;
    readonly title: string;
}
interface RelationshipKindSpecification {
    readonly technology?: string;
    readonly notation?: string;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
}

type DeploymentNodeKind<Kinds extends string = string> = Tagged<Kinds, 'DeploymentNodeKind'>;
type DeploymentElementStyle = ElementStyle & {
    readonly icon?: IconUrl;
    readonly shape?: ElementShape;
    readonly color?: Color;
};
interface DeploymentNodeKindSpecification {
    readonly technology?: string;
    readonly notation?: string;
    readonly style: DeploymentElementStyle;
}
interface DeploymentNode {
    readonly id: Fqn;
    readonly kind: DeploymentNodeKind;
    readonly title: string;
    readonly description?: string | null;
    readonly technology?: string | null;
    readonly tags?: NonEmptyArray<Tag> | null;
    readonly links?: NonEmptyArray<Link> | null;
    readonly style?: DeploymentElementStyle;
    readonly notation?: string;
    readonly metadata?: Record<string, string>;
}
interface DeployedInstance {
    /**
     * Format: `<DeploymentNode Fqn>.<Instance Id>`
     * i.e parent fqn is deployment target
     */
    readonly id: Fqn;
    readonly element: Fqn;
    readonly title?: string;
    readonly description?: string | null;
    readonly technology?: string | null;
    readonly tags?: NonEmptyArray<Tag> | null;
    readonly links?: NonEmptyArray<Link> | null;
    readonly style?: DeploymentElementStyle;
    readonly notation?: string;
    readonly metadata?: Record<string, string>;
}
type DeploymentElement = Simplify<MergeExclusive<DeploymentNode, DeployedInstance>>;
declare namespace DeploymentElement {
    const isDeploymentNode: (el: DeploymentElement) => el is DeploymentNode;
    const isInstance: (el: DeploymentElement) => el is DeployedInstance;
}
type PredicateSelector = 'children' | 'expanded' | 'descendants';
interface DeploymentRef {
    readonly id: Fqn;
    readonly element?: Fqn;
}
/**
 * NOTE:
 */
interface DeploymentRelation extends AbstractRelation {
    readonly id: RelationId;
    readonly source: DeploymentRef;
    readonly target: DeploymentRef;
}

/**
 * Represents a LikeC4 model with customizable type parameters,
 * parsed from DSL or result from Builder
 *
 * !IMPORTANT: This is a low-level type, use `LikeC4Model` instead.
 * !NOTE: Views are not computed yet.
 *
 * @typeParam ElementKinds - Types of elements in the model (defaults to string)
 * @typeParam RelationKinds - Types of relationships (defaults to string)
 * @typeParam Tags - Types of tags that can be applied (defaults to string)
 * @typeParam Fqns - Fully Qualified Names for elements (defaults to string)
 * @typeParam Views - Types of views in the model (defaults to string)
 * @typeParam DeploymentFqns - Fully Qualified Names for deployment nodes (defaults to string)
 */
interface ParsedLikeC4ModelData<ElementKinds extends string = string, RelationKinds extends string = string, Tags extends string = string, Fqns extends string = string, Views extends string = string, DeploymentFqns extends string = string> {
    __?: never;
    specification: {
        tags: Tag<Tags>[];
        elements: Record<ElementKinds, ElementKindSpecification>;
        deployments: Record<DeploymentNodeKind, DeploymentNodeKindSpecification>;
        relationships: Record<RelationKinds, RelationshipKindSpecification>;
    };
    elements: Record<Fqns, TypedElement<Fqns, ElementKinds, Tags>>;
    relations: Record<RelationId, ModelRelation>;
    globals: ModelGlobals;
    views: Record<Views, LikeC4View<Views, Tags>>;
    /**
     * Deployment Model.
     */
    deployments: {
        elements: Record<DeploymentFqns, DeploymentElement>;
        relations: Record<RelationId, DeploymentRelation>;
    };
    imports: Record<ProjectId, NonEmptyArray<Element>>;
}
type AnyParsedLikeC4ModelData = ParsedLikeC4ModelData<any, any, any, any, any, any>;
/**
 * Hook to get types from dump
 */
type LikeC4ModelDump = {
    elements: {
        [kind: string]: object;
    };
    deployments: {
        elements: {
            [kind: string]: object;
        };
    };
    views: {
        [kind: string]: object;
    };
};
/**
 * Same as {@link ParsedLikeC4ModelData}, but with computed views or layouted views.
 */
interface GenericLikeC4ModelData<Fqns extends string = string, DeploymentFqns extends string = string, Views extends string = string, Tags extends string = string, T = 'computed' | 'layouted'> extends Omit<ParsedLikeC4ModelData<string, string, Tags, Fqns, Views, DeploymentFqns>, 'views' | '__'> {
    __?: T;
    views: Record<Views, ComputedView<Views> | DiagramView<Views>>;
}
interface ComputedLikeC4ModelData<Fqns extends string = string, DeploymentFqns extends string = string, Views extends string = string, Tags extends string = string> extends Omit<GenericLikeC4ModelData<Fqns, DeploymentFqns, Views, Tags, 'computed'>, 'views'> {
    views: Record<Views, ComputedView<Views>>;
}
interface LayoutedLikeC4ModelData<Fqns extends string = string, DeploymentFqns extends string = string, Views extends string = string, Tags extends string = string> extends Omit<GenericLikeC4ModelData<Fqns, DeploymentFqns, Views, Tags, 'layouted'>, 'views'> {
    __: 'layouted';
    views: Record<Views, DiagramView<Views, Tags>>;
}

export { isTagEqual as $, type GlobalPredicateId as A, BorderStyles as B, type ComputedLikeC4ModelData as C, DeploymentElement as D, ElementKind as E, FqnExpr as F, type GlobalDynamicPredicates as G, type HexColorLiteral as H, type GlobalPredicates as I, type GlobalStyleID as J, type GlobalStyles as K, type LikeC4View as L, ModelLayer as M, type ModelGlobals as N, type AnyParsedLikeC4ModelData as O, type PredicateSelector as P, type GenericLikeC4ModelData as Q, RelationExpr as R, type LayoutedLikeC4ModelData as S, type ThemeColorValues as T, type LikeC4ModelDump as U, type ParsedLikeC4ModelData as V, isAndOperator as W, isKindEqual as X, isNotOperator as Y, isOrOperator as Z, isParticipantOperator as _, ComputedView as a, type CustomColorDefinitions as a$, whereOperatorAsPredicate as a0, type AllNever as a1, type AndOperator as a2, type EqualOperator as a3, type Filterable as a4, type KindEqual as a5, type NotOperator as a6, type OperatorPredicate as a7, type OrOperator as a8, type Participant as a9, DiagramNode as aA, extractStep as aB, getBBoxCenter as aC, getParallelStepsPrefix as aD, isAutoLayoutDirection as aE, isDeploymentView as aF, isDynamicView as aG, isDynamicViewParallelSteps as aH, isElementView as aI, isExtendsElementView as aJ, isScopedElementView as aK, isStepEdgeId as aL, isViewRuleAutoLayout as aM, isViewRuleGlobalPredicateRef as aN, isViewRuleGlobalStyle as aO, isViewRuleGroup as aP, isViewRulePredicate as aQ, isViewRuleStyle as aR, stepEdgeId as aS, type AutoLayoutDirection as aT, type BasicElementView as aU, type BasicView as aV, type BBox as aW, type ComputedDeploymentView as aX, type ComputedDynamicView as aY, type ComputedEdge as aZ, type ComputedElementView as a_, type ParticipantOperator as aa, type TagEqual as ab, type WhereOperator as ac, DefaultArrowType as ad, DefaultLineStyle as ae, DefaultRelationshipColor as af, type AbstractRelation as ag, type ModelRelation as ah, type RelationId as ai, type RelationshipArrowType as aj, type RelationshipKind as ak, type RelationshipKindSpecification as al, type RelationshipLineType as am, isThemeColor as an, ThemeColors as ao, type Color as ap, type ColorLiteral as aq, type ElementThemeColors as ar, type ElementThemeColorValues as as, type RelationshipThemeColors as at, type RelationshipThemeColorValues as au, type ShapeSize as av, type SpacingSize as aw, type TextSize as ax, type ThemeColor as ay, ComputedNode as az, type LikeC4Theme as b, type DeploymentView as b0, type DeploymentViewRule as b1, type DeploymentViewRulePredicate as b2, type DeploymentViewRuleStyle as b3, type DiagramEdge as b4, type DiagramView as b5, type DynamicView as b6, type DynamicViewIncludeRule as b7, type DynamicViewParallelSteps as b8, type DynamicViewRule as b9, type DynamicViewStep as ba, type DynamicViewStepOrParallel as bb, type EdgeId as bc, type ElementView as bd, type ExtendsElementView as be, type NodeId as bf, type ScopedElementView as bg, type StepEdgeId as bh, type StepEdgeIdLiteral as bi, type ViewAutoLayout as bj, type ViewId as bk, type ViewManualLayout as bl, type ViewRule as bm, type ViewRuleAutoLayout as bn, type ViewRuleGlobalPredicateRef as bo, type ViewRuleGlobalStyle as bp, type ViewRuleGroup as bq, type ViewRulePredicate as br, type ViewRuleStyle as bs, type ViewRuleStyleOrGlobalRef as bt, type ViewWithHash as bu, type ViewWithNotation as bv, type ElementNotation as bw, type DeployedInstance as c, type DeploymentElementStyle as d, type DeploymentNode as e, type DeploymentNodeKind as f, type DeploymentNodeKindSpecification as g, type DeploymentRef as h, type DeploymentRelation as i, DefaultElementShape as j, DefaultPaddingSize as k, DefaultShapeSize as l, DefaultTextSize as m, DefaultThemeColor as n, ElementShapes as o, type BorderStyle as p, type Element as q, type ElementKindSpecification as r, type ElementKindSpecificationStyle as s, type ElementShape as t, type ElementStyle as u, type Link as v, type TagSpec as w, type TypedElement as x, ExpressionV2 as y, FqnRef as z };
