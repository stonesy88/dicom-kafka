import { Simplify, UnionToIntersection, Tagged } from 'type-fest';

type NonEmptyArray<T> = [T, ...T[]];
type NonEmptyReadonlyArray<T> = readonly [T, ...T[]];
type CustomColor = string;
type Point = readonly [x: number, y: number];
interface XYPoint {
    x: number;
    y: number;
}
type KeysOf<T> = keyof T extends infer K extends string ? K : never;
type AllNever<Expressions> = UnionToIntersection<{
    [Name in keyof Expressions]: {
        -readonly [Key in keyof Expressions[Name]]?: never;
    };
}[keyof Expressions]>;
/**
 * @example
 *   type Variant1 = {
 *     a: string
 *   }
 *   type Variant2 = {
 *     b: number
 *   }
 *
 *   type Variants = ExclusiveUnion<{
 *     Variant1: Variant1,
 *     Variant2: Variant2
 *   }>
 *
 *   Fail here
 *   const variant1: Variants = {
 *      a: 'one',
 *      b: 1
 *   }
 */
type ExclusiveUnion<Expressions> = Expressions extends object ? {
    [Name in keyof Expressions]: Simplify<Omit<AllNever<Expressions>, keyof Expressions[Name]> & Expressions[Name]>;
}[keyof Expressions] : Expressions;
/**
 * Copy from https://github.com/remeda/remeda/blob/main/src/internal/types/NTuple.ts
 * An array with *exactly* N elements in it.
 *
 * Only literal N values are supported. For very large N the type might result
 * in a recurse depth error. For negative N the type would result in an infinite
 * recursion. None of these have protections because this is an internal type!
 */
type NTuple<T, N extends number, Result extends Array<unknown> = []> = Result['length'] extends N ? Result : NTuple<T, N, [...Result, T]>;
type IteratorLike<T> = IteratorObject<T, BuiltinIteratorReturn>;
type Predicate<T> = (x: T) => boolean;

type ProjectId = Tagged<string, 'ProjectID'>;
type IconUrl = Tagged<string, 'IconUrl'> | 'none';
type Fqn<Id extends string = string> = Tagged<Id, 'Fqn'>;
type Tag<Tags extends string = string> = Tagged<Tags, 'Tag'>;
declare function AsFqn(name: string, parent?: Fqn | null): Fqn;
type GlobalFqn<Id extends string = string> = Tagged<Fqn<Id>, 'GlobalFqn'>;
declare function GlobalFqn(projectId: ProjectId, name: string): GlobalFqn;
declare function isGlobalFqn(fqn: string): fqn is GlobalFqn;
declare function splitGlobalFqn<Id extends string>(fqn: Fqn<Id> | GlobalFqn<Id>): [ProjectId | null, Fqn<Id>];

export { AsFqn as A, type CustomColor as C, type ExclusiveUnion as E, type Fqn as F, GlobalFqn as G, type IteratorLike as I, type KeysOf as K, type NonEmptyArray as N, type Point as P, type Tag as T, type XYPoint as X, type NonEmptyReadonlyArray as a, type NTuple as b, type Predicate as c, type IconUrl as d, type ProjectId as e, isGlobalFqn as i, splitGlobalFqn as s };
