import { r as requireForeach, p as requireIterator, v as n } from '../shared/core.Cu-UdkSl.mjs';
export { S as Stack, c as commonHead, h as difference, j as equalsSet, g as getOrCreate, i as hasAtLeast, a as ifind, b as iflat, k as intersection, d as isIterable, e as isome, f as iunique, o as objectHash, n as stringHash, s as symmetricDifference, u as union } from '../shared/core.Cu-UdkSl.mjs';
import { j as getDefaultExportFromCjs, h as t, m as commonAncestor, q as compareFqnHierarchically } from '../shared/core.CQXU9DF7.mjs';
export { D as DefaultMap, l as ancestorsFqn, o as compareByFqnHierarchically, k as compareNatural, r as hierarchyDistance, u as hierarchyLevel, c as ifilter, d as imap, a as isAncestor, i as isDescendantOf, e as isNonEmptyArray, g as isSameHierarchy, x as isString, n as nameFromFqn, p as parentFqn, v as sortByFqnHierarchically, w as sortNaturalByFqn, s as sortParentsFirst, b as toArray, t as toSet } from '../shared/core.CQXU9DF7.mjs';
import { i as invariant } from '../shared/core.C-YXI-43.mjs';

function o(r,n){let e=Math.ceil(r),t=Math.floor(n);if(t<e)throw new RangeError(`randomInteger: The range [${r.toString()},${n.toString()}] contains no integer`);return Math.floor(Math.random()*(t-e+1)+e)}

/**
 * Mnemonist BiMap
 * ================
 *
 * JavaScript implementation of a BiMap.
 */

var biMap$1;
var hasRequiredBiMap;

function requireBiMap () {
	if (hasRequiredBiMap) return biMap$1;
	hasRequiredBiMap = 1;
	var forEach = requireForeach();

	/**
	 * Inverse Map.
	 *
	 * @constructor
	 */
	function InverseMap(original) {

	  this.size = 0;
	  this.items = new Map();
	  this.inverse = original;
	}

	/**
	 * BiMap.
	 *
	 * @constructor
	 */
	function BiMap() {

	  this.size = 0;
	  this.items = new Map();
	  this.inverse = new InverseMap(this);
	}

	/**
	 * Method used to clear the map.
	 *
	 * @return {undefined}
	 */
	function clear() {
	  this.size = 0;
	  this.items.clear();
	  this.inverse.items.clear();
	}

	BiMap.prototype.clear = clear;
	InverseMap.prototype.clear = clear;

	/**
	 * Method used to set a relation.
	 *
	 * @param  {any} key - Key.
	 * @param  {any} value - Value.
	 * @return {BiMap|InverseMap}
	 */
	function set(key, value) {

	  // First we need to attempt to see if the relation is not flawed
	  if (this.items.has(key)) {
	    var currentValue = this.items.get(key);

	    // The relation already exists, we do nothing
	    if (currentValue === value)
	      return this;
	    else
	      this.inverse.items.delete(currentValue);
	  }

	  if (this.inverse.items.has(value)) {
	    var currentKey = this.inverse.items.get(value);

	    if (currentKey === key)
	      return this;
	    else
	      this.items.delete(currentKey);
	  }

	  // Here we actually add the relation
	  this.items.set(key, value);
	  this.inverse.items.set(value, key);

	  // Size
	  this.size = this.items.size;
	  this.inverse.size = this.inverse.items.size;

	  return this;
	}

	BiMap.prototype.set = set;
	InverseMap.prototype.set = set;

	/**
	 * Method used to delete a relation.
	 *
	 * @param  {any} key - Key.
	 * @return {boolean}
	 */
	function del(key) {
	  if (this.items.has(key)) {
	    var currentValue = this.items.get(key);

	    this.items.delete(key);
	    this.inverse.items.delete(currentValue);

	    // Size
	    this.size = this.items.size;
	    this.inverse.size = this.inverse.items.size;

	    return true;
	  }

	  return false;
	}

	BiMap.prototype.delete = del;
	InverseMap.prototype.delete = del;

	/**
	 * Mapping some Map prototype function unto our two classes.
	 */
	var METHODS = ['has', 'get', 'forEach', 'keys', 'values', 'entries'];

	METHODS.forEach(function(name) {
	  BiMap.prototype[name] = InverseMap.prototype[name] = function() {
	    return Map.prototype[name].apply(this.items, arguments);
	  };
	});

	/**
	 * Attaching the #.values method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined') {
	  BiMap.prototype[Symbol.iterator] = BiMap.prototype.entries;
	  InverseMap.prototype[Symbol.iterator] = InverseMap.prototype.entries;
	}

	/**
	 * Convenience known methods.
	 */
	BiMap.prototype.inspect = function() {
	  var dummy = {
	    left: this.items,
	    right: this.inverse.items
	  };

	  // Trick so that node displays the name of the constructor
	  Object.defineProperty(dummy, 'constructor', {
	    value: BiMap,
	    enumerable: false
	  });

	  return dummy;
	};

	if (typeof Symbol !== 'undefined')
	  BiMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = BiMap.prototype.inspect;

	InverseMap.prototype.inspect = function() {
	  var dummy = {
	    left: this.inverse.items,
	    right: this.items
	  };

	  // Trick so that node displays the name of the constructor
	  Object.defineProperty(dummy, 'constructor', {
	    value: InverseMap,
	    enumerable: false
	  });

	  return dummy;
	};

	if (typeof Symbol !== 'undefined')
	  InverseMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = InverseMap.prototype.inspect;


	/**
	 * Static @.from function taking an arbitrary iterable & converting it into
	 * a bimap.
	 *
	 * @param  {Iterable} iterable - Target iterable.
	 * @return {BiMap}
	 */
	BiMap.from = function(iterable) {
	  var bimap = new BiMap();

	  forEach(iterable, function(value, key) {
	    bimap.set(key, value);
	  });

	  return bimap;
	};

	/**
	 * Exporting.
	 */
	biMap$1 = BiMap;
	return biMap$1;
}

var biMapExports = /*@__PURE__*/ requireBiMap();
const biMap = /*@__PURE__*/getDefaultExportFromCjs(biMapExports);

/**
 * Mnemonist DefaultWeakMap
 * =========================
 *
 * JavaScript implementation of a default weak map that will return a constructed
 * value any time one tries to access an non-existing key. It is similar to
 * DefaultMap but uses ES6 WeakMap that only holds weak reference to keys.
 */

var defaultWeakMap$1;
var hasRequiredDefaultWeakMap;

function requireDefaultWeakMap () {
	if (hasRequiredDefaultWeakMap) return defaultWeakMap$1;
	hasRequiredDefaultWeakMap = 1;
	/**
	 * DefaultWeakMap.
	 *
	 * @constructor
	 */
	function DefaultWeakMap(factory) {
	  if (typeof factory !== 'function')
	    throw new Error('mnemonist/DefaultWeakMap.constructor: expecting a function.');

	  this.items = new WeakMap();
	  this.factory = factory;
	}

	/**
	 * Method used to clear the structure.
	 *
	 * @return {undefined}
	 */
	DefaultWeakMap.prototype.clear = function() {

	  // Properties
	  this.items = new WeakMap();
	};

	/**
	 * Method used to get the value set for given key. If the key does not exist,
	 * the value will be created using the provided factory.
	 *
	 * @param  {any} key - Target key.
	 * @return {any}
	 */
	DefaultWeakMap.prototype.get = function(key) {
	  var value = this.items.get(key);

	  if (typeof value === 'undefined') {
	    value = this.factory(key);
	    this.items.set(key, value);
	  }

	  return value;
	};

	/**
	 * Method used to get the value set for given key. If the key does not exist,
	 * a value won't be created.
	 *
	 * @param  {any} key - Target key.
	 * @return {any}
	 */
	DefaultWeakMap.prototype.peek = function(key) {
	  return this.items.get(key);
	};

	/**
	 * Method used to set a value for given key.
	 *
	 * @param  {any} key   - Target key.
	 * @param  {any} value - Value.
	 * @return {DefaultMap}
	 */
	DefaultWeakMap.prototype.set = function(key, value) {
	  this.items.set(key, value);
	  return this;
	};

	/**
	 * Method used to test the existence of a key in the map.
	 *
	 * @param  {any} key   - Target key.
	 * @return {boolean}
	 */
	DefaultWeakMap.prototype.has = function(key) {
	  return this.items.has(key);
	};

	/**
	 * Method used to delete target key.
	 *
	 * @param  {any} key   - Target key.
	 * @return {boolean}
	 */
	DefaultWeakMap.prototype.delete = function(key) {
	  return this.items.delete(key);
	};

	/**
	 * Convenience known methods.
	 */
	DefaultWeakMap.prototype.inspect = function() {
	  return this.items;
	};

	if (typeof Symbol !== 'undefined')
	  DefaultWeakMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = DefaultWeakMap.prototype.inspect;

	/**
	 * Exporting.
	 */
	defaultWeakMap$1 = DefaultWeakMap;
	return defaultWeakMap$1;
}

var defaultWeakMapExports = /*@__PURE__*/ requireDefaultWeakMap();
const defaultWeakMap = /*@__PURE__*/getDefaultExportFromCjs(defaultWeakMapExports);

/**
 * Mnemonist Linked List
 * ======================
 *
 * Singly linked list implementation. Uses raw JavaScript objects as nodes
 * as benchmarks proved it was the fastest thing to do.
 */

var linkedList$1;
var hasRequiredLinkedList;

function requireLinkedList () {
	if (hasRequiredLinkedList) return linkedList$1;
	hasRequiredLinkedList = 1;
	var Iterator = requireIterator(),
	    forEach = requireForeach();

	/**
	 * Linked List.
	 *
	 * @constructor
	 */
	function LinkedList() {
	  this.clear();
	}

	/**
	 * Method used to clear the list.
	 *
	 * @return {undefined}
	 */
	LinkedList.prototype.clear = function() {

	  // Properties
	  this.head = null;
	  this.tail = null;
	  this.size = 0;
	};

	/**
	 * Method used to get the first item of the list.
	 *
	 * @return {any}
	 */
	LinkedList.prototype.first = function() {
	  return this.head ? this.head.item : undefined;
	};
	LinkedList.prototype.peek = LinkedList.prototype.first;

	/**
	 * Method used to get the last item of the list.
	 *
	 * @return {any}
	 */
	LinkedList.prototype.last = function() {
	  return this.tail ? this.tail.item : undefined;
	};

	/**
	 * Method used to add an item at the end of the list.
	 *
	 * @param  {any}    item - The item to add.
	 * @return {number}
	 */
	LinkedList.prototype.push = function(item) {
	  var node = {item: item, next: null};

	  if (!this.head) {
	    this.head = node;
	    this.tail = node;
	  }
	  else {
	    this.tail.next = node;
	    this.tail = node;
	  }

	  this.size++;

	  return this.size;
	};

	/**
	 * Method used to add an item at the beginning of the list.
	 *
	 * @param  {any}    item - The item to add.
	 * @return {number}
	 */
	LinkedList.prototype.unshift = function(item) {
	  var node = {item: item, next: null};

	  if (!this.head) {
	    this.head = node;
	    this.tail = node;
	  }
	  else {
	    if (!this.head.next)
	      this.tail = this.head;
	    node.next = this.head;
	    this.head = node;
	  }

	  this.size++;

	  return this.size;
	};

	/**
	 * Method used to retrieve & remove the first item of the list.
	 *
	 * @return {any}
	 */
	LinkedList.prototype.shift = function() {
	  if (!this.size)
	    return undefined;

	  var node = this.head;

	  this.head = node.next;
	  this.size--;

	  return node.item;
	};

	/**
	 * Method used to iterate over the list.
	 *
	 * @param  {function}  callback - Function to call for each item.
	 * @param  {object}    scope    - Optional scope.
	 * @return {undefined}
	 */
	LinkedList.prototype.forEach = function(callback, scope) {
	  if (!this.size)
	    return;

	  scope = arguments.length > 1 ? scope : this;

	  var n = this.head,
	      i = 0;

	  while (n) {
	    callback.call(scope, n.item, i, this);
	    n = n.next;
	    i++;
	  }
	};

	/**
	 * Method used to convert the list into an array.
	 *
	 * @return {array}
	 */
	LinkedList.prototype.toArray = function() {
	  if (!this.size)
	    return [];

	  var array = new Array(this.size);

	  for (var i = 0, l = this.size, n = this.head; i < l; i++) {
	    array[i] = n.item;
	    n = n.next;
	  }

	  return array;
	};

	/**
	 * Method used to create an iterator over a list's values.
	 *
	 * @return {Iterator}
	 */
	LinkedList.prototype.values = function() {
	  var n = this.head;

	  return new Iterator(function() {
	    if (!n)
	      return {
	        done: true
	      };

	    var value = n.item;
	    n = n.next;

	    return {
	      value: value,
	      done: false
	    };
	  });
	};

	/**
	 * Method used to create an iterator over a list's entries.
	 *
	 * @return {Iterator}
	 */
	LinkedList.prototype.entries = function() {
	  var n = this.head,
	      i = 0;

	  return new Iterator(function() {
	    if (!n)
	      return {
	        done: true
	      };

	    var value = n.item;
	    n = n.next;
	    i++;

	    return {
	      value: [i - 1, value],
	      done: false
	    };
	  });
	};

	/**
	 * Attaching the #.values method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined')
	  LinkedList.prototype[Symbol.iterator] = LinkedList.prototype.values;

	/**
	 * Convenience known methods.
	 */
	LinkedList.prototype.toString = function() {
	  return this.toArray().join(',');
	};

	LinkedList.prototype.toJSON = function() {
	  return this.toArray();
	};

	LinkedList.prototype.inspect = function() {
	  var array = this.toArray();

	  // Trick so that node displays the name of the constructor
	  Object.defineProperty(array, 'constructor', {
	    value: LinkedList,
	    enumerable: false
	  });

	  return array;
	};

	if (typeof Symbol !== 'undefined')
	  LinkedList.prototype[Symbol.for('nodejs.util.inspect.custom')] = LinkedList.prototype.inspect;

	/**
	 * Static @.from function taking an arbitrary iterable & converting it into
	 * a list.
	 *
	 * @param  {Iterable} iterable   - Target iterable.
	 * @return {LinkedList}
	 */
	LinkedList.from = function(iterable) {
	  var list = new LinkedList();

	  forEach(iterable, function(value) {
	    list.push(value);
	  });

	  return list;
	};

	/**
	 * Exporting.
	 */
	linkedList$1 = LinkedList;
	return linkedList$1;
}

var linkedListExports = /*@__PURE__*/ requireLinkedList();
const linkedList = /*@__PURE__*/getDefaultExportFromCjs(linkedListExports);

/**
 * Mnemonist MultiMap
 * ===================
 *
 * Implementation of a MultiMap with custom container.
 */

var multiMap$1;
var hasRequiredMultiMap;

function requireMultiMap () {
	if (hasRequiredMultiMap) return multiMap$1;
	hasRequiredMultiMap = 1;
	var Iterator = requireIterator(),
	    forEach = requireForeach();

	/**
	 * MultiMap.
	 *
	 * @constructor
	 */
	function MultiMap(Container) {

	  this.Container = Container || Array;
	  this.items = new Map();
	  this.clear();

	  Object.defineProperty(this.items, 'constructor', {
	    value: MultiMap,
	    enumerable: false
	  });
	}

	/**
	 * Method used to clear the structure.
	 *
	 * @return {undefined}
	 */
	MultiMap.prototype.clear = function() {

	  // Properties
	  this.size = 0;
	  this.dimension = 0;
	  this.items.clear();
	};

	/**
	 * Method used to set a value.
	 *
	 * @param  {any}      key   - Key.
	 * @param  {any}      value - Value to add.
	 * @return {MultiMap}
	 */
	MultiMap.prototype.set = function(key, value) {
	  var container = this.items.get(key),
	      sizeBefore;

	  if (!container) {
	    this.dimension++;
	    container = new this.Container();
	    this.items.set(key, container);
	  }

	  if (this.Container === Set) {
	    sizeBefore = container.size;
	    container.add(value);

	    if (sizeBefore < container.size)
	      this.size++;
	  }
	  else {
	    container.push(value);
	    this.size++;
	  }

	  return this;
	};

	/**
	 * Method used to delete the given key.
	 *
	 * @param  {any}     key - Key to delete.
	 * @return {boolean}
	 */
	MultiMap.prototype.delete = function(key) {
	  var container = this.items.get(key);

	  if (!container)
	    return false;

	  this.size -= (this.Container === Set ? container.size : container.length);
	  this.dimension--;
	  this.items.delete(key);

	  return true;
	};

	/**
	 * Method used to delete the remove an item in the container stored at the
	 * given key.
	 *
	 * @param  {any}     key - Key to delete.
	 * @return {boolean}
	 */
	MultiMap.prototype.remove = function(key, value) {
	  var container = this.items.get(key),
	      wasDeleted,
	      index;

	  if (!container)
	    return false;

	  if (this.Container === Set) {
	    wasDeleted = container.delete(value);

	    if (wasDeleted)
	      this.size--;

	    if (container.size === 0) {
	      this.items.delete(key);
	      this.dimension--;
	    }

	    return wasDeleted;
	  }
	  else {
	    index = container.indexOf(value);

	    if (index === -1)
	      return false;

	    this.size--;

	    if (container.length === 1) {
	      this.items.delete(key);
	      this.dimension--;

	      return true;
	    }

	    container.splice(index, 1);

	    return true;
	  }
	};

	/**
	 * Method used to return whether the given keys exists in the map.
	 *
	 * @param  {any}     key - Key to check.
	 * @return {boolean}
	 */
	MultiMap.prototype.has = function(key) {
	  return this.items.has(key);
	};

	/**
	 * Method used to return the container stored at the given key or `undefined`.
	 *
	 * @param  {any}     key - Key to get.
	 * @return {boolean}
	 */
	MultiMap.prototype.get = function(key) {
	  return this.items.get(key);
	};

	/**
	 * Method used to return the multiplicity of the given key, meaning the number
	 * of times it is set, or, more trivially, the size of the attached container.
	 *
	 * @param  {any}     key - Key to check.
	 * @return {number}
	 */
	MultiMap.prototype.multiplicity = function(key) {
	  var container = this.items.get(key);

	  if (typeof container === 'undefined')
	    return 0;

	  return this.Container === Set ? container.size : container.length;
	};
	MultiMap.prototype.count = MultiMap.prototype.multiplicity;

	/**
	 * Method used to iterate over each of the key/value pairs.
	 *
	 * @param  {function}  callback - Function to call for each item.
	 * @param  {object}    scope    - Optional scope.
	 * @return {undefined}
	 */
	MultiMap.prototype.forEach = function(callback, scope) {
	  scope = arguments.length > 1 ? scope : this;

	  // Inner iteration function is created here to avoid creating it in the loop
	  var key;
	  function inner(value) {
	    callback.call(scope, value, key);
	  }

	  this.items.forEach(function(container, k) {
	    key = k;
	    container.forEach(inner);
	  });
	};

	/**
	 * Method used to iterate over each of the associations.
	 *
	 * @param  {function}  callback - Function to call for each item.
	 * @param  {object}    scope    - Optional scope.
	 * @return {undefined}
	 */
	MultiMap.prototype.forEachAssociation = function(callback, scope) {
	  scope = arguments.length > 1 ? scope : this;

	  this.items.forEach(callback, scope);
	};

	/**
	 * Method returning an iterator over the map's keys.
	 *
	 * @return {Iterator}
	 */
	MultiMap.prototype.keys = function() {
	  return this.items.keys();
	};

	/**
	 * Method returning an iterator over the map's keys.
	 *
	 * @return {Iterator}
	 */
	MultiMap.prototype.values = function() {
	  var iterator = this.items.values(),
	      inContainer = false,
	      countainer,
	      step,
	      i,
	      l;

	  if (this.Container === Set)
	    return new Iterator(function next() {
	      if (!inContainer) {
	        step = iterator.next();

	        if (step.done)
	          return {done: true};

	        inContainer = true;
	        countainer = step.value.values();
	      }

	      step = countainer.next();

	      if (step.done) {
	        inContainer = false;
	        return next();
	      }

	      return {
	        done: false,
	        value: step.value
	      };
	    });

	  return new Iterator(function next() {
	    if (!inContainer) {
	      step = iterator.next();

	      if (step.done)
	        return {done: true};

	      inContainer = true;
	      countainer = step.value;
	      i = 0;
	      l = countainer.length;
	    }

	    if (i >= l) {
	      inContainer = false;
	      return next();
	    }

	    return {
	      done: false,
	      value: countainer[i++]
	    };
	  });
	};

	/**
	 * Method returning an iterator over the map's entries.
	 *
	 * @return {Iterator}
	 */
	MultiMap.prototype.entries = function() {
	  var iterator = this.items.entries(),
	      inContainer = false,
	      countainer,
	      step,
	      key,
	      i,
	      l;

	  if (this.Container === Set)
	    return new Iterator(function next() {
	      if (!inContainer) {
	        step = iterator.next();

	        if (step.done)
	          return {done: true};

	        inContainer = true;
	        key = step.value[0];
	        countainer = step.value[1].values();
	      }

	      step = countainer.next();

	      if (step.done) {
	        inContainer = false;
	        return next();
	      }

	      return {
	        done: false,
	        value: [key, step.value]
	      };
	    });

	  return new Iterator(function next() {
	    if (!inContainer) {
	      step = iterator.next();

	      if (step.done)
	        return {done: true};

	      inContainer = true;
	      key = step.value[0];
	      countainer = step.value[1];
	      i = 0;
	      l = countainer.length;
	    }

	    if (i >= l) {
	      inContainer = false;
	      return next();
	    }

	    return {
	      done: false,
	      value: [key, countainer[i++]]
	    };
	  });
	};

	/**
	 * Method returning an iterator over the map's containers.
	 *
	 * @return {Iterator}
	 */
	MultiMap.prototype.containers = function() {
	  return this.items.values();
	};

	/**
	 * Method returning an iterator over the map's associations.
	 *
	 * @return {Iterator}
	 */
	MultiMap.prototype.associations = function() {
	  return this.items.entries();
	};

	/**
	 * Attaching the #.entries method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined')
	  MultiMap.prototype[Symbol.iterator] = MultiMap.prototype.entries;

	/**
	 * Convenience known methods.
	 */
	MultiMap.prototype.inspect = function() {
	  return this.items;
	};

	if (typeof Symbol !== 'undefined')
	  MultiMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = MultiMap.prototype.inspect;
	MultiMap.prototype.toJSON = function() {
	  return this.items;
	};

	/**
	 * Static @.from function taking an arbitrary iterable & converting it into
	 * a structure.
	 *
	 * @param  {Iterable} iterable  - Target iterable.
	 * @param  {Class}    Container - Container.
	 * @return {MultiMap}
	 */
	MultiMap.from = function(iterable, Container) {
	  var map = new MultiMap(Container);

	  forEach(iterable, function(value, key) {
	    map.set(key, value);
	  });

	  return map;
	};

	/**
	 * Exporting.
	 */
	multiMap$1 = MultiMap;
	return multiMap$1;
}

var multiMapExports = /*@__PURE__*/ requireMultiMap();
const multiMap = /*@__PURE__*/getDefaultExportFromCjs(multiMapExports);

/**
 * Mnemonist Queue
 * ================
 *
 * Queue implementation based on the ideas of Queue.js that seems to beat
 * a LinkedList one in performance.
 */

var queue$1;
var hasRequiredQueue;

function requireQueue () {
	if (hasRequiredQueue) return queue$1;
	hasRequiredQueue = 1;
	var Iterator = requireIterator(),
	    forEach = requireForeach();

	/**
	 * Queue
	 *
	 * @constructor
	 */
	function Queue() {
	  this.clear();
	}

	/**
	 * Method used to clear the queue.
	 *
	 * @return {undefined}
	 */
	Queue.prototype.clear = function() {

	  // Properties
	  this.items = [];
	  this.offset = 0;
	  this.size = 0;
	};

	/**
	 * Method used to add an item to the queue.
	 *
	 * @param  {any}    item - Item to enqueue.
	 * @return {number}
	 */
	Queue.prototype.enqueue = function(item) {

	  this.items.push(item);
	  return ++this.size;
	};

	/**
	 * Method used to retrieve & remove the first item of the queue.
	 *
	 * @return {any}
	 */
	Queue.prototype.dequeue = function() {
	  if (!this.size)
	    return;

	  var item = this.items[this.offset];

	  if (++this.offset * 2 >= this.items.length) {
	    this.items = this.items.slice(this.offset);
	    this.offset = 0;
	  }

	  this.size--;

	  return item;
	};

	/**
	 * Method used to retrieve the first item of the queue.
	 *
	 * @return {any}
	 */
	Queue.prototype.peek = function() {
	  if (!this.size)
	    return;

	  return this.items[this.offset];
	};

	/**
	 * Method used to iterate over the queue.
	 *
	 * @param  {function}  callback - Function to call for each item.
	 * @param  {object}    scope    - Optional scope.
	 * @return {undefined}
	 */
	Queue.prototype.forEach = function(callback, scope) {
	  scope = arguments.length > 1 ? scope : this;

	  for (var i = this.offset, j = 0, l = this.items.length; i < l; i++, j++)
	    callback.call(scope, this.items[i], j, this);
	};

	/*
	 * Method used to convert the queue to a JavaScript array.
	 *
	 * @return {array}
	 */
	Queue.prototype.toArray = function() {
	  return this.items.slice(this.offset);
	};

	/**
	 * Method used to create an iterator over a queue's values.
	 *
	 * @return {Iterator}
	 */
	Queue.prototype.values = function() {
	  var items = this.items,
	      i = this.offset;

	  return new Iterator(function() {
	    if (i >= items.length)
	      return {
	        done: true
	      };

	    var value = items[i];
	    i++;

	    return {
	      value: value,
	      done: false
	    };
	  });
	};

	/**
	 * Method used to create an iterator over a queue's entries.
	 *
	 * @return {Iterator}
	 */
	Queue.prototype.entries = function() {
	  var items = this.items,
	      i = this.offset,
	      j = 0;

	  return new Iterator(function() {
	    if (i >= items.length)
	      return {
	        done: true
	      };

	    var value = items[i];
	    i++;

	    return {
	      value: [j++, value],
	      done: false
	    };
	  });
	};

	/**
	 * Attaching the #.values method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined')
	  Queue.prototype[Symbol.iterator] = Queue.prototype.values;

	/**
	 * Convenience known methods.
	 */
	Queue.prototype.toString = function() {
	  return this.toArray().join(',');
	};

	Queue.prototype.toJSON = function() {
	  return this.toArray();
	};

	Queue.prototype.inspect = function() {
	  var array = this.toArray();

	  // Trick so that node displays the name of the constructor
	  Object.defineProperty(array, 'constructor', {
	    value: Queue,
	    enumerable: false
	  });

	  return array;
	};

	if (typeof Symbol !== 'undefined')
	  Queue.prototype[Symbol.for('nodejs.util.inspect.custom')] = Queue.prototype.inspect;

	/**
	 * Static @.from function taking an arbitrary iterable & converting it into
	 * a queue.
	 *
	 * @param  {Iterable} iterable   - Target iterable.
	 * @return {Queue}
	 */
	Queue.from = function(iterable) {
	  var queue = new Queue();

	  forEach(iterable, function(value) {
	    queue.enqueue(value);
	  });

	  return queue;
	};

	/**
	 * Static @.of function taking an arbitrary number of arguments & converting it
	 * into a queue.
	 *
	 * @param  {...any} args
	 * @return {Queue}
	 */
	Queue.of = function() {
	  return Queue.from(arguments);
	};

	/**
	 * Exporting.
	 */
	queue$1 = Queue;
	return queue$1;
}

var queueExports = /*@__PURE__*/ requireQueue();
const queue = /*@__PURE__*/getDefaultExportFromCjs(queueExports);

function ireduce(arg1, arg2, arg3) {
  const reducer = n(arg3) ? arg2 : arg1;
  const initialValue = arg3 ?? arg2;
  invariant(t(reducer));
  function _reduce(iter) {
    let acc = initialValue;
    for (const value of iter) {
      acc = reducer(acc, value);
    }
    return acc;
  }
  return n(arg3) ? _reduce(arg1) : _reduce;
}

const DELAY = "LIKEC4_DELAY";
function delay(...args) {
  let ms = 100;
  if (args.length === 2) {
    ms = o(args[0], args[1]);
  } else if (args.length === 1) {
    ms = args[0];
  }
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(DELAY);
    }, ms ?? 100);
  });
}

const compareRelations = (a, b) => {
  const parentA = commonAncestor(a.source, a.target);
  const parentB = commonAncestor(b.source, b.target);
  if (parentA && !parentB) {
    return 1;
  }
  if (!parentA && parentB) {
    return -1;
  }
  const compareParents = parentA && parentB ? compareFqnHierarchically(parentA, parentB) : 0;
  if (compareParents !== 0) {
    return compareParents;
  }
  const compareSource = compareFqnHierarchically(a.source, b.source);
  if (compareSource !== 0) {
    return compareSource;
  }
  return compareFqnHierarchically(a.target, b.target);
};

export { biMap as BiMap, defaultWeakMap as DefaultWeakMap, linkedList as LinkedList, multiMap as MultiMap, queue as Queue, commonAncestor, compareFqnHierarchically, compareRelations, delay, ireduce };
