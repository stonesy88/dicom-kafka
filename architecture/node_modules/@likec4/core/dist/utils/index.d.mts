export { I as IterableContainer, R as ReorderedArray, a as ancestorsFqn, c as commonAncestor, b as compareByFqnHierarchically, d as compareFqnHierarchically, h as hierarchyDistance, e as hierarchyLevel, i as isAncestor, f as isDescendantOf, g as isSameHierarchy, n as nameFromFqn, p as parentFqn, s as sortByFqnHierarchically, j as sortNaturalByFqn, k as sortParentsFirst } from '../shared/core.D2830qgg.mjs';
import { N as NonEmptyArray, I as IteratorLike } from '../shared/core.SjLhMA7a.mjs';
import { IsNumericLiteral } from 'type-fest';

/**
 * Mnemonist DefaultMap Typings
 * =============================
 */
declare class DefaultMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;

  // Constructor
  constructor(factory: (key: K, index: number) => V);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V;
  peek(key: K): V | undefined;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static autoIncrement(): number;
}

/**
 * Mnemonist DefaultWeakMap Typings
 * ================================
 */
declare class DefaultWeakMap<K extends object, V> {

  // Constructor
  constructor(factory: (key: K) => V);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V;
  peek(key: K): V | undefined;
  inspect(): any;
}

/**
 * Mnemonist LinkedList Typings
 * =============================
 */
declare class LinkedList<T> implements Iterable<T> {

  // Members
  size: number;

  // Constructor
  constructor();

  // Methods
  clear(): void;
  first(): T | undefined;
  last(): T | undefined;
  peek(): T | undefined;
  push(value: T): number;
  shift(): T | undefined;
  unshift(value: T): number;
  forEach(callback: (value: T, index: number, list: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string]: I}): LinkedList<I>;
}

/**
 * Mnemonist Queue Typings
 * ========================
 */
declare class Queue<T> implements Iterable<T> {

  // Members
  size: number;

  // Constructor
  constructor();

  // Methods
  clear(): void;
  enqueue(item: T): number;
  dequeue(): T | undefined;
  peek(): T | undefined;
  forEach(callback: (item: T, index: number, queue: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string]: I}): Queue<I>;
  static of<I>(...items: Array<I>): Queue<I>;
}

interface MultiMapConstructor {
  new <K, V>(container: SetConstructor): MultiMap<K, V, Set<V>>;
  new <K, V>(container?: ArrayConstructor): MultiMap<K, V, V[]>;

  from<K, V>(
    iterable: Iterable<[K, V]> | {[key: string]: V},
    Container: SetConstructor
  ): MultiMap<K, V, Set<V>>;
  from<K, V>(
    iterable: Iterable<[K, V]> | {[key: string]: V},
    Container?: ArrayConstructor
  ): MultiMap<K, V, V[]>;
}
/**
 * Mnemonist MultiMap Typings
 * ===========================
 */

interface MultiMap<K, V, C extends V[] | Set<V> = V[]> extends Iterable<[K, V]> {

  // Members
  dimension: number;
  size: number;

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  remove(key: K, value: V): boolean;
  has(key: K): boolean;
  get(key: K): C | undefined;
  multiplicity(key: K): number;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  forEachAssociation(callback: (value: C, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  containers(): IterableIterator<C>;
  associations(): IterableIterator<[K, C]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;
  toJSON(): any;
}

declare const MultiMap: MultiMapConstructor;

/**
 * Mnemonist Stack Typings
 * ========================
 */
declare class Stack<T> implements Iterable<T> {

  // Members
  size: number;

  // Constructor
  constructor();

  // Methods
  clear(): void;
  push(item: T): number;
  pop(): T | undefined;
  peek(): T | undefined;
  forEach(callback: (item: T, index: number, stack: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string]: I}): Stack<I>;
  static of<I>(...items: Array<I>): Stack<I>;
}

/**
 * Mnemonist BiMap Typings
 * ========================
 */
declare class InverseMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;
  inverse: BiMap<V, K>;

  // Constructor
  constructor(original: BiMap<K, V>);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V | undefined;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;
}

declare class BiMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;
  inverse: InverseMap<V, K>;

  // Constructor
  constructor();

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V | undefined;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static from<I, J>(iterable: Iterable<[I, J]> | {[key: string]: J}): BiMap<I, J>;
}

/**
 * Common head of two arrays
 *
 * @param equals - Equality function, defaults to `Object.is`
 */
declare function commonHead<T>(sources: ReadonlyArray<T>, targets: ReadonlyArray<T>, equals?: (a: T, b: T) => boolean): T[];

declare function compareNatural(a: string | undefined, b: string | undefined): -1 | 0 | 1;

declare function getOrCreate<K, V>(map: Map<K, V>, key: K, create: (key: K) => V): V;

/**
 * This should only be used for defining generics which extend any kind of JS
 * array under the hood, this includes arrays *AND* tuples (of the form [x, y],
 * and of the form [x, ...y[]], etc...), and their readonly equivalent. This
 * allows us to be more inclusive to what functions can process.
 *
 * @example
 *   function map<T extends IterableContainer>(items: T) { ... }
 *
 * We would've named this `ArrayLike`, but that's already used by typescript...
 * @see This was inspired by the type-definition of Promise.all (https://github.com/microsoft/TypeScript/blob/1df5717b120cddd325deab8b0f2b2c3eecaf2b01/src/lib/es2015.promise.d.ts#L21)
 */
type IterableContainer<T = unknown> = ReadonlyArray<T> | readonly [];

type ArraySetRequired<T extends IterableContainer, Min extends number, Iteration extends ReadonlyArray<unknown> = []> = number extends Min ? never : Iteration["length"] extends Min ? T : T extends readonly [] ? never : T extends [infer Head, ...infer Rest] ? [
    Head,
    ...ArraySetRequired<Rest, Min, [unknown, ...Iteration]>
] : T extends readonly [infer Head, ...infer Rest] ? readonly [
    Head,
    ...ArraySetRequired<Rest, Min, [unknown, ...Iteration]>
] : T extends Array<infer Item> ? [
    Item,
    ...ArraySetRequired<T, Min, [unknown, ...Iteration]>
] : T extends ReadonlyArray<infer Item> ? readonly [
    Item,
    ...ArraySetRequired<T, Min, [unknown, ...Iteration]>
] : never;
/**
 * Checks if the given array has at least the defined number of elements. When
 * the minimum used is a literal (e.g. `3`) the output is refined accordingly so
 * that those indices are defined when accessing the array even when using
 * typescript's 'noUncheckedIndexAccess'.
 *
 * @param data - The input array.
 * @param minimum - The minimum number of elements the array must have.
 * @returns True if the array's length is *at least* `minimum`. When `minimum`
 * is a literal value, the output is narrowed to ensure the first items are
 * guaranteed.
 * @signature
 *   R.hasAtLeast(data, minimum)
 * @example
 *   R.hasAtLeast([], 4); // => false
 *
 *   const data: number[] = [1,2,3,4];
 *   R.hasAtLeast(data, 1); // => true
 *   data[0]; // 1, with type `number`
 * @dataFirst
 * @category Array
 */
declare function hasAtLeast<T extends IterableContainer, N extends number>(data: IterableContainer | T, minimum: IsNumericLiteral<N> extends true ? N : never): data is ArraySetRequired<T, N>;
declare function hasAtLeast(data: IterableContainer, minimum: number): boolean;
/**
 * Checks if the given array has at least the defined number of elements. When
 * the minimum used is a literal (e.g. `3`) the output is refined accordingly so
 * that those indices are defined when accessing the array even when using
 * typescript's 'noUncheckedIndexAccess'.
 *
 * @param minimum - The minimum number of elements the array must have.
 * @returns True if the array's length is *at least* `minimum`. When `minimum`
 * is a literal value, the output is narrowed to ensure the first items are
 * guaranteed.
 * @signature
 *   R.hasAtLeast(minimum)(data)
 * @example
 *   R.pipe([], R.hasAtLeast(4)); // => false
 *
 *   const data = [[1,2], [3], [4,5]];
 *   R.pipe(
 *     data,
 *     R.filter(R.hasAtLeast(2)),
 *     R.map(([, second]) => second),
 *   ); // => [2,5], with type `number[]`
 * @dataLast
 * @category Array
 */
declare function hasAtLeast<N extends number>(minimum: IsNumericLiteral<N> extends true ? N : never): <T extends IterableContainer>(data: IterableContainer | T) => data is ArraySetRequired<T, N>;
declare function hasAtLeast(minimum: number): (data: IterableContainer) => boolean;

declare function isString(value: unknown): value is string;
declare function isNonEmptyArray<A>(arr: ArrayLike<A> | undefined): arr is NonEmptyArray<A>;

declare function isIterable<T, I extends Iterable<T>>(something: I | unknown): something is Iterable<T>;

/**
 * Filters an iterable based on a predicate.
 * Composabel first version of `ifilter`.
 * @signature
 *    ifilter(predicate)(data)
 */
declare function ifilter<T, S extends T>(predicate: (v: T) => v is S): (iterable: Iterable<T>) => IteratorLike<S>;
declare function ifilter<T>(predicate: (v: T) => boolean): (iterable: Iterable<T>) => IteratorLike<T>;
/**
 * Filters an iterable based on a predicate.
 * Data first version of `ifilter`.
 * @signature
 *    ifilter(data, predicate)
 * @example
 *    ifilter(new Set([1, 2, 3]), x => x % 2 === 1) // => Iterable<[1, 3]>
 */
declare function ifilter<T, S extends T>(iterable: Iterable<T>, predicate: (v: T) => v is S): IteratorLike<S>;
declare function ifilter<T>(iterable: Iterable<T>, predicate: (v: T) => boolean): IteratorLike<T>;

/**
 * Finds the first element in the iterable that satisfies the predicate.
 * Composable first version of `find`.
 * @signature
 *   ifind(predicate)(data)
 */
declare function ifind<T>(predicate: (item: T) => boolean): (iterable: Iterable<T>) => T | undefined;
/**
 * Finds the first element in the iterable that satisfies the predicate.
 * Data first version of `find`.
 * @signature
 *  ifind(data, predicate)
 */
declare function ifind<T>(iterable: Iterable<T>, predicate: (item: T) => boolean): T | undefined;

declare function iflat(): <T>(iterable: Iterable<IteratorLike<T>>) => IteratorLike<T>;
declare function iflat<T>(iterable: Iterable<IteratorLike<T>>): IteratorLike<T>;

type MapFunction<T, S> = (item: T) => S;
/**
 * Maps an iterable using a mapper function.
 * Composable first version of `imap`.
 * @signature
 *   imap(mapper)(data)
 */
declare function imap<T, S>(mapper: MapFunction<T, S>): (iterable: Iterable<T>) => IteratorLike<S>;
/**
 * Maps an iterable using a mapper function.
 * Data first version of `imap`.
 * @signature
 *   imap(data, mapper)
 */
declare function imap<T, S>(iterable: Iterable<T>, mapper: MapFunction<T, S>): IteratorLike<S>;

declare function ireduce<T, R>(reducer: (acc: R, item: T) => R, initialValue: R): (iterable: Iterable<T>) => R;
declare function ireduce<T, R>(iterable: Iterable<T>, reducer: (acc: R, item: T) => R, initialValue: R): R;

/**
 * Checks if at least one element in the iterable satisfies the predicate.
 * Composable first version of `some`.
 * @signature
 *   isome(predicate)(data)
 */
declare function isome<T>(predicate: (item: T) => boolean): (iterable: Iterable<T>) => boolean;
/**
 * Checks if at least one element in the iterable satisfies the predicate.
 * Data first version of `some`.
 * @signature
 *  isome(data, predicate)
 */
declare function isome<T>(iterable: Iterable<T>, predicate: (item: T) => boolean): boolean;

declare function toArray(): <T>(iterable: Iterable<T> | ArrayLike<T>) => T[];
declare function toArray<T>(iterable: Iterable<T> | ArrayLike<T>): T[];
declare function toSet(): <T>(iterable: Iterable<T>) => Set<T>;
declare function toSet<T>(iterable: Iterable<T>): Set<T>;

/**
 * Returns an iterable that yields only unique values.
 * It uses a Set to keep track of the values.
 */
declare function iunique(): <T>(iterable: Iterable<T>) => IteratorLike<T>;
declare function iunique<T>(iterable: Iterable<T>): IteratorLike<T>;

declare function delay(): Promise<string>;
declare function delay(ms: number): Promise<string>;
declare function delay(randomFrom: number, randomTo: number): Promise<string>;

/**
 * Compares two relations hierarchically.
 * From the most general (implicit) to the most specific.
 */
declare const compareRelations: <T extends {
    source: string;
    target: string;
}>(a: T, b: T) => number;

/**
 * Returns new set as a union of given sets
 * Keeps order of elements
 */
declare function union<T>(...sets: ReadonlySet<T>[]): Set<T>;
/**
 * Returns new set as an intersection of all sets
 * Keeps order from the first set
 */
declare function intersection<T>(first: ReadonlySet<T>, ...sets: NonEmptyArray<ReadonlySet<NoInfer<T>>>): Set<T>;
declare function difference<T>(a: ReadonlySet<T>, b: ReadonlySet<NoInfer<T>>): Set<T>;
declare function equals<T>(a: ReadonlySet<T>, b: ReadonlySet<T>): boolean;
declare function symmetricDifference<T>(a: ReadonlySet<T>, b: ReadonlySet<T>): Set<T>;

/**
 * @see https://gist.github.com/victor-homyakov/bcb7d7911e4a388b1c810f8c3ce17bcf
 */
declare function stringHash(str: string): string;

declare function objectHash(value: any): string;

export { BiMap, DefaultMap, DefaultWeakMap, LinkedList, MultiMap, Queue, Stack, commonHead, compareNatural, compareRelations, delay, difference, equals as equalsSet, getOrCreate, hasAtLeast, ifilter, ifind, iflat, imap, intersection, ireduce, isIterable, isNonEmptyArray, isString, isome, iunique, objectHash, stringHash, symmetricDifference, toArray, toSet, union };
