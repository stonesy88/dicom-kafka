import { A as AnyAux, E as ElementModel, R as RelationshipModel, L as LikeC4Model } from '../../shared/core.CiFKryGW.mjs';
import 'type-fest';
import '../../shared/core.SjLhMA7a.mjs';
import '../../shared/core.DJvmfnEi.mjs';

type RelationshipsViewData<M extends AnyAux = AnyAux> = {
    incomers: ReadonlySet<ElementModel<M>>;
    incoming: ReadonlySet<RelationshipModel<M>>;
    subjects: ReadonlySet<ElementModel<M>>;
    outgoing: ReadonlySet<RelationshipModel<M>>;
    outgoers: ReadonlySet<ElementModel<M>>;
};

declare function computeRelationshipsView<const M extends AnyAux>(subjectId: NoInfer<M['Element']>, likec4model: LikeC4Model<M>, scopeViewId: NoInfer<M['View']> | null, scope?: 'global' | 'view'): RelationshipsViewData<M>;

declare function treeFromElements<const M extends AnyAux>(elements: Iterable<ElementModel<M>>): {
    sorted: readonly ElementModel<M>[];
    byId: (id: M["Element"]) => ElementModel<M>;
    root: ReadonlySet<ElementModel<M>>;
    parent: (el: ElementModel<M>) => ElementModel<M> | null;
    children: (el: ElementModel<M>) => ReadonlyArray<ElementModel<M>>;
    /**
     * Flattens the tree structure by removing redundant hierarchy levels.
     * @example
     *   A
     *   └── B
     *       ├── C
     *       │   └── D
     *       │       └── E
     *       └── F
     *           └── G
     * becomes
     *   A
     *   ├── C
     *   │   └── E
     *   └── F
     *       └── G
     */
    flatten: () => Set<ElementModel<M>>;
};

export { type RelationshipsViewData, computeRelationshipsView, treeFromElements };
