import { G as Graph, r, w as willCreateCycle, t as topologicalSortExports, i as i$1, a as i$2, l } from '../shared/core.CAcZ6_cP.mjs';
export { c as computeView, b as computeViews, u as unsafeComputeView } from '../shared/core.CAcZ6_cP.mjs';
import { i as isExtendsElementView, a as isElementView } from '../shared/core.DgfwjBtu.mjs';
import { e as isNonEmptyArray } from '../shared/core.CQXU9DF7.mjs';
import { i, m } from '../shared/core.Cu-UdkSl.mjs';
import { u } from '../shared/core.DbRvwARP.mjs';

function y(...t){return u(f,t)}function f(t,e){if(!i(e,1))return {...t};if(!i(e,2)){let{[e[0]]:r,...m}=t;return m}let o={...t};for(let r of e)delete o[r];return o}

function resolveRulesExtendedViews(unresolvedViews) {
  const g = new Graph({
    type: "directed"
  });
  const extendedViews = [];
  for (const view of r(unresolvedViews)) {
    g.addNode(view.id, { view });
    if (isExtendsElementView(view)) {
      extendedViews.push(view);
    }
  }
  if (extendedViews.length === 0) {
    return unresolvedViews;
  }
  for (const view of extendedViews) {
    if (!g.hasNode(view.extends)) {
      console.warn(`View "${view.id}" extends from "${view.extends}" which does not exist`);
      continue;
    }
    if (willCreateCycle(g, view.id, view.extends)) {
      console.warn(`View "${view.id}" extends from "${view.extends}" which creates a cycle`);
      continue;
    }
    g.addDirectedEdge(view.id, view.extends);
  }
  const sorted = topologicalSortExports.topologicalSort(g).reverse();
  return sorted.reduce((acc, id) => {
    const view = g.getNodeAttribute(id, "view");
    if (!isExtendsElementView(view)) {
      acc[view.id] = view;
      return acc;
    }
    const extendsFrom = acc[view.extends];
    if (!extendsFrom || !isElementView(extendsFrom)) {
      return acc;
    }
    const tags = i$1([
      ...extendsFrom.tags ?? [],
      ...view.tags ?? []
    ]);
    const links = [
      ...extendsFrom.links ?? [],
      ...view.links ?? []
    ];
    acc[view.id] = {
      ...extendsFrom,
      ...view,
      title: view.title ?? extendsFrom.title ?? null,
      description: view.description ?? extendsFrom.description ?? null,
      tags: isNonEmptyArray(tags) ? tags : null,
      links: isNonEmptyArray(links) ? links : null,
      rules: [...extendsFrom.rules, ...view.rules]
    };
    return acc;
  }, {});
}

function withReadableEdges({ edges, nodes, ...view }, separator = ":") {
  const edgeids = l(edges, (e) => [e.id, `${e.source}${separator}${e.target}`]);
  return {
    ...view,
    edges: edges.map((e) => ({
      ...e,
      id: edgeids[e.id]
    })),
    nodes: nodes.map((n) => ({
      ...n,
      inEdges: m(n.inEdges, (e) => edgeids[e]),
      outEdges: m(n.outEdges, (e) => edgeids[e])
    })),
    nodeIds: nodes.map((n) => n.id),
    edgeIds: edges.map((e) => edgeids[e.id])
  };
}
function viewsWithReadableEdges({ views, ...model }) {
  return {
    ...model,
    views: i$2(views, (v) => y(withReadableEdges(v), ["nodeIds", "edgeIds"]))
  };
}

export { resolveRulesExtendedViews, viewsWithReadableEdges, withReadableEdges };
