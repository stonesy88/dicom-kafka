import { A as AnyAux, d as DeploymentElementModel, E as ElementModel, D as DeployedInstanceModel, e as DeploymentNodeModel } from '../shared/core.CiFKryGW.mjs';
export { b as Aux, f as DeploymentRelationModel, g as EdgeModel, h as LikeC4DeploymentModel, L as LikeC4Model, i as LikeC4ViewModel, N as NodeModel, R as RelationshipModel } from '../shared/core.CiFKryGW.mjs';
import { C as Connection, D as DeploymentConnectionModel, a as ConnectionModel } from '../shared/core.CZR9J1Qx.mjs';
import { I as IterableContainer, R as ReorderedArray } from '../shared/core.D2830qgg.mjs';
import 'type-fest';
import '../shared/core.SjLhMA7a.mjs';
import '../shared/core.DJvmfnEi.mjs';

/**
 * Check if connection is nested inside another connection
 * (i.e. between descendants)
 */
declare function isNestedConnection<T extends {
    id: string;
}>(parent: WithSourceTarget<NoInfer<T>>): (nested: WithSourceTarget<T>) => boolean;
declare function isNestedConnection<T extends {
    id: string;
}>(nested: WithSourceTarget<T>, parent: WithSourceTarget<T>): boolean;
type ConnectionElemId = Connection<{
    readonly id: string;
}, any>;
declare function findDeepestNestedConnection<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): C | null;
declare function sortDeepestFirst<C extends ConnectionElemId>(connections: ReadonlyArray<C>): C[];
type WithBoundary = {
    boundary: null | {
        id: string;
    };
};
declare function sortConnectionsByBoundaryHierarchy(sort?: 'asc' | 'desc'): <T extends WithBoundary, A extends IterableContainer<T>>(array: A) => ReorderedArray<A>;
declare function sortConnectionsByBoundaryHierarchy<T extends WithBoundary, A extends IterableContainer<T>>(array: A, sort?: 'asc' | 'desc'): ReorderedArray<A>;
/**
 * Find connections that includes given connection (i.e between it's ancestors)
 */
declare function findAscendingConnections<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): Array<C>;
/**
 * Find connections that includes given connection (i.e between it's descendants)
 */
declare function findDescendantConnections<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): Array<C>;
declare function mergeConnections<C extends Connection>(connections: ReadonlyArray<C>): C[];
/**
 * Excludes the values existing in `other` array.
 * The output maintains the same order as the input.
 */
declare function differenceConnections<C extends Connection>(source: Iterable<C>, exclude: Iterable<C>): C[];
type WithSourceTarget<T = unknown> = {
    source: T;
    target: T;
};
declare function hasSameSourceTarget<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameSourceTarget<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
declare function hasSameSource<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameSource<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
declare function hasSameTarget<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameTarget<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
type WithId<T> = {
    id: T;
};
declare function isOutgoing<T extends string>(source: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isOutgoing<T extends string>(a: WithSourceTarget<WithId<T>>, source: WithId<T>): boolean;
declare function isIncoming<T extends string>(target: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isIncoming<T extends string>(a: WithSourceTarget<WithId<T>>, target: WithId<T>): boolean;
declare function isAnyInOut<T extends string>(source: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isAnyInOut<T extends string>(a: WithSourceTarget<WithId<T>>, source: WithId<T>): boolean;

/**
 * Resolve connection from source to target
 * If direction is `both`, also look for reverse connection
 *
 * @default direction directed
 */
declare function findConnection$1<M extends AnyAux>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction: 'directed'): readonly [DeploymentConnectionModel<M>] | readonly [];
declare function findConnection$1<M extends AnyAux>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction: 'both'): readonly [DeploymentConnectionModel<M>, DeploymentConnectionModel<M>] | readonly [DeploymentConnectionModel<M>] | readonly [];
declare function findConnection$1<M extends AnyAux>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction?: 'directed' | 'both'): readonly [DeploymentConnectionModel<M>, DeploymentConnectionModel<M>] | readonly [DeploymentConnectionModel<M>] | readonly [];
/**
 * Resolve all connections between element and others
 * By default, look for both directions.
 *
 * @default direction both
 */
declare function findConnectionsBetween$1<M extends AnyAux>(element: DeploymentElementModel<M>, others: Iterable<DeploymentElementModel<NoInfer<M>>>, direction?: 'directed' | 'both'): readonly DeploymentConnectionModel<M>[];
/**
 * Resolve all connections within a given set of elements
 */
declare function findConnectionsWithin$1<M extends AnyAux>(elements: Iterable<DeploymentElementModel<M>>): readonly DeploymentConnectionModel<M>[];

declare namespace find$1 {
  export { findConnection$1 as findConnection, findConnectionsBetween$1 as findConnectionsBetween, findConnectionsWithin$1 as findConnectionsWithin };
}

/**
 * Resolve connection from source to target
 *
 * @param direction - if 'both', also returns connection from target to source
 * @default `directed`
 */
declare function findConnection<M extends AnyAux>(source: ElementModel<M>, target: ElementModel<M>, direction?: 'directed' | 'both'): [ConnectionModel<M>, ConnectionModel<M>] | [ConnectionModel<M>] | [];
/**
 * Resolve all connections between element and others
 * @param direction - if 'directed', only look for outgoing connections from the element to others
 * @default `both`
 */
declare function findConnectionsBetween<M extends AnyAux>(element: ElementModel<M>, others: Iterable<ElementModel<NoInfer<M>>>, direction?: 'directed' | 'both'): readonly ConnectionModel<M>[];
/**
 * Resolve all connections within a given set of elements
 */
declare function findConnectionsWithin<M extends AnyAux>(elements: Iterable<ElementModel<M>>): readonly ConnectionModel<M>[];

declare const find_findConnection: typeof findConnection;
declare const find_findConnectionsBetween: typeof findConnectionsBetween;
declare const find_findConnectionsWithin: typeof findConnectionsWithin;
declare namespace find {
  export { find_findConnection as findConnection, find_findConnectionsBetween as findConnectionsBetween, find_findConnectionsWithin as findConnectionsWithin };
}

declare function isDeploymentNode(model: DeploymentElementModel): model is DeploymentNodeModel;
declare function isDeployedInstance(model: DeploymentElementModel): model is DeployedInstanceModel;

export { AnyAux, Connection, ConnectionModel, DeployedInstanceModel, DeploymentConnectionModel, DeploymentElementModel, DeploymentNodeModel, ElementModel, find$1 as deploymentConnection, differenceConnections, findAscendingConnections, findDeepestNestedConnection, findDescendantConnections, hasSameSource, hasSameSourceTarget, hasSameTarget, isAnyInOut, isDeployedInstance, isDeploymentNode, isIncoming, isNestedConnection, isOutgoing, mergeConnections, find as modelConnection, sortConnectionsByBoundaryHierarchy, sortDeepestFirst };
